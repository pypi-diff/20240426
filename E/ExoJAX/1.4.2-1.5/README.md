# Comparing `tmp/ExoJAX-1.4.2-py2.py3-none-any.whl.zip` & `tmp/ExoJAX-1.5-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,179 +1,162 @@
-Zip file size: 6142031 bytes, number of entries: 177
--rw-rw-r--  2.0 unx      298 b- defN 23-Sep-10 05:34 exojax/__init__.py
--rw-rw-r--  2.0 unx     1745 b- defN 23-Apr-09 00:40 exojax/data.py
--rw-rw-r--  2.0 unx      807 b- defN 23-Apr-09 00:41 exojax/emulate_broadpar.py
--rw-rw-r--  2.0 unx      213 b- defN 23-Jul-16 01:07 exojax/atm/__init__.py
--rw-rw-r--  2.0 unx     3023 b- defN 22-Apr-30 23:50 exojax/atm/amclouds.py
--rw-rw-r--  2.0 unx     6834 b- defN 23-Sep-18 03:20 exojax/atm/atmprof.py
--rw-rw-r--  2.0 unx      676 b- defN 22-Apr-30 23:50 exojax/atm/condinfo.py
--rw-rw-r--  2.0 unx    10719 b- defN 22-Oct-25 23:56 exojax/atm/fastchem2_call.py
--rw-rw-r--  2.0 unx      315 b- defN 22-Apr-30 23:50 exojax/atm/idealgas.py
--rw-rw-r--  2.0 unx      972 b- defN 22-Apr-30 23:50 exojax/atm/psat.py
--rw-rw-r--  2.0 unx      434 b- defN 22-Apr-30 23:50 exojax/atm/simple_clouds.py
--rw-rw-r--  2.0 unx     3002 b- defN 23-Mar-15 09:34 exojax/atm/viscosity.py
--rw-rw-r--  2.0 unx     4056 b- defN 22-Apr-30 23:50 exojax/atm/vterm.py
--rw-rw-r--  2.0 unx      171 b- defN 23-Jul-16 01:07 exojax/data/__init__.py
--rw-rw-r--  2.0 unx     2403 b- defN 22-Apr-30 23:50 exojax/data/abundance/AAG2021.dat
--rw-rw-r--  2.0 unx     9614 b- defN 23-Feb-06 13:31 exojax/data/atom/HITRAN_molparam.txt
--rw-rw-r--  2.0 unx   819291 b- defN 22-Apr-30 23:50 exojax/data/atom/NIST_Atomic_Ionization_Energies.txt
--rw-rw-r--  2.0 unx     6044 b- defN 22-Apr-30 23:50 exojax/data/atom/atomic.txt
--rw-rw-r--  2.0 unx   171536 b- defN 22-Apr-30 23:50 exojax/data/atom/barklem_collet_2016_pff.txt
--rw-rw-r--  2.0 unx     8322 b- defN 22-Apr-30 23:50 exojax/data/atom/iso_mn.txt
--rw-rw-r--  2.0 unx      188 b- defN 22-Apr-30 23:50 exojax/data/clouds/drag_force.txt
--rw-rw-r--  2.0 unx  3483224 b- defN 23-Mar-15 09:34 exojax/data/premodit/elower_grid_trange.npz
--rw-rw-r--  2.0 unx     2300 b- defN 23-Mar-15 09:34 exojax/data/testdata/H2-H2_TEST.cia
--rw-rw-r--  2.0 unx  1000000 b- defN 23-Mar-19 01:35 exojax/data/testdata/lpf_rt_test_hitemp_ref.txt
--rw-rw-r--  2.0 unx  1000000 b- defN 23-Mar-19 01:35 exojax/data/testdata/lpf_rt_test_ref.txt
--rw-rw-r--  2.0 unx  1000000 b- defN 23-Mar-15 09:34 exojax/data/testdata/lpf_test_hitemp_ref.txt
--rw-rw-r--  2.0 unx  1000000 b- defN 23-Mar-15 09:34 exojax/data/testdata/lpf_test_ref.txt
--rw-rw-r--  2.0 unx  1000000 b- defN 23-Mar-19 01:35 exojax/data/testdata/modit_rt_test_hitemp_ref.txt
--rw-rw-r--  2.0 unx  1000000 b- defN 23-Mar-19 01:35 exojax/data/testdata/modit_rt_test_ref.txt
--rw-rw-r--  2.0 unx   100000 b- defN 23-Feb-06 13:31 exojax/data/testdata/modit_rt_test_vald_ref.txt
--rw-rw-r--  2.0 unx  1000000 b- defN 23-Mar-15 09:34 exojax/data/testdata/modit_test_hitemp_ref.txt
--rw-rw-r--  2.0 unx  1000000 b- defN 23-Mar-15 09:34 exojax/data/testdata/modit_test_hitemp_ref_air.txt
--rw-rw-r--  2.0 unx  1000000 b- defN 23-Mar-15 09:34 exojax/data/testdata/modit_test_ref.txt
--rw-rw-r--  2.0 unx   157039 b- defN 23-Feb-10 10:51 exojax/data/testdata/moldb_co_exomol.pickle
--rw-rw-r--  2.0 unx    49346 b- defN 23-Feb-10 10:51 exojax/data/testdata/moldb_co_hitemp.pickle
--rw-rw-r--  2.0 unx    16092 b- defN 23-Feb-10 10:51 exojax/data/testdata/moldb_co_hitemp_single_isotope.pickle
--rw-rw-r--  2.0 unx 34576741 b- defN 23-Mar-15 09:34 exojax/data/testdata/moldb_h2o_exomol.pickle
--rw-rw-r--  2.0 unx   151554 b- defN 23-Feb-07 01:52 exojax/data/testdata/moldb_vald.pickle
--rw-rw-r--  2.0 unx   750000 b- defN 23-Feb-06 13:31 exojax/data/testdata/premodit_rt_test_hitemp_ref.txt
--rw-rw-r--  2.0 unx   750000 b- defN 22-Dec-07 12:18 exojax/data/testdata/premodit_rt_test_ref.txt
--rw-rw-r--  2.0 unx   250000 b- defN 23-Feb-06 13:31 exojax/data/testdata/premodit_test_hitemp_ref.txt
--rw-rw-r--  2.0 unx   250000 b- defN 22-Dec-07 12:18 exojax/data/testdata/premodit_test_ref.txt
--rw-rw-r--  2.0 unx    25000 b- defN 22-May-24 06:32 exojax/data/testdata/spectrum.txt
--rw-rw-r--  2.0 unx    75000 b- defN 22-Dec-07 12:18 exojax/data/testdata/spectrum_ch4.txt
--rw-rw-r--  2.0 unx    75000 b- defN 23-Mar-19 01:35 exojax/data/testdata/spectrum_ch4_new.txt
--rw-rw-r--  2.0 unx    75000 b- defN 22-Dec-07 12:18 exojax/data/testdata/spectrum_co.txt
--rw-rw-r--  2.0 unx  2104704 b- defN 23-Mar-15 09:34 exojax/data/testdata/CO/05_HITEMP_SAMPLE.par
--rw-rw-r--  2.0 unx     1944 b- defN 23-Mar-15 09:34 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__H2.broad
--rw-rw-r--  2.0 unx     1680 b- defN 23-Mar-15 09:34 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__He.broad
--rw-rw-r--  2.0 unx     5074 b- defN 23-Mar-15 09:34 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.def
--rw-rw-r--  2.0 unx   234000 b- defN 23-Mar-15 09:34 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.pf
--rw-rw-r--  2.0 unx    54318 b- defN 23-Mar-15 09:34 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.states.bz2
--rw-rw-r--  2.0 unx   217080 b- defN 23-Mar-15 09:34 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.states.hdf5
--rw-rw-r--  2.0 unx     3105 b- defN 23-Mar-15 09:34 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.trans.bz2
--rw-rw-r--  2.0 unx   134416 b- defN 23-Mar-15 09:34 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.trans.hdf5
--rw-rw-r--  2.0 unx      167 b- defN 23-Jul-16 01:07 exojax/dynamics/__init__.py
--rw-rw-r--  2.0 unx     2646 b- defN 23-Feb-06 13:31 exojax/dynamics/getE.py
--rw-rw-r--  2.0 unx     2806 b- defN 23-Feb-06 13:31 exojax/dynamics/rvfunc.py
--rw-rw-r--  2.0 unx      242 b- defN 23-Jul-16 01:07 exojax/plot/__init__.py
--rw-rw-r--  2.0 unx     5963 b- defN 23-Feb-06 13:31 exojax/plot/atmplot.py
--rw-rw-r--  2.0 unx     2124 b- defN 22-Apr-30 23:50 exojax/plot/ditplot.py
--rw-rw-r--  2.0 unx     1507 b- defN 23-Jul-14 23:49 exojax/plot/opaplot.py
--rw-rw-r--  2.0 unx     1651 b- defN 23-Sep-10 05:34 exojax/plot/rtplot.py
--rw-rw-r--  2.0 unx       65 b- defN 23-Feb-06 13:31 exojax/signal/__init__.py
--rw-rw-r--  2.0 unx      698 b- defN 23-Mar-15 09:34 exojax/signal/convolve.py
--rw-rw-r--  2.0 unx     6552 b- defN 23-Mar-01 22:26 exojax/signal/ola.py
--rw-rw-r--  2.0 unx      479 b- defN 23-Jul-16 01:07 exojax/spec/__init__.py
--rw-rw-r--  2.0 unx    42325 b- defN 23-Jul-16 01:07 exojax/spec/api.py
--rw-rw-r--  2.0 unx    36096 b- defN 23-Feb-04 02:33 exojax/spec/api_current.py
--rw-rw-r--  2.0 unx    12084 b- defN 23-Sep-18 03:20 exojax/spec/atmrt.py
--rw-rw-r--  2.0 unx    28504 b- defN 23-Mar-15 09:34 exojax/spec/atomll.py
--rw-rw-r--  2.0 unx    16616 b- defN 23-Jul-14 23:49 exojax/spec/atomllapi.py
--rw-rw-r--  2.0 unx    18377 b- defN 23-Sep-04 11:33 exojax/spec/autospec.py
--rw-rw-r--  2.0 unx     3004 b- defN 22-Oct-25 23:56 exojax/spec/check_nugrid.py
--rw-rw-r--  2.0 unx     1614 b- defN 23-Jul-14 23:49 exojax/spec/contdb.py
--rw-rw-r--  2.0 unx     1682 b- defN 22-Apr-30 23:50 exojax/spec/defcia.py
--rw-rw-r--  2.0 unx     3707 b- defN 23-Feb-10 11:28 exojax/spec/defmol.py
--rw-rw-r--  2.0 unx    11359 b- defN 23-Mar-19 01:35 exojax/spec/dit.py
--rw-rw-r--  2.0 unx     4499 b- defN 23-Feb-06 13:31 exojax/spec/ditkernel.py
--rw-rw-r--  2.0 unx     3560 b- defN 23-Jul-14 23:49 exojax/spec/dtau_mmwl.py
--rw-rw-r--  2.0 unx     6071 b- defN 22-Apr-30 23:50 exojax/spec/evalline.py
--rw-rw-r--  2.0 unx     1340 b- defN 22-Apr-30 23:50 exojax/spec/exomol.py
--rw-rw-r--  2.0 unx    15387 b- defN 23-Feb-10 10:51 exojax/spec/exomolapi.py
--rw-rw-r--  2.0 unx  1267866 b- defN 22-Aug-25 07:22 exojax/spec/hapi.py
--rw-rw-r--  2.0 unx     3546 b- defN 23-Mar-19 01:35 exojax/spec/hitran.py
--rw-rw-r--  2.0 unx     1916 b- defN 23-Mar-15 09:34 exojax/spec/hitranapi.py
--rw-rw-r--  2.0 unx     3357 b- defN 23-Mar-15 09:34 exojax/spec/hitrancia.py
--rw-rw-r--  2.0 unx     5845 b- defN 22-Apr-30 23:50 exojax/spec/hminus.py
--rw-rw-r--  2.0 unx    11602 b- defN 23-Jul-14 23:49 exojax/spec/initspec.py
--rw-rw-r--  2.0 unx     4219 b- defN 23-Jul-14 23:49 exojax/spec/layeropacity.py
--rw-rw-r--  2.0 unx     3979 b- defN 23-Mar-15 09:34 exojax/spec/lbd.py
--rw-rw-r--  2.0 unx     9993 b- defN 23-Mar-15 09:34 exojax/spec/lbderror.py
--rw-rw-r--  2.0 unx      405 b- defN 23-Feb-06 13:31 exojax/spec/limb_darkening.py
--rw-rw-r--  2.0 unx      121 b- defN 22-Sep-08 09:15 exojax/spec/linefilter.py
--rw-rw-r--  2.0 unx    12592 b- defN 23-Mar-19 01:35 exojax/spec/lpf.py
--rw-rw-r--  2.0 unx     8566 b- defN 23-Mar-15 09:34 exojax/spec/lsd.py
--rw-rw-r--  2.0 unx     3852 b- defN 23-Jul-14 23:49 exojax/spec/make_numatrix.py
--rw-rw-r--  2.0 unx    25279 b- defN 23-Mar-19 01:35 exojax/spec/modit.py
--rw-rw-r--  2.0 unx     5095 b- defN 23-Apr-01 23:50 exojax/spec/modit_scanfft.py
--rw-rw-r--  2.0 unx    24786 b- defN 23-Jul-16 01:07 exojax/spec/moldb.py
--rw-rw-r--  2.0 unx    62169 b- defN 23-Mar-14 23:00 exojax/spec/moldf.py
--rw-rw-r--  2.0 unx     5970 b- defN 23-Mar-15 09:34 exojax/spec/molinfo.py
--rw-rw-r--  2.0 unx    10523 b- defN 23-Jul-16 01:07 exojax/spec/multimol.py
--rw-rw-r--  2.0 unx     2320 b- defN 23-Jul-14 23:49 exojax/spec/nonair.py
--rw-rw-r--  2.0 unx    28380 b- defN 23-Jul-16 01:07 exojax/spec/opacalc.py
--rw-rw-r--  2.0 unx     1668 b- defN 23-Jul-14 23:49 exojax/spec/opachord.py
--rw-rw-r--  2.0 unx     3123 b- defN 22-Aug-25 03:34 exojax/spec/opacity.py
--rw-rw-r--  2.0 unx      847 b- defN 23-Feb-06 13:31 exojax/spec/opacitytools.py
--rw-rw-r--  2.0 unx     1369 b- defN 23-Jul-14 23:49 exojax/spec/opacont.py
--rw-rw-r--  2.0 unx     1110 b- defN 23-Apr-12 03:49 exojax/spec/opspec.py
--rw-rw-r--  2.0 unx     3526 b- defN 23-Jul-14 23:49 exojax/spec/optgrid.py
--rw-rw-r--  2.0 unx      663 b- defN 22-Apr-30 23:50 exojax/spec/planck.py
--rw-rw-r--  2.0 unx    21813 b- defN 23-Sep-04 11:33 exojax/spec/plg.py
--rw-rw-r--  2.0 unx    25815 b- defN 23-Jul-14 23:49 exojax/spec/premodit.py
--rw-rw-r--  2.0 unx     3295 b- defN 23-Mar-01 22:26 exojax/spec/presolar.py
--rw-rw-r--  2.0 unx       91 b- defN 23-Feb-28 02:56 exojax/spec/presolar_scanola.py
--rw-rw-r--  2.0 unx      399 b- defN 23-Jul-14 23:49 exojax/spec/qstate.py
--rw-rw-r--  2.0 unx      164 b- defN 22-Jul-13 05:12 exojax/spec/radis_test.py
--rw-rw-r--  2.0 unx     2763 b- defN 23-Jul-14 23:49 exojax/spec/response.py
--rw-rw-r--  2.0 unx     1384 b- defN 22-Oct-25 23:56 exojax/spec/rtcheck.py
--rw-rw-r--  2.0 unx     5882 b- defN 23-Sep-18 03:20 exojax/spec/rtransfer.py
--rw-rw-r--  2.0 unx     5573 b- defN 23-Jul-14 23:49 exojax/spec/set_ditgrid.py
--rw-rw-r--  2.0 unx     1325 b- defN 22-May-27 07:48 exojax/spec/set_ditgrid_matrix.py
--rw-rw-r--  2.0 unx     4168 b- defN 22-May-27 07:29 exojax/spec/setdit.py
--rw-rw-r--  2.0 unx      313 b- defN 22-Oct-16 01:41 exojax/spec/setrt.py
--rw-rw-r--  2.0 unx     1700 b- defN 23-Feb-06 13:31 exojax/spec/shapefilter.py
--rw-rw-r--  2.0 unx     3237 b- defN 23-Jul-14 23:49 exojax/spec/specop.py
--rw-rw-r--  2.0 unx     2185 b- defN 23-Mar-15 09:34 exojax/spec/spin_rotation.py
--rw-rw-r--  2.0 unx      847 b- defN 22-Oct-25 23:56 exojax/spec/tau1height.py
--rw-rw-r--  2.0 unx     3857 b- defN 23-Sep-10 05:34 exojax/spec/toon.py
--rw-rw-r--  2.0 unx     7835 b- defN 23-Sep-14 01:35 exojax/spec/twostream.py
--rw-rw-r--  2.0 unx     1614 b- defN 23-Jul-14 23:49 exojax/spec/unitconvert.py
--rw-rw-r--  2.0 unx      332 b- defN 23-Jul-16 01:07 exojax/special/__init__.py
--rw-rw-r--  2.0 unx    10399 b- defN 22-Sep-18 04:27 exojax/special/_special.py
--rw-rw-r--  2.0 unx     1067 b- defN 23-Feb-06 13:31 exojax/special/erfcx.py
--rw-rw-r--  2.0 unx      836 b- defN 22-Sep-05 22:10 exojax/special/expn.py
--rw-rw-r--  2.0 unx     3939 b- defN 23-Feb-06 13:31 exojax/special/faddeeva.py
--rw-rw-r--  2.0 unx     2129 b- defN 22-Oct-22 06:53 exojax/special/j0.py
--rw-rw-r--  2.0 unx       14 b- defN 23-Apr-09 00:44 exojax/test/__init__.py
--rw-rw-r--  2.0 unx     1745 b- defN 23-Jul-14 23:49 exojax/test/data.py
--rw-rw-r--  2.0 unx     1271 b- defN 23-Jul-14 23:49 exojax/test/emulate_broadpar.py
--rw-rw-r--  2.0 unx     2839 b- defN 23-Jul-14 23:49 exojax/test/emulate_mdb.py
--rw-rw-r--  2.0 unx     1509 b- defN 23-Feb-04 02:33 exojax/test/emulate_mdb_current.py
--rw-rw-r--  2.0 unx     1843 b- defN 23-Apr-09 00:45 exojax/test/generate.py
--rw-rw-r--  2.0 unx     2591 b- defN 23-Apr-09 00:46 exojax/test/generate_mdb.py
--rw-rw-r--  2.0 unx     3776 b- defN 23-Jul-14 23:49 exojax/test/generate_methane_spectrum.py
--rw-rw-r--  2.0 unx     3736 b- defN 23-Jul-14 23:49 exojax/test/generate_methane_trans.py
--rw-rw-r--  2.0 unx     3946 b- defN 23-Jul-14 23:49 exojax/test/generate_rt.py
--rw-rw-r--  2.0 unx     4958 b- defN 23-Jul-14 23:49 exojax/test/generate_xs.py
--rw-rw-r--  2.0 unx      178 b- defN 23-Jul-16 01:07 exojax/utils/__init__.py
--rw-rw-r--  2.0 unx      973 b- defN 22-Oct-25 23:56 exojax/utils/afunc.py
--rw-rw-r--  2.0 unx      943 b- defN 23-Mar-15 09:34 exojax/utils/astrofunc.py
--rw-rw-r--  2.0 unx      487 b- defN 23-Jul-14 23:49 exojax/utils/checkarray.py
--rw-rw-r--  2.0 unx      650 b- defN 23-Feb-06 13:31 exojax/utils/chopstacks.py
--rw-rw-r--  2.0 unx     1631 b- defN 23-Jul-14 23:49 exojax/utils/constants.py
--rw-rw-r--  2.0 unx      876 b- defN 22-Oct-15 00:05 exojax/utils/delta_velocity.py
--rw-rw-r--  2.0 unx     1970 b- defN 23-Mar-14 23:00 exojax/utils/exofile.py
--rw-rw-r--  2.0 unx      422 b- defN 22-Apr-30 23:50 exojax/utils/gpkernel.py
--rw-rw-r--  2.0 unx     6490 b- defN 23-Sep-16 22:48 exojax/utils/grids.py
--rw-rw-r--  2.0 unx     5206 b- defN 23-Feb-06 13:31 exojax/utils/indexing.py
--rw-rw-r--  2.0 unx     1554 b- defN 23-Mar-19 01:35 exojax/utils/instfunc.py
--rw-rw-r--  2.0 unx      902 b- defN 22-Dec-22 21:46 exojax/utils/isodata.py
--rw-rw-r--  2.0 unx     3326 b- defN 23-Mar-15 09:34 exojax/utils/isotopes.py
--rw-rw-r--  2.0 unx      900 b- defN 23-Jul-14 23:49 exojax/utils/jaxstatus.py
--rw-rw-r--  2.0 unx     5019 b- defN 23-Jul-14 23:49 exojax/utils/memuse.py
--rw-rw-r--  2.0 unx     4797 b- defN 23-Jul-14 23:49 exojax/utils/mollabel.py
--rw-rw-r--  2.0 unx     7962 b- defN 23-Jul-14 23:49 exojax/utils/molname.py
--rw-rw-r--  2.0 unx      565 b- defN 23-Mar-15 09:34 exojax/utils/progbar.py
--rw-rw-r--  2.0 unx     1772 b- defN 22-Apr-30 23:50 exojax/utils/recexomol.py
--rw-rw-r--  2.0 unx     1599 b- defN 22-Oct-25 23:25 exojax/utils/url.py
--rw-rw-r--  2.0 unx     4017 b- defN 22-Sep-05 11:45 exojax/utils/zsol.py
--rw-rw-r--  2.0 unx     1081 b- defN 23-Sep-18 03:30 ExoJAX-1.4.2.dist-info/LICENSE
--rw-rw-r--  2.0 unx     1635 b- defN 23-Sep-18 03:30 ExoJAX-1.4.2.dist-info/LICENSES_bundled.txt
--rw-rw-r--  2.0 unx     5022 b- defN 23-Sep-18 03:30 ExoJAX-1.4.2.dist-info/METADATA
--rw-rw-r--  2.0 unx      110 b- defN 23-Sep-18 03:30 ExoJAX-1.4.2.dist-info/WHEEL
--rw-rw-r--  2.0 unx        7 b- defN 23-Sep-18 03:30 ExoJAX-1.4.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx    15188 b- defN 23-Sep-18 03:30 ExoJAX-1.4.2.dist-info/RECORD
-177 files, 55555564 bytes uncompressed, 6118345 bytes compressed:  89.0%
+Zip file size: 5777552 bytes, number of entries: 160
+-rw-rw-r--  2.0 unx      298 b- defN 24-Feb-23 10:06 exojax/__init__.py
+-rw-rw-r--  2.0 unx      213 b- defN 24-Feb-23 10:06 exojax/atm/__init__.py
+-rw-rw-r--  2.0 unx     4717 b- defN 24-Apr-26 09:46 exojax/atm/amclouds.py
+-rw-rw-r--  2.0 unx      857 b- defN 24-Apr-26 09:46 exojax/atm/atmconvert.py
+-rw-rw-r--  2.0 unx     4716 b- defN 24-Apr-26 09:46 exojax/atm/atmphys.py
+-rw-rw-r--  2.0 unx     9398 b- defN 24-Apr-26 09:46 exojax/atm/atmprof.py
+-rw-rw-r--  2.0 unx     2257 b- defN 24-Apr-26 09:46 exojax/atm/condensate.py
+-rw-rw-r--  2.0 unx      325 b- defN 24-Apr-26 09:46 exojax/atm/idealgas.py
+-rw-rw-r--  2.0 unx      475 b- defN 24-Apr-26 09:46 exojax/atm/lorentz_lorenz.py
+-rw-rw-r--  2.0 unx      998 b- defN 24-Apr-26 09:46 exojax/atm/mixratio.py
+-rw-rw-r--  2.0 unx     1648 b- defN 24-Apr-26 09:46 exojax/atm/polarizability.py
+-rw-rw-r--  2.0 unx     4033 b- defN 24-Apr-26 09:46 exojax/atm/psat.py
+-rw-rw-r--  2.0 unx      434 b- defN 24-Feb-23 10:06 exojax/atm/simple_clouds.py
+-rw-rw-r--  2.0 unx     3086 b- defN 24-Apr-26 09:46 exojax/atm/viscosity.py
+-rw-rw-r--  2.0 unx     4295 b- defN 24-Apr-26 09:46 exojax/atm/vterm.py
+-rw-rw-r--  2.0 unx      171 b- defN 24-Feb-23 10:06 exojax/data/__init__.py
+-rw-rw-r--  2.0 unx     2403 b- defN 24-Feb-23 10:06 exojax/data/abundance/AAG2021.dat
+-rw-rw-r--  2.0 unx     9614 b- defN 24-Feb-23 10:06 exojax/data/atom/HITRAN_molparam.txt
+-rw-rw-r--  2.0 unx   819291 b- defN 24-Feb-23 10:06 exojax/data/atom/NIST_Atomic_Ionization_Energies.txt
+-rw-rw-r--  2.0 unx     6044 b- defN 24-Feb-23 10:06 exojax/data/atom/atomic.txt
+-rw-rw-r--  2.0 unx   171536 b- defN 24-Feb-23 10:06 exojax/data/atom/barklem_collet_2016_pff.txt
+-rw-rw-r--  2.0 unx     8322 b- defN 24-Feb-23 10:06 exojax/data/atom/iso_mn.txt
+-rw-rw-r--  2.0 unx      665 b- defN 24-Apr-26 09:46 exojax/data/clouds/ammonia_liquid_density.csv
+-rw-rw-r--  2.0 unx      188 b- defN 24-Feb-23 10:06 exojax/data/clouds/drag_force.txt
+-rw-rw-r--  2.0 unx  3483224 b- defN 24-Feb-23 10:06 exojax/data/premodit/elower_grid_trange.npz
+-rw-rw-r--  2.0 unx 10533704 b- defN 24-Apr-26 09:46 exojax/data/premodit/elower_grid_trange_v2.npz
+-rw-rw-r--  2.0 unx     2300 b- defN 24-Feb-23 10:06 exojax/data/testdata/H2-H2_TEST.cia
+-rw-rw-r--  2.0 unx  1000000 b- defN 24-Feb-23 10:06 exojax/data/testdata/lpf_rt_test_hitemp_ref.txt
+-rw-rw-r--  2.0 unx  1000000 b- defN 24-Feb-23 10:06 exojax/data/testdata/lpf_rt_test_ref.txt
+-rw-rw-r--  2.0 unx  1000000 b- defN 24-Feb-23 10:06 exojax/data/testdata/lpf_test_hitemp_ref.txt
+-rw-rw-r--  2.0 unx  1000000 b- defN 24-Feb-23 10:06 exojax/data/testdata/lpf_test_ref.txt
+-rw-rw-r--  2.0 unx    85036 b- defN 24-Apr-26 09:46 exojax/data/testdata/miegrid_lognorm_test.mg.npz
+-rw-rw-r--  2.0 unx  1000000 b- defN 24-Feb-23 10:06 exojax/data/testdata/modit_rt_test_hitemp_ref.txt
+-rw-rw-r--  2.0 unx  1000000 b- defN 24-Feb-23 10:06 exojax/data/testdata/modit_rt_test_ref.txt
+-rw-rw-r--  2.0 unx   100000 b- defN 24-Feb-23 10:06 exojax/data/testdata/modit_rt_test_vald_ref.txt
+-rw-rw-r--  2.0 unx  1000000 b- defN 24-Feb-23 10:06 exojax/data/testdata/modit_test_hitemp_ref.txt
+-rw-rw-r--  2.0 unx  1000000 b- defN 24-Feb-23 10:06 exojax/data/testdata/modit_test_hitemp_ref_air.txt
+-rw-rw-r--  2.0 unx  1000000 b- defN 24-Feb-23 10:06 exojax/data/testdata/modit_test_ref.txt
+-rw-rw-r--  2.0 unx   151554 b- defN 24-Feb-23 10:06 exojax/data/testdata/moldb_vald.pickle
+-rw-rw-r--  2.0 unx   750000 b- defN 24-Feb-23 10:06 exojax/data/testdata/premodit_rt_test_hitemp_ref.txt
+-rw-rw-r--  2.0 unx   750000 b- defN 24-Feb-23 10:06 exojax/data/testdata/premodit_rt_test_ref.txt
+-rw-rw-r--  2.0 unx    25000 b- defN 24-Feb-23 10:06 exojax/data/testdata/spectrum.txt
+-rw-rw-r--  2.0 unx    75000 b- defN 24-Feb-23 10:06 exojax/data/testdata/spectrum_ch4.txt
+-rw-rw-r--  2.0 unx    75000 b- defN 24-Feb-23 10:06 exojax/data/testdata/spectrum_ch4_new.txt
+-rw-rw-r--  2.0 unx    75000 b- defN 24-Feb-23 10:06 exojax/data/testdata/spectrum_co.txt
+-rw-rw-r--  2.0 unx     2303 b- defN 24-Apr-26 09:46 exojax/data/testdata/test.refrind
+-rw-rw-r--  2.0 unx  2104704 b- defN 24-Feb-23 10:06 exojax/data/testdata/CO/05_HITEMP_SAMPLE.par
+-rw-rw-r--  2.0 unx     1944 b- defN 24-Feb-23 10:06 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__H2.broad
+-rw-rw-r--  2.0 unx     1680 b- defN 24-Feb-23 10:06 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__He.broad
+-rw-rw-r--  2.0 unx     5074 b- defN 24-Feb-23 10:06 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.def
+-rw-rw-r--  2.0 unx   234000 b- defN 24-Feb-23 10:06 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.pf
+-rw-rw-r--  2.0 unx    54318 b- defN 24-Feb-23 10:06 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.states.bz2
+-rw-rw-r--  2.0 unx   217080 b- defN 24-Feb-23 10:06 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.states.hdf5
+-rw-rw-r--  2.0 unx     3105 b- defN 24-Feb-23 10:06 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.trans.bz2
+-rw-rw-r--  2.0 unx   134416 b- defN 24-Feb-23 10:06 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.trans.hdf5
+-rw-rw-r--  2.0 unx      167 b- defN 24-Feb-23 10:06 exojax/dynamics/__init__.py
+-rw-rw-r--  2.0 unx     2646 b- defN 24-Feb-23 10:06 exojax/dynamics/getE.py
+-rw-rw-r--  2.0 unx     2806 b- defN 24-Feb-23 10:06 exojax/dynamics/rvfunc.py
+-rw-rw-r--  2.0 unx      242 b- defN 24-Feb-23 10:06 exojax/plot/__init__.py
+-rw-rw-r--  2.0 unx     6378 b- defN 24-Apr-26 09:46 exojax/plot/atmplot.py
+-rw-rw-r--  2.0 unx     2124 b- defN 24-Feb-23 10:06 exojax/plot/ditplot.py
+-rw-rw-r--  2.0 unx     1507 b- defN 24-Feb-23 10:06 exojax/plot/opaplot.py
+-rw-rw-r--  2.0 unx     1666 b- defN 24-Apr-26 09:46 exojax/plot/rtplot.py
+-rw-rw-r--  2.0 unx       65 b- defN 24-Feb-23 10:06 exojax/signal/__init__.py
+-rw-rw-r--  2.0 unx      698 b- defN 24-Feb-23 10:06 exojax/signal/convolve.py
+-rw-rw-r--  2.0 unx      616 b- defN 24-Apr-26 09:46 exojax/signal/integrate.py
+-rw-rw-r--  2.0 unx     6552 b- defN 24-Feb-23 10:06 exojax/signal/ola.py
+-rw-rw-r--  2.0 unx      479 b- defN 24-Feb-23 10:06 exojax/spec/__init__.py
+-rw-rw-r--  2.0 unx    40618 b- defN 24-Apr-26 09:46 exojax/spec/api.py
+-rw-rw-r--  2.0 unx    27898 b- defN 24-Apr-26 09:46 exojax/spec/atmrt.py
+-rw-rw-r--  2.0 unx    28504 b- defN 24-Feb-23 10:06 exojax/spec/atomll.py
+-rw-rw-r--  2.0 unx    16616 b- defN 24-Feb-23 10:06 exojax/spec/atomllapi.py
+-rw-rw-r--  2.0 unx     1746 b- defN 24-Apr-26 09:46 exojax/spec/contdb.py
+-rw-rw-r--  2.0 unx    11359 b- defN 24-Feb-23 10:06 exojax/spec/dit.py
+-rw-rw-r--  2.0 unx     4499 b- defN 24-Feb-23 10:06 exojax/spec/ditkernel.py
+-rw-rw-r--  2.0 unx     3560 b- defN 24-Feb-23 10:06 exojax/spec/dtau_mmwl.py
+-rw-rw-r--  2.0 unx     1340 b- defN 24-Feb-23 10:06 exojax/spec/exomol.py
+-rw-rw-r--  2.0 unx     5030 b- defN 24-Apr-26 09:46 exojax/spec/generate_elower_grid_trange.py
+-rw-rw-r--  2.0 unx     3439 b- defN 24-Apr-26 09:46 exojax/spec/hitran.py
+-rw-rw-r--  2.0 unx     1916 b- defN 24-Feb-23 10:06 exojax/spec/hitranapi.py
+-rw-rw-r--  2.0 unx     3357 b- defN 24-Feb-23 10:06 exojax/spec/hitrancia.py
+-rw-rw-r--  2.0 unx     6042 b- defN 24-Apr-26 09:46 exojax/spec/hminus.py
+-rw-rw-r--  2.0 unx    11608 b- defN 24-Apr-26 09:46 exojax/spec/initspec.py
+-rw-rw-r--  2.0 unx     6698 b- defN 24-Apr-26 09:46 exojax/spec/layeropacity.py
+-rw-rw-r--  2.0 unx     3985 b- defN 24-Apr-26 09:46 exojax/spec/lbd.py
+-rw-rw-r--  2.0 unx    10411 b- defN 24-Apr-26 09:46 exojax/spec/lbderror.py
+-rw-rw-r--  2.0 unx      405 b- defN 24-Feb-23 10:06 exojax/spec/limb_darkening.py
+-rw-rw-r--  2.0 unx    12650 b- defN 24-Apr-26 09:46 exojax/spec/lpf.py
+-rw-rw-r--  2.0 unx     7319 b- defN 24-Apr-26 09:46 exojax/spec/lsd.py
+-rw-rw-r--  2.0 unx     3852 b- defN 24-Feb-23 10:06 exojax/spec/make_numatrix.py
+-rw-rw-r--  2.0 unx    12973 b- defN 24-Apr-26 09:46 exojax/spec/mie.py
+-rw-rw-r--  2.0 unx    25499 b- defN 24-Apr-26 09:46 exojax/spec/modit.py
+-rw-rw-r--  2.0 unx     5095 b- defN 24-Feb-23 10:06 exojax/spec/modit_scanfft.py
+-rw-rw-r--  2.0 unx    24786 b- defN 24-Feb-23 10:06 exojax/spec/moldb.py
+-rw-rw-r--  2.0 unx     5966 b- defN 24-Apr-26 09:46 exojax/spec/molinfo.py
+-rw-rw-r--  2.0 unx    10993 b- defN 24-Apr-26 09:46 exojax/spec/multimol.py
+-rw-rw-r--  2.0 unx     2320 b- defN 24-Feb-23 10:06 exojax/spec/nonair.py
+-rw-rw-r--  2.0 unx    30108 b- defN 24-Apr-26 09:46 exojax/spec/opacalc.py
+-rw-rw-r--  2.0 unx     2590 b- defN 24-Apr-26 09:46 exojax/spec/opachord.py
+-rw-rw-r--  2.0 unx      847 b- defN 24-Feb-23 10:06 exojax/spec/opacitytools.py
+-rw-rw-r--  2.0 unx    10847 b- defN 24-Apr-26 09:46 exojax/spec/opacont.py
+-rw-rw-r--  2.0 unx     4051 b- defN 24-Apr-26 09:46 exojax/spec/optgrid.py
+-rw-rw-r--  2.0 unx    11604 b- defN 24-Apr-26 09:46 exojax/spec/pardb.py
+-rw-rw-r--  2.0 unx      663 b- defN 24-Feb-23 10:06 exojax/spec/planck.py
+-rw-rw-r--  2.0 unx    25848 b- defN 24-Apr-26 09:46 exojax/spec/premodit.py
+-rw-rw-r--  2.0 unx     3295 b- defN 24-Feb-23 10:06 exojax/spec/presolar.py
+-rw-rw-r--  2.0 unx      430 b- defN 24-Apr-26 09:46 exojax/spec/qstate.py
+-rw-rw-r--  2.0 unx     1888 b- defN 24-Apr-26 09:46 exojax/spec/rayleigh.py
+-rw-rw-r--  2.0 unx     4276 b- defN 24-Apr-26 09:46 exojax/spec/response.py
+-rw-rw-r--  2.0 unx    18273 b- defN 24-Apr-26 09:46 exojax/spec/rtransfer.py
+-rw-rw-r--  2.0 unx     5573 b- defN 24-Feb-23 10:06 exojax/spec/set_ditgrid.py
+-rw-rw-r--  2.0 unx     1700 b- defN 24-Feb-23 10:06 exojax/spec/shapefilter.py
+-rw-rw-r--  2.0 unx     4851 b- defN 24-Apr-26 09:46 exojax/spec/specop.py
+-rw-rw-r--  2.0 unx     3202 b- defN 24-Apr-26 09:46 exojax/spec/spin_rotation.py
+-rw-rw-r--  2.0 unx     3857 b- defN 24-Apr-26 09:46 exojax/spec/toon.py
+-rw-rw-r--  2.0 unx     8019 b- defN 24-Apr-26 09:46 exojax/spec/twostream.py
+-rw-rw-r--  2.0 unx     2026 b- defN 24-Apr-26 09:46 exojax/spec/unitconvert.py
+-rw-rw-r--  2.0 unx      332 b- defN 24-Feb-23 10:06 exojax/special/__init__.py
+-rw-rw-r--  2.0 unx     1067 b- defN 24-Feb-23 10:06 exojax/special/erfcx.py
+-rw-rw-r--  2.0 unx      836 b- defN 24-Feb-23 10:06 exojax/special/expn.py
+-rw-rw-r--  2.0 unx     3939 b- defN 24-Feb-23 10:06 exojax/special/faddeeva.py
+-rw-rw-r--  2.0 unx     2129 b- defN 24-Feb-23 10:06 exojax/special/j0.py
+-rw-rw-r--  2.0 unx     2226 b- defN 24-Apr-26 09:46 exojax/special/lognormal.py
+-rw-rw-r--  2.0 unx       14 b- defN 24-Feb-23 10:06 exojax/test/__init__.py
+-rw-rw-r--  2.0 unx     1647 b- defN 24-Apr-26 09:46 exojax/test/data.py
+-rw-rw-r--  2.0 unx     1271 b- defN 24-Feb-23 10:06 exojax/test/emulate_broadpar.py
+-rw-rw-r--  2.0 unx     2839 b- defN 24-Feb-23 10:06 exojax/test/emulate_mdb.py
+-rw-rw-r--  2.0 unx      870 b- defN 24-Apr-26 09:46 exojax/test/emulate_pdb.py
+-rw-rw-r--  2.0 unx     1836 b- defN 24-Apr-26 09:46 exojax/test/generate.py
+-rw-rw-r--  2.0 unx     3773 b- defN 24-Apr-26 09:46 exojax/test/generate_methane_spectrum.py
+-rw-rw-r--  2.0 unx     3733 b- defN 24-Apr-26 09:46 exojax/test/generate_methane_trans.py
+-rw-rw-r--  2.0 unx      729 b- defN 24-Apr-26 09:46 exojax/test/generate_pdb.py
+-rw-rw-r--  2.0 unx     3933 b- defN 24-Apr-26 09:46 exojax/test/generate_rt.py
+-rw-rw-r--  2.0 unx     4975 b- defN 24-Apr-26 09:46 exojax/test/generate_xs.py
+-rw-rw-r--  2.0 unx      178 b- defN 24-Feb-23 10:06 exojax/utils/__init__.py
+-rw-rw-r--  2.0 unx      954 b- defN 24-Apr-26 09:46 exojax/utils/astrofunc.py
+-rw-rw-r--  2.0 unx     1281 b- defN 24-Apr-26 09:46 exojax/utils/checkarray.py
+-rw-rw-r--  2.0 unx     1967 b- defN 24-Apr-26 09:46 exojax/utils/constants.py
+-rw-rw-r--  2.0 unx     1256 b- defN 24-Apr-26 09:46 exojax/utils/files.py
+-rw-rw-r--  2.0 unx      422 b- defN 24-Feb-23 10:06 exojax/utils/gpkernel.py
+-rw-rw-r--  2.0 unx     6288 b- defN 24-Apr-26 09:46 exojax/utils/grids.py
+-rw-rw-r--  2.0 unx     4759 b- defN 24-Apr-26 09:46 exojax/utils/indexing.py
+-rw-rw-r--  2.0 unx     1554 b- defN 24-Feb-23 10:06 exojax/utils/instfunc.py
+-rw-rw-r--  2.0 unx      796 b- defN 24-Apr-26 09:46 exojax/utils/interp.py
+-rw-rw-r--  2.0 unx      902 b- defN 24-Feb-23 10:06 exojax/utils/isodata.py
+-rw-rw-r--  2.0 unx     3326 b- defN 24-Feb-23 10:06 exojax/utils/isotopes.py
+-rw-rw-r--  2.0 unx      893 b- defN 24-Apr-26 09:46 exojax/utils/jaxstatus.py
+-rw-rw-r--  2.0 unx     5012 b- defN 24-Apr-26 09:46 exojax/utils/memuse.py
+-rw-rw-r--  2.0 unx     4797 b- defN 24-Feb-23 10:06 exojax/utils/mollabel.py
+-rw-rw-r--  2.0 unx     7962 b- defN 24-Feb-23 10:06 exojax/utils/molname.py
+-rw-rw-r--  2.0 unx      565 b- defN 24-Feb-23 10:06 exojax/utils/progbar.py
+-rw-rw-r--  2.0 unx     1772 b- defN 24-Feb-23 10:06 exojax/utils/recexomol.py
+-rw-rw-r--  2.0 unx     1858 b- defN 24-Apr-26 09:46 exojax/utils/url.py
+-rw-rw-r--  2.0 unx     4017 b- defN 24-Feb-23 10:06 exojax/utils/zsol.py
+-rw-rw-r--  2.0 unx     1081 b- defN 24-Apr-26 09:51 ExoJAX-1.5.dist-info/LICENSE
+-rw-rw-r--  2.0 unx    48407 b- defN 24-Apr-26 09:51 ExoJAX-1.5.dist-info/LICENSES_bundled.txt
+-rw-rw-r--  2.0 unx     5561 b- defN 24-Apr-26 09:51 ExoJAX-1.5.dist-info/METADATA
+-rw-rw-r--  2.0 unx      110 b- defN 24-Apr-26 09:51 ExoJAX-1.5.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        7 b- defN 24-Apr-26 09:51 ExoJAX-1.5.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx    13749 b- defN 24-Apr-26 09:51 ExoJAX-1.5.dist-info/RECORD
+160 files, 29546427 bytes uncompressed, 5756086 bytes compressed:  80.5%
```

## zipnote {}

```diff
@@ -1,32 +1,38 @@
 Filename: exojax/__init__.py
 Comment: 
 
-Filename: exojax/data.py
+Filename: exojax/atm/__init__.py
 Comment: 
 
-Filename: exojax/emulate_broadpar.py
+Filename: exojax/atm/amclouds.py
 Comment: 
 
-Filename: exojax/atm/__init__.py
+Filename: exojax/atm/atmconvert.py
 Comment: 
 
-Filename: exojax/atm/amclouds.py
+Filename: exojax/atm/atmphys.py
 Comment: 
 
 Filename: exojax/atm/atmprof.py
 Comment: 
 
-Filename: exojax/atm/condinfo.py
+Filename: exojax/atm/condensate.py
 Comment: 
 
-Filename: exojax/atm/fastchem2_call.py
+Filename: exojax/atm/idealgas.py
 Comment: 
 
-Filename: exojax/atm/idealgas.py
+Filename: exojax/atm/lorentz_lorenz.py
+Comment: 
+
+Filename: exojax/atm/mixratio.py
+Comment: 
+
+Filename: exojax/atm/polarizability.py
 Comment: 
 
 Filename: exojax/atm/psat.py
 Comment: 
 
 Filename: exojax/atm/simple_clouds.py
 Comment: 
@@ -54,20 +60,26 @@
 
 Filename: exojax/data/atom/barklem_collet_2016_pff.txt
 Comment: 
 
 Filename: exojax/data/atom/iso_mn.txt
 Comment: 
 
+Filename: exojax/data/clouds/ammonia_liquid_density.csv
+Comment: 
+
 Filename: exojax/data/clouds/drag_force.txt
 Comment: 
 
 Filename: exojax/data/premodit/elower_grid_trange.npz
 Comment: 
 
+Filename: exojax/data/premodit/elower_grid_trange_v2.npz
+Comment: 
+
 Filename: exojax/data/testdata/H2-H2_TEST.cia
 Comment: 
 
 Filename: exojax/data/testdata/lpf_rt_test_hitemp_ref.txt
 Comment: 
 
 Filename: exojax/data/testdata/lpf_rt_test_ref.txt
@@ -75,14 +87,17 @@
 
 Filename: exojax/data/testdata/lpf_test_hitemp_ref.txt
 Comment: 
 
 Filename: exojax/data/testdata/lpf_test_ref.txt
 Comment: 
 
+Filename: exojax/data/testdata/miegrid_lognorm_test.mg.npz
+Comment: 
+
 Filename: exojax/data/testdata/modit_rt_test_hitemp_ref.txt
 Comment: 
 
 Filename: exojax/data/testdata/modit_rt_test_ref.txt
 Comment: 
 
 Filename: exojax/data/testdata/modit_rt_test_vald_ref.txt
@@ -93,53 +108,38 @@
 
 Filename: exojax/data/testdata/modit_test_hitemp_ref_air.txt
 Comment: 
 
 Filename: exojax/data/testdata/modit_test_ref.txt
 Comment: 
 
-Filename: exojax/data/testdata/moldb_co_exomol.pickle
-Comment: 
-
-Filename: exojax/data/testdata/moldb_co_hitemp.pickle
-Comment: 
-
-Filename: exojax/data/testdata/moldb_co_hitemp_single_isotope.pickle
-Comment: 
-
-Filename: exojax/data/testdata/moldb_h2o_exomol.pickle
-Comment: 
-
 Filename: exojax/data/testdata/moldb_vald.pickle
 Comment: 
 
 Filename: exojax/data/testdata/premodit_rt_test_hitemp_ref.txt
 Comment: 
 
 Filename: exojax/data/testdata/premodit_rt_test_ref.txt
 Comment: 
 
-Filename: exojax/data/testdata/premodit_test_hitemp_ref.txt
-Comment: 
-
-Filename: exojax/data/testdata/premodit_test_ref.txt
-Comment: 
-
 Filename: exojax/data/testdata/spectrum.txt
 Comment: 
 
 Filename: exojax/data/testdata/spectrum_ch4.txt
 Comment: 
 
 Filename: exojax/data/testdata/spectrum_ch4_new.txt
 Comment: 
 
 Filename: exojax/data/testdata/spectrum_co.txt
 Comment: 
 
+Filename: exojax/data/testdata/test.refrind
+Comment: 
+
 Filename: exojax/data/testdata/CO/05_HITEMP_SAMPLE.par
 Comment: 
 
 Filename: exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__H2.broad
 Comment: 
 
 Filename: exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__He.broad
@@ -189,69 +189,51 @@
 
 Filename: exojax/signal/__init__.py
 Comment: 
 
 Filename: exojax/signal/convolve.py
 Comment: 
 
+Filename: exojax/signal/integrate.py
+Comment: 
+
 Filename: exojax/signal/ola.py
 Comment: 
 
 Filename: exojax/spec/__init__.py
 Comment: 
 
 Filename: exojax/spec/api.py
 Comment: 
 
-Filename: exojax/spec/api_current.py
-Comment: 
-
 Filename: exojax/spec/atmrt.py
 Comment: 
 
 Filename: exojax/spec/atomll.py
 Comment: 
 
 Filename: exojax/spec/atomllapi.py
 Comment: 
 
-Filename: exojax/spec/autospec.py
-Comment: 
-
-Filename: exojax/spec/check_nugrid.py
-Comment: 
-
 Filename: exojax/spec/contdb.py
 Comment: 
 
-Filename: exojax/spec/defcia.py
-Comment: 
-
-Filename: exojax/spec/defmol.py
-Comment: 
-
 Filename: exojax/spec/dit.py
 Comment: 
 
 Filename: exojax/spec/ditkernel.py
 Comment: 
 
 Filename: exojax/spec/dtau_mmwl.py
 Comment: 
 
-Filename: exojax/spec/evalline.py
-Comment: 
-
 Filename: exojax/spec/exomol.py
 Comment: 
 
-Filename: exojax/spec/exomolapi.py
-Comment: 
-
-Filename: exojax/spec/hapi.py
+Filename: exojax/spec/generate_elower_grid_trange.py
 Comment: 
 
 Filename: exojax/spec/hitran.py
 Comment: 
 
 Filename: exojax/spec/hitranapi.py
 Comment: 
@@ -273,38 +255,35 @@
 
 Filename: exojax/spec/lbderror.py
 Comment: 
 
 Filename: exojax/spec/limb_darkening.py
 Comment: 
 
-Filename: exojax/spec/linefilter.py
-Comment: 
-
 Filename: exojax/spec/lpf.py
 Comment: 
 
 Filename: exojax/spec/lsd.py
 Comment: 
 
 Filename: exojax/spec/make_numatrix.py
 Comment: 
 
+Filename: exojax/spec/mie.py
+Comment: 
+
 Filename: exojax/spec/modit.py
 Comment: 
 
 Filename: exojax/spec/modit_scanfft.py
 Comment: 
 
 Filename: exojax/spec/moldb.py
 Comment: 
 
-Filename: exojax/spec/moldf.py
-Comment: 
-
 Filename: exojax/spec/molinfo.py
 Comment: 
 
 Filename: exojax/spec/multimol.py
 Comment: 
 
 Filename: exojax/spec/nonair.py
@@ -312,179 +291,149 @@
 
 Filename: exojax/spec/opacalc.py
 Comment: 
 
 Filename: exojax/spec/opachord.py
 Comment: 
 
-Filename: exojax/spec/opacity.py
-Comment: 
-
 Filename: exojax/spec/opacitytools.py
 Comment: 
 
 Filename: exojax/spec/opacont.py
 Comment: 
 
-Filename: exojax/spec/opspec.py
-Comment: 
-
 Filename: exojax/spec/optgrid.py
 Comment: 
 
-Filename: exojax/spec/planck.py
+Filename: exojax/spec/pardb.py
 Comment: 
 
-Filename: exojax/spec/plg.py
+Filename: exojax/spec/planck.py
 Comment: 
 
 Filename: exojax/spec/premodit.py
 Comment: 
 
 Filename: exojax/spec/presolar.py
 Comment: 
 
-Filename: exojax/spec/presolar_scanola.py
-Comment: 
-
 Filename: exojax/spec/qstate.py
 Comment: 
 
-Filename: exojax/spec/radis_test.py
+Filename: exojax/spec/rayleigh.py
 Comment: 
 
 Filename: exojax/spec/response.py
 Comment: 
 
-Filename: exojax/spec/rtcheck.py
-Comment: 
-
 Filename: exojax/spec/rtransfer.py
 Comment: 
 
 Filename: exojax/spec/set_ditgrid.py
 Comment: 
 
-Filename: exojax/spec/set_ditgrid_matrix.py
-Comment: 
-
-Filename: exojax/spec/setdit.py
-Comment: 
-
-Filename: exojax/spec/setrt.py
-Comment: 
-
 Filename: exojax/spec/shapefilter.py
 Comment: 
 
 Filename: exojax/spec/specop.py
 Comment: 
 
 Filename: exojax/spec/spin_rotation.py
 Comment: 
 
-Filename: exojax/spec/tau1height.py
-Comment: 
-
 Filename: exojax/spec/toon.py
 Comment: 
 
 Filename: exojax/spec/twostream.py
 Comment: 
 
 Filename: exojax/spec/unitconvert.py
 Comment: 
 
 Filename: exojax/special/__init__.py
 Comment: 
 
-Filename: exojax/special/_special.py
-Comment: 
-
 Filename: exojax/special/erfcx.py
 Comment: 
 
 Filename: exojax/special/expn.py
 Comment: 
 
 Filename: exojax/special/faddeeva.py
 Comment: 
 
 Filename: exojax/special/j0.py
 Comment: 
 
+Filename: exojax/special/lognormal.py
+Comment: 
+
 Filename: exojax/test/__init__.py
 Comment: 
 
 Filename: exojax/test/data.py
 Comment: 
 
 Filename: exojax/test/emulate_broadpar.py
 Comment: 
 
 Filename: exojax/test/emulate_mdb.py
 Comment: 
 
-Filename: exojax/test/emulate_mdb_current.py
+Filename: exojax/test/emulate_pdb.py
 Comment: 
 
 Filename: exojax/test/generate.py
 Comment: 
 
-Filename: exojax/test/generate_mdb.py
-Comment: 
-
 Filename: exojax/test/generate_methane_spectrum.py
 Comment: 
 
 Filename: exojax/test/generate_methane_trans.py
 Comment: 
 
+Filename: exojax/test/generate_pdb.py
+Comment: 
+
 Filename: exojax/test/generate_rt.py
 Comment: 
 
 Filename: exojax/test/generate_xs.py
 Comment: 
 
 Filename: exojax/utils/__init__.py
 Comment: 
 
-Filename: exojax/utils/afunc.py
-Comment: 
-
 Filename: exojax/utils/astrofunc.py
 Comment: 
 
 Filename: exojax/utils/checkarray.py
 Comment: 
 
-Filename: exojax/utils/chopstacks.py
-Comment: 
-
 Filename: exojax/utils/constants.py
 Comment: 
 
-Filename: exojax/utils/delta_velocity.py
-Comment: 
-
-Filename: exojax/utils/exofile.py
+Filename: exojax/utils/files.py
 Comment: 
 
 Filename: exojax/utils/gpkernel.py
 Comment: 
 
 Filename: exojax/utils/grids.py
 Comment: 
 
 Filename: exojax/utils/indexing.py
 Comment: 
 
 Filename: exojax/utils/instfunc.py
 Comment: 
 
+Filename: exojax/utils/interp.py
+Comment: 
+
 Filename: exojax/utils/isodata.py
 Comment: 
 
 Filename: exojax/utils/isotopes.py
 Comment: 
 
 Filename: exojax/utils/jaxstatus.py
@@ -507,26 +456,26 @@
 
 Filename: exojax/utils/url.py
 Comment: 
 
 Filename: exojax/utils/zsol.py
 Comment: 
 
-Filename: ExoJAX-1.4.2.dist-info/LICENSE
+Filename: ExoJAX-1.5.dist-info/LICENSE
 Comment: 
 
-Filename: ExoJAX-1.4.2.dist-info/LICENSES_bundled.txt
+Filename: ExoJAX-1.5.dist-info/LICENSES_bundled.txt
 Comment: 
 
-Filename: ExoJAX-1.4.2.dist-info/METADATA
+Filename: ExoJAX-1.5.dist-info/METADATA
 Comment: 
 
-Filename: ExoJAX-1.4.2.dist-info/WHEEL
+Filename: ExoJAX-1.5.dist-info/WHEEL
 Comment: 
 
-Filename: ExoJAX-1.4.2.dist-info/top_level.txt
+Filename: ExoJAX-1.5.dist-info/top_level.txt
 Comment: 
 
-Filename: ExoJAX-1.4.2.dist-info/RECORD
+Filename: ExoJAX-1.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## exojax/atm/amclouds.py

```diff
@@ -1,110 +1,152 @@
 """Ackerman and Marley 2001 cloud model.
 
-- Ackerman and Marley (2001) ApJ 556, 872, hereafter AM01
+    - based on Ackerman and Marley (2001) ApJ 556, 872, hereafter AM01
+
 """
+
 from jax import jit
 import jax.numpy as jnp
 from jax import vmap
 
 
+def mixing_ratio_cloud_pressure(pressure, cloud_base_pressure, fsed, mr_cloud_base, kc):
+    """mol mixing ratio of clouds based on AM01 a given single pressure.
+
+    Args:
+        pressure (float): pressure (bar) where we want to compute VMR of clouds
+        cloud_base_pressure: cloud base pressure (bar)
+        fsed: fsed
+        mr_cloud_base: mass mixing ratio (MMR) or mol mixing ratio of condensate at cloud base
+        kc: constant ratio of condenstates to total mixing ratio
+
+    Returns:
+        mol mixing ratio of condensates
+    """
+    return jnp.where(
+        cloud_base_pressure > pressure,
+        mr_cloud_base * (pressure / cloud_base_pressure) ** (fsed / kc),
+        0.0,
+    )
+
+
 @jit
-def VMRcloud(P, Pbase, fsed, VMRbase, kc=1):
-    """VMR of clouds based on AM01.
+def mixing_ratio_cloud_profile(
+    pressures, cloud_base_pressure, fsed, mr_cloud_base, kc=1
+):
+    """volume mixing ratio of clouds based on AM01 given pressure.
 
     Args:
-        P: Pressure (bar)
-        Pbase: base pressure (bar)
+        pressures: pressure array  (Nlayer) (bar) where we want to compute VMR of clouds
+        cloud_base_pressure: cloud base pressure (bar)
         fsed: fsed
-        VMRbase: VMR of condensate at cloud base
+        mr_cloud_base: mass mixing ratio (MMR) or mol mixing ratio of condensate at cloud base
         kc: constant ratio of condenstates to total mixing ratio
 
     Returns:
         VMR of condensates
     """
-    VMRc = jnp.where(Pbase > P, VMRbase*(P/Pbase)**(fsed/kc), 0.0)
-    return VMRc
+    vmaped_function = vmap(mixing_ratio_cloud_pressure, (0, None, None, None, None), 0)
+    return vmaped_function(pressures, cloud_base_pressure, fsed, mr_cloud_base, kc)
+
+
+@jit
+def compute_cloud_base_pressure(pressure, saturation_pressure, vmr_vapor):
+    """computes cloud base pressure from an intersection of a T-P profile and Psat(T) curves
+    Args:
+        pressure: pressure array
+        saturation_presure: saturation pressure arrau
+        vmr_vapor: volume mixing ratio (VMR) for vapor
+
+    Returns:
+        cloud base pressure
+    """
+    ibase = compute_cloud_base_pressure_index(pressure, saturation_pressure, vmr_vapor)
+    return pressure[ibase]
 
 
 @jit
-def get_Pbase(Parr, Psat, VMR):
-    """get Pbase from an intersection of a T-P profile and Psat(T) curves
+def compute_cloud_base_pressure_index(pressure, saturation_pressure, vmr_vapor):
+    """computes cloud base pressure from an intersection of a T-P profile and Psat(T) curves
     Args:
-        Parr: pressure array
-        Psat: saturation pressure arrau
-        VMR: VMR for vapor
+        pressure: pressure array
+        saturation_presure: saturation pressure arrau
+        vmr_vapor: volume mixing ratio (VMR) for vapor
 
     Returns:
-        Pbase: base pressure
+        int: cloud base pressure index
     """
-    # ibase=jnp.searchsorted((Psat/VMR)-Parr,0.0) # 231 +- 9.2 us
-    ibase = jnp.argmin(jnp.abs(jnp.log(Parr)-jnp.log(Psat) +
-                       jnp.log(VMR)))  # 73.8 +- 2.9 us
-    return Parr[ibase]
+    ibase=jnp.searchsorted((saturation_pressure/vmr_vapor)-pressure,0.0) # 231 +- 9.2 us, find index from ascending array 
+    return ibase
 
 
-def get_rw(vfs, Kzz, L, rarr):
+def get_rw(terminal_velocity, Kzz, L, rarr):
     """compute rw in AM01 implicitly defined by (11)
 
     Args:
-       vfs: terminal velocity (cm/s)
-       Kzz: diffusion coefficient (cm2/s)
-       L: typical convection scale (cm)
-       rarr: condensate scale array
+        vfs: terminal velocity (cm/s)
+        Kzz: diffusion coefficient (cm2/s)
+        L: typical convection scale (cm)
+        rarr: condensate scale array
 
     Returns:
-       rw: rw (cm) in AM01. i.e. condensate size that balances an upward transport and sedimentation
+        rw: rw (cm) in AM01. i.e. condensate size that balances an upward transport and sedimentation
     """
-    iscale = jnp.searchsorted(vfs, Kzz/L)
+    iscale = jnp.searchsorted(terminal_velocity, Kzz / L)
     rw = rarr[iscale]
     return rw
 
 
 def get_rg(rw, fsed, alpha, sigmag):
     """compute rg of the lognormal size distribution defined by (9) in AM01.
     The computation is based on (13) in AM01.
 
     Args:
-       rw: rw (cm)
-       fsed: fsed
-       alpha: power of the condensate size distribution
-       sigmag: sigmag in the lognormal size distribution
-
+        rw: rw (cm)
+        fsed: fsed
+        alpha: power of the condensate size distribution
+        sigmag:sigmag parameter (geometric standard deviation) in the lognormal distribution of condensate size, defined by (9) in AM01, must be sigmag > 1
+        
     Returns
+        rg: rg parameter in the lognormal distribution of condensate size, defined by (9) in AM01
+
     """
-    rg = rw*fsed**(1.0/alpha)*jnp.exp(-(alpha/2.0+3.0)*(jnp.log(sigmag))**2)
+    rg = (
+        rw
+        * fsed ** (1.0 / alpha)
+        * jnp.exp(-(alpha / 2.0 + 3.0) * (jnp.log(sigmag)) ** 2)
+    )
     return rg
 
 
-def find_rw(rarr, vf, KzzpL):
+def find_rw(rarr, terminal_velocity, Kzz_over_L):
     """finding rw from rarr and terminal velocity array.
 
     Args:
         rarr: particle radius array (cm)
-        vf: terminal velocity (cm/s)
-        KzzpL: Kzz/L in Ackerman and Marley 2001
+        terminal_velocity: terminal velocity (cm/s)
+        Kzz_over_L: Kzz/L in Ackerman and Marley 2001
 
     Returns:
         rw in Ackerman and Marley 2001
     """
-    iscale = jnp.searchsorted(vf, KzzpL)
+    iscale = jnp.searchsorted(terminal_velocity, Kzz_over_L)
     rw = rarr[iscale]
     return rw
 
+def geometric_radius(rg, sigmag):
+    """ computes the paritculate geometric radius
+    
+    Args:
+        rg (float): rg parameter in lognormal distribution in cgs
+        sigmag (float): sigma_g parameter in lognormal distribution 
+
 
-def dtau_cloudgeo(Parr, muc, rhoc, mu, VMRc, rg, sigmag, g):
-    """the optical depth using a geometric cross-section approximation, based
-    on (16) in AM01.
-
-    Args:
-       Parr: pressure array (bar)
-       muc: mass weight of condensate
-       rhoc: condensate density (g/cm3)
-       mu: mean molecular weight of atmosphere
-       VMRc: VMR array of condensate [Nlayer]
-       rg: rg parameter in the lognormal distribution of condensate size, defined by (9) in AM01
-       sigmag:sigmag parameter in the lognormal distribution of condensate size, defined by (9) in AM01
-    """
-
-    fac = jnp.exp(-2.5*jnp.log(sigmag)**2)
-    dtau = 1.5*muc/mu*VMRc*fac/(rg*rhoc*g)*Parr*1.e6
-    return dtau
+    Note:
+        The cross section is given by $S = Q_e \pi r_geo^2$ 
+
+    Returns:
+        _type_: geometric radius in cgs 
+    """
+    #logs = jnp.log(sigmag)
+    #return jnp.exp(logs*logs)*rg
+    return sigmag**jnp.log(sigmag)*rg
```

## exojax/atm/atmprof.py

```diff
@@ -3,103 +3,163 @@
 from exojax.utils.constants import kB, m_u
 import jax.numpy as jnp
 import numpy as np
 from jax.lax import scan
 from jax import jit
 
 
-def pressure_layer_logspace(log_pressure_top=-8.,
-                            log_pressure_btm=2.,
-                            nlayer=20,
-                            mode='ascending',
-                            reference_point=0.5,
-                            numpy=False):
-    """ Pressure layer evenly spaced in logspace, i.e. logP interval is constant 
-
-    Args:
-       log_pressure_top: log10(P[bar]) at the top layer
-       log_pressure_btm: log10(P[bar]) at the bottom layer
-       nlayer: the number of the layers
-       mode: ascending or descending
-       reference_point (float): reference point in a layer (0-1). Center:0.5, lower boundary:1.0, upper boundary:0
-       numpy: if True use numpy array instead of jnp array
-
-    Returns:
-         pressure: pressure layer
-         dParr: delta pressure layer
-         pressure_decrease_rate: pressure decrease rate of the layer (k-factor; k < 1) pressure[i-1] = pressure_decrease_rate*pressure[i]
+def pressure_layer_logspace(
+    log_pressure_top=-8.0,
+    log_pressure_btm=2.0,
+    nlayer=20,
+    mode="ascending",
+    reference_point=0.5,
+    numpy=False,
+):
+    """Pressure layer evenly spaced in logspace, i.e. logP interval is constant
+
+    Args:
+        log_pressure_top: log10(P[bar]) at the top layer
+        log_pressure_btm: log10(P[bar]) at the bottom layer
+        nlayer: the number of the layers
+        mode: ascending or descending
+        reference_point (float): reference point in a layer (0-1). Center:0.5, lower boundary:1.0, upper boundary:0
+        numpy: if True use numpy array instead of jnp array
+
+    Returns:
+        pressures: representative pressures (array) of the layers
+        delta_pressures: delta pressure layer, the old name is dParr
+        pressure_decrease_rate: pressure decrease rate of the layer (k-factor; k < 1) pressure[i-1] = pressure_decrease_rate*pressure[i]
 
     Note:
-        d logP is constant using this function. 
+        d logP is constant using this function.
     """
     dlogP = (log_pressure_btm - log_pressure_top) / (nlayer - 1)
     if numpy:
-        pressure = np.logspace(log_pressure_top, log_pressure_btm, nlayer)
+        pressures = np.logspace(log_pressure_top, log_pressure_btm, nlayer)
     else:
-        pressure = jnp.logspace(log_pressure_top, log_pressure_btm, nlayer)
+        pressures = jnp.logspace(log_pressure_top, log_pressure_btm, nlayer)
 
     k = 10**-dlogP
-    dParr = (k**(reference_point - 1.0) - k**reference_point) * pressure
-    
-    if mode == 'descending':
-        pressure = pressure[::-1]
-        dParr = dParr[::-1]
+    delta_pressures = (k ** (reference_point - 1.0) - k**reference_point) * pressures
+
+    if mode == "descending":
+        pressures = pressures[::-1]
+        delta_pressures = delta_pressures[::-1]
+
+    return pressures, delta_pressures, k
+
+
+def pressure_upper_logspace(pressures, pressure_decrease_rate, reference_point=0.5):
+    """computes pressure at the upper point of the layers
 
-    return pressure, dParr, k
+    Args:
+        pressures (_type_): representative pressure (output of pressure_layer_logspace)
+        pressure_decrease_rate: pressure decrease rate of the layer (k-factor; k < 1) pressure[i-1] = pressure_decrease_rate*pressure[i]
+        reference_point (float): reference point in a layer (0-1). Center:0.5, lower boundary:1.0, upper boundary:0
+
+    Returns:
+        _type_: pressure at the upper point (\overline{P}_i)
+    """
+    return (pressure_decrease_rate**reference_point) * pressures
+
+
+def pressure_lower_logspace(pressures, pressure_decrease_rate, reference_point=0.5):
+    """computes pressure at the lower point of the layers
+
+    Args:
+        pressures (_type_): representative pressure (output of pressure_layer_logspace)
+        pressure_decrease_rate: pressure decrease rate of the layer (k-factor; k < 1) pressure[i-1] = pressure_decrease_rate*pressure[i]
+        reference_point (float): reference point in a layer (0-1). Center:0.5, lower boundary:1.0, upper boundary:0
+
+    Returns:
+        _type_: pressure at the lower point (underline{P}_i)
+    """
+    return (pressure_decrease_rate ** (reference_point - 1.0)) * pressures
+
+
+def pressure_boundary_logspace(
+    pressures, pressure_decrease_rate, reference_point=0.5, numpy=False
+):
+    """computes pressure at the boundary of the layers (Nlayer + 1)
+
+    Args:
+        pressures (_type_): representative pressure (output of pressure_layer_logspace)
+        pressure_decrease_rate: pressure decrease rate of the layer (k-factor; k < 1) pressure[i-1] = pressure_decrease_rate*pressure[i]
+        reference_point (float): reference point in a layer (0-1). Center:0.5, lower boundary:1.0, upper boundary:0
+        numpy: if True use numpy array instead of jnp array
+
+    Returns:
+        _type_: pressure at the boundary (Nlayer + 1)
+    """
+    pressure_bottom_boundary = (
+        pressure_decrease_rate ** (reference_point - 1.0)
+    ) * pressures[-1]
+    pressure_upper = pressure_upper_logspace(
+        pressures, pressure_decrease_rate, reference_point
+    )
+    if numpy:
+        return np.append(pressure_upper, pressure_bottom_boundary)
+    else:
+        return jnp.append(pressure_upper, pressure_bottom_boundary)
 
 
 @jit
-def normalized_layer_height(temperature, pressure_decrease_rate,
-                            mean_molecular_weight, radius_btm, gravity_btm):
-    """compute normalized height/radius at the upper boundary of the atmospheric layer, neglecting atmospheric mass. 
+def normalized_layer_height(
+    temperature, pressure_decrease_rate, mean_molecular_weight, radius_btm, gravity_btm
+):
+    """compute normalized height/radius at the upper boundary of the atmospheric layer, neglecting atmospheric mass, examining non-constant gravity.
+
+    Note:
+        This method computes the height of the atmospheric layers taking the effect of the decrease of gravity (i.e. $ \propto 1/r^2 $) into account.
 
     Args:
         temperature (1D array): temperature profile (K) of the layer, (Nlayer, from atmospheric top to bottom)
         pressure_decrease_rate:  pressure decrease rate of the layer (k-factor; k < 1) pressure[i-1] = pressure_decrease_rate*pressure[i]
-        mean_molecular_weight (1D array): mean molecular weight profile, (Nlayer, from atmospheric top to bottom) 
+        mean_molecular_weight (1D array): mean molecular weight profile, (Nlayer, from atmospheric top to bottom)
         radius_btm (float): radius (cm) at the lower boundary of the bottom layer, R0 or r_N
         gravity_btm (float): gravity (cm/s2) at the lower boundary of the bottom layer, g_N
 
     Returns:
         1D array (Nlayer) : layer height normalized by radius_btm starting from top atmosphere
         1D array (Nlayer) : radius at lower bondary normalized by radius_btm starting from top atmosphere
     """
     inverse_Tarr = temperature[::-1]
     inverse_mmr_arr = mean_molecular_weight[::-1]
-    Mat = jnp.vstack([inverse_Tarr, inverse_mmr_arr]).T
+    stacked_profiles = jnp.vstack([inverse_Tarr, inverse_mmr_arr]).T
 
     def compute_radius(normalized_radius_lower, arr):
-        T_layer = arr[0:1][0]
-        mmw_layer = arr[1:2][0]
-        gravity_lower = gravity_btm / normalized_radius_lower
-        Hn_lower = pressure_scale_height(gravity_lower, T_layer,
-                                         mmw_layer) / radius_btm
-        fac = pressure_decrease_rate**(-Hn_lower /
-                                       normalized_radius_lower) - 1.0
+        T_layer, mmw_layer = arr
+        gravity_lower = gravity_btm / normalized_radius_lower**2
+        Hn_lower = pressure_scale_height(gravity_lower, T_layer, mmw_layer) / radius_btm
+        a = 1.0 + Hn_lower / normalized_radius_lower * jnp.log(pressure_decrease_rate)
+        fac = 1.0 / a - 1.0
         normalized_height_layer = fac * normalized_radius_lower
         carry = normalized_radius_lower + normalized_height_layer
         return carry, [normalized_height_layer, normalized_radius_lower]
 
-    _, results = scan(compute_radius, 1.0, Mat)
+    _, results = scan(compute_radius, 1.0, stacked_profiles)
     normalized_height = results[0][::-1]
     normalized_radius_lower = results[1][::-1]
     return normalized_height, normalized_radius_lower
 
 
 def gh_product(temperature, mean_molecular_weight):
-    """prodict of gravity and pressure scale height
+    """product of gravity and pressure scale height
 
     Args:
         temperature: isothermal temperature (K)
         mean_molecular_weight: mean molecular weight
 
     Returns:
         gravity x pressure scale height cm2/s2
     """
-    return kB * temperature / (m_u * mean_molecular_weight)
+    return (
+        kB * temperature / m_u / mean_molecular_weight
+    )  # Apply mmw (jnp array) last to minimize rounding errors in 32bit mode.
 
 
 def pressure_scale_height(gravity, T, mean_molecular_weight):
     """pressure scale height assuming an isothermal atmosphere.
 
     Args:
         gravity: gravity acceleration (cm/s2)
@@ -109,99 +169,99 @@
     Returns:
         pressure scale height (cm)
     """
 
     return gh_product(T, mean_molecular_weight) / gravity
 
 
-def atmprof_powerlow(pressure, T0, alpha):
+def atmprof_powerlow(pressures, T0, alpha):
     """powerlaw temperature profile
 
     Args:
-        pressure: pressure array (bar)
+        pressures: pressure array (bar)
         T0 (float): T at P=1 bar in K
         alpha (float): powerlaw index
 
     Returns:
         array: temperature profile
     """
-    return T0 * pressure**alpha
+    return T0 * pressures**alpha
 
 
-def atmprof_gray(pressure, gravity, kappa, Tint):
+def atmprof_gray(pressures, gravity, kappa, Tint):
     """
 
     Args:
-        pressure (1D array): pressure array (bar)
+        pressures (1D array): pressure array (bar)
         gravity (float): gravity (cm/s2)
-        kappa: infrared opacity 
+        kappa: infrared opacity
         Tint: temperature equivalence of the intrinsic energy flow
 
     Returns:
         array: temperature profile
 
     """
 
-    tau = pressure * 1.e6 * kappa / gravity
-    Tarr = (0.75 * Tint**4 * (2.0 / 3.0 + tau))**0.25
+    tau = pressures * 1.0e6 * kappa / gravity
+    Tarr = (0.75 * Tint**4 * (2.0 / 3.0 + tau)) ** 0.25
     return Tarr
 
 
-def atmprof_Guillot(pressure, gravity, kappa, gamma, Tint, Tirr, f=0.25):
+def atmprof_Guillot(pressures, gravity, kappa, gamma, Tint, Tirr, f=0.25):
     """
 
     Notes:
         Guillot (2010) Equation (29)
 
     Args:
-        pressure: pressure array (bar)
+        pressures: pressure array (bar)
         gravity: gravity (cm/s2)
         kappa: thermal/IR opacity (kappa_th in Guillot 2010)
         gamma: ratio of optical and IR opacity (kappa_v/kappa_th), gamma > 1 means thermal inversion
         Tint: temperature equivalence of the intrinsic energy flow
         Tirr: temperature equivalence of the irradiation
-        f = 1 at the substellar point, f = 1/2 for a day-side average 
+        f = 1 at the substellar point, f = 1/2 for a day-side average
             and f = 1/4 for an averaging over the whole planetary surface
 
     Returns:
         array: temperature profile
 
     """
-    tau = pressure * 1.e6 * kappa / gravity  # Equation (51)
+    tau = pressures * 1.0e6 * kappa / gravity  # Equation (51)
     invsq3 = 1.0 / jnp.sqrt(3.0)
     fac = 2.0 / 3.0 + invsq3 * (
-        1.0 / gamma + (gamma - 1.0 / gamma) * jnp.exp(-gamma * tau / invsq3))
-    Tarr = (0.75 * Tint**4 * (2.0 / 3.0 + tau) +
-            0.75 * Tirr**4 * f * fac)**0.25
+        1.0 / gamma + (gamma - 1.0 / gamma) * jnp.exp(-gamma * tau / invsq3)
+    )
+    Tarr = (0.75 * Tint**4 * (2.0 / 3.0 + tau) + 0.75 * Tirr**4 * f * fac) ** 0.25
 
     return Tarr
 
 
 def Teq2Tirr(Teq):
     """Tirr from equilibrium temperature and intrinsic temperature.
 
     Args:
-       Teq: equilibrium temperature
-       
+        Teq: equilibrium temperature
+
     Return:
-       Tirr: iradiation temperature
+        Tirr: iradiation temperature
 
     Note:
-       Here we assume A=0 (albedo) and beta=1 (fully-energy distributed)
+        Here we assume A=0 (albedo) and beta=1 (fully-energy distributed)
     """
     return (2.0**0.5) * Teq
 
 
 def Teff2Tirr(Teff, Tint):
     """Tirr from effective temperature and intrinsic temperature.
 
     Args:
-       Teff: effective temperature
-       Tint: intrinsic temperature
+        Teff: effective temperature
+        Tint: intrinsic temperature
 
     Return:
-       Tirr: iradiation temperature
+        Tirr: iradiation temperature
 
     Note:
-       Here we assume A=0 (albedo) and beta=1 (fully-energy distributed)
+        Here we assume A=0 (albedo) and beta=1 (fully-energy distributed)
     """
-    return (4.0 * Teff**4 - Tint**4)**0.25
+    return (4.0 * Teff**4 - Tint**4) ** 0.25
```

## exojax/atm/idealgas.py

```diff
@@ -3,15 +3,15 @@
 from exojax.utils.constants import kB
 
 
 def number_density(Parr, Tarr):
     """number density of ideal gas in cgs.
 
     Args:
-       Parr: pressure array (bar)
-       Tarr: temperature array (K)
+        Parr: pressure array (bar)
+        Tarr: temperature array (K)
 
     Returns:
-       number density (1/cm3)
+        number density (1/cm3)
     """
 
-    return (Parr*1.e6)/(kB*Tarr)
+    return (Parr * 1.0e6) / (kB * Tarr)
```

## exojax/atm/psat.py

```diff
@@ -1,47 +1,170 @@
 """Saturation Vapor Pressure."""
 import jax.numpy as jnp
+from exojax.utils.constants import Tc_water, Ttp_water
 
 
-def Psat_enstatite_AM01(T):
+def psat_water_Magnus(T):
+    """
+    Saturation Vapor Pressure for water (Magnus, or August-Roche-Magnus)
+
+    Note:
+        See https://en.wikipedia.org/wiki/Clausius%E2%80%93Clapeyron_relation#August%E2%80%93Roche%E2%80%93Magnus_approximation
+
+    Args:
+        T: temperature (K)
+
+    Returns:
+        saturation vapor pressure (bar)
+    """
+    Tcelcius = T - Tc_water
+
+    return 6.1094e-3 * jnp.exp(17.625 * (Tcelcius) / ((Tcelcius) + 243.04))
+
+
+def psat_water_AM01(T):
+    """
+    Saturation Vapor Pressure for water (but for T<1048K)
+
+    Note:
+        Taken from Ackerman and Marley 2001 Appendix A (A4) see also their errata and updated
+        Buck 1981, 1996
+
+    Args:
+        T: temperature (K)
+
+    Returns:
+        saturation vapor pressure (bar)
+    """
+    Tcelcius = T - Tc_water
+    Tcrit = 1048 # K
+    return jnp.where(
+        T > Tcrit,
+        600.0,
+        jnp.where(
+            T < Tc_water,            
+            _psat_water_buck_ice(Tcelcius),
+            _psat_water_buck_liquid(Tcelcius),
+        )
+    )
+
+
+def _psat_water_buck_ice(T):
+    return 0.0061115 * jnp.exp((23.036 * T - T**2 / 333.7) / (T + 279.82))
+
+
+def _psat_water_buck_liquid(T):
+    # return 0.0061121*jnp.exp((18.729*T - T**2/227.3)/(T + 257.87)) AM Appendix but old
+    return 0.0061121 * jnp.exp(
+        (18.678 * T - T**2 / 234.5) / (T + 257.14)
+    )  # from wikipedia (updated)
+
+
+def psat_ammonia_AM01(T):
+    """Saturation Vapor Pressure for Ammonia
+
+    Note:
+        Taken from Ackerman and Marley 2001 Appendix A (A4) see also their errata.
+
+    Args:
+        T: temperature (K)
+
+    Returns:
+        saturation vapor pressure (bar)
+    """
+    return jnp.exp(10.53 - 2161.0 / T - 86596.0 / T**2)
+
+
+def psat_enstatite_AM01(T):
     """Saturation Vapor Pressure for Enstatite (MgSiO3)
 
     Note:
-       Taken from Ackerman and Marley 2001 Appendix A (A4) see also their errata.
+        Taken from Ackerman and Marley 2001 Appendix A (A4) see also their errata, originally from  Barshay and Lewis (1976)
 
     Args:
-       T: temperature (K)
+        T: temperature (K)
 
     Returns:
-       saturation vapor pressure (bar)
+        saturation vapor pressure (bar)
     """
-    return jnp.exp(25.37-58663./T)
+    return jnp.exp(25.37 - 58663.0 / T)
 
 
-def Psat_Fe_solid(T):
+def psat_Fe_AM01(T):
+    """
+    Saturation Vapor Pressure for iron
+
+    Note:
+        Taken from Ackerman and Marley 2001 Appendix A (A3), originally from  Barshay and Lewis (1976)
+        
+
+    Args:
+        T: temperature (K)
+
+    Returns:
+        saturation vapor pressure (bar)
+    """
+    Tc_Fe = 1800.0
+
+    return jnp.where(
+        T > Tc_Fe,
+        _psat_Fe_liquid(T),
+        _psat_Fe_solid(T),
+    )
+    #return jnp.exp(25.37 - 58663.0 / T)
+
+
+def _psat_Fe_solid(T):
     """Saturation Vapor Pressure for Solid Fe (Fe)
 
     Note:
-       Taken from Ackerman and Marley 2001 Appendix A (A4) see also their errata.
+        Taken from Ackerman and Marley 2001 Appendix A (A4) see also their errata.
 
     Args:
-       T: temperature (K)
+        T: temperature (K)
 
     Returns:
-       saturation vapor pressure (bar)
+        saturation vapor pressure (bar)
     """
-    return jnp.exp(15.71-47664./T)
+    return jnp.exp(15.71 - 47664.0 / T)
 
 
-def Psat_Fe_liquid(T):
+def _psat_Fe_liquid(T):
     """Saturation Vapor Pressure for liquid Fe (Fe)
 
     Note:
-       Taken from Ackerman and Marley 2001 Appendix A (A4) see also their errata.
+        Taken from Ackerman and Marley 2001 Appendix A (A4) see also their errata.
 
     Args:
-       T: temperature (K)
+        T: temperature (K)
 
     Returns:
-       saturation vapor pressure (bar)
+        saturation vapor pressure (bar)
     """
-    return jnp.exp(9.86-37120./T)
+    return jnp.exp(9.86 - 37120.0 / T)
+
+
+if __name__ == "__main__":
+    import numpy as np
+    import matplotlib.pyplot as plt
+
+    t = np.linspace(100.0, 3000.0, 1000)
+    plt.plot(t, psat_water_AM01(t), label="H2O", color="C0")
+    plt.plot(t, psat_ammonia_AM01(t), label="NH3", color="C3")
+
+    t = np.linspace(400.0, 3000.0, 1000)
+    plt.plot(t, psat_Fe_AM01(t), label="Fe", color="C1")
+    plt.plot(1800.0, psat_Fe_AM01(1800.0), "*", color="C1")
+    plt.plot(t, psat_enstatite_AM01(t), label="MgSiO3", color="C2")
+
+    plt.plot(Tc_water, psat_water_AM01(Tc_water), "*", label="liquid/soild boundary", color="C0")
+    
+
+    plt.ylim(1.e3,1.e-8)    
+
+    plt.xlabel("T (K)")
+    plt.ylabel("P (bar)")
+    plt.yscale("log")
+    plt.xscale("log")
+    plt.legend()
+    plt.savefig("psat.png")
+    plt.show()
```

## exojax/atm/viscosity.py

```diff
@@ -3,92 +3,92 @@
 import numpy as np
 
 
 def eta_Rosner_H2(T):
     """dynamic viscocity of the H2 atmosphere by Rosner (2000)
 
     Args:
-       T: temperature (K) (applicable from 179 to 11940K)
+        T: temperature (K) (applicable from 179 to 11940K)
 
     Returns:
-       dynamic viscosity (g/s/cm)
+        dynamic viscosity (g/s/cm)
     """
     return eta_Rosner(T, 2.02072025e-6)
 
 
 def eta_Rosner(T, vfactor):
     """dynamic viscocity by Rosner (2000)
 
     Args:
-       T: temperature (K)
-       vfactor: vfactor
+        T: temperature (K)
+        vfactor: vfactor
 
     Returns:
-       dynamic viscosity (g/s/cm)
+        dynamic viscosity (g/s/cm)
     """
-    eta = vfactor*(T**0.66)
+    eta = vfactor * (T**0.66)
     return eta
 
 
 def get_LJPparam():
     """Lennard-Jones Potential Parameters.
 
     Returns:
-       LJPparam_d: Dict for Lennard-Jones Potential Parameters (d (cm))
-       LJPparam_epsilon_per_kB: Dict for Lennard-Jones Potential Parameters (epsilon/kB)
+        LJPparam_d: Dict for Lennard-Jones Potential Parameters (d (cm))
+        LJPparam_epsilon_per_kB: Dict for Lennard-Jones Potential Parameters (epsilon/kB)
 
     Note:
-       Lennard-Jones Potential Parameters (LJPparam) were taken from p107, Table 3.2.1 of Transport process in chemically reacting flow systems by Daniel E. Rosner, originally from Svehla (1962).
+        Lennard-Jones Potential Parameters (LJPparam) were taken from p107, Table 3.2.1 of Transport process in chemically reacting flow systems by Daniel E. Rosner, originally from Svehla (1962).
     """
     LJPparam_d = {}
     LJPparam_epsilon_per_kB = {}
 
-    LJPparam_d['H2'] = 2.827e-8
-    LJPparam_epsilon_per_kB['H2'] = 59.7
+    LJPparam_d["H2"] = 2.827e-8
+    LJPparam_epsilon_per_kB["H2"] = 59.7
 
-    LJPparam_d['He'] = 2.551e-8
-    LJPparam_epsilon_per_kB['He'] = 10.22
+    LJPparam_d["He"] = 2.551e-8
+    LJPparam_epsilon_per_kB["He"] = 10.22
 
-    LJPparam_d['N2'] = 3.798e-8
-    LJPparam_epsilon_per_kB['N2'] = 71.4
+    LJPparam_d["N2"] = 3.798e-8
+    LJPparam_epsilon_per_kB["N2"] = 71.4
 
-    LJPparam_d['CO2'] = 3.941e-8
-    LJPparam_epsilon_per_kB['CO2'] = 195.2
+    LJPparam_d["CO2"] = 3.941e-8
+    LJPparam_epsilon_per_kB["CO2"] = 195.2
 
-    LJPparam_d['H2O'] = 2.641e-8
-    LJPparam_epsilon_per_kB['H2O'] = 809.1
+    LJPparam_d["H2O"] = 2.641e-8
+    LJPparam_epsilon_per_kB["H2O"] = 809.1
 
-    LJPparam_d['CH4'] = 3.758e-8
-    LJPparam_epsilon_per_kB['CH4'] = 148.6
+    LJPparam_d["CH4"] = 3.758e-8
+    LJPparam_epsilon_per_kB["CH4"] = 148.6
 
-    LJPparam_d['CO'] = 3.69e-8
-    LJPparam_epsilon_per_kB['CO'] = 91.7
+    LJPparam_d["CO"] = 3.69e-8
+    LJPparam_epsilon_per_kB["CO"] = 91.7
 
-    LJPparam_d['O2'] = 3.467e-8
-    LJPparam_epsilon_per_kB['O2'] = 106.7
+    LJPparam_d["O2"] = 3.467e-8
+    LJPparam_epsilon_per_kB["O2"] = 106.7
 
-    LJPparam_d['Air'] = 3.711e-8
-    LJPparam_epsilon_per_kB['Air'] = 78.6
+    LJPparam_d["Air"] = 3.711e-8
+    LJPparam_epsilon_per_kB["Air"] = 78.6
 
     return LJPparam_d, LJPparam_epsilon_per_kB
 
 
-def calc_vfactor(atm='H2', LJPparam=None):
+def calc_vfactor(atm="H2", LJPparam=None):
     """
 
     Args:
-       atm: molecule consisting of atmosphere, "H2", "O2", and "N2" 
-       LJPparam: Custom Lennard-Jones Potential Parameters (d (cm) and epsilon/kB)
+        atm: molecule consisting of atmosphere, "H2", "O2", and "N2"
+        LJPparam: Custom Lennard-Jones Potential Parameters (d (cm) and epsilon/kB)
 
     Returns:
-       vfactor: dynamic viscosity factor for Rosner eta = viscosity*T**0.66
-       applicable tempature range (K,K) 
+        vfactor: dynamic viscosity factor for Rosner eta = viscosity*T**0.66
+        applicable tempature range (K,K)
 
     Note:
-       The dynamic viscosity is from the Rosner book (3-2-12) and caption in p106 Hirschfelder et al. (1954) within Trange.
+        The dynamic viscosity is from the Rosner book (3-2-12) and caption in p106 Hirschfelder et al. (1954) within Trange.
 
 
     """
     from exojax.spec.molinfo import molmass_isotope
     from exojax.utils.constants import kB, m_u
 
     mu = molmass_isotope(atm)
@@ -97,21 +97,26 @@
         LJPparam_d, LJPparam_epsilon_per_kB = get_LJPparam()
         epsilon_per_kB = LJPparam_epsilon_per_kB[atm]
         d = LJPparam_d[atm]
     else:
         epsilon_per_kB = LJPparam[0]
         d = LJPparam[1]
 
-    vfactor = 5.0/16.0*np.sqrt(np.pi*kB*mu*m_u) / \
-        (np.pi*d*d)/1.22*(1.0/epsilon_per_kB)**0.16
-    Trange = [3.0*epsilon_per_kB, 200.0*epsilon_per_kB]
+    vfactor = (
+        5.0
+        / 16.0
+        * np.sqrt(np.pi * kB * mu * m_u)
+        / (np.pi * d * d)
+        / 1.22
+        * (1.0 / epsilon_per_kB) ** 0.16
+    )
+    Trange = [3.0 * epsilon_per_kB, 200.0 * epsilon_per_kB]
 
     return vfactor, Trange
 
 
-if __name__ == '__main__':
-
-    vfactor, Tr = calc_vfactor('H2')
+if __name__ == "__main__":
+    vfactor, Tr = calc_vfactor("H2")
     dvisc = eta_Rosner(1500.0, vfactor)
     print(vfactor, dvisc)
     dvisc = eta_Rosner_H2(1500.0)
     print(dvisc)
```

## exojax/atm/vterm.py

```diff
@@ -82,46 +82,47 @@
         terminal velocity (cm/s)
     """
     ND = Ndavies(r, g, eta, drho, rho)
     Cd = 0.45
     return eta/(2.0*rho*r)*jnp.sqrt(ND/Cd)
 
 
+
 @jit
-def vf(r, g, eta, rhoc, rho, Nkn=0.0):
-    """terminal velocity.
+def terminal_velocity(r, gravity, dynamic_viscosity, rho_cloud, rho_atm, Nkn=0.0):
+    """computes terminal velocity in a wide particles size range.
 
     Args:
         r: particle size (cm)
         g: gravity (cm/s2)
-        eta: dynamic viscosity (g/s/cm)
-        rhoc: condensate density (g/cm3)
-        rho: atmosphere density (g/cm3)
+        dynamic_viscosity: dynamic viscosity (g/s/cm)
+        rho_cloud: condensate density (g/cm3)
+        rho_atm: atmosphere density (g/cm3)
         Nkn: Knudsen number
 
     Return:
         terminal velocity (cm/s)    
 
     Example:
 
         >>> #terminal velocity at T=300K, for Earth atmosphere/gravity.
         >>> g=980.
         >>> drho=1.0
         >>> rho=1.29*1.e-3 #g/cm3
         >>> vfactor,Tr=vc.calc_vfactor(atm="Air")
         >>> eta=vc.eta_Rosner(300.0,vfactor)
         >>> r=jnp.logspace(-5,0,70)
-        >>> vf(r,g,eta,drho,rho) #terminal velocity (cm/s)
+        >>> terminal_velocity(r,g,eta,drho,rho) #terminal velocity (cm/s)
     """
-    drho = rhoc-rho
-    ND = Ndavies(r, g, eta, drho, rho)
+    drho = rho_cloud-rho_atm
+    ND = Ndavies(r, gravity, dynamic_viscosity, drho, rho_atm)
     cond = [ND < 42.877543, (ND >= 42.877543) *
             (ND < 119643.38), ND >= 119643.38]
-    choice = [vf_stokes(r, g, eta, drho, Nkn), vf_midNre(
-        r, g, eta, drho, rho), vf_largeNre(r, g, eta, drho, rho)]
+    choice = [vf_stokes(r, gravity, dynamic_viscosity, drho, Nkn), vf_midNre(
+        r, gravity, dynamic_viscosity, drho, rho_atm), vf_largeNre(r, gravity, dynamic_viscosity, drho, rho_atm)]
     vft = jnp.select(cond, choice)
     return vft
 
 
 if __name__ == '__main__':
     import matplotlib.pyplot as plt
     import exojax.atm.viscosity as vc
@@ -129,14 +130,14 @@
     g = 980.
     drho = 1.0
     rho = 1.29*1.e-3  # g/cm3
     vfactor, Tr = vc.calc_vfactor(atm='Air')
     eta = vc.eta_Rosner(300.0, vfactor)
     r = jnp.logspace(-5, 0, 70)
     plt.figure(figsize=(5, 3))
-    plt.plot(r*1.e4, vf(r, g, eta, drho, rho), color='black')
+    plt.plot(r*1.e4, terminal_velocity(r, g, eta, drho, rho), color='black')
     plt.xscale('log')
     plt.yscale('log')
     plt.xlabel('r (micron)')
     plt.ylabel('terminal velocity (cm/s)')
     plt.savefig('vterm.pdf', bbox_inches='tight', pad_inches=0.0)
     plt.show()
```

## exojax/plot/atmplot.py

```diff
@@ -1,202 +1,218 @@
 """plotting tool for atmospheric structure."""
+
 import numpy as np
 import matplotlib.pyplot as plt
 from exojax.utils.constants import hcperk
+from exojax.utils.grids import check_eslog_wavenumber_grid
+import warnings
 
 
-def plottau(nus,
-            dtauM,
-            Tarr=None,
-            Parr=None,
-            unit=None,
-            mode=None,
-            vmin=-3,
-            vmax=3):
+def plottau(nugrid, dtauM, Tarr=None, Parr=None, unit=None, mode=None, vmin=-3, vmax=3):
     """Plot optical depth (tau). This function gives the color map of log10(tau) (or log10(dtau)), optionally w/ a T-P profile.
 
     Args:
-       nus: wavenumber
-       dtauM: dtau matrix
-       Tarr: temperature profile
-       Parr: perssure profile
-       unit: x-axis unit=um (wavelength microns), nm  = (wavelength nm), AA  = (wavelength Angstrom),
-       mode: mode=None (lotting tau), mode=dtau (plotting delta tau for each layer)
-       vmin: color value min (default=-3)
-       vmax: color value max (default=3)
+        nus: wavenumber in linear scale
+        dtauM: dtau matrix
+        Tarr: temperature profile
+        Parr: perssure profile
+        unit: x-axis unit=um (wavelength microns), nm  = (wavelength nm), AA  = (wavelength Angstrom),
+        mode: mode=None (lotting tau), mode=dtau (plotting delta tau for each layer)
+        vmin: color value min (default=-3)
+        vmax: color value max (default=3)
     """
-    if mode == 'dtau':
+    if check_eslog_wavenumber_grid(nugrid):
+        warnings.warn(
+            "nugrid looks in log scale, results in a wrong X-axis value. Use log10(nugrid) instead."
+        )
+
+    if mode == "dtau":
         ltau = np.log10(dtauM)
     else:
         ltau = np.log10(np.cumsum(dtauM, axis=0))
 
     plt.figure(figsize=(20, 3))
     ax = plt.subplot2grid((1, 20), (0, 3), colspan=18)
-
+    c = None
     if unit == "um" or unit == "nm" or unit == "AA":
         factor, labelx = factor_labelx_for_unit()
-        extent = [
-            factor[unit] / nus[-1], factor[unit] / nus[0],
-            np.log10(Parr[-1]),
-            np.log10(Parr[0])
-        ]
-        c = imshow_custom(vmin, vmax, ltau[:, ::-1], extent, ax)
+        if Parr is not None:
+            extent = [
+                factor[unit] / nugrid[-1],
+                factor[unit] / nugrid[0],
+                np.log10(Parr[-1]),
+                np.log10(Parr[0]),
+            ]
+            c = imshow_custom(vmin, vmax, ltau[:, ::-1], extent, ax)
         plt.xlabel(labelx[unit])
     else:
-        extent = [nus[0], nus[-1], np.log10(Parr[-1]), np.log10(Parr[0])]
-        c = imshow_custom(vmin, vmax, ltau, extent, ax)
-        plt.xlabel('wavenumber ($\mathrm{cm}^{-1}$)')
-
-    plt.colorbar(c, shrink=0.8)
-    plt.ylabel('log10 (P (bar))')
+        if Parr is not None:
+            extent = [nugrid[0], nugrid[-1], np.log10(Parr[-1]), np.log10(Parr[0])]
+            c = imshow_custom(vmin, vmax, ltau, extent, ax)
+        plt.xlabel("wavenumber ($\mathrm{cm}^{-1}$)")
+
+    if c is not None:
+        plt.colorbar(c, shrink=0.8)
+    plt.ylabel("log10 (P (bar))")
     ax.set_aspect(0.2 / ax.get_data_ratio())
+
     if Tarr is not None and Parr is not None:
-        plot_TPprofile(Tarr, Parr)
+        _plot_profile_left_panel(Tarr, Parr, xlabel="temperature (K)")
 
 
 def factor_labelx_for_unit():
     factor = {}
-    factor["um"] = 1.e4
-    factor["nm"] = 1.e7
-    factor["AA"] = 1.e8
+    factor["um"] = 1.0e4
+    factor["nm"] = 1.0e7
+    factor["AA"] = 1.0e8
     labelx = {}
-    labelx["um"] = 'wavelength ($\mu \mathrm{m}$)'
-    labelx["nm"] = 'wavelength (nm)'
-    labelx["AA"] = 'wavelength ($\AA$)'
-    labelx["cm-1"] = 'wavenumber ($\mathrm{cm}^{-1}$)'
+    labelx["um"] = "wavelength ($\mu \mathrm{m}$)"
+    labelx["nm"] = "wavelength (nm)"
+    labelx["AA"] = "wavelength ($\AA$)"
+    labelx["cm-1"] = "wavenumber ($\mathrm{cm}^{-1}$)"
     return factor, labelx
 
 
-def plotcf(nus,
-           dtauM,
-           Tarr,
-           Parr,
-           dParr,
-           unit="cm-1",
-           mode=None,
-           log=False,
-           normalize=True,
-           cmap='bone_r'):
-    """plot the contribution function. This function gives a plot of contribution function, optionally w/ a T-P profile.
+def plotcf(
+    nus,
+    dtauM,
+    Tarr,
+    Parr,
+    dParr,
+    unit="cm-1",
+    log=False,
+    normalize=True,
+    cmap="bone_r",
+    optarr=None,
+    leftxlabel="Warning: specify leftxpanel",
+    leftxlog=False,
+):
+    """plot the contribution function. This function gives a plot of contribution function, optionally w/ a T-P (or any) profile.
 
     Args:
-       nus: wavenumber
-       dtauM: dtau matrix
-       Tarr: temperature profile
-       Parr: perssure profile
-       dParr: perssure difference profile
-       unit: x-axis unit=cm-1, um (wavelength microns), nm  = (wavelength nm), AA  = (wavelength Angstrom),
-       mode: None=contour, "cmap"=color map
-       log: True=use log10(cf)
-       normalize: normalize cf for each wavenumber?
-       cmap: colormap
+        nus: wavenumber
+        dtauM: dtau matrix
+        Tarr: temperature profile
+        Parr: perssure profile
+        dParr: perssure difference profile
+        unit: x-axis unit=cm-1, um (wavelength microns), nm  = (wavelength nm), AA  = (wavelength Angstrom),
+        log: True=use log10(cf)
+        normalize: normalize cf for each wavenumber?
+        cmap: colormap
+        optarr: the optional profile X, i.e. a X-P profile of the left panel, instead of a T-P profile
+        leftxlabel: xlable of the left panel
+        leftxlog: if True, log for the x grid of the left panel
 
     Returns:
-       contribution function
+        contribution function
     """
     tau = np.cumsum(dtauM, axis=0)
-    cf = np.exp(-tau)*dtauM\
-        * (Parr[:, None]/dParr[:, None])\
-        * nus**3/(np.exp(hcperk*nus/Tarr[:, None])-1.0)
+    cf = (
+        np.exp(-tau)
+        * dtauM
+        * (Parr[:, None] / dParr[:, None])
+        * nus**3
+        / np.expm1(hcperk * nus / Tarr[:, None])
+        # / (np.exp(hcperk * nus / Tarr[:, None]) - 1.0)
+    )
 
     if normalize:
-        cf = (cf / np.sum(cf, axis=0))
+        cf = cf / np.sum(cf, axis=0)
     if log:
         cf = np.log10(cf)
 
     plt.figure(figsize=(20, 3))
     ax = plt.subplot2grid((1, 20), (0, 3), colspan=18)
     factor, labelx = factor_labelx_for_unit()
 
     if unit == "um" or unit == "nm" or unit == "AA":
-        extent = [
-            factor[unit] / nus[-1], factor[unit] / nus[0],
-            np.log10(Parr[-1]),
-            np.log10(Parr[0])
-        ]
-        xcf=cf[:, ::-1]
-        xnus=factor[unit] / nus
+        xnus = factor[unit] / nus
     else:
-        extent = [nus[0], nus[-1], np.log10(Parr[-1]), np.log10(Parr[0])]
-        xcf = cf
-        xnus = nus        
-        
-    if mode == 'cmap':
-        c = ax.imshow(xcf, cmap=cmap, alpha=0.9, extent=extent)
-    else:
-        X, Y = np.meshgrid(xnus, np.log10(Parr))
-        c = ax.contourf(X, Y, cf, 30, cmap=cmap)
-        plt.gca().invert_yaxis()
+        xnus = nus
+
+    X, Y = np.meshgrid(xnus, np.log10(Parr))
+    c = ax.contourf(X, Y, cf, 30, cmap=cmap)
+    plt.gca().invert_yaxis()
 
     plt.xlabel(labelx[unit])
-    plt.ylabel('log10 (P (bar))')
+    plt.ylabel("log10 (P (bar))")
     plt.colorbar(c, shrink=0.8)
     ax.set_aspect(0.2 / ax.get_data_ratio())
 
-    if Tarr is not None and Parr is not None:
-        plot_TPprofile(Tarr, Parr)
+    if optarr is not None and Parr is not None:
+        xlabel = leftxlabel
+        xlog = leftxlog
+    elif Tarr is not None and Parr is not None:
+        xlabel = "temperature (K)"
+        xlog = False
+
+    _plot_profile_left_panel(Tarr, Parr, xlabel=xlabel, xlog=xlog)
 
     return cf
 
 
 def imshow_custom(vmin, vmax, ltau, extent, ax):
-    c = ax.imshow(ltau,
-                  vmin=vmin,
-                  vmax=vmax,
-                  cmap='RdYlBu_r',
-                  alpha=0.9,
-                  extent=extent)
+    c = ax.imshow(ltau, vmin=vmin, vmax=vmax, cmap="RdYlBu_r", alpha=0.9, extent=extent)
     return c
 
 
-def plot_TPprofile(Tarr, Parr):
+def _plot_profile_left_panel(Tarr, Parr, xlabel, xlog=False):
     ax = plt.subplot2grid((1, 20), (0, 0), colspan=2)
-    plt.plot(Tarr, np.log10(Parr), color='gray')
-    plt.xlabel('temperature (K)')
-    plt.ylabel('log10 (P (bar))')
+    plt.plot(Tarr, np.log10(Parr), color="gray")
+    plt.xlabel(xlabel)
+    plt.ylabel("log10 (P (bar))")
     plt.gca().invert_yaxis()
     plt.ylim(np.log10(Parr[-1]), np.log10(Parr[0]))
+    if xlog:
+        plt.xscale("log")
+
     ax.set_aspect(1.45 / ax.get_data_ratio())
 
 
-def plot_maxpoint(mask, Parr, maxcf, maxcia, mol='CO'):
+def plot_maxpoint(mask, Parr, maxcf, maxcia, mol="CO"):
     """Plotting max contribution function  points.
 
     Args:
-       mask: weak line mask
-       Parr: Paressure array
-       maxcf: max contribution function of the molecules
-       maxcia: max contribution function of CIA
-       mol: molecular name
+        mask: weak line mask
+        Parr: Paressure array
+        maxcf: max contribution function of the molecules
+        maxcia: max contribution function of CIA
+        mol: molecular name
     """
     plt.figure(figsize=(14, 6))
     xarr = np.array(range(0, len(mask)))
-    masknon0 = (maxcf > 0)
-    plt.plot(xarr[masknon0],
-             Parr[maxcf[masknon0]],
-             '.',
-             label=mol,
-             alpha=1.0,
-             color='gray',
-             rasterized=True)
-    plt.plot(xarr[mask],
-             Parr[maxcf[mask]],
-             '.',
-             label=mol + ' selected',
-             alpha=1.0,
-             color='C3',
-             rasterized=True)
-    plt.plot(xarr,
-             Parr[maxcia],
-             '-',
-             label='CIA (H2-H2)',
-             alpha=1.0,
-             color='C2',
-             rasterized=True)
+    masknon0 = maxcf > 0
+    plt.plot(
+        xarr[masknon0],
+        Parr[maxcf[masknon0]],
+        ".",
+        label=mol,
+        alpha=1.0,
+        color="gray",
+        rasterized=True,
+    )
+    plt.plot(
+        xarr[mask],
+        Parr[maxcf[mask]],
+        ".",
+        label=mol + " selected",
+        alpha=1.0,
+        color="C3",
+        rasterized=True,
+    )
+    plt.plot(
+        xarr,
+        Parr[maxcia],
+        "-",
+        label="CIA (H2-H2)",
+        alpha=1.0,
+        color="C2",
+        rasterized=True,
+    )
 
-    plt.yscale('log')
+    plt.yscale("log")
     plt.ylim(Parr[0], Parr[-1])
     plt.gca().invert_yaxis()
     plt.tick_params(labelsize=20)
-    plt.xlabel('#line', fontsize=20)
-    plt.ylabel('Pressure (bar)', fontsize=20)
+    plt.xlabel("#line", fontsize=20)
+    plt.ylabel("Pressure (bar)", fontsize=20)
     plt.legend(fontsize=20)
```

## exojax/plot/rtplot.py

```diff
@@ -38,8 +38,8 @@
                  'contribution function ($\hat{Q} \prod \hat{T}$)',
                  'log scale')
     plt.plot(spectrum, label="That * Qhat ")
     plt.plot(spectrum_pure, label="Tpure * Qpure", ls="dashed", lw=2)
     plt.legend()
     plt.show()
 
-    return spectrum
+    return spectrum, spectrum_pure
```

## exojax/spec/api.py

```diff
@@ -14,121 +14,130 @@
 from exojax.utils.constants import Tref_original
 from exojax.utils.molname import e2s
 from exojax.spec import hitranapi
 from exojax.spec.hitranapi import molecid_hitran
 from exojax.spec.molinfo import isotope_molmass
 from exojax.utils.isotopes import molmass_hitran
 
-from radis.api.exomolapi import MdbExomol as CapiMdbExomol  #MdbExomol in the common API
+from radis.api.exomolapi import (
+    MdbExomol as CapiMdbExomol,
+)  # MdbExomol in the common API
 from radis.api.hitempapi import HITEMPDatabaseManager
 from radis.api.hitranapi import HITRANDatabaseManager
 from radis.api.hdf5 import update_pytables_to_vaex
 from radis.db.classes import get_molecule
 from radis.levels.partfunc import PartFuncTIPS
 import warnings
 
-__all__ = ['MdbExomol', 'MdbHitemp', 'MdbHitran']
+__all__ = ["MdbExomol", "MdbHitemp", "MdbHitran"]
 
 
 class MdbExomol(CapiMdbExomol):
     """molecular database of ExoMol.
-    
+
     MdbExomol is a class for ExoMol.
 
     Attributes:
         simple_molecule_name: simple molecule name
         nurange: nu range [min,max] (cm-1)
         nu_lines (nd array): line center (cm-1)
         Sij0 (nd array): line strength at T=Tref (cm)
-        
+
         logsij0 (jnp array): log line strength at T=Tref
         A (jnp array): Einstein A coeeficient
         gamma_natural (DataFrame or jnp array): gamma factor of the natural broadening
         elower (DataFrame or jnp array): the lower state energy (cm-1)
         gpp (DataFrame or jnp array): statistical weight
         jlower (DataFrame or jnp array): J_lower
         jupper (DataFrame or jnp array): J_upper
         n_Texp (DataFrame or jnp array): temperature exponent
         dev_nu_lines (jnp array): line center in device (cm-1)
         alpha_ref (jnp array): alpha_ref (gamma0), Lorentzian half-width at reference temperature and pressure in cm-1/bar
         n_Texp_def: default temperature exponent in .def file, used for jlower not given in .broad
         alpha_ref_def: default alpha_ref (gamma0) in .def file, used for jlower not given in .broad
     """
-    def __init__(self,
-                 path,
-                 nurange=[-np.inf, np.inf],
-                 crit=0.,
-                 elower_max=None,
-                 Ttyp=1000.,
-                 bkgdatm='H2',
-                 broadf=True,
-                 gpu_transfer=True,
-                 inherit_dataframe=False,
-                 optional_quantum_states=False,
-                 activation=True,
-                 local_databases="./"):
+
+    def __init__(
+        self,
+        path,
+        nurange=[-np.inf, np.inf],
+        crit=0.0,
+        elower_max=None,
+        Ttyp=1000.0,
+        bkgdatm="H2",
+        broadf=True,
+        gpu_transfer=True,
+        inherit_dataframe=False,
+        optional_quantum_states=False,
+        activation=True,
+        local_databases="./",
+    ):
         """Molecular database for Exomol form.
 
         Args:
             path: path for Exomol data directory/tag. For instance, "/home/CO/12C-16O/Li2015"
             nurange: wavenumber range list (cm-1) [min,max] or wavenumber grid, if None, it starts as the nonactive mode
             crit: line strength lower limit for extraction
             Ttyp: typical temperature to calculate Sij(T) used in crit
             bkgdatm: background atmosphere for broadening. e.g. H2, He,
             broadf: if False, the default broadening parameters in .def file is used
             gpu_transfer: if True, some instances will be transfered to jnp.array. False is recommended for PreMODIT.
             inherit_dataframe: if True, it makes self.df instance available, which needs more DRAM when pickling.
             optional_quantum_states: if True, all of the fields available in self.df will be loaded. if False, the mandatory fields (i,E,g,J) will be loaded.
-            activation: if True, the activation of mdb will be done when initialization, if False, the activation won't be done and it makes self.df instance available. 
+            activation: if True, the activation of mdb will be done when initialization, if False, the activation won't be done and it makes self.df instance available.
 
 
         Note:
             The trans/states files can be very large. For the first time to read it, we convert it to HDF/vaex. After the second-time, we use the HDF5 format with vaex instead.
         """
         self.dbtype = "exomol"
         self.path = pathlib.Path(path).expanduser()
         self.exact_molecule_name = self.path.parents[0].stem
         self.database = str(self.path.stem)
         self.bkgdatm = bkgdatm
-        #molecbroad = self.exact_molecule_name + '__' + self.bkgdatm
+        # molecbroad = self.exact_molecule_name + '__' + self.bkgdatm
         self.Tref = Tref_original
         self.gpu_transfer = gpu_transfer
         self.Ttyp = Ttyp
         self.broadf = broadf
         self.simple_molecule_name = e2s(self.exact_molecule_name)
         self.molmass = isotope_molmass(self.exact_molecule_name)
         self.skip_optional_data = not optional_quantum_states
         self.activation = activation
         wavenum_min, wavenum_max = self.set_wavenum(nurange)
 
-        super().__init__(str(self.path),
-                         local_databases=local_databases,
-                         molecule=self.simple_molecule_name,
-                         name="EXOMOL-{molecule}",
-                         nurange=[wavenum_min, wavenum_max],
-                         engine="vaex",
-                         crit=crit,
-                         bkgdatm=self.bkgdatm,
-                         broadf=self.broadf,
-                         cache=True,
-                         skip_optional_data=self.skip_optional_data)
+        super().__init__(
+            str(self.path),
+            local_databases=local_databases,
+            molecule=self.simple_molecule_name,
+            name="EXOMOL-{molecule}",
+            nurange=[wavenum_min, wavenum_max],
+            engine="vaex",
+            crit=crit,
+            bkgdatm=self.bkgdatm,
+            broadf=self.broadf,
+            cache=True,
+            skip_optional_data=self.skip_optional_data,
+        )
 
         self.crit = crit
         self.elower_max = elower_max
         self.QTtyp = np.array(self.QT_interp(self.Ttyp))
 
         # Get cache files to load :
         mgr = self.get_datafile_manager()
         local_files = [mgr.cache_file(f) for f in self.trans_file]
+
         # data frame instance:
         df = self.load(
             local_files,
-            columns=[k for k in self.__dict__ if k not in ["logsij0"]],
-            lower_bound=([("Sij0", 0.0)]),
-            output="vaex")
+            # columns=[k for k in self.__dict__ if k not in ["logsij0"]],
+            # lower_bound=([("Sij0", 0.0)]),
+            output="vaex",
+        )
 
         self.df_load_mask = self.compute_load_mask(df)
 
         if self.activation:
             self.activate(df)
         if inherit_dataframe or not self.activation:
             print("DataFrame (self.df) available.")
@@ -145,59 +154,65 @@
         if wavenum_min == -np.inf:
             wavenum_min = None
         if wavenum_max == np.inf:
             wavenum_max = None
         return wavenum_min, wavenum_max
 
     def activate(self, df, mask=None):
-        """activation of moldb, 
-        
+        """activation of moldb,
+
         Notes:
-            activation includes, making instances, computing broadening parameters, natural width, 
+            activation includes, making instances, computing broadening parameters, natural width,
             and transfering instances to gpu arrays when self.gpu_transfer = True
 
         Args:
             df: DataFrame
             mask: mask of DataFrame to be used for the activation, if None, no additional mask is applied.
 
         Note:
             self.df_load_mask is always applied when the activation.
 
         Examples:
-            
+
             >>> # we would extract the line with delta nu = 2 here
             >>> mdb = api.MdbExomol(emf, nus, optional_quantum_states=True, activation=False)
             >>> load_mask = (mdb.df["v_u"] - mdb.df["v_l"] == 2)
             >>> mdb.activate(mdb.df, load_mask)
 
 
         """
         if mask is not None:
             mask = mask * self.df_load_mask
         else:
             mask = self.df_load_mask
 
         self.instances_from_dataframes(df[mask])
-        self.compute_broadening(self.jlower.astype(int), self.jupper.astype(int))
+        try:  # old radis <=0.14
+            self.compute_broadening(self.jlower.astype(int), self.jupper.astype(int))
+        except:
+            self.set_broadening_coef(df[mask], add_columns=False)
+
         self.gamma_natural = gn(self.A)
         if self.gpu_transfer:
             self.generate_jnp_arrays()
 
     def compute_load_mask(self, df):
-
-        #wavelength
-        mask = (df.nu_lines > self.nurange[0]) \
-                    * (df.nu_lines < self.nurange[1])
+        # wavelength
+        print(df)
+        mask = (df.nu_lines > self.nurange[0]) * (df.nu_lines < self.nurange[1])
         QTtyp = np.array(self.QT_interp(self.Ttyp))
         QTref_original = np.array(self.QT_interp(Tref_original))
-        mask *= (line_strength_numpy(self.Ttyp, df.Sij0, df.nu_lines,
-                                     df.elower, QTtyp / QTref_original) >
-                 self.crit)
+        mask *= (
+            line_strength_numpy(
+                self.Ttyp, df.Sij0, df.nu_lines, df.elower, QTtyp / QTref_original
+            )
+            > self.crit
+        )
         if self.elower_max is not None:
-            mask *= (df.elower < self.elower_max)
+            mask *= df.elower < self.elower_max
         return mask
 
     def instances_from_dataframes(self, df_masked):
         """generate instances from (usually masked) data frame
 
         Args:
             df_masked (DataFrame): (masked) data frame
@@ -212,14 +227,15 @@
         if isinstance(df_masked, vaex.dataframe.DataFrameLocal):
             self.A = df_masked.A.values
             self.nu_lines = df_masked.nu_lines.values
             self.elower = df_masked.elower.values
             self.jlower = df_masked.jlower.values
             self.jupper = df_masked.jupper.values
             self.line_strength_ref = df_masked.Sij0.values
+            self.logsij0 = np.log(self.line_strength_ref)
             self.gpp = df_masked.gup.values
         else:
             raise ValueError("Use vaex dataframe as input.")
 
     def apply_mask_mdb(self, mask):
         """apply mask for mdb class
 
@@ -242,15 +258,15 @@
         self.elower = self.elower[mask]
         self.jlower = self.jlower[mask]
         self.jupper = self.jupper[mask]
         self.line_strength_ref = self.line_strength_ref[mask]
         self.gpp = self.gpp[mask]
 
     def Sij0(self):
-        """Deprecated line_strength_ref. 
+        """Deprecated line_strength_ref.
 
         Returns:
             ndarray: line_strength_ref
         """
         msg = "Sij0 instance was replaced to line_strength_ref and will be removed."
         warnings.warn(msg, FutureWarning)
         return self.line_strength_ref
@@ -300,47 +316,48 @@
         """change the reference temperature Tref and recompute Sij0
 
         Args:
             Tref_new (float): new Tref in Kelvin
         """
         print("Tref changed: " + str(self.Tref) + "K->" + str(Tref_new) + "K")
         qr = self.qr_interp(Tref_new)
-        self.line_strength_ref = line_strength_numpy(Tref_new,
-                                                     self.line_strength_ref,
-                                                     self.nu_lines,
-                                                     self.elower, qr,
-                                                     self.Tref)
+        self.line_strength_ref = line_strength_numpy(
+            Tref_new, self.line_strength_ref, self.nu_lines, self.elower, qr, self.Tref
+        )
+        self.logsij0 = np.log(self.line_strength_ref)
         self.Tref = Tref_new
 
 
-class MdbCommonHitempHitran():
-    def __init__(self,
-                 path="CO",
-                 nurange=[-np.inf, np.inf],
-                 crit=0.,
-                 elower_max=None,
-                 Ttyp=1000.,
-                 isotope=1,
-                 gpu_transfer=False,
-                 inherit_dataframe=False,
-                 activation=True,
-                 parfile=None,
-                 with_error=False):
+class MdbCommonHitempHitran:
+    def __init__(
+        self,
+        path="CO",
+        nurange=[-np.inf, np.inf],
+        crit=0.0,
+        elower_max=None,
+        Ttyp=1000.0,
+        isotope=1,
+        gpu_transfer=False,
+        inherit_dataframe=False,
+        activation=True,
+        parfile=None,
+        with_error=False,
+    ):
         """Molecular database for HITRAN/HITEMP form.
 
         Args:
             molecule: molecule
             nurange: wavenumber range list (cm-1) [min,max] or wavenumber grid
             crit: line strength lower limit for extraction
             elower_max: maximum lower state energy, Elower (cm-1)
             Ttyp: typical temperature to calculate Sij(T) used in crit
-            isotope: isotope number, 0 or None = use all isotopes. 
+            isotope: isotope number, 0 or None = use all isotopes.
             gpu_transfer: tranfer data to jnp.array?
             inherit_dataframe: if True, it makes self.df instance available, which needs more DRAM when pickling.
-            activation: if True, the activation of mdb will be done when initialization, if False, the activation won't be done and it makes self.df instance available. 
+            activation: if True, the activation of mdb will be done when initialization, if False, the activation won't be done and it makes self.df instance available.
             parfile: if not none, provide path, then directly load parfile
             with_error: if True, uncertainty indices become available.
         """
 
         self.path = pathlib.Path(path).expanduser()
         self.molecid = molecid_hitran(str(self.path.stem))
         self.simple_molecule_name = get_molecule(self.molecid)
@@ -349,16 +366,15 @@
         self.Tref = Tref_original
         self.Ttyp = Ttyp
         self.nurange = [np.min(nurange), np.max(nurange)]
         self.isotope = isotope
         self.set_molmass()
         self.gpu_transfer = gpu_transfer
         self.activation = activation
-        self.load_wavenum_min, self.load_wavenum_max = self.set_wavenum(
-            nurange)
+        self.load_wavenum_min, self.load_wavenum_max = self.set_wavenum(nurange)
         self.with_error = with_error
 
     def QT_for_select_line(self, Ttyp):
         if self.isotope is None or self.isotope == 0:
             isotope_for_Qt = 1  # we use isotope=1 for QT
         else:
             isotope_for_Qt = int(self.isotope)
@@ -379,64 +395,62 @@
         if wavenum_min == -np.inf:
             wavenum_min = None
         if wavenum_max == np.inf:
             wavenum_max = None
         return wavenum_min, wavenum_max
 
     def activate(self, df, mask=None):
-        """activation of moldb, 
-        
+        """activation of moldb,
+
         Notes:
-            activation includes, making instances, computing broadening parameters, natural width, 
+            activation includes, making instances, computing broadening parameters, natural width,
             and transfering instances to gpu arrays when self.gpu_transfer = True
 
         Args:
             df: DataFrame
             mask: mask of DataFrame to be used for the activation, if None, no additional mask is applied.
 
         Note:
             self.df_load_mask is always applied when the activation.
 
         Examples:
-            
+
             >>> # we would extract the line with delta nu = 2 here
             >>> mdb = api.MdbExomol(emf, nus, optional_quantum_states=True, activation=False)
             >>> load_mask = (mdb.df["v_u"] - mdb.df["v_l"] == 2)
             >>> mdb.activate(mdb.df, load_mask)
 
 
         """
         if mask is not None:
             mask = mask * self.df_load_mask
         else:
             mask = self.df_load_mask
 
         self.instances_from_dataframes(df[mask])
         self.gQT, self.T_gQT = hitranapi.make_partition_function_grid_hitran(
-            self.molecid, self.uniqiso)
+            self.molecid, self.uniqiso
+        )
 
         if self.gpu_transfer:
             self.generate_jnp_arrays()
 
     def set_molmass(self):
         molmass_isotope, abundance_isotope = molmass_hitran()
         if self.isotope is None:
             self.molmass = molmass_isotope[self.simple_molecule_name][0]
         else:
-            self.molmass = molmass_isotope[self.simple_molecule_name][
-                self.isotope]
+            self.molmass = molmass_isotope[self.simple_molecule_name][self.isotope]
 
     def compute_load_mask(self, df, qrtyp):
-        #wavelength
-        mask = (df.wav > self.load_wavenum_min) \
-                    * (df.wav < self.load_wavenum_max)
-        mask *= (line_strength_numpy(self.Ttyp, df.int, df.wav, df.El, qrtyp) >
-                 self.crit)
+        # wavelength
+        mask = (df.wav > self.load_wavenum_min) * (df.wav < self.load_wavenum_max)
+        mask *= line_strength_numpy(self.Ttyp, df.int, df.wav, df.El, qrtyp) > self.crit
         if self.elower_max is not None:
-            mask *= (df.elower < self.elower_max)
+            mask *= df.El < self.elower_max
         return mask
 
     def apply_mask_mdb(self, mask):
         """apply mask for mdb class
 
         Args:
             mask: mask to be applied
@@ -452,53 +466,50 @@
         self.delta_air = self.delta_air[mask]
         self.A = self.A[mask]
         self.n_air = self.n_air[mask]
         self.gamma_air = self.gamma_air[mask]
         self.gamma_self = self.gamma_self[mask]
         self.elower = self.elower[mask]
         self.gpp = self.gpp[mask]
-        #isotope
+        # isotope
         self.isoid = self.isoid[mask]
         self.uniqiso = np.unique(self.isoid)
         if self.with_error:
-            #uncertainties
+            # uncertainties
             self.ierr = self.ierr[mask]
 
     def Sij0(self):
-        """old line strength definition    
-        """
+        """old line strength definition"""
         msg = "Sij0 instance was replaced to line_strength_ref."
         raise ValueError(msg)
 
     def QT_interp(self, isotope, T):
         """interpolated partition function.
 
         Args:
            isotope: HITRAN isotope number starting from 1
            T: temperature
 
         Returns:
            Q(idx, T) interpolated in jnp.array
         """
-        isotope_index = _isotope_index_from_isotope_number(
-            isotope, self.uniqiso)
+        isotope_index = _isotope_index_from_isotope_number(isotope, self.uniqiso)
         return _QT_interp(isotope_index, T, self.T_gQT, self.gQT)
 
     def qr_interp(self, isotope, T):
         """interpolated partition function ratio.
 
         Args:
             isotope: HITRAN isotope number starting from 1
             T: temperature
 
         Returns:
             qr(T)=Q(T)/Q(Tref) interpolated in jnp.array
         """
-        isotope_index = _isotope_index_from_isotope_number(
-            isotope, self.uniqiso)
+        isotope_index = _isotope_index_from_isotope_number(isotope, self.uniqiso)
         return _qr_interp(isotope_index, T, self.T_gQT, self.gQT, self.Tref)
 
     def qr_interp_lines(self, T):
         """Partition Function ratio using HAPI partition data.
         (This function works for JAX environment.)
 
         Args:
@@ -506,71 +517,80 @@
 
         Returns:
             Qr_line, partition function ratio array for lines [Nlines]
 
         Note:
             Nlines=len(self.nu_lines)
         """
-        return _qr_interp_lines(T, self.isoid, self.uniqiso, self.T_gQT,
-                                self.gQT, self.Tref)
+        return _qr_interp_lines(
+            T, self.isoid, self.uniqiso, self.T_gQT, self.gQT, self.Tref
+        )
 
     def exact_isotope_name(self, isotope):
         """exact isotope name
 
         Args:
             isotope (int): isotope number starting from 1
 
         Returns:
             str: exact isotope name such as (12C)(16O)
         """
         from exojax.utils.molname import exact_molecule_name_from_isotope
-        return exact_molecule_name_from_isotope(
-            self.simple_molecule_name, isotope)
+
+        return exact_molecule_name_from_isotope(self.simple_molecule_name, isotope)
 
     def change_reference_temperature(self, Tref_new):
         """change the reference temperature Tref and recompute Sij0
 
         Args:
             Tref_new (float): new Tref in Kelvin
         """
-        print("Change the reference temperature from " + str(self.Tref) +
-              "K to " + str(Tref_new) + " K.")
+        print(
+            "Change the reference temperature from "
+            + str(self.Tref)
+            + "K to "
+            + str(Tref_new)
+            + " K."
+        )
         if self.isotope is None or self.isotope == 0:
             msg1 = "Currently all isotope mode is not fully compatible to change_reference_temperature."
-            msg2 = "QT used in change_reference_temperature is assumed isotope=1 instead."
+            msg2 = (
+                "QT used in change_reference_temperature is assumed isotope=1 instead."
+            )
             warnings.warn(msg1 + msg2, UserWarning)
             qr = self.qr_interp(1, Tref_new)
         else:
             qr = self.qr_interp(self.isotope, Tref_new)
 
-        self.line_strength_ref = line_strength_numpy(Tref_new,
-                                                     self.line_strength_ref,
-                                                     self.nu_lines,
-                                                     self.elower, qr,
-                                                     self.Tref)
+        self.line_strength_ref = line_strength_numpy(
+            Tref_new, self.line_strength_ref, self.nu_lines, self.elower, qr, self.Tref
+        )
+        self.logsij0 = np.log(self.line_strength_ref)
         self.Tref = Tref_new
 
     def check_line_existence_in_nurange(self, df_load_mask):
         if len(df_load_mask) == 0:
             raise ValueError("No line found in ", self.nurange, "cm-1")
-        
+
     def add_error(self):
-        """uncertainty codes of HITRAN or HITEMP database  
+        """uncertainty codes of HITRAN or HITEMP database
         ref.: Table 2 and 5 in HITRAN 2004 (Rothman et al. 2005)
 
         Returns:
             Uncertainty indices for 6 critical parameters
         """
-        is_place = lambda x,i: (x // 10**(i)) % 10 #extract the digits for 10**i place (0<=i<=5)
-        self.nu_lines_err = is_place(self.ierr,5) #0-9
-        self.line_strength_ref_err = is_place(self.ierr,4) #0-8
-        self.gamma_air_err = is_place(self.ierr,3) #0-8
-        self.gamma_self_err = is_place(self.ierr,2) #0-8
-        self.n_air_err = is_place(self.ierr,1)
-        self.delta_air_err = is_place(self.ierr,0) #0-9
+        is_place = (
+            lambda x, i: (x // 10 ** (i)) % 10
+        )  # extract the digits for 10**i place (0<=i<=5)
+        self.nu_lines_err = is_place(self.ierr, 5)  # 0-9
+        self.line_strength_ref_err = is_place(self.ierr, 4)  # 0-8
+        self.gamma_air_err = is_place(self.ierr, 3)  # 0-8
+        self.gamma_self_err = is_place(self.ierr, 2)  # 0-8
+        self.n_air_err = is_place(self.ierr, 1)
+        self.delta_air_err = is_place(self.ierr, 0)  # 0-9
 
 
 class MdbHitemp(MdbCommonHitempHitran, HITEMPDatabaseManager):
     """molecular database of HITEMP.
 
     Attributes:
         simple_molecule_name: simple molecule name
@@ -583,100 +603,103 @@
         gamma_natural (jnp array): gamma factor of the natural broadening
         gamma_air (jnp array): gamma factor of air pressure broadening
         gamma_self (jnp array): gamma factor of self pressure broadening
         elower (jnp array): the lower state energy (cm-1)
         gpp (jnp array): statistical weight
         n_air (jnp array): air temperature exponent
     """
-    def __init__(self,
-                 path,
-                 nurange=[-np.inf, np.inf],
-                 crit=0.,
-                 elower_max=None,
-                 Ttyp=1000.,
-                 isotope=1,
-                 gpu_transfer=False,
-                 inherit_dataframe=False,
-                 activation=True,
-                 parfile=None,
-                 with_error=False):
+
+    def __init__(
+        self,
+        path,
+        nurange=[-np.inf, np.inf],
+        crit=0.0,
+        elower_max=None,
+        Ttyp=1000.0,
+        isotope=1,
+        gpu_transfer=False,
+        inherit_dataframe=False,
+        activation=True,
+        parfile=None,
+        with_error=False,
+    ):
         """Molecular database for HITRAN/HITEMP form.
 
         Args:
             molecule: molecule
             nurange: wavenumber range list (cm-1) [min,max] or wavenumber grid
             crit: line strength lower limit for extraction
             elower_max: maximum lower state energy, Elower (cm-1)
             Ttyp: typical temperature to calculate Sij(T) used in crit
-            isotope: isotope number, 0 or None = use all isotopes. 
+            isotope: isotope number, 0 or None = use all isotopes.
             gpu_transfer: tranfer data to jnp.array?
             inherit_dataframe: if True, it makes self.df instance available, which needs more DRAM when pickling.
-            activation: if True, the activation of mdb will be done when initialization, if False, the activation won't be done and it makes self.df instance available. 
+            activation: if True, the activation of mdb will be done when initialization, if False, the activation won't be done and it makes self.df instance available.
             parfile: if not none, provide path, then directly load parfile
             with_error: if True, uncertainty indices become available.
         """
 
         self.dbtype = "hitran"
-        MdbCommonHitempHitran.__init__(self,
-                                       path=path,
-                                       nurange=nurange,
-                                       crit=crit,
-                                       elower_max=elower_max,
-                                       Ttyp=Ttyp,
-                                       isotope=isotope,
-                                       gpu_transfer=gpu_transfer,
-                                       inherit_dataframe=inherit_dataframe,
-                                       activation=activation,
-                                       parfile=parfile,
-                                       with_error=with_error)
+        MdbCommonHitempHitran.__init__(
+            self,
+            path=path,
+            nurange=nurange,
+            crit=crit,
+            elower_max=elower_max,
+            Ttyp=Ttyp,
+            isotope=isotope,
+            gpu_transfer=gpu_transfer,
+            inherit_dataframe=inherit_dataframe,
+            activation=activation,
+            parfile=parfile,
+            with_error=with_error,
+        )
 
         HITEMPDatabaseManager.__init__(
             self,
             molecule=self.simple_molecule_name,
             name="HITEMP-{molecule}",
             local_databases=self.path.parent,
             engine="default",
             verbose=True,
             chunksize=100000,
             parallel=True,
         )
 
         if parfile is not None:
             from radis.api.hitranapi import hit2df
+
             df = hit2df(parfile, engine="vaex", cache="regen")
             if isotope is None:
                 mask = None
             elif isotope == 0:
                 mask = None
             elif isotope > 0:
-                mask = (df["iso"] == isotope)
+                mask = df["iso"] == isotope
         else:
             # Get list of all expected local files for this database:
             local_files, urlnames = self.get_filenames()
 
             # Get missing files
             download_files = self.get_missing_files(local_files)
-            download_files = self.keep_only_relevant(download_files,
-                                                     self.load_wavenum_min,
-                                                     self.load_wavenum_max)
+            download_files = self.keep_only_relevant(
+                download_files, self.load_wavenum_min, self.load_wavenum_max
+            )
             # do not re-download files if they exist in another format :
 
             converted = []
             for f in download_files:
                 if exists(f.replace(".hdf5", ".h5")):
                     update_pytables_to_vaex(f.replace(".hdf5", ".h5"))
                     converted.append(f)
-                download_files = [
-                    f for f in download_files if f not in converted
-                ]
+                download_files = [f for f in download_files if f not in converted]
             # do not re-download remaining files that exist. Let user decide what to do.
             # (download & re-parsing is a long solution!)
             download_files = [
-                f for f in download_files
-                if not exists(f.replace(".hdf5", ".h5"))
+                f for f in download_files if not exists(f.replace(".hdf5", ".h5"))
             ]
 
             # Download files
             if len(download_files) > 0:
                 if urlnames is None:
                     urlnames = self.fetch_urlnames()
                 filesmap = dict(zip(local_files, urlnames))
@@ -684,26 +707,25 @@
                 self.download_and_parse(download_urls, download_files)
 
             clean_cache_files = True
             if len(download_files) > 0 and clean_cache_files:
                 self.clean_download_files()
 
             # Load and return
-            files_loaded = self.keep_only_relevant(local_files,
-                                                   self.load_wavenum_min,
-                                                   self.load_wavenum_max)
-            columns = None,
+            files_loaded = self.keep_only_relevant(
+                local_files, self.load_wavenum_min, self.load_wavenum_max
+            )
+            columns = (None,)
             output = "vaex"
 
             isotope_dfform = _convert_proper_isotope(self.isotope)
             df = self.load(
                 files_loaded,  # filter other files,
                 columns=columns,
-                within=[("iso", isotope_dfform)]
-                if isotope_dfform is not None else [],
+                within=[("iso", isotope_dfform)] if isotope_dfform is not None else [],
                 output=output,
             )
             mask = None
 
         self.isoid = df.iso
         self.uniqiso = np.unique(df.iso.values)
         QTref, QTtyp = self.QT_for_select_line(Ttyp)
@@ -721,34 +743,35 @@
         Args:
             df_load_mask (DataFrame): (masked) data frame
 
         """
         self.check_line_existence_in_nurange(df_masked)
         self.nu_lines = df_masked.wav.values
         self.line_strength_ref = df_masked.int.values
+        self.logsij0 = np.log(self.line_strength_ref)
         self.delta_air = df_masked.Pshft.values
         self.A = df_masked.A.values
         self.n_air = df_masked.Tdpair.values
         self.gamma_air = df_masked.airbrd.values
         self.gamma_self = df_masked.selbrd.values
         self.elower = df_masked.El.values
         self.gpp = df_masked.gp.values
-        #isotope
+        # isotope
         self.isoid = df_masked.iso.values
         self.uniqiso = np.unique(self.isoid)
         if self.with_error:
-            #uncertainties
+            # uncertainties
             self.ierr = df_masked.ierr.values.to_numpy().astype(np.int64)
 
     def generate_jnp_arrays(self):
         """(re)generate jnp.arrays.
-        
+
         Note:
            We have nd arrays and jnp arrays. We usually apply the mask to nd arrays and then generate jnp array from the corresponding nd array. For instance, self._A is nd array and self.A is jnp array.
-        
+
         """
         # jnp.array copy from the copy sources
         self.dev_nu_lines = jnp.array(self.nu_lines)
         self.logsij0 = jnp.array(np.log(self.line_strength_ref))
         self.line_strength_ref = jnp.array(self.line_strength_ref)
         self.delta_air = jnp.array(self.delta_air)
         self.A = jnp.array(self.A)
@@ -775,107 +798,115 @@
         gamma_natural (jnp array): gamma factor of the natural broadening
         gamma_air (jnp array): gamma factor of air pressure broadening
         gamma_self (jnp array): gamma factor of self pressure broadening
         elower (jnp array): the lower state energy (cm-1)
         gpp (jnp array): statistical weight
         n_air (jnp array): air temperature exponent
     """
-    def __init__(self,
-                 path,
-                 nurange=[-np.inf, np.inf],
-                 crit=0.,
-                 elower_max=None,
-                 Ttyp=1000.,
-                 isotope=0,
-                 gpu_transfer=False,
-                 inherit_dataframe=False,
-                 activation=True,
-                 parfile=None,
-                 nonair_broadening=False,
-                 with_error=False):
+
+    def __init__(
+        self,
+        path,
+        nurange=[-np.inf, np.inf],
+        crit=0.0,
+        elower_max=None,
+        Ttyp=1000.0,
+        isotope=0,
+        gpu_transfer=False,
+        inherit_dataframe=False,
+        activation=True,
+        parfile=None,
+        nonair_broadening=False,
+        with_error=False,
+    ):
         """Molecular database for HITRAN/HITEMP form.
 
         Args:
             path: path for HITRAN/HITEMP par file
             nurange: wavenumber range list (cm-1) [min,max] or wavenumber grid
             crit: line strength lower limit for extraction
             elower_max: maximum lower state energy, Elower (cm-1)
             Ttyp: typical temperature to calculate Sij(T) used in crit
-            isotope: isotope number. 0 or None= use all isotopes. 
+            isotope: isotope number. 0 or None= use all isotopes.
             gpu_transfer: tranfer data to jnp.array?
             inherit_dataframe: if True, it makes self.df instance available, which needs more DRAM when pickling.
-            activation: if True, the activation of mdb will be done when initialization, if False, the activation won't be done and it makes self.df instance available. 
+            activation: if True, the activation of mdb will be done when initialization, if False, the activation won't be done and it makes self.df instance available.
             nonair_broadening: If True, background atmospheric broadening parameters(n and gamma) other than air will also be downloaded (e.g. h2, he...)
             with_error: if True, uncertainty indices become available. (Please set drop_non_numeric=False in radis.api.hitranapi)
         """
         self.dbtype = "hitran"
-        MdbCommonHitempHitran.__init__(self,
-                                       path=path,
-                                       nurange=nurange,
-                                       crit=crit,
-                                       elower_max=elower_max,
-                                       Ttyp=Ttyp,
-                                       isotope=isotope,
-                                       gpu_transfer=gpu_transfer,
-                                       inherit_dataframe=inherit_dataframe,
-                                       activation=activation,
-                                       parfile=parfile,
-                                       with_error=with_error)
+        MdbCommonHitempHitran.__init__(
+            self,
+            path=path,
+            nurange=nurange,
+            crit=crit,
+            elower_max=elower_max,
+            Ttyp=Ttyp,
+            isotope=isotope,
+            gpu_transfer=gpu_transfer,
+            inherit_dataframe=inherit_dataframe,
+            activation=activation,
+            parfile=parfile,
+            with_error=with_error,
+        )
 
         # HITRAN ONLY FUNCTIONALITY
         if nonair_broadening:
             self.nonair_broadening = True
             extra_params = "all"
         else:
             self.nonair_broadening = False
             extra_params = None
 
-        HITRANDatabaseManager.__init__(self,
-                                       molecule=self.simple_molecule_name,
-                                       name="HITRAN-{molecule}",
-                                       local_databases=self.path.parent,
-                                       engine="default",
-                                       verbose=True,
-                                       parallel=True,
-                                       extra_params=extra_params)
+        HITRANDatabaseManager.__init__(
+            self,
+            molecule=self.simple_molecule_name,
+            name="HITRAN-{molecule}",
+            local_databases=self.path.parent,
+            engine="default",
+            verbose=True,
+            parallel=True,
+            extra_params=extra_params,
+        )
 
         # Get list of all expected local files for this database:
         local_file = self.get_filenames()
 
         # Download files
-        if with_error: 
+        if with_error:
             # to distinguish hdf5 files with error and without error.
-            local_file = [local_file[0].split('.hdf5')[0] + '_werr.hdf5']
+            local_file = [local_file[0].split(".hdf5")[0] + "_werr.hdf5"]
         download_files = self.get_missing_files(local_file)
         if download_files:
-            self.download_and_parse(download_files,
-                                    cache=True,
-                                    parse_quanta=True,
-                                    add_HITRAN_uncertainty_code=with_error
-                                    )
+            self.download_and_parse(
+                download_files,
+                cache=True,
+                parse_quanta=True,
+                add_HITRAN_uncertainty_code=with_error,
+            )
 
         if len(download_files) > 0:
             self.clean_download_files()
 
         # Load and return
         columns = None
         output = "vaex"
 
         isotope_dfform = _convert_proper_isotope(self.isotope)
         df = self.load(
             local_file,
             columns=columns,
-            within=[("iso",
-                     isotope_dfform)] if isotope_dfform is not None else [],
+            within=[("iso", isotope_dfform)] if isotope_dfform is not None else [],
             # for relevant files, get only the right range :
-            #lower_bound=[("wav", load_wavenum_min)]
-            #if load_wavenum_min is not None else [],
-            #upper_bound=[("wav", load_wavenum_max)]
-            #if load_wavenum_max is not None else [],
-            output=output)
+            # lower_bound=[("wav", load_wavenum_min)]
+            # if load_wavenum_min is not None else [],
+            # upper_bound=[("wav", load_wavenum_max)]
+            # if load_wavenum_max is not None else [],
+            output=output,
+        )
 
         self.isoid = df.iso
         self.uniqiso = np.unique(df.iso.values)
         QTref, QTtyp = self.QT_for_select_line(Ttyp)
         self.df_load_mask = self.compute_load_mask(df, QTtyp / QTref)
         if self.activation:
             self.activate(df)
@@ -892,50 +923,51 @@
         Raises:
             ValueError: _description_
         """
         self.check_line_existence_in_nurange(df_load_mask)
         if isinstance(df_load_mask, vaex.dataframe.DataFrameLocal):
             self.nu_lines = df_load_mask.wav.values
             self.line_strength_ref = df_load_mask.int.values
+            self.logsij0 = np.log(self.line_strength_ref)
             self.delta_air = df_load_mask.Pshft.values
             self.A = df_load_mask.A.values
             self.n_air = df_load_mask.Tdpair.values
             self.gamma_air = df_load_mask.airbrd.values
             self.gamma_self = df_load_mask.selbrd.values
             self.elower = df_load_mask.El.values
             self.gpp = df_load_mask.gp.values
-            #isotope
+            # isotope
             self.isoid = df_load_mask.iso.values
             self.uniqiso = np.unique(self.isoid)
             if self.with_error:
-                #uncertainties
+                # uncertainties
                 self.ierr = df_load_mask.ierr.values
 
-            if hasattr(df_load_mask, 'n_h2') and self.nonair_broadening:
+            if hasattr(df_load_mask, "n_h2") and self.nonair_broadening:
                 self.n_h2 = df_load_mask.n_h2.values
                 self.gamma_h2 = df_load_mask.gamma_h2.values
 
-            if hasattr(df_load_mask, 'n_he') and self.nonair_broadening:
+            if hasattr(df_load_mask, "n_he") and self.nonair_broadening:
                 self.n_he = df_load_mask.n_he.values
                 self.gamma_he = df_load_mask.gamma_he.values
 
-            if hasattr(df_load_mask, 'n_co2') and self.nonair_broadening:
+            if hasattr(df_load_mask, "n_co2") and self.nonair_broadening:
                 self.n_co2 = df_load_mask.n_co2.values
                 self.gamma_co2 = df_load_mask.gamma_co2.values
 
-            if hasattr(df_load_mask, 'n_h2o') and self.nonair_broadening:
+            if hasattr(df_load_mask, "n_h2o") and self.nonair_broadening:
                 self.n_h2o = df_load_mask.n_h2o.values
                 self.gamma_h2o = df_load_mask.gamma_h2o.values
 
     def generate_jnp_arrays(self):
         """(re)generate jnp.arrays.
-        
+
         Note:
            We have nd arrays and jnp arrays. We usually apply the mask to nd arrays and then generate jnp array from the corresponding nd array. For instance, self._A is nd array and self.A is jnp array.
-        
+
         """
         # jnp.array copy from the copy sources
         self.dev_nu_lines = jnp.array(self.nu_lines)
         self.logsij0 = jnp.array(np.log(self.line_strength_ref))
         self.line_strength_ref = jnp.array(self.line_strength_ref)
         self.delta_air = jnp.array(self.delta_air)
         self.A = jnp.array(self.A)
@@ -943,33 +975,33 @@
         self.gamma_air = jnp.array(self.gamma_air)
         self.gamma_self = jnp.array(self.gamma_self)
         self.elower = jnp.array(self.elower)
         self.gpp = jnp.array(self.gpp)
         if self.with_error:
             self.ierr = jnp.array(self.ierr)
 
-        if hasattr(self.df_load_mask, 'n_h2') and self.nonair_broadening:
+        if hasattr(self.df_load_mask, "n_h2") and self.nonair_broadening:
             self.n_h2 = jnp.array(self.n_h2)
             self.gamma_h2 = jnp.array(self.gamma_h2)
 
-        if hasattr(self.df_load_mask, 'n_he') and self.nonair_broadening:
+        if hasattr(self.df_load_mask, "n_he") and self.nonair_broadening:
             self.n_he = jnp.array(self.n_he)
             self.gamma_he = jnp.array(self.gamma_he)
 
-        if hasattr(self.df_load_mask, 'n_co2') and self.nonair_broadening:
+        if hasattr(self.df_load_mask, "n_co2") and self.nonair_broadening:
             self.n_co2 = jnp.array(self.n_co2)
             self.gamma_co2 = jnp.array(self.gamma_co2)
 
-        if hasattr(self.df_load_mask, 'n_h2o') and self.nonair_broadening:
+        if hasattr(self.df_load_mask, "n_h2o") and self.nonair_broadening:
             self.n_h2o = jnp.array(self.n_h2o)
             self.gamma_h2o = jnp.array(self.gamma_h2o)
 
 
 def _convert_proper_isotope(isotope):
-    """covert isotope (int) to proper type for df 
+    """covert isotope (int) to proper type for df
 
     Args:
         isotope (int or other type): isotope
 
     Returns:
         str: proper isotope type
     """
@@ -982,88 +1014,89 @@
     else:
         raise ValueError("Invalid isotope type")
 
 
 def _isotope_index_from_isotope_number(isotope, uniqiso):
     """isotope index given HITRAN/HITEMP isotope number
 
-        Args:
-            isotope (int): isotope number
-            uniqiso (nd int array): unique isotope array 
+    Args:
+        isotope (int): isotope number
+        uniqiso (nd int array): unique isotope array
 
-        Returns:
-            int: isotope_index for T_gQT and gQT  
-        """
+    Returns:
+        int: isotope_index for T_gQT and gQT
+    """
     isotope_index = np.where(uniqiso == isotope)[0][0]
     return isotope_index
 
 
 def _QT_interp(isotope_index, T, T_gQT, gQT):
     """interpolated partition function.
 
-        Note:
-            isotope_index is NOT isotope (number for HITRAN). 
-            isotope_index is index for gQT and T_gQT.
-            _isotope_index_from_isotope_number can be used 
-            to get isotope index from isotope.
-            
-        Args:
-            isotope index: isotope index, index from 0 to len(uniqiso) - 1
-            T: temperature
-            gQT: jnp array of partition function grid
-            T_gQT: jnp array of temperature grid for gQT
+    Note:
+        isotope_index is NOT isotope (number for HITRAN).
+        isotope_index is index for gQT and T_gQT.
+        _isotope_index_from_isotope_number can be used
+        to get isotope index from isotope.
 
-        Returns:
-            Q(idx, T) interpolated in jnp.array
-        """
+    Args:
+        isotope index: isotope index, index from 0 to len(uniqiso) - 1
+        T: temperature
+        gQT: jnp array of partition function grid
+        T_gQT: jnp array of temperature grid for gQT
+
+    Returns:
+        Q(idx, T) interpolated in jnp.array
+    """
 
     return jnp.interp(T, T_gQT[isotope_index], gQT[isotope_index])
 
 
 def _qr_interp(isotope_index, T, T_gQT, gQT, Tref):
     """interpolated partition function ratio.
 
-        Note:
-            isotope_index is NOT isotope (number for HITRAN). 
-            isotope_index is index for gQT and T_gQT.
-            _isotope_index_from_isotope_number can be used 
-            to get isotope index from isotope.
-    
-        Args:
-            isotope index: isotope index, index from 0 to len(uniqiso) - 1
-            T: temperature
-            gQT: jnp array of partition function grid
-            T_gQT: jnp array of temperature grid for gQT
-            Tref: reference temperature in K
+    Note:
+        isotope_index is NOT isotope (number for HITRAN).
+        isotope_index is index for gQT and T_gQT.
+        _isotope_index_from_isotope_number can be used
+        to get isotope index from isotope.
 
-        Returns:
-            qr(T)=Q(T)/Q(Tref) interpolated in jnp.array
-        """
+    Args:
+        isotope index: isotope index, index from 0 to len(uniqiso) - 1
+        T: temperature
+        gQT: jnp array of partition function grid
+        T_gQT: jnp array of temperature grid for gQT
+        Tref: reference temperature in K
+
+    Returns:
+        qr(T)=Q(T)/Q(Tref) interpolated in jnp.array
+    """
     return _QT_interp(isotope_index, T, T_gQT, gQT) / _QT_interp(
-        isotope_index, Tref, T_gQT, gQT)
+        isotope_index, Tref, T_gQT, gQT
+    )
 
 
 def _qr_interp_lines(T, isoid, uniqiso, T_gQT, gQT, Tref):
     """Partition Function ratio using HAPI partition data.
-        (This function works for JAX environment.)
+    (This function works for JAX environment.)
 
-        Args:
-            T: temperature (K)
-            isoid:
-            uniqiso:
-            gQT: jnp array of partition function grid
-            T_gQT: jnp array of temperature grid for gQT
-            Tref: reference temperature in K
+    Args:
+        T: temperature (K)
+        isoid:
+        uniqiso:
+        gQT: jnp array of partition function grid
+        T_gQT: jnp array of temperature grid for gQT
+        Tref: reference temperature in K
 
-        Returns:
-            Qr_line, partition function ratio array for lines [Nlines]
+    Returns:
+        Qr_line, partition function ratio array for lines [Nlines]
 
-        Note:
-            Nlines=len(self.nu_lines)
-        """
+    Note:
+        Nlines=len(self.nu_lines)
+    """
     qr_line = jnp.zeros(len(isoid))
     for isotope in uniqiso:
         mask_idx = np.where(isoid == isotope)
         isotope_index = _isotope_index_from_isotope_number(isotope, uniqiso)
         qr_each_isotope = _qr_interp(isotope_index, T, T_gQT, gQT, Tref)
         qr_line = qr_line.at[jnp.index_exp[mask_idx]].set(qr_each_isotope)
     return qr_line
```

## exojax/spec/atmrt.py

```diff
@@ -1,33 +1,41 @@
 """Atmospheric Radiative Transfer (art) class
 
     Notes:
-        opacity is computed in art because it uses planet physical quantities 
-        such as gravity, mmr.
+        The opacity is computed in art because it uses planet physical quantities 
+        such as gravity, mmr. "run" method computes a spectrum. 
 
 """
+
 import numpy as np
 import jax.numpy as jnp
 from exojax.spec.planck import piBarr
-from exojax.spec.rtransfer import rtrun_emis_pure_absorption
-from exojax.spec.rtransfer import rtrun_trans_pure_absorption
+from exojax.spec.rtransfer import rtrun_emis_pureabs_ibased_linsap
+from exojax.spec.rtransfer import rtrun_emis_pureabs_fbased2st
+from exojax.spec.rtransfer import rtrun_emis_pureabs_ibased
+from exojax.spec.rtransfer import rtrun_emis_scat_lart_toonhm
+from exojax.spec.rtransfer import rtrun_emis_scat_fluxadding_toonhm
+from exojax.spec.rtransfer import rtrun_reflect_fluxadding_toonhm
+from exojax.spec.rtransfer import rtrun_trans_pureabs_trapezoid
+from exojax.spec.rtransfer import rtrun_trans_pureabs_simpson
 from exojax.spec.layeropacity import layer_optical_depth
+from exojax.spec.layeropacity import layer_optical_depth_clouds_lognormal
 from exojax.atm.atmprof import atmprof_gray, atmprof_Guillot, atmprof_powerlow
 from exojax.atm.idealgas import number_density
 from exojax.atm.atmprof import normalized_layer_height
+from exojax.spec.opachord import chord_geometric_matrix_lower
 from exojax.spec.opachord import chord_geometric_matrix
 from exojax.spec.opachord import chord_optical_depth
-from exojax.spec.rtransfer import rtrun_trans_pure_absorption
 from exojax.utils.constants import logkB, logm_ucgs
 import warnings
 
 
-class ArtCommon():
-    """Common Atmospheric Radiative Transfer
-    """
+class ArtCommon:
+    """Common Atmospheric Radiative Transfer"""
+
     def __init__(self, pressure_top, pressure_btm, nlayer, nu_grid=None):
         """initialization of art
 
         Args:
             pressure_top (float):top pressure in bar
             pressure_bottom (float): bottom pressure in bar
             nlayer (int): # of atmospheric layers
@@ -37,126 +45,185 @@
         self.method = None  # which art is used
         self.ready = False  # ready for art computation
         self.Tlow = 0.0
         self.Thigh = jnp.inf
 
         if nu_grid is None:
             warnings.warn(
-                "nu_grid is not given. specify nu_grid when using 'run' ",
-                UserWarning)
+                "nu_grid is not given. specify nu_grid when using 'run' ", UserWarning
+            )
         self.nu_grid = nu_grid
 
         self.pressure_top = pressure_top
         self.pressure_btm = pressure_btm
         self.nlayer = nlayer
         self.check_pressure()
         self.log_pressure_btm = np.log10(self.pressure_btm)
         self.log_pressure_top = np.log10(self.pressure_top)
         self.init_pressure_profile()
 
         self.fguillot = 0.25
 
-    def atmosphere_height(self, temperature, mean_molecular_weight, radius_btm,
-                          gravity_btm):
+    def atmosphere_height(
+        self, temperature, mean_molecular_weight, radius_btm, gravity_btm
+    ):
         """atmosphere height and radius
 
         Args:
             temperature (1D array): temparature profile (Nlayer)
             mean_molecular_weight (float/1D array): mean molecular weight profile (float/Nlayer)
             radius_btm (float): the bottom radius of the atmospheric layer
             gravity_btm (float): the bottom gravity cm2/s at radius_btm, i.e. G M_p/radius_btm
 
         Returns:
             1D array: height normalized by radius_btm (Nlayer)
             1D array: layer radius r_n normalized by radius_btm (Nlayer)
-            1D array: radius at lower boundary normalized by radius_btm (Nlayer)
 
         Notes:
             Our definitions of the radius_lower, radius_layer, and height are as follows:
             n=0,1,...,N-1
             radius_lower[N-1] = radius_btm (i.e. R0)
             radius_lower[n-1] = radius_lower[n] + height[n]
-            radius_layer[n] =  radius_lower[n] + height[n]/2
             "normalized" means physical length divided by radius_btm
 
 
         """
-        print("k=", self.k)
         normalized_height, normalized_radius_lower = normalized_layer_height(
-            temperature, self.k, mean_molecular_weight, radius_btm,
-            gravity_btm)
-        normalized_radius_layer = normalized_radius_lower + 0.5 * normalized_height
-        return normalized_height, normalized_radius_layer, normalized_radius_lower
+            temperature,
+            self.pressure_decrease_rate,
+            mean_molecular_weight,
+            radius_btm,
+            gravity_btm,
+        )
+        return normalized_height, normalized_radius_lower
 
     def constant_gravity_profile(self, value):
         return value * np.array([np.ones_like(self.pressure)]).T
 
-    def gravity_profile(self, temperature, mean_molecular_weight, radius_btm,
-                        gravity_btm):
+    def gravity_profile(
+        self, temperature, mean_molecular_weight, radius_btm, gravity_btm
+    ):
         """gravity layer profile assuming hydrostatic equilibrium
 
         Args:
             temperature (1D array): temparature profile (Nlayer)
             mean_molecular_weight (float/1D array): mean molecular weight profile (float/Nlayer)
             radius_btm (float): the bottom radius of the atmospheric layer
             gravity_btm (float): the bottom gravity cm2/s at radius_btm, i.e. G M_p/radius_btm
 
         Returns:
             2D array: gravity in cm2/s (Nlayer, 1), suitable for the input of opacity_profile_lines
         """
-        _, normalized_radius_layer, _ = self.atmosphere_height(
-            temperature, mean_molecular_weight, radius_btm, gravity_btm)
+        normalized_height, normalized_radius_lower = self.atmosphere_height(
+            temperature, mean_molecular_weight, radius_btm, gravity_btm
+        )
+        normalized_radius_layer = normalized_radius_lower + 0.5 * normalized_height
         return jnp.array([gravity_btm / normalized_radius_layer]).T
 
     def constant_mmr_profile(self, value):
         return value * np.ones_like(self.pressure)
 
-    def opacity_profile_lines(self, xsmatrix, mixing_ratio, molmass, gravity):
-        """opacity profile (delta tau) for lines
+    def opacity_profile_lines(self, xs, mixing_ratio, molmass, gravity):
+        raise ValueError(
+            "opacity_profile_lines was removed. Use opacity_profile_xs instead"
+        )
+
+    def opacity_profile_xs(self, xs, mixing_ratio, molmass, gravity):
+        """opacity profile (delta tau) from cross section matrix or vector, molecular line/Rayleigh scattering
 
         Args:
-            xsmatrix (2D array): cross section matrix (Nlayer, N_wavenumber)
+            xs (2D array/1D array): cross section matrix i.e. xsmatrix (Nlayer, N_wavenumber) or vector i.e. xsvector (N_wavenumber)
             mixing_ratio (1D array): mass mixing ratio, Nlayer, (or volume mixing ratio profile)
             molmass (float): molecular mass (or mean molecular weight)
             gravity (float/1D profile): constant or 1d profile of gravity in cgs
 
         Returns:
-            dtau: opacity profile, whose element is optical depth in each layer. 
+            dtau: opacity profile, whose element is optical depth in each layer.
+        """
+        return layer_optical_depth(
+            self.dParr, jnp.abs(xs), mixing_ratio, molmass, gravity
+        )
+
+    def opacity_profile_cloud_lognormal(
+        self,
+        extinction_coefficient,
+        condensate_substance_density,
+        mmr_condensate,
+        rg,
+        sigmag,
+        gravity,
+    ):
+        """opacity profile (delta tau) from extinction coefficient assuming the AM cloud model with a lognormal cloud distribution
+        Args:
+            gravity (float/1D profile): constant or 1d profile of gravity in cgs
+
+        Returns:
+            dtau: opacity profile, whose element is optical depth in each layer.
         """
-        return layer_optical_depth(self.dParr, jnp.abs(xsmatrix), mixing_ratio,
-                                   molmass, gravity)
 
-    def opacity_profile_cia(self, logacia_matrix, temperature, vmr1, vmr2, mmw,
-                            gravity):
+        return layer_optical_depth_clouds_lognormal(
+            self.dParr,
+            extinction_coefficient,
+            condensate_substance_density,
+            mmr_condensate,
+            rg,
+            sigmag,
+            gravity,
+        )
+
+    def opacity_profile_cia(
+        self, logacia_matrix, temperature, vmr1, vmr2, mmw, gravity
+    ):
         narr = number_density(self.pressure, temperature)
         lognarr1 = jnp.log10(vmr1 * narr)  # log number density
         lognarr2 = jnp.log10(vmr2 * narr)  # log number density
         logg = jnp.log10(gravity)
         ddParr = self.dParr / self.pressure
-        return 10**(logacia_matrix + lognarr1[:, None] + lognarr2[:, None] +
-                    logkB - logg -
-                    logm_ucgs) * temperature[:, None] / mmw * ddParr[:, None]
+        return (
+            10
+            ** (
+                logacia_matrix
+                + lognarr1[:, None]
+                + lognarr2[:, None]
+                + logkB
+                - logg
+                - logm_ucgs
+            )
+            * temperature[:, None]
+            / mmw
+            * ddParr[:, None]
+        )
 
     def check_pressure(self):
         if self.pressure_btm < self.pressure_top:
             raise ValueError(
                 "Pressure at bottom should be higher than that at top atmosphere."
             )
         if type(self.nlayer) is not int:
             raise ValueError("Number of the layer should be integer")
 
     def init_pressure_profile(self):
         from exojax.atm.atmprof import pressure_layer_logspace
-        self.pressure, self.dParr, self.k = pressure_layer_logspace(
+        from exojax.atm.atmprof import pressure_boundary_logspace
+
+        (
+            self.pressure,
+            self.dParr,
+            self.pressure_decrease_rate,
+        ) = pressure_layer_logspace(
             log_pressure_top=self.log_pressure_top,
             log_pressure_btm=self.log_pressure_btm,
             nlayer=self.nlayer,
-            mode='ascending',
+            mode="ascending",
             reference_point=0.5,
-            numpy=True)
+            numpy=True,
+        )
+        self.pressure_boundary = pressure_boundary_logspace(
+            self.pressure, self.pressure_decrease_rate, reference_point=0.5
+        )
 
     def change_temperature_range(self, Tlow, Thigh):
         """temperature range to be assumed.
 
         Note:
             The default temperature range is self.Tlow = 0 K, self.Thigh = jnp.inf.
 
@@ -184,127 +251,519 @@
         Args:
             T0 (float): T at P=1 bar in K
             alpha (float): powerlaw index
 
         Returns:
             array: temperature profile
         """
-        return self.clip_temperature(atmprof_powerlow(self.pressure, T0,
-                                                      alpha))
+        return self.clip_temperature(atmprof_powerlow(self.pressure, T0, alpha))
 
     def gray_temperature(self, gravity, kappa, Tint):
-        """ gray temperature profile
+        """gray temperature profile
 
         Args:
             gravity: gravity (cm/s2)
-            kappa: infrared opacity 
+            kappa: infrared opacity
             Tint: temperature equivalence of the intrinsic energy flow in K
 
         Returns:
             array: temperature profile
 
         """
-        return self.clip_temperature(
-            atmprof_gray(self.pressure, gravity, kappa, Tint))
+        return self.clip_temperature(atmprof_gray(self.pressure, gravity, kappa, Tint))
 
-    def guillot_temeprature(self, gravity, kappa, gamma, Tint, Tirr):
-        """ Guillot tempearture profile
+    def guillot_temperature(self, gravity, kappa, gamma, Tint, Tirr):
+        """Guillot tempearture profile
 
-        Notes:  
+        Notes:
             Set self.fguillot (default 0.25) to change the assumption of irradiation.
-            self.fguillot = 1. at the substellar point, self.fguillot = 0.5 for a day-side average 
+            self.fguillot = 1. at the substellar point, self.fguillot = 0.5 for a day-side average
             and self.fguillot = 0.25 for an averaging over the whole planetary surface
             See Guillot (2010) Equation (29) for details.
 
         Args:
             gravity: gravity (cm/s2)
             kappa: thermal/IR opacity (kappa_th in Guillot 2010)
             gamma: ratio of optical and IR opacity (kappa_v/kappa_th), gamma > 1 means thermal inversion
             Tint: temperature equivalence of the intrinsic energy flow in K
             Tirr: temperature equivalence of the irradiation in K
-            
+
         Returns:
             array: temperature profile
 
         """
         return self.clip_temperature(
-            atmprof_Guillot(self.pressure, gravity, kappa, gamma, Tint, Tirr,
-                            self.fguillot))
+            atmprof_Guillot(
+                self.pressure, gravity, kappa, gamma, Tint, Tirr, self.fguillot
+            )
+        )
 
+    def powerlaw_temperature_boundary(self, T0, alpha):
+        """powerlaw temperature at the upper point (overline{T}) + TB profile
 
-class ArtEmisPure(ArtCommon):
-    """Atmospheric RT for emission w/ pure absorption
+        Args:
+            T0 (float): T at P=1 bar in K
+            alpha (float): powerlaw index
+
+        Returns:
+            array: layer boundary temperature profile (Nlayer + 1)
+        """
+        return self.clip_temperature(
+            atmprof_powerlow(self.pressure_boundary, T0, alpha)
+        )
+
+
+class ArtReflectPure(ArtCommon):
+    """Atmospheric RT for Pure Reflected light (no source term)
 
     Attributes:
         pressure_layer: pressure profile in bar
-        
+
     """
+
     def __init__(
         self,
-        pressure_top=1.e-8,
-        pressure_btm=1.e2,
+        pressure_top=1.0e-8,
+        pressure_btm=1.0e2,
         nlayer=100,
         nu_grid=None,
+        rtsolver="fluxadding_toon_hemispheric_mean",
+    ):
+        """initialization of ArtReflectPure
+
+        Args:
+            pressure_top (float, optional): top pressure in bar. Defaults to 1.0e-8.
+            pressure_btm (float, optional): bottom pressure in bar. Defaults to 1.0e2.
+            nlayer (int, optional): the number of the atmospheric layers. Defaults to 100.
+            nu_grid (float, array, optional): the wavenumber grid. Defaults to None.
+            rtsolver (str): Radiative Transfer Solver, fluxadding_toon_hemispheric_mean
+
+
+        """
+        super().__init__(pressure_top, pressure_btm, nlayer, nu_grid)
+        self.rtsolver = rtsolver
+        self.method = "reflection_using_" + self.rtsolver
+
+    def run(
+        self,
+        dtau,
+        single_scattering_albedo,
+        asymmetric_parameter,
+        reflectivity_surface,
+        incoming_flux,
+    ):
+        """run radiative transfer
+
+        Args:
+            dtau (2D array): optical depth matrix, dtau  (N_layer, N_nus)
+            single_scattering_albedo: single scattering albedo (Nlayer, N_nus)
+            asymmetric_parameter: assymetric parameter (Nlayer, N_nus)
+            reflectivity_surface: reflectivity from the surface (N_nus)
+            incoming flux: incoming flux F_0^- (N_nus)
+            nu_grid (1D array): if nu_grid is not initialized, provide it.
+
+
+        Returns:
+            1D array: spectrum
+        """
+
+        if self.rtsolver == "fluxadding_toon_hemispheric_mean":
+            _, Nnus = dtau.shape
+            sourcef = jnp.zeros_like(dtau)
+            source_surface = jnp.zeros(Nnus)
+            return rtrun_reflect_fluxadding_toonhm(
+                dtau,
+                single_scattering_albedo,
+                asymmetric_parameter,
+                sourcef,
+                source_surface,
+                reflectivity_surface,
+                incoming_flux,
+            )
+        else:
+            print("rtsolver=", self.rtsolver)
+            raise ValueError("Unknown radiative transfer solver (rtsolver).")
+
+
+class ArtReflectEmis(ArtCommon):
+    """Atmospheric RT for Reflected light with Source Term
+
+    Attributes:
+        pressure_layer: pressure profile in bar
+
+    """
+
+    def __init__(
+        self,
+        pressure_top=1.0e-8,
+        pressure_btm=1.0e2,
+        nlayer=100,
+        nu_grid=None,
+        rtsolver="fluxadding_toon_hemispheric_mean",
     ):
         """initialization of ArtEmisPure
 
-        
+        Args:
+            pressure_top (float, optional): top pressure in bar. Defaults to 1.0e-8.
+            pressure_btm (float, optional): bottom pressure in bar. Defaults to 1.0e2.
+            nlayer (int, optional): the number of the atmospheric layers. Defaults to 100.
+            nu_grid (float, array, optional): the wavenumber grid. Defaults to None.
+            rtsolver (str): Radiative Transfer Solver, fluxadding_toon_hemispheric_mean
+
+
         """
         super().__init__(pressure_top, pressure_btm, nlayer, nu_grid)
-        self.method = "emission_with_pure_absorption"
+        self.rtsolver = rtsolver
+        self.method = "reflection_using_" + self.rtsolver
 
-    def run(self, dtau, temperature, nu_grid=None):
+    def run(
+        self,
+        dtau,
+        single_scattering_albedo,
+        asymmetric_parameter,
+        temperature,
+        source_surface,
+        reflectivity_surface,
+        incoming_flux,
+        nu_grid=None,
+    ):
+        """run radiative transfer
+
+        Args:
+            dtau (2D array): optical depth matrix, dtau  (N_layer, N_nus)
+            single_scattering_albedo: single scattering albedo (Nlayer, N_nus)
+            asymmetric_parameter: assymetric parameter (Nlayer, N_nus)
+            temperature (1D array): temperature profile (Nlayer)
+            source_surface: source from the surface (N_nus)
+            reflectivity_surface: reflectivity from the surface (N_nus)
+            incoming flux: incoming flux F_0^- (N_nus)
+            nu_grid (1D array): if nu_grid is not initialized, provide it.
+
+
+        Returns:
+            1D array: spectrum
+        """
+        if self.nu_grid is not None:
+            sourcef = piBarr(temperature, self.nu_grid)
+        elif nu_grid is not None:
+            sourcef = piBarr(temperature, nu_grid)
+        else:
+            raise ValueError("the wavenumber grid is not given.")
+
+        if self.rtsolver == "fluxadding_toon_hemispheric_mean":
+            return rtrun_reflect_fluxadding_toonhm(
+                dtau,
+                single_scattering_albedo,
+                asymmetric_parameter,
+                sourcef,
+                source_surface,
+                reflectivity_surface,
+                incoming_flux,
+            )
+        else:
+            print("rtsolver=", self.rtsolver)
+            raise ValueError("Unknown radiative transfer solver (rtsolver).")
+
+
+class ArtEmisScat(ArtCommon):
+    """Atmospheric RT for emission w/ scattering
+
+    Attributes:
+        pressure_layer: pressure profile in bar
+
+    """
+
+    def __init__(
+        self,
+        pressure_top=1.0e-8,
+        pressure_btm=1.0e2,
+        nlayer=100,
+        nu_grid=None,
+        rtsolver="fluxadding_toon_hemispheric_mean",
+    ):
+        """initialization of ArtEmisScat
+
+        Args:
+            pressure_top (float, optional): top pressure in bar. Defaults to 1.0e-8.
+            pressure_btm (float, optional): bottom pressure in bar. Defaults to 1.0e2.
+            nlayer (int, optional): the number of the atmospheric layers. Defaults to 100.
+            nu_grid (float, array, optional): the wavenumber grid. Defaults to None.
+            rtsolver (str): Radiative Transfer Solver, fluxadding_toon_hemispheric_mean (default), lart_toon_hemispheric_mean
+
+        """
+        super().__init__(pressure_top, pressure_btm, nlayer, nu_grid)
+        self.rtsolver = rtsolver
+        self.method = "emission_with_scattering_using_" + self.rtsolver
+
+    def run(
+        self,
+        dtau,
+        single_scattering_albedo,
+        asymmetric_parameter,
+        temperature,
+        nu_grid=None,
+        show=False,
+    ):
         """run radiative transfer
 
         Args:
             dtau (2D array): optical depth matrix, dtau  (N_layer, N_nus)
             temperature (1D array): temperature profile (Nlayer)
-            nu_grid (1D array): if nu_grid is not initialized, provide it. 
+            nu_grid (1D array): if nu_grid is not initialized, provide it.
+            show: plot intermediate results
 
         Returns:
-            _type_: _description_
+            1D array: spectrum
         """
         if self.nu_grid is not None:
             sourcef = piBarr(temperature, self.nu_grid)
         elif nu_grid is not None:
             sourcef = piBarr(temperature, nu_grid)
         else:
             raise ValueError("the wavenumber grid is not given.")
-        return rtrun_emis_pure_absorption(dtau, sourcef)
+
+        if self.rtsolver == "lart_toon_hemispheric_mean":
+            (
+                spectrum,
+                cumTtilde,
+                Qtilde,
+                trans_coeff,
+                scat_coeff,
+                piB,
+            ) = rtrun_emis_scat_lart_toonhm(
+                dtau, single_scattering_albedo, asymmetric_parameter, sourcef
+            )
+            if show:
+                from exojax.plot.rtplot import comparison_with_pure_absorption
+
+                spec, spec_pure = comparison_with_pure_absorption(
+                    cumTtilde, Qtilde, spectrum, trans_coeff, scat_coeff, piB
+                )
+                return spectrum, spec, spec_pure
+
+        elif self.rtsolver == "fluxadding_toon_hemispheric_mean":
+            spectrum = rtrun_emis_scat_fluxadding_toonhm(
+                dtau, single_scattering_albedo, asymmetric_parameter, sourcef
+            )
+
+        else:
+            print("rtsolver=", self.rtsolver)
+            raise ValueError("Unknown radiative transfer solver (rtsolver).")
+
+        return spectrum
+
+
+class ArtEmisPure(ArtCommon):
+    """Atmospheric RT for emission w/ pure absorption
+
+    Notes:
+        The default radiative transfer scheme has been the intensity-based transfer since version 1.5
+
+    Attributes:
+        pressure_layer: pressure profile in bar
+
+    """
+
+    def __init__(
+        self,
+        pressure_top=1.0e-8,
+        pressure_btm=1.0e2,
+        nlayer=100,
+        nu_grid=None,
+        rtsolver="ibased",
+        nstream=8,
+    ):
+        """
+        initialization of ArtEmisPure
+
+        Args:
+            pressure_top (float, optional): top pressure in bar. Defaults to 1.0e-8.
+            pressure_btm (float, optional): bottom pressure in bar. Defaults to 1.0e2.
+            nlayer (int, optional): the number of the atmospheric layers. Defaults to 100.
+            nu_grid (float, array, optional): the wavenumber grid. Defaults to None.
+            rtsolver (str, optional): radiative transfer solver (ibased, fbased2st, ibased_linsap). Defaults to "ibased".
+            nstream (int, optional): the number of stream. Defaults to 8. Should be 2 for rtsolver = fbased2st
+        """
+        super().__init__(pressure_top, pressure_btm, nlayer, nu_grid)
+        self.method = "emission_with_pure_absorption"
+        self.set_capable_rtsolvers()
+        self.validate_rtsolver(rtsolver, nstream)
+
+    def set_capable_rtsolvers(self):
+        self.rtsolver_dict = {
+            "fbased2st": rtrun_emis_pureabs_fbased2st,
+            "ibased": rtrun_emis_pureabs_ibased,
+            "ibased_linsap": rtrun_emis_pureabs_ibased_linsap,
+        }
+
+        self.valid_rtsolvers = list(self.rtsolver_dict.keys())
+
+        # source function to be used in rtsolver
+        self.source_position_dict = {
+            "fbased2st": "representative",
+            "ibased": "representative",
+            "ibased_linsap": "upper_boundary",
+        }
+
+        self.rtsolver_explanation = {
+            "fbased2st": "Flux-based two-stream solver, isothermal layer (ExoJAX1, HELIOS-R1 like)",
+            "ibased": "Intensity-based n-stream solver, isothermal layer (e.g. NEMESIS, pRT like)",
+            "ibased_linsap": "Intensity-based n-stream solver w/ linear source approximation (linsap), see Olson and Kunasz (e.g. HELIOS-R2 like)",
+        }
+
+    def validate_rtsolver(self, rtsolver, nstream):
+        """validates rtsolver
+
+        Args:
+            rtsolver (str): rtsolver
+            nstream (int): the number of streams
+
+        """
+
+        if rtsolver in self.valid_rtsolvers:
+            self.rtsolver = rtsolver
+            self.source_position = self.source_position_dict[self.rtsolver]
+            print("rtsolver: ", self.rtsolver)
+            print(self.rtsolver_explanation[self.rtsolver])
+        else:
+            str_valid_rtsolvers = (
+                ", ".join(self.valid_rtsolvers[:-1])
+                + f", or {self.valid_rtsolvers[-1]}"
+            )
+            raise ValueError("Unknown rtsolver. Use " + str_valid_rtsolvers)
+        if rtsolver == "fbased2st" and nstream != 2:
+            raise ValueError(
+                "fbased2st (flux-based two-stream) rtsolver requires nstream = 2."
+            )
+        self.nstream = nstream
+
+    def run(self, dtau, temperature, nu_grid=None):
+        """run radiative transfer
+
+        Args:
+            dtau (2D array): optical depth matrix, dtau  (N_layer, N_nus)
+            temperature (1D array): temperature profile (Nlayer)
+            nu_grid (1D array): if nu_grid is not initialized, provide it.
+
+        Returns:
+            1D array: emission spectrum
+        """
+        if self.nu_grid is not None:
+            nu_grid = self.nu_grid
+
+        sourcef = piBarr(temperature, nu_grid)
+        rtfunc = self.rtsolver_dict[self.rtsolver]
+
+        if self.rtsolver == "fbased2st":
+            return rtfunc(dtau, sourcef)
+        elif self.rtsolver == "ibased" or self.rtsolver == "ibased_linsap":
+            from exojax.spec.rtransfer import initialize_gaussian_quadrature
+
+            mus, weights = initialize_gaussian_quadrature(self.nstream)
+            return rtfunc(dtau, sourcef, mus, weights)
 
 
 class ArtTransPure(ArtCommon):
-    def __init__(self, pressure_top=1.e-8, pressure_btm=1.e2, nlayer=100):
+    """Atmospheric Radiative Transfer for transmission spectroscopy
+
+    Args:
+        ArtCommon: ArtCommon class
+    """
+
+    def __init__(
+        self, pressure_top=1.0e-8, pressure_btm=1.0e2, nlayer=100, integration="simpson"
+    ):
         """initialization of ArtTransPure
 
-        
+        Args:
+            pressure_top (float, optional): layer top pressure in bar. Defaults to 1.0e-8.
+            pressure_btm (float, optional): layer bottom pressure in bar. Defaults to 1.0e2.
+            nlayer (int, optional): The number of the layers Defaults to 100.
+            integration (str, optional): Integration scheme ("simpson", "trapezoid"). Defaults to "simpson".
+
+        Note:
+            The users can choose the integration scheme of the chord integration from Trapezoid method or Simpson method.
+
         """
         super().__init__(pressure_top, pressure_btm, nlayer, nu_grid=None)
         self.method = "transmission_with_pure_absorption"
+        self.set_capable_integration()
+        self.set_integration_scheme(integration)
+
+    def set_capable_integration(self):
+        """sets integration scheme directory"""
+        self.integration_dict = {
+            "trapezoid": rtrun_trans_pureabs_trapezoid,
+            "simpson": rtrun_trans_pureabs_simpson,
+        }
+
+        self.valid_integration = list(self.integration_dict.keys())
+
+        self.integration_explanation = {
+            "trapezoid": "Trapezoid integration, uses the chord optical depth at the lower boundary of the layers only",
+            "simpson": "Simpson integration, uses the chord optical depth at the lower boundary and midppoint of the layers.",
+        }
+
+    def set_integration_scheme(self, integration):
+        """sets and validates integration
 
-    def run(self, dtau, temperature, mean_molecular_weight, radius_btm,
-            gravity_btm):
+        Args:
+            integration (str): integration scheme, i.e. "trapezoid" or "simpson"
+
+        """
+
+        if integration in self.valid_integration:
+            self.integration = integration
+            print("integration: ", self.integration)
+            print(self.integration_explanation[self.integration])
+        else:
+            str_valid_integration = (
+                ", ".join(self.valid_integration[:-1])
+                + f", or {self.valid_integration[-1]}"
+            )
+            raise ValueError(
+                "Unknown integration (scheme). Use " + str_valid_integration
+            )
+
+    def run(self, dtau, temperature, mean_molecular_weight, radius_btm, gravity_btm):
         """run radiative transfer
 
         Args:
             dtau (2D array): optical depth matrix, dtau  (N_layer, N_nus)
             temperature (1D array): temperature profile (Nlayer)
-            mean_molecular_weight (1D array): mean molecular weight profile, (Nlayer, from atmospheric top to bottom) 
+            mean_molecular_weight (1D array): mean molecular weight profile, (Nlayer, from atmospheric top to bottom)
             radius_btm (float): radius (cm) at the lower boundary of the bottom layer, R0 or r_N
             gravity_btm (float): gravity (cm/s2) at the lower boundary of the bottom layer, g_N
 
         Returns:
             1D array: transit squared radius normalized by radius_btm**2, i.e. it returns (radius/radius_btm)**2
 
         Notes:
             This function gives the sqaure of the transit radius.
             If you would like to obtain the transit radius, take sqaure root of the output and multiply radius_btm.
             If you would like to compute the transit depth, divide the output by (stellar radius/radius_btm)**2
 
         """
 
-        normalized_height, _, normalized_radius_lower = self.atmosphere_height(
-            temperature, mean_molecular_weight, radius_btm, gravity_btm)
-        cgm = chord_geometric_matrix(normalized_height,
-                                     normalized_radius_lower)
-        tauchord = chord_optical_depth(cgm, dtau)
-        return rtrun_trans_pure_absorption(tauchord, normalized_radius_lower)
+        normalized_height, normalized_radius_lower = self.atmosphere_height(
+            temperature, mean_molecular_weight, radius_btm, gravity_btm
+        )
+        normalized_radius_top = normalized_radius_lower[0] + normalized_height[0]
+        cgm = chord_geometric_matrix_lower(normalized_height, normalized_radius_lower)
+        dtau_chord_lower = chord_optical_depth(cgm, dtau)
+        func = self.integration_dict[self.integration]
+
+        if self.integration == "trapezoid":
+            return func(
+                dtau_chord_lower, normalized_radius_lower, normalized_radius_top
+            )
+        elif self.integration == "simpson":
+            cgm_midpoint = chord_geometric_matrix(
+                normalized_height, normalized_radius_lower
+            )
+            dtau_chord_midpoint = chord_optical_depth(cgm_midpoint, dtau)
+            return func(
+                dtau_chord_midpoint,
+                dtau_chord_lower,
+                normalized_radius_lower,
+                normalized_height,
+            )
```

## exojax/spec/contdb.py

```diff
@@ -1,54 +1,57 @@
 """Continuum database (CDB) class.
 
 * CdbCIA is the CDB for CIA
 """
 import numpy as np
 import jax.numpy as jnp
-from jax import lax
 import pathlib
 from exojax.spec.hitrancia import read_cia
 
-__all__ = ['CdbCIA']
+__all__ = ["CdbCIA"]
 
 
 class CdbCIA(object):
     def __init__(self, path, nurange=[-np.inf, np.inf], margin=10.0):
         """Continuum database for HITRAN CIA.
 
         Args:
-           path: path for HITRAN cia file
-           nurange: wavenumber range list (cm-1) or wavenumber array
-           margin: margin for nurange (cm-1)
+            path: path for HITRAN cia file
+            nurange: wavenumber range list (cm-1) or wavenumber array
+            margin: margin for nurange (cm-1)
         """
         self.nurange = [np.min(nurange), np.max(nurange)]
         self.margin = margin
         self.path = pathlib.Path(path)
         if not self.path.exists():
             self.download()
         self.nucia, self.tcia, ac = read_cia(
-            path, self.nurange[0]-self.margin, self.nurange[1]+self.margin)
+            path, self.nurange[0] - self.margin, self.nurange[1] + self.margin
+        )
         self.logac = jnp.array(np.log10(ac))
         self.tcia = jnp.array(self.tcia)
         self.nucia = jnp.array(self.nucia)
 
     def download(self):
         """Downloading HITRAN cia file.
 
         Note:
-           The download URL is written in exojax.utils.url.
+            The download URL is written in exojax.utils.url.
         """
         import urllib.request
         import os
         from exojax.utils.url import url_HITRANCIA
+
         try:
             os.makedirs(str(self.path.parent), exist_ok=True)
             url = url_HITRANCIA()+self.path.name
-            urllib.request.urlretrieve(url, str(self.path))
+            data = urllib.request.urlopen(url).read()
+            with open(str(self.path), mode="wb") as f:
+                f.write(data)   
+            #urllib.request.urlretrieve(url, str(self.path))
         except:
-            print('HITRAN download failed')
+            print("HITRAN download failed")
 
 
-if __name__ == '__main__':
-    ciaH2H2 = CdbCIA(
-        '~/exojax/data/CIA/H2-H2_2011.cia', nurange=[4050.0, 4150.0])
+if __name__ == "__main__":
+    ciaH2H2 = CdbCIA("~/exojax/data/CIA/H2-H2_2011.cia", nurange=[4050.0, 4150.0])
     print(ciaH2H2.tcia)
```

## exojax/spec/hitran.py

```diff
@@ -1,132 +1,131 @@
 from jax import jit
 import jax.numpy as jnp
 import numpy as np
 from exojax.utils.constants import hcperk, Tref_original
 from exojax.utils.constants import Patm
 
 
-def line_strength(T, logsij0, nu_lines, elower, qT):
-    """(alias, deprecated) use hitran.line_strength, will be removed. 
-   """
-    return line_strength(T, logsij0, nu_lines, elower, qT)
-
-
 @jit
-def line_strength(T, logsij0, nu_lines, elower, qr):
+def line_strength(T, logsij0, nu_lines, elower, qr, Tref):
     """Line strength as a function of temperature, JAX/XLA compatible
 
-   Notes:
-      Use Tref=296.0 (default) in moldb
+    Notes:
+        Tref=296.0 (default) in moldb, but it might have been changed by OpaPremodit.
 
-   Args:
-      T: temperature (K)
-      logsij0: log(Sij(Tref)) (Tref=296K)
-      nu_lines: line center wavenumber (cm-1)
-      elower: elower
-      qr: partition function ratio qr(T) = Q(T)/Q(Tref)
-
-   Returns:
-      Sij(T): Line strength (cm)
-   """
-    Tref = Tref_original  # reference tempearture (K)
+    Args:
+        T: temperature (K)
+        logsij0: log(Sij(Tref)) (Tref=296K)
+        nu_lines: line center wavenumber (cm-1)
+        elower: elower
+        qr: partition function ratio qr(T) = Q(T)/Q(Tref)
+        Tref: reference temperature
+
+    Returns:
+        Sij(T): Line strength (cm)
+    """
     expow = logsij0 - hcperk * (elower / T - elower / Tref)
     fac = (1.0 - jnp.exp(-hcperk * nu_lines / T)) / (
-        1.0 - jnp.exp(-hcperk * nu_lines / Tref))
+        1.0 - jnp.exp(-hcperk * nu_lines / Tref)
+    )
     # expow=logsij0-hcperk*elower*(1.0/T-1.0/Tref)
     # fac=jnp.expm1(-hcperk*nu_lines/T)/jnp.expm1(-hcperk*nu_lines/Tref)
     return jnp.exp(expow) / qr * fac
 
 
 def line_strength_numpy(T, Sij0, nu_lines, elower, qr, Tref=Tref_original):
     """Line strength as a function of temperature, numpy version
 
-        Args:
-            T: temperature (K)
-            Sij0: line strength at Tref=296K
-            elower: elower
-            nu_lines: line center wavenumber 
-            qr : partition function ratio qr(T) = Q(T)/Q(Tref)
-            Tref: reference temeparture
-
-        Returns:
-            line strength at Ttyp
-        """
-    return Sij0 / qr \
-        * np.exp(-hcperk*elower * (1./T - 1./Tref)) \
-        * np.expm1(-hcperk*nu_lines/T) / np.expm1(-hcperk*nu_lines/Tref_original)
+    Args:
+        T: temperature (K)
+        Sij0: line strength at Tref=296K
+        elower: elower
+        nu_lines: line center wavenumber
+        qr : partition function ratio qr(T) = Q(T)/Q(Tref)
+        Tref: reference temeparture
+
+    Returns:
+        line strength at Ttyp
+    """
+    return (
+        Sij0
+        * np.exp(-hcperk * elower * (1.0 / T - 1.0 / Tref))
+        * np.expm1(-hcperk * nu_lines / T)
+        / np.expm1(-hcperk * nu_lines / Tref)
+        / qr  # Apply qr (jnp array) last to minimize rounding errors in 32bit mode.
+    )
 
 
 @jit
 def gamma_hitran(P, T, Pself, n_air, gamma_air_ref, gamma_self_ref):
     """gamma factor by a pressure broadening.
 
     Args:
-       P: pressure (bar)
-       T: temperature (K)
-       Pself: partial pressure (bar)
-       n_air: coefficient of the  temperature  dependence  of  the  air-broadened halfwidth
-       gamma_air_ref: gamma air
-       gamma_self_ref: gamma self
+        P: pressure (bar)
+        T: temperature (K)
+        Pself: partial pressure (bar)
+        n_air: coefficient of the temperature dependence of the air-broadened halfwidth
+        gamma_air_ref: gamma air
+        gamma_self_ref: gamma self
 
     Returns:
-       gamma: pressure gamma factor (cm-1)
+        gamma: pressure gamma factor (cm-1)
     """
     Tref = Tref_original  # reference tempearture (K)
-    gamma = (Tref / T)**n_air * (gamma_air_ref *
-                                 ((P - Pself) / Patm) + gamma_self_ref *
-                                 (Pself / Patm))
+    gamma = (Tref / T) ** n_air * (
+        gamma_air_ref * ((P - Pself) / Patm) + gamma_self_ref * (Pself / Patm)
+    )
     return gamma
 
 
 @jit
 def gamma_natural(A):
     """gamma factor by natural broadning.
 
     1/(4 pi c) = 2.6544188e-12 (cm-1 s)
 
     Args:
-       A: Einstein A-factor (1/s)
+        A: Einstein A-factor (1/s)
 
     Returns:
-       gamma_natural: natural width (cm-1)
+        gamma_natural: natural width (cm-1)
     """
     return 2.6544188e-12 * A
 
 
 @jit
 def doppler_sigma(nu_lines, T, M):
     """Dopper width (sigmaD)
 
     Note:
-       c3 is sqrt(kB/m_u)/c
+        c3 is sqrt(kB/m_u)/c
 
     Args:
-       nu_lines: line center wavenumber (cm-1)
-       T: temperature (K)
-       M: atom/molecular mass
+        nu_lines: line center wavenumber (cm-1)
+        T: temperature (K)
+        M: atom/molecular mass
 
     Returns:
-       sigma: doppler width (standard deviation) (cm-1)
+        sigma: doppler width (standard deviation) (cm-1)
     """
     c3 = 3.0415595e-07
     return c3 * jnp.sqrt(T / M) * nu_lines
 
 
 @jit
 def normalized_doppler_sigma(T, M, R):
     """Normalized Dopper width (nsigmaD) by wavenumber difference at line
     centers.
 
     Note:
-       This quantity is used in MODIT. c3 is sqrt(kB/m_u)/c
+        This quantity is used in MODIT. c3 is sqrt(kB/m_u)/c
 
     Args:
-       T: temperature (K)
-       M: atom/molecular mass
-       R: spectral resolution
+        T: temperature (K)
+        M: atom/molecular mass
+        R: spectral resolution
 
     Returns:
-       nsigma: normalized Doppler width (standard deviation)
+        nsigma: normalized Doppler width (standard deviation)
     """
     c3 = 3.0415595e-07
     return c3 * jnp.sqrt(T / M) * R
```

## exojax/spec/hminus.py

```diff
@@ -3,113 +3,122 @@
 import numpy as np
 import jax.numpy as jnp
 from jax import jit, vmap
 from jax.lax import scan
 from exojax.utils.constants import kB, ccgs, hcgs
 
 
-def log_hminus_continuum(nus, temperature, number_density_e, number_density_h):
+def log_hminus_continuum(nu_grid, temperatures, number_density_e, number_density_h):
     """John (1988) H- continuum opacity.
 
     Args:
-       nus: wavenumber grid (cm-1) [Nnu]
-       temperature: gas temperature array [K] [Nlayer]
-       number_density_e: electron number density array [Nlayer]
-       number_density_h: H atom number density array [Nlayer]
+        nu_grid: wavenumber grid (cm-1) [Nnu]
+        temperature: gas temperature array [K] [Nlayer]
+        number_density_e: electron number density array [Nlayer]
+        number_density_h: H atom number density array [Nlayer]
 
     Returns:
-       log10(absorption coefficient) [Nlayer,Nnu]
+        log10(absorption coefficient in cm-1) [Nlayer,Nnu]
     """
     # wavelength in units of microns
-    wavelength_um = 1e4/nus
+    wavelength_um = 1e4 / nu_grid
     # first, compute the cross sections (in cm4/dyne)
     vkappa_bf = vmap(bound_free_absorption, (None, 0), 0)
     vkappa_ff = vmap(free_free_absorption, (None, 0), 0)
     mkappa_bf = vmap(vkappa_bf, (0, None), 0)
     mkappa_ff = vmap(vkappa_ff, (0, None), 0)
-    kappa_bf = mkappa_bf(wavelength_um, temperature)
-    kappa_ff = mkappa_ff(wavelength_um, temperature)
-#    kappa_bf = bound_free_absorption(wavelength_um, temperature)
-#    kappa_ff = free_free_absorption(wavelength_um, temperature)
-
-    electron_pressure = number_density_e * kB * \
-        temperature  # //electron pressure in dyne/cm2
+    kappa_bf = mkappa_bf(wavelength_um, temperatures)
+    kappa_ff = mkappa_ff(wavelength_um, temperatures)
+    #    kappa_bf = bound_free_absorption(wavelength_um, temperature)
+    #    kappa_ff = free_free_absorption(wavelength_um, temperature)
+
+    electron_pressure = (
+        number_density_e * kB * temperatures
+    )  # //electron pressure in dyne/cm2
     hydrogen_density = number_density_h
 
     # and now finally the absorption_coeff (in cm-1)
-    absorption_coeff = (kappa_bf + kappa_ff) * \
-        electron_pressure * hydrogen_density
+    absorption_coeff = (kappa_bf + kappa_ff) * electron_pressure * hydrogen_density
 
     return jnp.log10(absorption_coeff.T)
 
 
 def bound_free_absorption(wavelength_um, temperature):
     """bound free absorption of H-
 
     Note:
-       alpha has a value of 1.439e4 micron-1 K-1, the value stated in John (1988) is wrong
+        alpha has a value of 1.439e4 micron-1 K-1, the value stated in John (1988) is wrong
 
     Args:
         wavelength_um: wavelength in the unit of micron
         temperature: temperature in the unit of Kelvin
 
     Returns:
         absorption coefficient [cm4/dyne]
     """
     # here, we express alpha using physical constants
-    alpha = ccgs*hcgs/kB*10000.0
+    alpha = ccgs * hcgs / kB * 10000.0
     lambda_0 = 1.6419  # photo-detachment threshold
 
     #   //tabulated constant from John (1988)
     def f(wavelength_um):
         C_n = jnp.vstack(
-            [jnp.arange(7), [0.0, 152.519, 49.534, -
-                             118.858, 92.536, -34.194, 4.982]]
+            [jnp.arange(7), [0.0, 152.519, 49.534, -118.858, 92.536, -34.194, 4.982]]
         ).T
 
         def body_fun(val, x):
             i, C_n_i = x
-            return val, val + C_n_i * jnp.power(jnp.clip(1.0/wavelength_um - 1.0/lambda_0, a_min=0, a_max=None), (i-1)/2.0)
+            return val, val + C_n_i * jnp.power(
+                jnp.clip(1.0 / wavelength_um - 1.0 / lambda_0, a_min=0, a_max=None),
+                (i - 1) / 2.0,
+            )
 
         return scan(body_fun, jnp.zeros_like(wavelength_um), C_n)[-1].sum(0)
 
     # first, we calculate the photo-detachment cross-section (in cm2)
-    kappa_bf = (1e-18 * wavelength_um ** 3 *
-                jnp.power(jnp.clip(1.0/wavelength_um - 1.0/lambda_0,
-                          a_min=0, a_max=None), 1.5) * f(wavelength_um)
-                )
+    kappa_bf = (
+        1e-18
+        * wavelength_um**3
+        * jnp.power(
+            jnp.clip(1.0 / wavelength_um - 1.0 / lambda_0, a_min=0, a_max=None), 1.5
+        )
+        * f(wavelength_um)
+    )
 
     kappa_bf = jnp.where(
         (wavelength_um <= lambda_0) & (wavelength_um > 0.125),
-        (0.750 * jnp.power(temperature, -2.5) * jnp.exp(alpha / lambda_0 / temperature) *
-         (1.0 - jnp.exp(-alpha / wavelength_um / temperature)) * kappa_bf),
-        0
+        (
+            0.750
+            * jnp.power(temperature, -2.5)
+            * jnp.exp(alpha / lambda_0 / temperature)
+            * (1.0 - jnp.exp(-alpha / wavelength_um / temperature))
+            * kappa_bf
+        ),
+        0,
     )
     return kappa_bf
 
 
 def free_free_absorption(wavelength_um, temperature):
     """free free absorption of H- (coefficients from John (1988))
 
     Note:
-       to follow his notation (which starts at an index of 1), the 0-index components are 0 for wavelengths larger than 0.3645 micron
+        to follow his notation (which starts at an index of 1), the 0-index components are 0 for wavelengths larger than 0.3645 micron
 
     Args:
         wavelength_um: wavelength in the unit of micron
         temperature: temperature in the unit of Kelvin
 
     Returns:
         absorption coefficient [cm4/dyne]
     """
     A_n1 = [0.0, 0.0, 2483.3460, -3449.8890, 2200.0400, -696.2710, 88.2830]
     B_n1 = [0.0, 0.0, 285.8270, -1158.3820, 2427.7190, -1841.4000, 444.5170]
-    C_n1 = [0.0, 0.0, -2054.2910, 8746.5230, -
-            13651.1050, 8624.9700, -1863.8650]
-    D_n1 = [0.0, 0.0, 2827.7760, -11485.6320,
-            16755.5240, -10051.5300, 2095.2880]
+    C_n1 = [0.0, 0.0, -2054.2910, 8746.5230, -13651.1050, 8624.9700, -1863.8650]
+    D_n1 = [0.0, 0.0, 2827.7760, -11485.6320, 16755.5240, -10051.5300, 2095.2880]
     E_n1 = [0.0, 0.0, -1341.5370, 5303.6090, -7510.4940, 4400.0670, -901.7880]
     F_n1 = [0.0, 0.0, 208.9520, -812.9390, 1132.7380, -655.0200, 132.9850]
 
     # for wavelengths between 0.1823 micron and 0.3645 micron
     A_n2 = [0.0, 518.1021, 473.2636, -482.2089, 115.5291, 0.0, 0.0]
     B_n2 = [0.0, -734.8666, 1443.4137, -737.1616, 169.6374, 0.0, 0.0]
     C_n2 = [0.0, 1021.1775, -1977.3395, 1096.8827, -245.6490, 0.0, 0.0]
@@ -117,48 +126,53 @@
     E_n2 = [0.0, 93.1373, -178.9275, 101.7963, -21.9972, 0.0, 0.0]
     F_n2 = [0.0, -6.4285, 12.3600, -7.0571, 1.5097, 0.0, 0.0]
 
     def ff(wavelength, A_n, B_n, C_n, D_n, E_n, F_n):
         x = 0
 
         for i in range(1, 7):
-            x += (jnp.power(5040.0/temperature, (i+1)/2.0) *
-                  (wavelength**2 * A_n[i] + B_n[i] + C_n[i]/wavelength + D_n[i]/wavelength**2 +
-                   E_n[i]/wavelength**3 + F_n[i]/wavelength**4))
+            x += jnp.power(5040.0 / temperature, (i + 1) / 2.0) * (
+                wavelength**2 * A_n[i]
+                + B_n[i]
+                + C_n[i] / wavelength
+                + D_n[i] / wavelength**2
+                + E_n[i] / wavelength**3
+                + F_n[i] / wavelength**4
+            )
 
-        return x*1e-29
+        return x * 1e-29
 
     kappa_ff = jnp.where(
-        wavelength_um > 0.3645,
-        ff(wavelength_um, A_n1, B_n1, C_n1, D_n1, E_n1, F_n1),
-        0
+        wavelength_um > 0.3645, ff(wavelength_um, A_n1, B_n1, C_n1, D_n1, E_n1, F_n1), 0
     ) + jnp.where(
         (wavelength_um >= 0.1823) & (wavelength_um <= 0.3645),
         ff(wavelength_um, A_n2, B_n2, C_n2, D_n2, E_n2, F_n2),
-        0
+        0,
     )
 
     return kappa_ff
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     import matplotlib.pyplot as plt
+
     Tin = 3000.0
     wav = np.linspace(0.8, 2.4, 100)
     plt.plot(wav, free_free_absorption(wav, Tin))
     plt.plot(wav, bound_free_absorption(wav, Tin))
-    plt.yscale('log')
+    plt.yscale("log")
     plt.show()
 
     Nlayer = 100
     Parr = np.logspace(-8, 2, Nlayer)
     Tarr = np.linspace(2000, 3000, Nlayer)
     Nnu = 40000
     nus = np.linspace(1900.0, 2300.0, Nnu, dtype=np.float64)
     kB = 1.380649e-16
-    narr = (Parr*1.e6)/(kB*Tarr)
+    narr = (Parr * 1.0e6) / (kB * Tarr)
     vmrh = 0.001
     vmre = vmrh
-    number_density_e = vmre*narr
-    number_density_h = vmrh*narr
-    print(jnp.shape(log_hminus_continuum(
-        nus, Tarr, number_density_e, number_density_h)))
+    number_density_e = vmre * narr
+    number_density_h = vmrh * narr
+    print(
+        jnp.shape(log_hminus_continuum(nus, Tarr, number_density_e, number_density_h))
+    )
```

## exojax/spec/initspec.py

```diff
@@ -3,15 +3,15 @@
 The functions in this module are a wrapper for initialization processes
 for opacity computation.
 """
 import jax.numpy as jnp
 import numpy as np
 import warnings
 
-from exojax.spec.lsd import npgetix
+from exojax.utils.indexing import npgetix
 from exojax.spec.make_numatrix import make_numatrix0
 from exojax.utils.instfunc import resolution_eslog
 from exojax.spec.premodit import make_elower_grid
 from exojax.spec.premodit import make_broadpar_grid
 from exojax.spec.premodit import generate_lbd
```

## exojax/spec/layeropacity.py

```diff
@@ -3,43 +3,46 @@
 """
 
 from jax import jit, vmap
 import jax.numpy as jnp
 from exojax.spec.hitrancia import interp_logacia_matrix
 from exojax.spec.hminus import log_hminus_continuum
 from exojax.atm.idealgas import number_density
-from exojax.utils.constants import logkB, logm_ucgs
+from exojax.utils.constants import logkB
+from exojax.utils.constants import logm_ucgs
 from exojax.utils.constants import opfac
+from exojax.utils.constants import bar_cgs
 from exojax.spec.dtau_mmwl import dtauM_mmwl
 
 
 def layer_optical_depth(dParr, xsmatrix, mixing_ratio, mass, gravity):
-    """dtau of the molecular cross section.
+    """dtau matrix from the cross section matrix/vector.
 
     Note:
         opfac=bar_cgs/(m_u (g)). m_u: atomic mass unit. It can be obtained by fac=1.e3/m_u, where m_u = scipy.constants.m_u.
 
     Args:
         dParr: delta pressure profile (bar) [N_layer]
-        xsmatrix: cross section matrix (cm2) [N_layer, N_nus]
+        xsmatrix: cross section matrix (cm2) [N_layer, N_nus] or cross section vector (cm2) [N_nus]
         mixing_ratio: volume mixing ratio (VMR) or mass mixing ratio (MMR) [N_layer]
         mass: mean molecular weight for VMR or molecular mass for MMR
         gravity: gravity (cm/s2)
 
     Returns:
         2D array: optical depth matrix, dtau  [N_layer, N_nus]
     """
 
-    return opfac * xsmatrix * dParr[:, None] * mixing_ratio[:, None] / (
-        mass * gravity)
+    return opfac * xsmatrix * dParr[:, None] * mixing_ratio[:, None] / (mass * gravity)
 
 
-def layer_optical_depth_CIA(nu_grid, temperature, pressure, dParr, vmr1, vmr2,
-                            mmw, g, nucia, tcia, logac):
-    """dtau of the CIA continuum. Not used in art.
+def layer_optical_depth_CIA(
+    nu_grid, temperature, pressure, dParr, vmr1, vmr2, mmw, g, nucia, tcia, logac
+):
+    """dtau of the CIA continuum. Not
+    used in art.
 
     Args:
         nu_grid: wavenumber matrix (cm-1)
         temperature: temperature array (K)
         pressure: pressure array (bar)
         dParr: delta temperature array (bar)
         vmr1: volume mixing ratio (VMR) for molecules 1 [N_layer]
@@ -55,17 +58,27 @@
     """
     narr = number_density(pressure, temperature)
     lognarr1 = jnp.log10(vmr1 * narr)  # log number density
     lognarr2 = jnp.log10(vmr2 * narr)  # log number density
     logg = jnp.log10(g)
     ddParr = dParr / pressure
     dtauc = (
-        10**(interp_logacia_matrix(temperature, nu_grid, nucia, tcia, logac) +
-             lognarr1[:, None] + lognarr2[:, None] + logkB - logg - logm_ucgs)
-        * temperature[:, None] / mmw * ddParr[:, None])
+        10
+        ** (
+            interp_logacia_matrix(temperature, nu_grid, nucia, tcia, logac)
+            + lognarr1[:, None]
+            + lognarr2[:, None]
+            + logkB
+            - logg
+            - logm_ucgs
+        )
+        * temperature[:, None]
+        / mmw
+        * ddParr[:, None]
+    )
 
     return dtauc
 
 
 def layer_optical_depth_VALD(dParr, xsm, VMR, mean_molecular_weight, gravity):
     """dtau of the atomic (+ionic) cross section from VALD.
 
@@ -75,22 +88,22 @@
         VMR: volume mixing ratio [N_species x N_layer]
         mean_molecular_weight: mean molecular weight [N_layer]
         gravity: gravity (cm/s2)
 
     Returns:
         2D array: optical depth matrix, dtau  [N_layer, N_nus]
     """
-    dtauS = jit(vmap(dtauM_mmwl, (None, 0, 0, None, None)))( \
-                            dParr, xsm, VMR, mean_molecular_weight, gravity)
+    dtauS = jit(vmap(dtauM_mmwl, (None, 0, 0, None, None)))(
+        dParr, xsm, VMR, mean_molecular_weight, gravity
+    )
     dtau = jnp.abs(jnp.sum(dtauS, axis=0))
     return dtau
 
 
-def layer_optical_depth_Hminus(nu_grid, temperature, Parr, dParr, vmre, vmrh,
-                               mmw, g):
+def layer_optical_depth_Hminus(nu_grid, temperature, Parr, dParr, vmre, vmrh, mmw, g):
     """dtau of the H- continuum.
 
     Args:
         nu_grid: wavenumber matrix (cm-1)
         Tarr: temperature array (K)
         Parr: temperature array (bar)
         dParr: delta temperature array (bar)
@@ -103,13 +116,78 @@
         optical depth matrix  [N_layer, N_nus]
     """
     narr = number_density(Parr, temperature)
     number_density_e = vmre * narr  # number density for e- [N_layer]
     number_density_h = vmrh * narr  # number density for H atoms [N_layer]
     logg = jnp.log10(g)
     ddParr = dParr / Parr
-    logabc = (log_hminus_continuum(nu_grid, temperature, number_density_e,
-                                   number_density_h))
-    dtauh = 10**(logabc + logkB - logg -
-                 logm_ucgs) * temperature[:, None] / mmw * ddParr[:, None]
+    logabc = log_hminus_continuum(
+        nu_grid, temperature, number_density_e, number_density_h
+    )
+    dtauh = (
+        10 ** (logabc + logkB - logg - logm_ucgs)
+        * temperature[:, None]
+        / mmw
+        * ddParr[:, None]
+    )
 
     return dtauh
+
+
+def layer_optical_depth_cloudgeo(
+    dParr, condensate_substance_density, mmr_condensate, rg, sigmag, gravity
+):
+    """the optical depth using a geometric cross-section approximation, based
+    on (16) in AM01.
+
+    Args:
+        dParr: delta pressure profile (bar)
+        condensate_substance_density: condensate substance density (g/cm3)
+        mmr_condensate: Mass mixing ratio (array) of condensate [Nlayer]
+        rg: rg parameter in the lognormal distribution of condensate size, defined by (9) in AM01
+        sigmag:sigmag parameter (geometric standard deviation) in the lognormal distribution of condensate size, defined by (9) in AM01, must be sigmag > 1
+        gravity: gravity (cm/s2)
+
+    """
+
+    fac = jnp.exp(-2.5 * jnp.log(sigmag) ** 2)
+    dtau = (
+        1.5
+        * mmr_condensate
+        * fac
+        / (rg * condensate_substance_density * gravity)
+        * dParr
+        * bar_cgs
+    )
+    return dtau
+
+
+def layer_optical_depth_clouds_lognormal(
+    dParr,
+    extinction_coefficient,
+    condensate_substance_density,
+    mmr_condensate,
+    rg,
+    sigmag,
+    gravity,
+    N0=1.0,
+):
+    """dtau matrix from the cross section matrix/vector for the lognormal particulate distribution.
+
+
+    Args:
+        dParr: delta pressure profile (bar) [N_layer]
+        extinction coefficient: extinction coefficient  in cgs (cm-1) [N_layer, N_nus]
+        condensate_substance_density: condensate substance density (g/cm3)
+        mmr_condensate: Mass mixing ratio (array) of condensate [Nlayer]
+        rg: rg parameter in the lognormal distribution of condensate size, defined by (9) in AM01
+        sigmag:sigmag parameter (geometric standard deviation) in the lognormal distribution of condensate size, defined by (9) in AM01, must be sigmag > 1
+        gravity: gravity (cm/s2)
+        N0 (float, optional): the normalization of the lognormal distribution ($N_0$). Defaults to 1.0.
+
+    Returns:
+        2D array: optical depth matrix, dtau  [N_layer, N_nus]
+    """
+    expfac = bar_cgs*sigmag**(jnp.log(sigmag**-4.5))  # bar_cgs * exp(-9/2 * (log sigmag)**2), see tests/manual_check/f32/lnmoment_amcloud.py
+    fac = 0.75 / jnp.pi / rg**3 / condensate_substance_density
+    em = extinction_coefficient * mmr_condensate[:, None] / N0
+    return expfac * fac * em * dParr[:, None] / gravity
```

## exojax/spec/lbd.py

```diff
@@ -1,10 +1,10 @@
 import numpy as np
 from exojax.utils.constants import hcperk
-from exojax.spec.lsd import npgetix
+from exojax.utils.indexing import npgetix
 
 
 def lbd_coefficients(elower_lines,
                      elower_grid,
                      Tref,
                      Twt,
                      diffmode=2,
```

## exojax/spec/lbderror.py

```diff
@@ -22,16 +22,15 @@
         p (float): between 0 to 1
 
     Returns:
         weight at point 2
     """
 
     fac1 = 1.0 - jnp.exp(_beta(t, tref) * p * dE)
-    fac2 = jnp.exp(-_beta(t, tref) *
-                   (1.0 - p) * dE) - jnp.exp(_beta(t, tref) * p * dE)
+    fac2 = jnp.exp(-_beta(t, tref) * (1.0 - p) * dE) - jnp.exp(_beta(t, tref) * p * dE)
     return fac1 / fac2
 
 
 def weight_point1_dE(t, tref, dE, p=0.5):
     """dE version of the weight at point 1 for PreMODIT
 
     Args:
@@ -83,18 +82,16 @@
 
     Returns:
         _type_: _description_
     """
 
     dfw1 = grad(weight_point1_dE, argnums=0)
     dfw2 = grad(weight_point2_dE, argnums=0)
-    w1 = weight_point1_dE(twp, tref, dE,
-                          p) + dfw1(twp, tref, dE, p) * (t - twp)
-    w2 = weight_point2_dE(twp, tref, dE,
-                          p) + dfw2(twp, tref, dE, p) * (t - twp)
+    w1 = weight_point1_dE(twp, tref, dE, p) + dfw1(twp, tref, dE, p) * (t - twp)
+    w2 = weight_point2_dE(twp, tref, dE, p) + dfw2(twp, tref, dE, p) * (t - twp)
     return single_tilde_line_strength(t, w1, w2, tref, dE, p)
 
 
 def single_tilde_line_strength_second(t, twp, tref, dE, p=0.5):
     """Single Line Line strength prediction for Premodit/diffmode=1
 
     Args:
@@ -109,18 +106,24 @@
     """
 
     dfw1 = grad(weight_point1_dE, argnums=0)
     dfw2 = grad(weight_point2_dE, argnums=0)
     ddfw1 = grad(dfw1, argnums=0)
     ddfw2 = grad(dfw2, argnums=0)
 
-    w1 = weight_point1_dE(twp, tref, dE, p) + dfw1(twp, tref, dE, p) * (
-        t - twp) + ddfw1(twp, tref, dE, p) * (t - twp)**2 / 2.0
-    w2 = weight_point2_dE(twp, tref, dE, p) + dfw2(twp, tref, dE, p) * (
-        t - twp) + ddfw2(twp, tref, dE, p) * (t - twp)**2 / 2.0
+    w1 = (
+        weight_point1_dE(twp, tref, dE, p)
+        + dfw1(twp, tref, dE, p) * (t - twp)
+        + ddfw1(twp, tref, dE, p) * (t - twp) ** 2 / 2.0
+    )
+    w2 = (
+        weight_point2_dE(twp, tref, dE, p)
+        + dfw2(twp, tref, dE, p) * (t - twp)
+        + ddfw2(twp, tref, dE, p) * (t - twp) ** 2 / 2.0
+    )
     return single_tilde_line_strength(t, w1, w2, tref, dE, p)
 
 
 def worst_tilde_line_strength_first(T, Ttyp, Tref, dE):
     """worst deviation of single tilde line search first in terms of p
 
     Args:
@@ -129,17 +132,17 @@
         Tref (float): reference tempearture K
         dE (float): Elower interval cm-1
 
     Return:
         worst value of single_tilde_line_strength_first in terms of p
 
     """
+
     def f(p):
-        return single_tilde_line_strength_first(1 / T, 1 / Ttyp, 1 / Tref, dE,
-                                                p)
+        return single_tilde_line_strength_first(1 / T, 1 / Ttyp, 1 / Tref, dE, p)
 
     ff = vmap(f)
     parr = jnp.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
     return jnp.max(jnp.abs(ff(parr)), axis=0)
 
 
 def worst_tilde_line_strength_second(T, Ttyp, Tref, dE):
@@ -151,37 +154,37 @@
         Tref (float): reference tempearture K
         dE (float): Elower interval cm-1
 
     Return:
         worst value of single_tilde_line_strength_first in terms of p
 
     """
+
     def f(p):
-        return single_tilde_line_strength_second(1 / T, 1 / Ttyp, 1 / Tref, dE,
-                                                 p)
+        return single_tilde_line_strength_second(1 / T, 1 / Ttyp, 1 / Tref, dE, p)
 
     ff = vmap(f)
     parr = jnp.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
     return jnp.max(jnp.abs(ff(parr)), axis=0)
 
 
 def evaluate_trange(Tarr, tlide_line_strength, crit, Twt):
     """evaluate robust temperature range
 
     Args:
         Tarr (ndarray): temperature array, shape = (N,)
         tlide_line_strength (ndarray): line strength error, shape = (N,)
         crit (float): criterion of line strength error (0.01=1%)
         Twt (float): weight temperature
-        
+
     Returns:
-        float, float: Tl, Tu. The line strength error is below crit within [Tl, Tu] 
+        float, float: Tl, Tu. The line strength error is below crit within [Tl, Tu]
     """
 
-    #exclude all nan case
+    # exclude all nan case
     validmask = tlide_line_strength == tlide_line_strength
     novalidmask = np.logical_not(validmask)
     if len(tlide_line_strength[validmask]) == 0:
         return Twt, Twt
     elif len(tlide_line_strength[novalidmask]) > 0:
         tlide_line_strength[novalidmask] = np.inf
 
@@ -199,65 +202,79 @@
     if len(dT_masked_upper) > 0:
         Tu = Twt + np.min(-dT_masked_upper)
     else:
         Tu = Tarr[-1]
     return Tl, Tu
 
 
-def default_elower_grid_trange_file():
+def default_elower_grid_trange_file(version):
     """default elower_grid_trange filename
+
+    Args:
+        version (int): version of default elower_grid_trange file, 1 or 2
+
     Returns:
-        default_elower_grid_trange filename
+        default_elower_grid_trange (degt) filename
 
     Note:
         This file assumes 1 % precision of line strength within [Tl, Tu]
-        default_elower_grid_trange_file generated by 
-        examples/gendata/gen_elower_grid_trange.py.
-    """
-    filename = pkg_resources.resource_filename(
-        'exojax', 'data/premodit/elower_grid_trange.npz')
+        default_elower_grid_trange_file generated by
+        spec/generate_elower_grid_trange.py.
+        Version 1 The original one when premodit was implemented
+        Version 2 a wider temperature range (Jan 2024)
+
+    """
+    print("default elower grid trange (degt) file version:", version)
+
+    if version == 1:
+        filename = pkg_resources.resource_filename(
+            "exojax", "data/premodit/elower_grid_trange.npz"
+        )
+    elif version == 2:
+        filename = pkg_resources.resource_filename(
+            "exojax", "data/premodit/elower_grid_trange_v2.npz"
+        )
+    else:
+        raise ValueError("currently version=1 or 2 are available.")
+
     return filename
 
 
-def optimal_params(Tl,
-                   Tu,
-                   diffmode=2,
-                   makefig=False,
-                   filename=None):
+def optimal_params(Tl, Tu, diffmode=2, version=2, makefig=False, filename=None):
     """derive the optimal parameters for a given Tu and Tl, 
-       which satisfies x % (1% if filename=None) precision within [Tl, Tu]
+    which satisfies x % (1% if filename=None) precision within [Tl, Tu]
 
     Args:
         Tl (float): lower temperature
         Tu (float): upper temperature
         diffmode (int, optional): diff mode. Defaults to 2.
+        version (int, optional): version of the default_elower_grid_trange_file, 1 or 2 (default)
         makefig (bool, optional): if you wanna make a fig. Defaults to False.
         filename: grid_trange file,  if None default_elower_grid_trange_file is used.
 
-    
     Returns:
         float: dE, Tref, Twt (optimal ones)
     """
 
     if filename is None:
-        filename = default_elower_grid_trange_file()
+        filename = default_elower_grid_trange_file(version=version)
     dat = np.load(filename)
     arr = dat["arr_0"]
-    #Tarr = dat["arr_1"]
+    # Tarr = dat["arr_1"]
     Twtarr = dat["arr_2"]
     Trefarr = dat["arr_3"]
     dEarr = dat["arr_4"]
 
     if Tl > Tu:
         raise ValueError("Tl must be smaller than Tu.")
     if diffmode > 2:
         raise ValueError("diffmode is currently to be <= 2.")
 
-    maskl = (arr[0, :, :, :, diffmode] <= Tl)
-    masku = (arr[1, :, :, :, diffmode] >= Tu)
+    maskl = arr[0, :, :, :, diffmode] <= Tl
+    masku = arr[1, :, :, :, diffmode] >= Tu
     mask = maskl * masku
     for i in range(len(dEarr)):
         k = -i - 1
         j = np.sum(mask[:, :, k])
         Tlarr = arr[0, :, :, k, diffmode]
         Tuarr = arr[1, :, :, k, diffmode]
         if j > 0:
@@ -276,36 +293,31 @@
             _pltadd(c, Trefallow, Twtallow)
             ax = fig.add_subplot(133)
             c = _draw_map(Tuarr - Tlarr, ax, Trefarr, Twtarr, Tu * 1.2)
             _pltadd(c, Trefallow, Twtallow)
             plt.show()
 
         if j == 1:
-            return dEarr[k]*(diffmode+1), Trefallow[0], Twtallow[0]
+            return dEarr[k] * (diffmode + 1), Trefallow[0], Twtallow[0]
         elif j > 1:
-            #choose the largest interval.        
+            # choose the largest interval.
             Tlx = arr[0, indices[0], indices[1], k, diffmode]
             Tux = arr[1, indices[0], indices[1], k, diffmode]
-            dT = (Tux-Tlx)
+            dT = Tux - Tlx
             ind = np.argsort(dT)[::-1]
-            print("Robust range:",Tlx[ind[0]],"-",Tux[ind[0]],"K")
-            return dEarr[k]*(diffmode+1), Trefallow[ind[0]], Twtallow[ind[0]]
+            print("Robust range:", Tlx[ind[0]], "-", Tux[ind[0]], "K")
+            return dEarr[k] * (diffmode + 1), Trefallow[ind[0]], Twtallow[ind[0]]
 
         if i == len(dEarr) - 1:
-            warnings.warn("Couldn't find the params.")
-            return None, None, None
+            raise ValueError("could not find the optimal trange. use a different degt file or regenerate a new one.")
+            
 
 
 def _draw_map(value, ax, Trefarr, Twtarr, Tmax_view):
-    c = ax.pcolor(Trefarr,
-                  Twtarr,
-                  value,
-                  cmap="rainbow",
-                  vmin=0.0,
-                  vmax=Tmax_view)
+    c = ax.pcolor(Trefarr, Twtarr, value, cmap="rainbow", vmin=0.0, vmax=Tmax_view)
     ax.set_aspect("equal")
     ax.set_xscale("log")
     ax.set_yscale("log")
     return c
 
 
 def _pltadd(c, Trefallow, Twtallow):
```

## exojax/spec/lpf.py

```diff
@@ -32,17 +32,17 @@
     Returns:
        line intensity matrix,
        gammaL matrix,
        sigmaD matrix
     """
 
     qt = vmap(mdb.qr_interp)(Tarr)
-    SijM = jit(vmap(line_strength, (0, None, None, None, 0)))(Tarr, mdb.logsij0,
+    SijM = jit(vmap(line_strength, (0, None, None, None, 0, None)))(Tarr, mdb.logsij0,
                                                      mdb.dev_nu_lines,
-                                                     mdb.elower, qt)
+                                                              mdb.elower, qt, mdb.Tref)
     gammaLMP = jit(vmap(gamma_exomol,
                         (0, 0, None, None)))(Parr, Tarr, mdb.n_Texp,
                                              mdb.alpha_ref)
     gammaLMN = gamma_natural(mdb.A)
     gammaLM = gammaLMP + gammaLMN[None, :]
     sigmaDM = jit(vmap(doppler_sigma, (None, 0, None)))(mdb.nu_lines, Tarr,
                                                         molmass)
@@ -66,31 +66,31 @@
     
     """
     # Compute normalized partition function for each species
     qt_284 = vmap(adb.QT_interp_284)(Tarr)
     qt = qt_284[:, adb.QTmask]
 
     # Compute line strength matrix
-    SijM = jit(vmap(line_strength,(0,None,None,None,0)))\
-        (Tarr, adb.logsij0, adb.nu_lines, adb.elower, qt)
+    SijM = jit(vmap(line_strength,(0,None,None,None,0,None)))\
+        (Tarr, adb.logsij0, adb.nu_lines, adb.elower, qt, adb.Tref)
 
     # Compute gamma parameters for the pressure and natural broadenings
     gammaLM = jit(vmap(gamma_vald3,(0,0,0,0,None,None,None,None,None,None,None,None,None,None,None)))\
             (Tarr, PH, PHH, PHe, adb.ielem, adb.iion, adb.dev_nu_lines, adb.elower, adb.eupper, adb.atomicmass, adb.ionE, adb.gamRad, adb.gamSta, adb.vdWdamp, 1.0)
 
     # Compute doppler broadening
     sigmaDM = jit(vmap(doppler_sigma,(None,0,None)))\
         (adb.nu_lines, Tarr, adb.atomicmass)
 
     return SijM, gammaLM, sigmaDM
 
 
 def vald_each(Tarr, PH, PHe, PHH, \
             qt_284_T, QTmask, \
-             logsij0, nu_lines, ielem, iion, dev_nu_lines, elower, eupper, atomicmass, ionE, gamRad, gamSta, vdWdamp, ):
+              logsij0, nu_lines, ielem, iion, dev_nu_lines, elower, eupper, atomicmass, ionE, gamRad, gamSta, vdWdamp, Tref, ):
     """Compute VALD line information required for LPF for separated each species
     
     Args:
         Tarr:  temperature array [N_layer]
         PH:  partial pressure array of neutral hydrogen (H) [N_layer]
         PHe:  partial pressure array of neutral helium (He) [N_layer]
         PHH:  partial pressure array of molecular hydrogen (H2) [N_layer]
@@ -115,16 +115,16 @@
        sigmaDM: sigmaD matrix [N_layer x N_line]
     
     """
     # Compute normalized partition function for each species
     qt = qt_284_T[:, QTmask]
 
     # Compute line strength matrix
-    SijM = jit(vmap(line_strength,(0,None,None,None,0)))\
-        (Tarr, logsij0, nu_lines, elower, qt)
+    SijM = jit(vmap(line_strength,(0,None,None,None,0,None)))\
+        (Tarr, logsij0, nu_lines, elower, qt, Tref)
     SijM = jnp.nan_to_num(SijM, nan=0.0)
 
     # Compute gamma parameters for the pressure and natural broadenings
     gammaLM = jit(vmap(gamma_vald3,(0,0,0,0,None,None,None,None,None,None,None,None,None,None,None)))\
             (Tarr, PH, PHH, PHe, ielem, iion, dev_nu_lines, elower, eupper, atomicmass, ionE, gamRad, gamSta, vdWdamp, 1.0)
 
     # Compute doppler broadening
```

## exojax/spec/lsd.py

```diff
@@ -1,67 +1,19 @@
 """functions for computation of line shape density (LSD) 
 
    * there are both numpy and jnp versions. (np)*** is numpy version.
-   * (np)getix provides the contribution and index.
    * (np)add(x)D constructs the (x)Dimensional LSD array given the contribution and index.
 
 """
 import numpy as np
 from jax.numpy import index_exp
 import jax.numpy as jnp
 from jax import jit
 from exojax.utils.progbar import print_progress
-
-def getix(x, xv):
-    """jnp version of getix.
-
-    Args:
-        x: x array
-        xv: x grid, should be ascending order 
-
-    Returns:
-        cont (contribution)
-        index (index)
-
-    Note:
-       cont is the contribution for i=index+1. 1 - cont is the contribution for i=index. For other i, the contribution should be zero.
-
-    Example:
-
-       >>> from exojax.spec.lsd import getix
-       >>> import jax.numpy as jnp
-       >>> y=jnp.array([1.1,4.3])
-       >>> yv=jnp.arange(6)
-       >>> getix(y,yv)
-       (DeviceArray([0.10000002, 0.3000002 ], dtype=float32), DeviceArray([1, 4], dtype=int32))
-    """
-    indarr = jnp.arange(len(xv))
-    pos = jnp.interp(x, xv, indarr)
-    cont, index = jnp.modf(pos)
-    return cont, index.astype(int)
-
-
-def npgetix(x, xv):
-    """numpy version of getix.
-
-    Args:
-        x: x array
-        xv: x grid, should be ascending order
-
-    Returns:
-        cont (contribution)
-        index (index)
-
-    Note:
-       cont is the contribution for i=index+1. 1 - cont is the contribution for i=index. For other i, the contribution should be zero.
-    """
-    indarr = np.arange(len(xv))
-    pos = np.interp(x, xv, indarr)
-    cont, index = np.modf(pos)
-    return cont, index.astype(int)
+from exojax.utils.indexing import getix
 
 
 def add2D(a, w, cx, ix, cy, iy):
     """Add into an array when contirbutions and indices are given (2D).
 
     Args:
         a: lineshape density (LSD) array (np.array)
```

## exojax/spec/modit.py

```diff
@@ -160,17 +160,17 @@
         
     Returns:
         line intensity matrix,
         normalized gammaL matrix,
         normalized sigmaD matrix
     """
     qt = vmap(mdb.qr_interp)(Tarr)
-    SijM = jit(vmap(line_strength, (0, None, None, None, 0)))(Tarr, mdb.logsij0,
+    SijM = jit(vmap(line_strength, (0, None, None, None, 0, None)))(Tarr, mdb.logsij0,
                                                      mdb.dev_nu_lines,
-                                                     mdb.elower, qt)
+                                                                 mdb.elower, qt, mdb.Tref)
     gammaLMP = jit(vmap(gamma_exomol,
                         (0, 0, None, None)))(Parr, Tarr, mdb.n_Texp,
                                              mdb.alpha_ref)
     gammaLMN = gamma_natural(mdb.A)
     gammaLM = gammaLMP + gammaLMN[None, :]
     ngammaLM = gammaLM / (mdb.dev_nu_lines / R)
     nsigmaDl = normalized_doppler_sigma(Tarr, molmass, R)[:, jnp.newaxis]
@@ -232,17 +232,17 @@
 
     Returns:
        line intensity matrix,
        normalized gammaL matrix,
        normalized sigmaD matrix
     """
     qt = vmap(mdb.qr_interp_lines)(Tarr)
-    SijM = jit(vmap(line_strength, (0, None, None, None, 0)))(Tarr, mdb.logsij0,
+    SijM = jit(vmap(line_strength, (0, None, None, None, 0, None)))(Tarr, mdb.logsij0,
                                                      mdb.dev_nu_lines,
-                                                     mdb.elower, qt)
+                                                              mdb.elower, qt, mdb.Tref)
     gammaLMP = jit(vmap(gamma_hitran,
                         (0, 0, 0, None, None, None)))(Parr, Tarr, Pself,
                                                       mdb.n_air, mdb.gamma_air,
                                                       mdb.gamma_self)
     gammaLMN = gamma_natural(mdb.A)
     gammaLM = gammaLMP + gammaLMN[None, :]
     ngammaLM = gammaLM / (mdb.dev_nu_lines / R)
@@ -293,15 +293,15 @@
     dgm_ngammaL = precompute_modit_ditgrid_matrix(
         set_dgm_minmax, dit_grid_resolution=dit_grid_resolution)
     return jnp.array(dgm_ngammaL)
 
 
 @jit
 def vald_each(Tarr, PH, PHe, PHH, R, qt_284_T, QTmask, \
-               ielem, iion, atomicmass, ionE, dev_nu_lines, logsij0, elower, eupper, gamRad, gamSta, vdWdamp):
+               ielem, iion, atomicmass, ionE, dev_nu_lines, logsij0, elower, eupper, gamRad, gamSta, vdWdamp, Tref):
     """Compute atomic line information required for MODIT for separated EACH species, using parameters attributed in VALD separated atomic database (asdb).
 
     Args:
         Tarr:  temperature array [N_layer]
         PH:  partial pressure array of neutral hydrogen (H) [N_layer]
         PHe:  partial pressure array of neutral helium (He) [N_layer]
         PHH:  partial pressure array of molecular hydrogen (H2) [N_layer]
@@ -315,26 +315,27 @@
         dev_nu_lines:  line center (cm-1) in device
         logsij0:  log line strength at T=Tref
         elower:  the lower state energy (cm-1)
         eupper:  the upper state energy (cm-1)
         gamRad:  log of gamma of radiation damping (s-1)
         gamSta:  log of gamma of Stark damping (s-1)
         vdWdamp:  log of (van der Waals damping constant / neutral hydrogen number) (s-1)
+        Tref: reference temperature
 
     Returns:
         SijM:  line intensity matrix [N_layer x N_line]
         ngammaLM:  normalized gammaL matrix [N_layer x N_line]
         nsigmaDl:  normalized sigmaD matrix [N_layer x 1]
     """
     # Compute normalized partition function for each species
     qt = qt_284_T[:, QTmask]
 
     # Compute line strength matrix
-    SijM = jit(vmap(line_strength,(0,None,None,None,0)))\
-        (Tarr, logsij0, dev_nu_lines, elower, qt)
+    SijM = jit(vmap(line_strength,(0,None,None,None,0,None)))\
+        (Tarr, logsij0, dev_nu_lines, elower, qt, Tref)
 
     # Compute gamma parameters for the pressure and natural broadenings
     gammaLM = jit(vmap(gamma_vald3,(0,0,0,0,None,None,None,None,None,None,None,None,None,None,None)))\
             (Tarr, PH, PHH, PHe, ielem, iion, dev_nu_lines, elower, eupper, atomicmass, ionE, gamRad, gamSta, vdWdamp, 1.0)
     ngammaLM = gammaLM / (dev_nu_lines / R)
     # Do NOT remove NaN because "set_ditgrid_matrix_vald_each" makes good use of them. # ngammaLM = jnp.nan_to_num(ngammaLM, nan = 0.0)
 
@@ -359,36 +360,36 @@
         ngammaLMS:  normalized gammaL matrix [N_species x N_layer x N_line]
         nsigmaDlS:  normalized sigmaD matrix [N_species x N_layer x 1]
     """
     gQT_284species = asdb.gQT_284species
     T_gQT = asdb.T_gQT
     qt_284_T = vmap(interp_QT284, (0, None, None))(Tarr, T_gQT, gQT_284species)
 
-    SijMS, ngammaLMS, nsigmaDlS = jit(vmap(vald_each, (None, None, None, None, None, None, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, )))\
+    SijMS, ngammaLMS, nsigmaDlS = jit(vmap(vald_each, (None, None, None, None, None, None, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, None, )))\
         (Tarr, PH, PHe, PHH, R, qt_284_T, \
                  asdb.QTmask, asdb.ielem, asdb.iion, asdb.atomicmass, asdb.ionE, \
-                       asdb.dev_nu_lines, asdb.logsij0, asdb.elower, asdb.eupper, asdb.gamRad, asdb.gamSta, asdb.vdWdamp)
+                       asdb.dev_nu_lines, asdb.logsij0, asdb.elower, asdb.eupper, asdb.gamRad, asdb.gamSta, asdb.vdWdamp, asdb.Tref)
 
     return SijMS, ngammaLMS, nsigmaDlS
 
 
-def setdgm_vald_each(ielem, iion, atomicmass, ionE, dev_nu_lines, logsij0, elower, eupper, gamRad, gamSta, vdWdamp, \
+def setdgm_vald_each(ielem, iion, atomicmass, ionE, dev_nu_lines, logsij0, elower, eupper, gamRad, gamSta, vdWdamp, Tref, \
                 QTmask, T_gQT, gQT_284species, PH, PHe, PHH, R, fT, dit_grid_resolution, *kargs):
     warn_msg = " Use `modit.set_ditgrid_matrix_vald_each` instead"
     warnings.warn(warn_msg, FutureWarning)
     return set_ditgrid_matrix_vald_each(ielem, iion, atomicmass, ionE,
                                         dev_nu_lines, logsij0, elower, eupper,
-                                        gamRad, gamSta, vdWdamp, QTmask, T_gQT,
+                                        gamRad, gamSta, vdWdamp, Tref, QTmask, T_gQT,
                                         gQT_284species, PH, PHe, PHH, R, fT,
                                         dit_grid_resolution, *kargs)
 
 
 def set_ditgrid_matrix_vald_each(ielem, iion, atomicmass, ionE, dev_nu_lines,
                                  logsij0, elower, eupper, gamRad, gamSta,
-                                 vdWdamp, QTmask, T_gQT, gQT_284species, PH,
+                                 vdWdamp, Tref, QTmask, T_gQT, gQT_284species, PH,
                                  PHe, PHH, R, fT, dit_grid_resolution, *kargs):
     """Easy Setting of DIT Grid Matrix (dgm) using VALD.
 
     Args:
         ielem:  atomic number (e.g., Fe=26)
         iion:  ionized level (e.g., neutral=1, singly ionized=2, etc.)
         atomicmass:  atomic mass (amu)
@@ -396,14 +397,15 @@
         dev_nu_lines:  line center (cm-1) in device
         logsij0:  log line strength at T=Tref
         elower:  the lower state energy (cm-1)
         eupper:  the upper state energy (cm-1)
         gamRad:  log of gamma of radiation damping (s-1)
         gamSta:  log of gamma of Stark damping (s-1)
         vdWdamp:  log of (van der Waals damping constant / neutral hydrogen number) (s-1)
+        Tref: reference temperature
         T_gQT:  temperature in the grid obtained from the adb instance
         gQT_284species:  partition function in the grid from the adb instance
         QTmask:  array of index of Q(Tref) grid (gQT) for each line
         PH:  partial pressure array of neutral hydrogen (H) [N_layer]
         PHe:  partial pressure array of neutral helium (He) [N_layer]
         PHH:  partial pressure array of molecular hydrogen (H2) [N_layer]
         R:  spectral resolution
@@ -417,15 +419,15 @@
     set_dgm_minmax = []
     Tarr_list = fT(*kargs)
     for Tarr in Tarr_list:
         qt_284_T = vmap(interp_QT284, (0, None, None))(Tarr, T_gQT,
                                                        gQT_284species)
         SijM, ngammaLM, nsigmaDl = vald_each(Tarr, PH, PHe, PHH, R, qt_284_T, \
              QTmask, ielem, iion, atomicmass, ionE, \
-                   dev_nu_lines, logsij0, elower, eupper, gamRad, gamSta, vdWdamp)
+                                             dev_nu_lines, logsij0, elower, eupper, gamRad, gamSta, vdWdamp, Tref)
         floop = lambda c, arr: (c,
                                 jnp.nan_to_num(arr,
                                                nan=jnp.nanmin(arr),
                                                posinf=jnp.nanmin(arr),
                                                neginf=jnp.nanmin(arr)))
         ngammaLM = scan(floop, 0, ngammaLM)[1]
         set_dgm_minmax.append(
@@ -469,15 +471,15 @@
     T_gQT = asdb.T_gQT
     gQT_284species = asdb.gQT_284species
 
     dgm_ngammaLS_BeforePadding = []
     lendgm = []
     for i in range(asdb.N_usp):
         dgm_ngammaL_sp = set_ditgrid_matrix_vald_each(asdb.ielem[i], asdb.iion[i], asdb.atomicmass[i], asdb.ionE[i], \
-            asdb.dev_nu_lines[i], asdb.logsij0[i], asdb.elower[i], asdb.eupper[i], asdb.gamRad[i], asdb.gamSta[i], asdb.vdWdamp[i], \
+            asdb.dev_nu_lines[i], asdb.logsij0[i], asdb.elower[i], asdb.eupper[i], asdb.gamRad[i], asdb.gamSta[i], asdb.vdWdamp[i], asdb.Tref, \
             asdb.QTmask[i], T_gQT, gQT_284species, PH, PHe, PHH, R, fT, dit_grid_resolution, *kargs)
         dgm_ngammaLS_BeforePadding.append(dgm_ngammaL_sp)
         lendgm.append(dgm_ngammaL_sp.shape[1])
     Lmax_dgm = np.max(np.array(lendgm))
 
     # Padding to unity the length of all the DIT Grid Matrix (dgm) and convert them into jnp.array
     pad2Dm = lambda arr, L: jnp.pad(arr, ((0, 0), (0, L - arr.shape[1])),
```

## exojax/spec/molinfo.py

```diff
@@ -37,15 +37,15 @@
        molecule: molecular name e.g. CO2, He
        db_HIT: if True, use the molecular mass considering the natural terrestrial abundance and mass of each isotopologue provided by HITRAN (https://hitran.org/docs/iso-meta/)
 
     Returns: 
        molecular mass
 
     Example:
-       >>> from exojax.spec.moinfo import mean_molmass
+       >>> from exojax.spec.molinfo import molmass
        >>> print(molmass("H2"))
        >>> 2.01588
        >>> print(molmass("CO2"))
        >>> 44.0095
        >>> print(molmass("He"))
        >>> 4.002602
        >>> print(molmass("air"))
```

## exojax/spec/multimol.py

```diff
@@ -1,10 +1,11 @@
 import numpy as np
 from exojax.spec import api
 import os
+import traceback
 
 
 class MultiMol():
     """multiple molecular database handler
 
         Notes:
             MultiMol provides an easy way to generate multiple mdb (multimdb) and multiple opa (multiopa) 
@@ -115,16 +116,21 @@
                             api.MdbHitemp(os.path.join(self.database_root_path,
                                                        self.db_dirs[k][i]),
                                           nu_grid_list[k],
                                           crit=crit,
                                           Ttyp=Ttyp,
                                           gpu_transfer=False,
                                           isotope=1))
-                except:
-                    mask[i] = False
+                except Exception as e:
+                    if 'No line found in ' in e.args:
+                        print(self.molmulti[k][i], self.dbmulti[k][i], "in the range of", e.args[1], e.args[2], "will be ignored due to no available lines found")
+                        mask[i] = False
+                    else:
+                        print(traceback.format_exc())
+                        exit()
 
             self.masked_molmulti[k] = np.array(self.molmulti[k])[mask].tolist()
             _multimdb.append(mdb_k)
             self.derive_unique_molecules()
         
         return _multimdb
 
@@ -153,15 +159,16 @@
 
 
     def multiopa_premodit(self,
                           multimdb,
                           nu_grid_list,
                           auto_trange,
                           diffmode=2,
-                          dit_grid_resolution=0.2):
+                          dit_grid_resolution=0.2,
+                          allow_32bit=False):
         """multiple opa for PreMODIT
 
         Args:
             multimdb (): multimdb
             nu_grid_list (): wavenumber grid list
             auto_trange (optional): temperature range [Tl, Tu], in which line strength is within 1 % prescision. Defaults to None.
             diffmode (int, optional): _description_. Defaults to 2.
@@ -175,15 +182,16 @@
         for k in range(len(multimdb)):
             opa_k = []
             for i in range(len(multimdb[k])):
                 opa_i = OpaPremodit(mdb=multimdb[k][i],
                                     nu_grid=nu_grid_list[k],
                                     diffmode=diffmode,
                                     auto_trange=auto_trange,
-                                    dit_grid_resolution=dit_grid_resolution)
+                                    dit_grid_resolution=dit_grid_resolution,
+                                    allow_32bit=allow_32bit)
                 opa_k.append(opa_i)
             multiopa.append(opa_k)
 
         return multiopa
 
     def molmass(self):
         """return molecular mass list and H and He
```

## exojax/spec/opacalc.py

```diff
@@ -1,121 +1,128 @@
 """opacity calculator class
 
 Notes:
     Opa does not assume any T-P structure, no fixed T, P, mmr grids.
 
 """
 
-__all__ = ['OpaPremodit', 'OpaModit', 'OpaDirect']
+__all__ = ["OpaPremodit", "OpaModit", "OpaDirect"]
 
 from exojax.spec import initspec
 from exojax.spec.lbderror import optimal_params
 from exojax.utils.grids import wavenumber_grid
 from exojax.utils.instfunc import nx_from_resolution_eslog
 from exojax.utils.grids import nu2wav
 from exojax.utils.instfunc import resolution_eslog
 from exojax.utils.constants import Patm
 from exojax.utils.constants import Tref_original
 from exojax.utils.jaxstatus import check_jax64bit
+from exojax.utils.checkarray import is_outside_range
 import jax.numpy as jnp
 from jax import jit
 from jax import vmap
 import numpy as np
 import warnings
 
 
-class OpaCalc():
-    """Common Opacity Calculator Class
-    """
+class OpaCalc:
+    """Common Opacity Calculator Class"""
+
     def __init__(self):
         self.opainfo = None
         self.method = None  # which opacity calc method is used
         self.ready = False  # ready for opacity computation
 
 
 class OpaPremodit(OpaCalc):
     """Opacity Calculator Class for PreMODIT
 
     Attributes:
         opainfo: information set used in PreMODIT
 
     """
-    def __init__(self,
-                 mdb,
-                 nu_grid,
-                 diffmode=0,
-                 broadening_resolution={
-                     "mode": "manual",
-                     "value": 0.2
-                 },
-                 auto_trange=None,
-                 manual_params=None,
-                 dit_grid_resolution=None,
-                 allow_32bit=False,
-                 wavelength_order="descending"):
+
+    def __init__(
+        self,
+        mdb,
+        nu_grid,
+        diffmode=0,
+        broadening_resolution={"mode": "manual", "value": 0.2},
+        auto_trange=None,
+        manual_params=None,
+        dit_grid_resolution=None,
+        allow_32bit=False,
+        wavelength_order="descending",
+        version_auto_trange=2
+    ):
         """initialization of OpaPremodit
 
         Note:
-            If auto_trange nor manual_params is not given in arguments, 
+            If auto_trange nor manual_params is not given in arguments,
             use manual_setting()
             or provide self.dE, self.Tref, self.Twt and apply self.apply_params()
-            
+
         Note:
             The option of "broadening_parameter_resolution" controls the resolution of broadening parameters.
             When you wanna use the manual resolution, set broadening_parameter_resolution = {mode: "manual", value: 0.2}.
             When you wanna use the min and max values of broadening parameters in database, set broadening_parameter_resolution = {mode: "minmax", value: None}.
             When you wanna give single broadening parameters: set broadening_parameter_resolution = {mode: "single", value: None} the median values of gamma_ref, n_Texp are used
-            or set broadening_parameter_resolution = {mode: "single", value: [gamma_ref, n_Texp]} values are at 296K, for the fixed parameter set.  
-            The use of device memory: "manual" >= "minmax" > "single". In general, small value (such as 0.2) requires large device memory. 
+            or set broadening_parameter_resolution = {mode: "single", value: [gamma_ref, n_Texp]} values are at 296K, for the fixed parameter set.
+            The use of device memory: "manual" >= "minmax" > "single". In general, small value (such as 0.2) requires large device memory.
             We recommend to check the difference of the final specrum between "manual", "minmax", and "single" when you had a device memory problem.
-            
+
         Args:
             mdb (mdb class): mdbExomol, mdbHitemp, mdbHitran
             nu_grid (): wavenumber grid (cm-1)
             diffmode (int, optional): _description_. Defaults to 0.
-            broadening_resolution (dict, optional): definition of the broadening parameter resolution. Default to {"mode": "manual", value: 0.2}. See Note. 
+            broadening_resolution (dict, optional): definition of the broadening parameter resolution. Default to {"mode": "manual", value: 0.2}. See Note.
             auto_trange (optional): temperature range [Tl, Tu], in which line strength is within 1 % prescision. Defaults to None.
             manual_params (optional): premodit parameter set [dE, Tref, Twt]. Defaults to None.
             dit_grid_resolution (float, optional): force to set broadening_parameter_resolution={mode:manual, value: dit_grid_resolution}), ignores broadening_parameter_resolution.
             allow_32bit (bool, optional): If True, allow 32bit mode of JAX. Defaults to False.
             wavlength order: wavelength order: "ascending" or "descending"
+            version_auto_trange: version of the default elower grid trange (degt) file, Default to 2 since Jan 2024.
         """
         super().__init__()
         check_jax64bit(allow_32bit)
 
-        #default setting
+        # default setting
         self.method = "premodit"
         self.diffmode = diffmode
         self.warning = True
         self.nu_grid = nu_grid
         self.wavelength_order = wavelength_order
-        self.wav = nu2wav(self.nu_grid,
-                          wavelength_order=self.wavelength_order,
-                          unit="AA")
+        self.wav = nu2wav(
+            self.nu_grid, wavelength_order=self.wavelength_order, unit="AA"
+        )
         self.resolution = resolution_eslog(nu_grid)
         self.mdb = mdb
         self.ngrid_broadpar = None
-
-        #broadening parameter setting
-        self.determine_broadening_parameter_resolution(broadening_resolution,
-                                                       dit_grid_resolution)
+        self.version_auto_trange = version_auto_trange
+        # check if the mdb lines are in nu_grid
+        if is_outside_range(self.mdb.nu_lines, self.nu_grid[0], self.nu_grid[-1]):
+            raise ValueError("None of the lines in mdb are within nu_grid.")
+
+        # broadening parameter setting
+        self.determine_broadening_parameter_resolution(
+            broadening_resolution, dit_grid_resolution
+        )
         self.broadening_parameters_setting()
 
         if auto_trange is not None:
             self.auto_setting(auto_trange[0], auto_trange[1])
         elif manual_params is not None:
-            self.manual_setting(manual_params[0], manual_params[1],
-                                manual_params[2])
+            self.manual_setting(manual_params[0], manual_params[1], manual_params[2])
         else:
             print("OpaPremodit: initialization without parameters setting")
             print("Call self.apply_params() to complete the setting.")
 
     def auto_setting(self, Tl, Tu):
         print("OpaPremodit: params automatically set.")
-        self.dE, self.Tref, self.Twt = optimal_params(Tl, Tu, self.diffmode)
+        self.dE, self.Tref, self.Twt = optimal_params(Tl, Tu, self.diffmode, self.version_auto_trange)
         self.Tmax = Tu
         self.Tmin = Tl
         self.apply_params()
 
     def manual_setting(self, dE, Tref, Twt, Tmax=None, Tmin=None):
         """setting PreMODIT parameters by manual
 
@@ -141,34 +148,37 @@
 
     def set_nu_grid(self, x0, x1, unit, resolution=700000, Nx=None):
         if Nx is None:
             Nx = nx_from_resolution_eslog(x0, x1, resolution)
         if np.mod(Nx, 2) == 1:
             Nx = Nx + 1
         self.nu_grid, self.wav, self.resolution = wavenumber_grid(
-            x0, x1, Nx, unit=unit, xsmode="premodit")
+            x0, x1, Nx, unit=unit, xsmode="premodit"
+        )
 
     def set_Tref_broadening_to_midpoint(self):
-        """Set self.Tref_broadening using log midpoint of Tmax and Tmin
-        """
+        """Set self.Tref_broadening using log midpoint of Tmax and Tmin"""
         from exojax.spec.premodit import reference_temperature_broadening_at_midpoint
+
         self.Tref_broadening = reference_temperature_broadening_at_midpoint(
-            self.Tmin, self.Tmax)
-        print("OpaPremodit: Tref_broadening is set to ", self.Tref_broadening,
-              "K")
+            self.Tmin, self.Tmax
+        )
+        print("OpaPremodit: Tref_broadening is set to ", self.Tref_broadening, "K")
 
     def determine_broadening_parameter_resolution(
-            self, broadening_parameter_resolution, dit_grid_resolution):
+        self, broadening_parameter_resolution, dit_grid_resolution
+    ):
         if dit_grid_resolution is not None:
             warnings.warn(
                 "dit_grid_resolution is not None. Ignoring broadening_parameter_resolution.",
-                UserWarning)
+                UserWarning,
+            )
             self.broadening_parameter_resolution = {
                 "mode": "manual",
-                "value": dit_grid_resolution
+                "value": dit_grid_resolution,
             }
         else:
             self.broadening_parameter_resolution = broadening_parameter_resolution
 
     def broadening_parameters_setting(self):
         mode = self.broadening_parameter_resolution["mode"]
         val = self.broadening_parameter_resolution["value"]
@@ -191,40 +201,38 @@
                 "Unknown mode in broadening_parameter_resolution e.g. manual/single/minmax."
             )
 
     def compute_gamma_ref_and_n_Texp(self, mdb):
         """convert gamma_ref to the regular formalization and noramlize it for Tref_braodening
 
         Notes:
-            gamma (T) = (gamma at Tref_original) * (Tref_original/Tref_broadening)**n 
-            * (T/Tref_broadening)**-n * (P/1bar) 
+            gamma (T) = (gamma at Tref_original) * (Tref_original/Tref_broadening)**n
+            * (T/Tref_broadening)**-n * (P/1bar)
 
         Args:
             mdb (_type_): mdb instance
 
         """
         if mdb.dbtype == "hitran":
             print(
                 "OpaPremodit: gamma_air and n_air are used. gamma_ref = gamma_air/Patm"
             )
             self.n_Texp = mdb.n_air
-            reference_factor = (Tref_original /
-                                self.Tref_broadening)**(self.n_Texp)
+            reference_factor = (Tref_original / self.Tref_broadening) ** (self.n_Texp)
             self.gamma_ref = mdb.gamma_air * reference_factor / Patm
         elif mdb.dbtype == "exomol":
             self.n_Texp = mdb.n_Texp
-            reference_factor = (Tref_original /
-                                self.Tref_broadening)**(self.n_Texp)
+            reference_factor = (Tref_original / self.Tref_broadening) ** (self.n_Texp)
             self.gamma_ref = mdb.alpha_ref * reference_factor
 
     def apply_params(self):
         self.mdb.change_reference_temperature(self.Tref)
         self.dbtype = self.mdb.dbtype
 
-        #broadening
+        # broadening
         if self.single_broadening:
             print("OpaPremodit: a single broadening parameter set is used.")
             self.Tref_broadening = Tref_original
         else:
             self.set_Tref_broadening_to_midpoint()
 
         self.compute_gamma_ref_and_n_Texp(self.mdb)
@@ -242,179 +250,280 @@
             Tmax=self.Tmax,
             Tmin=self.Tmin,
             dE=self.dE,
             dit_grid_resolution=self.dit_grid_resolution,
             diffmode=self.diffmode,
             single_broadening=self.single_broadening,
             single_broadening_parameters=self.single_broadening_parameters,
-            warning=self.warning)
+            warning=self.warning,
+        )
         self.ready = True
 
-        lbd_coeff, multi_index_uniqgrid, elower_grid, \
-            ngamma_ref_grid, n_Texp_grid, R, pmarray = self.opainfo
+        (
+            lbd_coeff,
+            multi_index_uniqgrid,
+            elower_grid,
+            ngamma_ref_grid,
+            n_Texp_grid,
+            R,
+            pmarray,
+        ) = self.opainfo
         self.ngrid_broadpar = len(multi_index_uniqgrid)
         self.ngrid_elower = len(elower_grid)
 
     def xsvector(self, T, P):
         from exojax.spec.premodit import xsvector_zeroth
         from exojax.spec.premodit import xsvector_first
         from exojax.spec.premodit import xsvector_second
         from exojax.spec import normalized_doppler_sigma
 
-        lbd_coeff, multi_index_uniqgrid, elower_grid, \
-            ngamma_ref_grid, n_Texp_grid, R, pmarray = self.opainfo
+        (
+            lbd_coeff,
+            multi_index_uniqgrid,
+            elower_grid,
+            ngamma_ref_grid,
+            n_Texp_grid,
+            R,
+            pmarray,
+        ) = self.opainfo
         nsigmaD = normalized_doppler_sigma(T, self.mdb.molmass, R)
 
         if self.mdb.dbtype == "hitran":
             qt = self.mdb.qr_interp(self.mdb.isotope, T)
         elif self.mdb.dbtype == "exomol":
             qt = self.mdb.qr_interp(T)
 
         if self.diffmode == 0:
-            return xsvector_zeroth(T, P, nsigmaD, lbd_coeff, self.Tref, R,
-                                   pmarray, self.nu_grid, elower_grid,
-                                   multi_index_uniqgrid, ngamma_ref_grid,
-                                   n_Texp_grid, qt, self.Tref_broadening)
+            return xsvector_zeroth(
+                T,
+                P,
+                nsigmaD,
+                lbd_coeff,
+                self.Tref,
+                R,
+                pmarray,
+                self.nu_grid,
+                elower_grid,
+                multi_index_uniqgrid,
+                ngamma_ref_grid,
+                n_Texp_grid,
+                qt,
+                self.Tref_broadening,
+            )
         elif self.diffmode == 1:
-            return xsvector_first(T, P, nsigmaD, lbd_coeff, self.Tref,
-                                  self.Twt, R, pmarray, self.nu_grid,
-                                  elower_grid, multi_index_uniqgrid,
-                                  ngamma_ref_grid, n_Texp_grid, qt,
-                                  self.Tref_broadening)
+            return xsvector_first(
+                T,
+                P,
+                nsigmaD,
+                lbd_coeff,
+                self.Tref,
+                self.Twt,
+                R,
+                pmarray,
+                self.nu_grid,
+                elower_grid,
+                multi_index_uniqgrid,
+                ngamma_ref_grid,
+                n_Texp_grid,
+                qt,
+                self.Tref_broadening,
+            )
         elif self.diffmode == 2:
-            return xsvector_second(T, P, nsigmaD, lbd_coeff, self.Tref,
-                                   self.Twt, R, pmarray, self.nu_grid,
-                                   elower_grid, multi_index_uniqgrid,
-                                   ngamma_ref_grid, n_Texp_grid, qt,
-                                   self.Tref_broadening)
+            return xsvector_second(
+                T,
+                P,
+                nsigmaD,
+                lbd_coeff,
+                self.Tref,
+                self.Twt,
+                R,
+                pmarray,
+                self.nu_grid,
+                elower_grid,
+                multi_index_uniqgrid,
+                ngamma_ref_grid,
+                n_Texp_grid,
+                qt,
+                self.Tref_broadening,
+            )
 
     def xsmatrix(self, Tarr, Parr):
         """cross section matrix
 
         Args:
-            Tarr (): tempearture array in K 
+            Tarr (): tempearture array in K
             Parr (): pressure array in bar
 
         Raises:
             ValueError: _description_
 
         Returns:
             jnp.array : cross section matrix (Nlayer, N_wavenumber)
         """
         from exojax.spec.premodit import xsmatrix_zeroth
         from exojax.spec.premodit import xsmatrix_first
         from exojax.spec.premodit import xsmatrix_second
         from jax import vmap
-        lbd_coeff, multi_index_uniqgrid, elower_grid, \
-            ngamma_ref_grid, n_Texp_grid, R, pmarray = self.opainfo
+
+        (
+            lbd_coeff,
+            multi_index_uniqgrid,
+            elower_grid,
+            ngamma_ref_grid,
+            n_Texp_grid,
+            R,
+            pmarray,
+        ) = self.opainfo
 
         if self.mdb.dbtype == "hitran":
             qtarr = vmap(self.mdb.qr_interp, (None, 0))(self.mdb.isotope, Tarr)
         elif self.mdb.dbtype == "exomol":
             qtarr = vmap(self.mdb.qr_interp)(Tarr)
 
         if self.diffmode == 0:
-            return xsmatrix_zeroth(Tarr, Parr, self.Tref, R, pmarray,
-                                   lbd_coeff, self.nu_grid, ngamma_ref_grid,
-                                   n_Texp_grid, multi_index_uniqgrid,
-                                   elower_grid, self.mdb.molmass, qtarr,
-                                   self.Tref_broadening)
+            return xsmatrix_zeroth(
+                Tarr,
+                Parr,
+                self.Tref,
+                R,
+                pmarray,
+                lbd_coeff,
+                self.nu_grid,
+                ngamma_ref_grid,
+                n_Texp_grid,
+                multi_index_uniqgrid,
+                elower_grid,
+                self.mdb.molmass,
+                qtarr,
+                self.Tref_broadening,
+            )
 
         elif self.diffmode == 1:
-            return xsmatrix_first(Tarr, Parr, self.Tref, self.Twt, R, pmarray,
-                                  lbd_coeff, self.nu_grid, ngamma_ref_grid,
-                                  n_Texp_grid, multi_index_uniqgrid,
-                                  elower_grid, self.mdb.molmass, qtarr,
-                                  self.Tref_broadening)
+            return xsmatrix_first(
+                Tarr,
+                Parr,
+                self.Tref,
+                self.Twt,
+                R,
+                pmarray,
+                lbd_coeff,
+                self.nu_grid,
+                ngamma_ref_grid,
+                n_Texp_grid,
+                multi_index_uniqgrid,
+                elower_grid,
+                self.mdb.molmass,
+                qtarr,
+                self.Tref_broadening,
+            )
 
         elif self.diffmode == 2:
-            return xsmatrix_second(Tarr, Parr, self.Tref, self.Twt, R, pmarray,
-                                   lbd_coeff, self.nu_grid, ngamma_ref_grid,
-                                   n_Texp_grid, multi_index_uniqgrid,
-                                   elower_grid, self.mdb.molmass, qtarr,
-                                   self.Tref_broadening)
+            return xsmatrix_second(
+                Tarr,
+                Parr,
+                self.Tref,
+                self.Twt,
+                R,
+                pmarray,
+                lbd_coeff,
+                self.nu_grid,
+                ngamma_ref_grid,
+                n_Texp_grid,
+                multi_index_uniqgrid,
+                elower_grid,
+                self.mdb.molmass,
+                qtarr,
+                self.Tref_broadening,
+            )
 
         else:
             raise ValueError("diffmode should be 0, 1, 2.")
 
-    def plot_broadening_parameters(self,
-                                   figname="broadpar_grid.png",
-                                   crit=300000):
+    def plot_broadening_parameters(self, figname="broadpar_grid.png", crit=300000):
         """plot broadening parameters and grids
 
         Args:
             figname (str, optional): output image file. Defaults to "broadpar_grid.png".
             crit (int, optional): sampling criterion. Defaults to 300000. when the number of lines is huge and if it exceeded ~ crit, we sample the lines to reduce the computation.
         """
         from exojax.plot.opaplot import plot_broadening_parameters_grids
+
         _, _, _, ngamma_ref_grid, n_Texp_grid, _, _ = self.opainfo
         gamma_ref_in = self.gamma_ref
         n_Texp_in = self.n_Texp
-        plot_broadening_parameters_grids(ngamma_ref_grid, n_Texp_grid,
-                                         self.nu_grid, self.resolution,
-                                         gamma_ref_in, n_Texp_in, crit,
-                                         figname)
+        plot_broadening_parameters_grids(
+            ngamma_ref_grid,
+            n_Texp_grid,
+            self.nu_grid,
+            self.resolution,
+            gamma_ref_in,
+            n_Texp_in,
+            crit,
+            figname,
+        )
 
 
 class OpaModit(OpaCalc):
     """Opacity Calculator Class for MODIT
 
     Attributes:
         opainfo: information set used in MODIT: cont_nu, index_nu, R, pmarray
 
     """
-    def __init__(self,
-                 mdb,
-                 nu_grid,
-                 Tarr_list=None,
-                 Parr=None,
-                 Pself_ref=None,
-                 dit_grid_resolution=0.2,
-                 allow_32bit=False,
-                 wavelength_order="descending"):
+
+    def __init__(
+        self,
+        mdb,
+        nu_grid,
+        Tarr_list=None,
+        Parr=None,
+        Pself_ref=None,
+        dit_grid_resolution=0.2,
+        allow_32bit=False,
+        wavelength_order="descending",
+    ):
         """initialization of OpaModit
 
         Note:
             Tarr_list and Parr are used to compute xsmatrix. No need for xsvector
 
         Args:
             mdb (mdb class): mdbExomol, mdbHitemp, mdbHitran
             nu_grid (): wavenumber grid (cm-1)
             Tarr_list (1d or 2d array, optional): tempearture array to be tested such as [Tarr_1, Tarr_2, ..., Tarr_n]
             Parr (1d array, optional): pressure array in bar
             Pself_ref (1d array, optional): self pressure array in bar. Defaults to None. If None Pself = 0.0.
             dit_grid_resolution (float, optional): dit grid resolution. Defaxults to 0.2.
             allow_32bit (bool, optional): If True, allow 32bit mode of JAX. Defaults to False.
             wavlength order: wavelength order: "ascending" or "descending"
-            
+
         Raises:
             ValueError: _description_
         """
         super().__init__()
         check_jax64bit(allow_32bit)
 
-        #default setting
+        # default setting
         self.method = "modit"
         self.warning = True
         self.nu_grid = nu_grid
         self.wavelength_order = wavelength_order
-        self.wav = nu2wav(self.nu_grid,
-                          wavelength_order=self.wavelength_order,
-                          unit="AA")
+        self.wav = nu2wav(
+            self.nu_grid, wavelength_order=self.wavelength_order, unit="AA"
+        )
         self.resolution = resolution_eslog(nu_grid)
         self.mdb = mdb
         self.dit_grid_resolution = dit_grid_resolution
         if not self.mdb.gpu_transfer:
             raise ValueError("For MODIT, gpu_transfer should be True in mdb.")
         self.apply_params()
         if Tarr_list is not None and Parr is not None:
             self.setdgm(Tarr_list, Parr, Pself_ref=Pself_ref)
         else:
-            warnings.warn("Tarr_list/Parr are needed for xsmatrix.",
-                          UserWarning)
+            warnings.warn("Tarr_list/Parr are needed for xsmatrix.", UserWarning)
 
     def apply_params(self):
         self.dbtype = self.mdb.dbtype
         self.opainfo = initspec.init_modit(self.mdb.nu_lines, self.nu_grid)
         self.ready = True
 
     def xsvector(self, T, P, Pself=0.0):
@@ -422,47 +531,58 @@
 
         Args:
             T (float): temperature
             P (float): pressure in bar
             Pself (float, optional): self pressure for HITEMP/HITRAN. Defaults to 0.0.
 
         Returns:
-            1D array: cross section in cm2 
+            1D array: cross section in cm2
         """
         from exojax.spec import normalized_doppler_sigma, gamma_natural
         from exojax.spec.hitran import line_strength
         from exojax.spec.exomol import gamma_exomol
         from exojax.spec.hitran import gamma_hitran
         from exojax.spec.set_ditgrid import ditgrid_log_interval
         from exojax.spec.modit_scanfft import xsvector_scanfft
         from exojax.spec import normalized_doppler_sigma
 
         cont_nu, index_nu, R, pmarray = self.opainfo
 
         if self.mdb.dbtype == "hitran":
             qt = self.mdb.qr_interp(self.mdb.isotope, T)
             gammaL = gamma_hitran(
-                P, T, Pself, self.mdb.n_air, self.mdb.gamma_air,
-                self.mdb.gamma_self) + gamma_natural(self.mdb.A)
+                P, T, Pself, self.mdb.n_air, self.mdb.gamma_air, self.mdb.gamma_self
+            ) + gamma_natural(self.mdb.A)
         elif self.mdb.dbtype == "exomol":
             qt = self.mdb.qr_interp(T)
-            gammaL = gamma_exomol(P, T, self.mdb.n_Texp,
-                                  self.mdb.alpha_ref) + gamma_natural(
-                                      self.mdb.A)
+            gammaL = gamma_exomol(
+                P, T, self.mdb.n_Texp, self.mdb.alpha_ref
+            ) + gamma_natural(self.mdb.A)
         dv_lines = self.mdb.nu_lines / R
         ngammaL = gammaL / dv_lines
 
         nsigmaD = normalized_doppler_sigma(T, self.mdb.molmass, R)
-        Sij = line_strength(T, self.mdb.logsij0, self.mdb.nu_lines,
-                            self.mdb.elower, qt)
+        Sij = line_strength(
+            T, self.mdb.logsij0, self.mdb.nu_lines, self.mdb.elower, qt, self.mdb.Tref
+        )
 
         ngammaL_grid = ditgrid_log_interval(
-            ngammaL, dit_grid_resolution=self.dit_grid_resolution)
-        return xsvector_scanfft(cont_nu, index_nu, R, pmarray, nsigmaD,
-                                ngammaL, Sij, self.nu_grid, ngammaL_grid)
+            ngammaL, dit_grid_resolution=self.dit_grid_resolution
+        )
+        return xsvector_scanfft(
+            cont_nu,
+            index_nu,
+            R,
+            pmarray,
+            nsigmaD,
+            ngammaL,
+            Sij,
+            self.nu_grid,
+            ngammaL_grid,
+        )
 
     def setdgm(self, Tarr_list, Parr, Pself_ref=None):
         """_summary_
 
         Args:
             Tarr_list (1d or 2d array): tempearture array to be tested such as [Tarr_1, Tarr_2, ..., Tarr_n]
             Parr (1d array): pressure array in bar
@@ -481,81 +601,93 @@
             Tarr_list = np.array([Tarr_list])
         if Pself_ref is None:
             Pself_ref = np.zeros_like(Parr)
 
         set_dgm_minmax = []
         for Tarr in Tarr_list:
             if self.mdb.dbtype == "exomol":
-                SijM, ngammaLM, nsigmaDl = exomol(self.mdb, Tarr, Parr, R,
-                                                  self.mdb.molmass)
+                SijM, ngammaLM, nsigmaDl = exomol(
+                    self.mdb, Tarr, Parr, R, self.mdb.molmass
+                )
             elif self.mdb.dbtype == "hitran":
-                SijM, ngammaLM, nsigmaDl = hitran(self.mdb, Tarr, Parr,
-                                                  Pself_ref, R,
-                                                  self.mdb.molmass)
+                SijM, ngammaLM, nsigmaDl = hitran(
+                    self.mdb, Tarr, Parr, Pself_ref, R, self.mdb.molmass
+                )
             set_dgm_minmax.append(
-                minmax_ditgrid_matrix(ngammaLM, self.dit_grid_resolution))
+                minmax_ditgrid_matrix(ngammaLM, self.dit_grid_resolution)
+            )
         dgm_ngammaL = precompute_modit_ditgrid_matrix(
-            set_dgm_minmax, dit_grid_resolution=self.dit_grid_resolution)
+            set_dgm_minmax, dit_grid_resolution=self.dit_grid_resolution
+        )
         self.dgm_ngammaL = jnp.array(dgm_ngammaL)
 
     def xsmatrix(self, Tarr, Parr):
         """cross section matrix
 
         Notes:
             Currently Pself is regarded to be zero for HITEMP/HITRAN
 
         Args:
-            Tarr (): tempearture array in K 
+            Tarr (): tempearture array in K
             Parr (): pressure array in bar
 
         Raises:
             ValueError: _description_
 
         Returns:
             jnp.array : cross section matrix (Nlayer, N_wavenumber)
         """
         from exojax.spec.modit_scanfft import xsmatrix_scanfft
         from exojax.spec.modit import exomol
         from exojax.spec.modit import hitran
+
         cont_nu, index_nu, R, pmarray = self.opainfo
 
         if self.mdb.dbtype == "hitran":
-            #qtarr = vmap(self.mdb.qr_interp, (None, 0))(self.mdb.isotope, Tarr)
-            SijM, ngammaLM, nsigmaDl = hitran(self.mdb, Tarr, Parr,
-                                              np.zeros_like(Parr), R,
-                                              self.mdb.molmass)
+            # qtarr = vmap(self.mdb.qr_interp, (None, 0))(self.mdb.isotope, Tarr)
+            SijM, ngammaLM, nsigmaDl = hitran(
+                self.mdb, Tarr, Parr, np.zeros_like(Parr), R, self.mdb.molmass
+            )
         elif self.mdb.dbtype == "exomol":
-            #qtarr = vmap(self.mdb.qr_interp)(Tarr)
-            SijM, ngammaLM, nsigmaDl = exomol(self.mdb, Tarr, Parr, R,
-                                              self.mdb.molmass)
+            # qtarr = vmap(self.mdb.qr_interp)(Tarr)
+            SijM, ngammaLM, nsigmaDl = exomol(self.mdb, Tarr, Parr, R, self.mdb.molmass)
 
-        return xsmatrix_scanfft(cont_nu, index_nu, R, pmarray, nsigmaDl,
-                                ngammaLM, SijM, self.nu_grid, self.dgm_ngammaL)
+        return xsmatrix_scanfft(
+            cont_nu,
+            index_nu,
+            R,
+            pmarray,
+            nsigmaDl,
+            ngammaLM,
+            SijM,
+            self.nu_grid,
+            self.dgm_ngammaL,
+        )
 
 
 class OpaDirect(OpaCalc):
     def __init__(self, mdb, nu_grid, wavelength_order="descending"):
         """initialization of OpaDirect (LPF)
 
-            
+
 
         Args:
             mdb (mdb class): mdbExomol, mdbHitemp, mdbHitran
             nu_grid (): wavenumber grid (cm-1)
         """
         super().__init__()
 
-        #default setting
+        # default setting
         self.method = "lpf"
         self.warning = True
         self.nu_grid = nu_grid
         self.wavelength_order = wavelength_order
-        self.wav = nu2wav(self.nu_grid,
-                          wavelength_order=self.wavelength_order,
-                          unit="AA")
+        self.wav = nu2wav(
+            self.nu_grid, wavelength_order=self.wavelength_order, unit="AA"
+        )
         self.mdb = mdb
         self.apply_params()
 
     def apply_params(self):
         self.dbtype = self.mdb.dbtype
         self.opainfo = initspec.init_lpf(self.mdb.nu_lines, self.nu_grid)
         self.ready = True
@@ -565,48 +697,49 @@
 
         Args:
             T (float): temperature
             P (float): pressure in bar
             Pself (float, optional): self pressure for HITEMP/HITRAN. Defaults to 0.0.
 
         Returns:
-            1D array: cross section in cm2 
+            1D array: cross section in cm2
         """
         from exojax.spec import gamma_natural
         from exojax.spec import doppler_sigma
         from exojax.spec.exomol import gamma_exomol
         from exojax.spec.hitran import gamma_hitran
         from exojax.spec.hitran import line_strength
         from exojax.spec.lpf import xsvector as xsvector_lpf
 
         numatrix = self.opainfo
 
         if self.mdb.dbtype == "hitran":
             qt = self.mdb.qr_interp(self.mdb.isotope, T)
             gammaL = gamma_hitran(
-                P, T, Pself, self.mdb.n_air, self.mdb.gamma_air,
-                self.mdb.gamma_self) + gamma_natural(self.mdb.A)
+                P, T, Pself, self.mdb.n_air, self.mdb.gamma_air, self.mdb.gamma_self
+            ) + gamma_natural(self.mdb.A)
         elif self.mdb.dbtype == "exomol":
             qt = self.mdb.qr_interp(T)
-            gammaL = gamma_exomol(P, T, self.mdb.n_Texp,
-                                  self.mdb.alpha_ref) + gamma_natural(
-                                      self.mdb.A)
+            gammaL = gamma_exomol(
+                P, T, self.mdb.n_Texp, self.mdb.alpha_ref
+            ) + gamma_natural(self.mdb.A)
         sigmaD = doppler_sigma(self.mdb.nu_lines, T, self.mdb.molmass)
-        Sij = line_strength(T, self.mdb.logsij0, self.mdb.nu_lines,
-                            self.mdb.elower, qt)
+        Sij = line_strength(
+            T, self.mdb.logsij0, self.mdb.nu_lines, self.mdb.elower, qt, self.mdb.Tref
+        )
         return xsvector_lpf(numatrix, sigmaD, gammaL, Sij)
 
     def xsmatrix(self, Tarr, Parr):
         """cross section matrix
 
         Notes:
             Currently Pself is regarded to be zero for HITEMP/HITRAN
 
         Args:
-            Tarr (): tempearture array in K 
+            Tarr (): tempearture array in K
             Parr (): pressure array in bar
 
         Raises:
             ValueError: _description_
 
         Returns:
             jnp.array : cross section matrix (Nlayer, N_wavenumber)
@@ -616,52 +749,112 @@
         from exojax.spec.exomol import gamma_exomol
         from exojax.spec.hitran import gamma_hitran
         from exojax.spec.hitran import line_strength
         from exojax.spec.atomll import gamma_vald3
         from exojax.spec.lpf import xsmatrix as xsmatrix_lpf
 
         numatrix = self.opainfo
-        vmaplinestrengh = jit(vmap(line_strength, (0, None, None, None, 0)))
+        vmaplinestrengh = jit(vmap(line_strength, (0, None, None, None, 0, None)))
         if self.mdb.dbtype == "hitran":
             vmapqt = vmap(self.mdb.qr_interp, (None, 0))
             qt = vmapqt(self.mdb.isotope, Tarr)
             vmaphitran = jit(vmap(gamma_hitran, (0, 0, 0, None, None, None)))
-            gammaLM = vmaphitran(Parr, Tarr, np.zeros_like(Parr),
-                                 self.mdb.n_air, self.mdb.gamma_air,
-                                 self.mdb.gamma_self) + gamma_natural(
-                                     self.mdb.A)
-            SijM = vmaplinestrengh(Tarr, self.mdb.logsij0, self.mdb.nu_lines,
-                                   self.mdb.elower, qt)
-            sigmaDM = jit(vmap(doppler_sigma,
-                            (None, 0, None)))(self.mdb.nu_lines, Tarr,
-                                                self.mdb.molmass)
+            gammaLM = vmaphitran(
+                Parr,
+                Tarr,
+                np.zeros_like(Parr),
+                self.mdb.n_air,
+                self.mdb.gamma_air,
+                self.mdb.gamma_self,
+            ) + gamma_natural(self.mdb.A)
+            SijM = vmaplinestrengh(
+                Tarr,
+                self.mdb.logsij0,
+                self.mdb.nu_lines,
+                self.mdb.elower,
+                qt,
+                self.mdb.Tref,
+            )
+            sigmaDM = jit(vmap(doppler_sigma, (None, 0, None)))(
+                self.mdb.nu_lines, Tarr, self.mdb.molmass
+            )
         elif self.mdb.dbtype == "exomol":
             vmapqt = vmap(self.mdb.qr_interp)
             qt = vmapqt(Tarr)
             vmapexomol = jit(vmap(gamma_exomol, (0, 0, None, None)))
-            gammaLMP = vmapexomol(Parr, Tarr, self.mdb.n_Texp,
-                                  self.mdb.alpha_ref)
+            gammaLMP = vmapexomol(Parr, Tarr, self.mdb.n_Texp, self.mdb.alpha_ref)
             gammaLMN = gamma_natural(self.mdb.A)
             gammaLM = gammaLMP + gammaLMN[None, :]
-            SijM = vmaplinestrengh(Tarr, self.mdb.logsij0, self.mdb.nu_lines,
-                                   self.mdb.elower, qt)
-            sigmaDM = jit(vmap(doppler_sigma,
-                            (None, 0, None)))(self.mdb.nu_lines, Tarr,
-                                                self.mdb.molmass)
+            SijM = vmaplinestrengh(
+                Tarr,
+                self.mdb.logsij0,
+                self.mdb.nu_lines,
+                self.mdb.elower,
+                qt,
+                self.mdb.Tref,
+            )
+            sigmaDM = jit(vmap(doppler_sigma, (None, 0, None)))(
+                self.mdb.nu_lines, Tarr, self.mdb.molmass
+            )
         elif (self.mdb.dbtype == "kurucz") or (self.mdb.dbtype == "vald"):
-            qt_284=vmap(self.mdb.QT_interp_284)(Tarr)
+            qt_284 = vmap(self.mdb.QT_interp_284)(Tarr)
             qt_K = jnp.zeros([len(self.mdb.QTmask), len(Tarr)])
             for i, mask in enumerate(self.mdb.QTmask):
-                qt_K = qt_K.at[i].set(qt_284[:,mask]) #e.g., qt_284[:,76] #Fe I
-            qt_K = jnp.array(qt_K)     
-            vmapvald3 = jit(vmap(gamma_vald3,(0,0,0,0,None,None,None,None,None,None,None,None,None,None,None)))
-            PH,PHe,PHH = Parr*self.mdb.vmrH, Parr*self.mdb.vmrHe, Parr*self.mdb.vmrHH 
-            gammaLM = vmapvald3(Tarr, PH, PHH, PHe, self.mdb.ielem, self.mdb.iion, \
-                                self.mdb.dev_nu_lines, self.mdb.elower, self.mdb.eupper, \
-                                self.mdb.atomicmass, self.mdb.ionE, \
-                                self.mdb.gamRad, self.mdb.gamSta, self.mdb.vdWdamp, 1.0)
-            SijM = vmaplinestrengh(Tarr, self.mdb.logsij0, self.mdb.nu_lines, \
-                                    self.mdb.elower, qt_K.T)  
-            sigmaDM = jit(vmap(doppler_sigma,(None,0,None)))\
-                (self.mdb.nu_lines, Tarr, self.mdb.atomicmass)
+                qt_K = qt_K.at[i].set(qt_284[:, mask])  # e.g., qt_284[:,76] #Fe I
+            qt_K = jnp.array(qt_K)
+            vmapvald3 = jit(
+                vmap(
+                    gamma_vald3,
+                    (
+                        0,
+                        0,
+                        0,
+                        0,
+                        None,
+                        None,
+                        None,
+                        None,
+                        None,
+                        None,
+                        None,
+                        None,
+                        None,
+                        None,
+                        None,
+                    ),
+                )
+            )
+            PH, PHe, PHH = (
+                Parr * self.mdb.vmrH,
+                Parr * self.mdb.vmrHe,
+                Parr * self.mdb.vmrHH,
+            )
+            gammaLM = vmapvald3(
+                Tarr,
+                PH,
+                PHH,
+                PHe,
+                self.mdb.ielem,
+                self.mdb.iion,
+                self.mdb.dev_nu_lines,
+                self.mdb.elower,
+                self.mdb.eupper,
+                self.mdb.atomicmass,
+                self.mdb.ionE,
+                self.mdb.gamRad,
+                self.mdb.gamSta,
+                self.mdb.vdWdamp,
+                1.0,
+            )
+            SijM = vmaplinestrengh(
+                Tarr,
+                self.mdb.logsij0,
+                self.mdb.nu_lines,
+                self.mdb.elower,
+                qt_K.T,
+                self.mdb.Tref,
+            )
+            sigmaDM = jit(vmap(doppler_sigma, (None, 0, None)))(
+                self.mdb.nu_lines, Tarr, self.mdb.atomicmass
+            )
 
-        return xsmatrix_lpf(numatrix, sigmaDM, gammaLM, SijM)
+        return xsmatrix_lpf(numatrix, sigmaDM, gammaLM, SijM)
```

## exojax/spec/opachord.py

```diff
@@ -1,44 +1,75 @@
 import jax.numpy as jnp
-import numpy as np
 from jax import jit
 
 
 @jit
+def chord_geometric_matrix_lower(height, radius_lower):
+    """compute chord geometric matrix
+
+    Args:
+        height (1D array): (normalized) height of the layers from top atmosphere, Nlayer
+        radius_lower (1D array): (normalized) radius at the lower boundary from top to bottom (R0), (Nlayer)
+
+    Returns:
+        2D array: chord geometric matrix (Nlayer, Nlayer), lower triangle matrix
+
+    Notes:
+        Our definitions of the radius_lower and height (and radius_top, internally defined) are as follows:
+        n=0,1,...,N-1
+        radius_lower[N-1] = radius_btm (i.e. R0)
+        radius_lower[n-1] = radius_lower[n] + height[n]
+
+    """
+    radius_upper = radius_lower + height
+    fac_left = jnp.sqrt(
+        jnp.tril(radius_upper[None, :] ** 2 - radius_lower[:, None] ** 2)
+    )
+    fac_right = jnp.sqrt(
+        jnp.tril(radius_lower[None, :] ** 2 - radius_lower[:, None] ** 2, k=-1)
+    )
+    raw_matrix = 2.0 * (fac_left - fac_right) / height
+    return raw_matrix
+
+
+@jit
 def chord_geometric_matrix(height, radius_lower):
     """compute chord geometric matrix
 
     Args:
         height (1D array): (normalized) height of the layers from top atmosphere, Nlayer
         radius_lower (1D array): (normalized) radius at the lower boundary from top to bottom (R0), (Nlayer)
 
     Returns:
         2D array: chord geometric matrix (Nlayer, Nlayer), lower triangle matrix
 
     Notes:
         Our definitions of the radius_lower and height (and radius_top, internally defined) are as follows:
         n=0,1,...,N-1
-        radius_lower[N-1] = radius_btm (i.e. R0)    
+        radius_lower[N-1] = radius_btm (i.e. R0)
         radius_lower[n-1] = radius_lower[n] + height[n]
         radius_top = radius_lower[0] + height[0]
-        
+
     """
-    radius_top = radius_lower[0] + height[0]  #radius at TOA
-    radius_shifted = jnp.roll(radius_lower, 1)  # r_{k-1}
-    radius_shifted = radius_shifted.at[0].set(radius_top)
-    fac_right = jnp.sqrt(radius_lower[None, :]**2 - radius_lower[:, None]**2)
-    fac_left = jnp.sqrt(radius_shifted[None, :]**2 - radius_lower[:, None]**2)
-    raw_matrix = 2.0 * (fac_left - fac_right) / height
-    return jnp.tril(raw_matrix)
+    radius_upper = radius_lower + height
+    radius_midpoint = radius_lower + height / 2.0
 
+    fac_left = jnp.tril(radius_upper[None, :] ** 2 - radius_midpoint[:, None] ** 2)
+    fac_right = jnp.tril(
+        radius_lower[None, :] ** 2 - radius_midpoint[:, None] ** 2, k=-1
+    )
+    raw_matrix = 2.0 * (jnp.sqrt(fac_left) - jnp.sqrt(fac_right)) / height
+    return raw_matrix
 
+
+@jit
 def chord_optical_depth(chord_geometric_matrix, dtau):
     """chord optical depth vector from a chord geometric matrix and dtau
-    
+
     Args:
-        chord_geometric_matrix (jnp array): chord geometric matrix (Nlayer, Nlayer), lower triangle matrix 
+        chord_geometric_matrix (jnp array): chord geometric matrix (Nlayer, Nlayer), lower triangle matrix
         dtau (jnp array): layer optical depth matrix, dtau (Nlayer, N_wavenumber)
 
     Returns: chord optical depth (tauchord) matrix (Nlayer, N_wavenumber)
 
     """
     return jnp.dot(chord_geometric_matrix, dtau)
```

## exojax/spec/opacont.py

```diff
@@ -1,46 +1,297 @@
 """opacity continuum calculator class
 
 Notes:
     Opa does not assume any T-P structure, no fixed T, P, mmr grids.
 
 """
-from exojax.utils.grids import nu2wav
+
 from exojax.spec.hitrancia import interp_logacia_vector
 from exojax.spec.hitrancia import interp_logacia_matrix
+from exojax.spec.mie import mie_lognormal_pymiescatt
+from exojax.spec.hminus import log_hminus_continuum
+from exojax.spec.rayleigh import xsvector_rayleigh_gas
+import warnings
+import jax.numpy as jnp
+from jax import vmap
+import numpy as np
+
+__all__ = ["OpaCIA"]
 
-__all__ = ['OpaCIA']
 
+class OpaCont:
+    """Common Opacity Calculator Class"""
 
-class OpaCont():
-    """Common Opacity Calculator Class
-    """
     __slots__ = [
         "opainfo",
     ]
 
     def __init__(self):
         self.method = None  # which opacity cont method is used
         self.ready = False  # ready for opacity computation
 
 
 class OpaCIA(OpaCont):
-    """Opacity Continuum Calculator Class for CIA
+    """Opacity Continuum Calculator Class for CIA"""
 
-    """
-    def __init__(self, cdb, nu_grid, wavelength_order="descending"):
+    def __init__(self, cdb, nu_grid):
+        """initialization of opacity calcluator for CIA
+
+        Args:
+            cdb (_type_): Continuum database
+            nu_grid (_type_): _wavenumber grid
+        """
         self.method = "cia"
         self.warning = True
         self.nu_grid = nu_grid
-        self.wavelength_order = wavelength_order
-        self.wav = nu2wav(self.nu_grid,
-                          wavelength_order=self.wavelength_order,
-                          unit="AA")
         self.cdb = cdb
+        self.ready = True
 
     def logacia_vector(self, T):
-        return interp_logacia_vector(T, self.nu_grid, self.cdb.nucia,
-                                     self.cdb.tcia, self.cdb.logac)
+        return interp_logacia_vector(
+            T, self.nu_grid, self.cdb.nucia, self.cdb.tcia, self.cdb.logac
+        )
+
+    def logacia_matrix(self, temperatures):
+        return interp_logacia_matrix(
+            temperatures, self.nu_grid, self.cdb.nucia, self.cdb.tcia, self.cdb.logac
+        )
+
+
+class OpaHminus(OpaCont):
+    def __init__(self, nu_grid):
+        self.method = "hminus"
+        self.warning = True
+        self.nu_grid = nu_grid
+        self.ready = True
+
+    def logahminus_matrix(self, temperatures, number_density_e, number_density_h):
+        """absorption coefficient (cm-1) matrix of H- continuum
+
+        Args:
+            temperatures (_type_): temperature array
+            number_density_e (_type_): number density of electron in cgs
+            number_density_h (_type_): number density of H in cgs
+
+        Returns:
+            log10(absorption coefficient in cm-1 ) [Nlayer,Nnu]
+
+        """
+        return log_hminus_continuum(
+            self.nu_grid, temperatures, number_density_e, number_density_h
+        )
+
+
+class OpaRayleigh(OpaCont):
+    def __init__(self, nu_grid, molname):
+        """sets opa
+
+        Args:
+            nu_grid (float, array): wavenumber grid
+            molname (str): gas molecule name, such as "N2"
+        """
+        self.method = "rayleigh"
+        self.nu_grid = nu_grid
+        self.molname = molname
+        self.set_auto_polarizability()
+        self.set_auto_king_factor()
+        self.check_ready()
+
+    def set_auto_polarizability(self):
+        from exojax.atm.polarizability import polarizability
+
+        try:
+            self.polarizability = polarizability[self.molname]
+        except:
+            self.polarizability = None
+            warnings.warn(
+                "No polarizability found. Set opa.polarizability by yourself."
+            )
+
+    def set_auto_king_factor(self):
+        from exojax.atm.polarizability import king_correction_factor
+
+        try:
+            self.king_factor = king_correction_factor[self.molname]
+        except:
+            self.king_factor = 1.0
+            warnings.warn(
+                "No king correction factor found. Applied to 1. you can modify by setting opa.king_factor."
+            )
+
+    def check_ready(self):
+        if self.polarizability is None:
+            print("no opa.polarizability. Not ready for OpaRayleigh yet.")
+            self.ready = False
+        else:
+            print("Ready for OpaRayleigh.")
+            self.ready = True
+
+    def xsvector(self):
+        """computes cross section vector of the Rayleigh scattering
+
+        Returns:
+            float, array: Rayleigh scattring cross section vector [Nnus] in cm2
+        """
+        return xsvector_rayleigh_gas(
+            self.nu_grid, self.polarizability, king_factor=self.king_factor
+        )
+
+
+class OpaMie(OpaCont):
+    def __init__(
+        self,
+        pdb,
+        nu_grid,
+    ):
+        self.method = "mie"
+        self.nu_grid = nu_grid
+        self.pdb = pdb
+        self.ready = True
+
+    def mieparams_vector(self, rg, sigmag):
+        """interpolate the Mie parameters vector (Nnu: wavenumber direction) from Miegrid
+
+        Args:
+            rg (float): rg parameter in the lognormal distribution of condensate size, defined by (9) in AM01
+            sigmag (float): sigmag parameter in the lognormal distribution of condensate size, defined by (9) in AM01
+
+        Notes:
+            AM01 = Ackerman and Marley 2001
+            Volume extinction coefficient (1/cm) for the number density N can be computed by beta_extinction = N*beta0_extinction/N0
+
+        Returns:
+            sigma_extinction, extinction cross section (cm2) = volume extinction coefficient (1/cm) normalized by the reference numbver density N0.
+            sigma_scattering, scattering cross section (cm2) = volume extinction coefficient (1/cm) normalized by the reference numbver density N0.
+            asymmetric factor, (mean g)
+        """
+
+        # loads grid (mieparams in cgs)
+        sigexg, sigscg, gg = (
+            self.pdb.mieparams_cgs_at_refraction_index_wavenumber_from_miegrid(
+                rg, sigmag
+            )
+        )
+
+        # interpolation
+        sigma_extinction = jnp.interp(
+            self.nu_grid, self.pdb.refraction_index_wavenumber, sigexg
+        )
+        sigma_scattering = jnp.interp(
+            self.nu_grid, self.pdb.refraction_index_wavenumber, sigscg
+        )
+        asymmetric_factor = jnp.interp(
+            self.nu_grid, self.pdb.refraction_index_wavenumber, gg
+        )
+
+        return sigma_extinction, sigma_scattering, asymmetric_factor
+
+    def mieparams_matrix(self, rg_layer, sigmag_layer):
+        """interpolate the Mie parameters matrix (Nlayer x Nnu) from Miegrid
+        Args:
+            rg_layer (1d array): layer rg parameters  in the lognormal distribution of condensate size, defined by (9) in AM01
+            sigmag_layer (1d array): layer sigmag parameters in the lognormal distribution of condensate size, defined by (9) in AM01
+
+        Notes:
+            AM01 = Ackerman and Marley 2001
+            Volume extinction coefficient (1/cm) for the number density N can be computed by beta_extinction = N*beta0_extinction/N0
+
+        Returns:
+            sigma_extinction matrix, extinction cross section (cm2) = volume extinction coefficient (1/cm) normalized by the reference number density N0
+            omega0  matrix, single scattering albedo
+            g  matrix, asymmetric factor (mean g)
+        """
+
+        f = vmap(self.mieparams_vector, (0, 0), 0)
+        return f(rg_layer, sigmag_layer)
+
+    def mieparams_vector_direct_from_pymiescatt(self, rg, sigmag):
+        """compute the Mie parameters vector (Nnu: wavenumber direction) from pymiescatt direclty (slow), i.e. no need of Miegrid, the unit is in cgs
+
+        Args:
+            rg (float): rg parameter in the lognormal distribution of condensate size, defined by (9) in AM01
+            sigmag (float): sigmag parameter in the lognormal distribution of condensate size, defined by (9) in AM01
+
+        Notes:
+            AM01 = Ackerman and Marley 2001
+            Volume extinction coefficient (1/cm) for the number density N can be computed by beta_extinction = N*beta0_extinction/N0
+
+        Returns:
+            sigma_extinction, extinction cross section (cm2) = volume extinction coefficient (1/cm) normalized by the reference numbver density N0.
+            sigma_scattering, scattering cross section (cm2) = volume extinction coefficient (1/cm) normalized by the reference numbver density N0.
+            asymmetric factor, (mean g)
+        """
+        from exojax.spec.mie import auto_rgrid
+        from tqdm import tqdm
+
+        # restrict wavenumber grid
+        nind = len(self.pdb.refraction_index_wavenumber)
+        numin = np.min(self.nu_grid)
+        imin = np.searchsorted(self.pdb.refraction_index_wavenumber, numin)
+        imin = np.max([imin - 1, 0])
+        numax = np.max(self.nu_grid)
+        imax = np.searchsorted(self.pdb.refraction_index_wavenumber, numax)
+        imax = np.min([imax + 1, nind])
+
+        refraction_index_wavenumber_restricted = self.pdb.refraction_index_wavenumber[
+            imin:imax
+        ]
+        nind = len(refraction_index_wavenumber_restricted)
+        refraction_index_restricted = self.pdb.refraction_index[imin:imax]
+
+        # generates grid
+        convfactor_to_cgs = (
+            1.0e-8 / self.pdb.N0
+        )  # conversion to cgs(1/Mega meter to 1/cm)
+
+        sigexg = np.zeros(nind)
+        sigscg = np.zeros(nind)
+        gg = np.zeros(nind)
+
+        cm2nm = 1.0e7
+        rg_nm = rg * cm2nm
+        rgrid = auto_rgrid(rg_nm, sigmag)
+        for ind_m, m in enumerate(tqdm(refraction_index_restricted)):
+            coeff = mie_lognormal_pymiescatt(
+                m,
+                refraction_index_wavenumber_restricted[ind_m],
+                sigmag,
+                rg_nm,
+                self.pdb.N0,
+                rgrid,
+            )
+
+            sigexg[ind_m] = coeff[0] * convfactor_to_cgs
+            sigscg[ind_m] = coeff[1] * convfactor_to_cgs
+            gg[ind_m] = coeff[3]
+
+        # interpolation
+        sigma_extinction = np.interp(
+            self.nu_grid, refraction_index_wavenumber_restricted, sigexg
+        )
+        sigma_scattering = np.interp(
+            self.nu_grid, refraction_index_wavenumber_restricted, sigscg
+        )
+        asymmetric_factor = np.interp(
+            self.nu_grid, refraction_index_wavenumber_restricted, gg
+        )
+
+        return sigma_extinction, sigma_scattering, asymmetric_factor
+
+    def mieparams_matrix_direct_from_pymiescatt(self, rg_layer, sigmag_layer):
+        """compute the Mie parameters matrix (Nlayer x Nnu) from pymiescatt direclty (slow), i.e. no need of Miegrid
+        Args:
+            rg_layer (1d array): layer rg parameters  in the lognormal distribution of condensate size, defined by (9) in AM01
+            sigmag_layer (1d array): layer sigmag parameters in the lognormal distribution of condensate size, defined by (9) in AM01
+
+        Notes:
+            AM01 = Ackerman and Marley 2001
+            Volume extinction coefficient (1/cm) for the number density N can be computed by beta_extinction = N*beta0_extinction/N0
+
+        Returns:
+            sigma_extinction matrix, extinction cross section (cm2) = volume extinction coefficient (1/cm) normalized by the reference number density N0
+            omega0  matrix, single scattering albedo
+            g  matrix, asymmetric factor (mean g)
+        """
 
-    def logacia_matrix(self, temperature):
-        return interp_logacia_matrix(temperature, self.nu_grid, self.cdb.nucia,
-                                     self.cdb.tcia, self.cdb.logac)
+        f = vmap(self.mieparams_vector_direct_from_pymiescatt, (0, 0), 0)
+        return f(rg_layer, sigmag_layer)
```

## exojax/spec/optgrid.py

```diff
@@ -3,87 +3,136 @@
 from exojax.spec.opacalc import OpaPremodit
 from exojax.utils.constants import Tref_original
 from exojax.spec import normalized_doppler_sigma
 from exojax.utils.constants import Tref_original
 from tqdm import tqdm
 
 
-def optelower(mdb,
-              nu_grid,
-              Tmax,
-              Pmin,
-              accuracy=0.01,
-              dE=100.0,
-              display=False):
-    """look for the value of the optimal maximum Elower 
+def optelower(
+    mdb, nu_grid, Tmax, Pmin, accuracy=0.01, dE=100.0, isotope=1, display=False
+):
+    """look for the value of the optimal maximum Elower
 
     Note:
-        The memory use of PreModit depends on the maximum Elower of mdb. 
-        This function determine the optimal maximum Elower that does not change 
-        the cross section within the accuracy. 
+        The memory use of PreModit depends on the maximum Elower of mdb.
+        This function determine the optimal maximum Elower that does not change
+        the cross section within the accuracy.
 
     Args:
         mdb (mdb): molecular db
         nu_grid (array): wavenumber array cm-1
         Tmax (float): maximum temperature in your use (K)
         Pmin (float): minimum temperature in your use (bar)
         accuracy (float, optional): accuracy allowed. Defaults to 0.01.
         dE (float, optional): E grid to search for the optimal Elower. Defaults to 100.0.
+        isotope: isotope number for HITRAN/HITEMP default to 1
         display (bool, optional): if you want to compare the cross section using Eopt w/ ground truth, set True. Defaults to False.
 
     Returns:
-        float: optimal maximum Elower (Eopt) in cm-1 
+        float: optimal maximum Elower (Eopt) in cm-1
     """
-    from jax.config import config
+    from jax import config
+
     config.update("jax_enable_x64", True)
-    print("Maximum Elower = ",np.max(mdb.elower))
 
-    #for single temperature, 0-th order is sufficient
+    if isotope == 0 or isotope is None:
+        raise ValueError("all isotope mode is not supported in optgrid.")
+    print("Maximum Elower = ", np.max(mdb.elower))
+
+    # for single temperature, 0-th order is sufficient
     opa = OpaPremodit(mdb=mdb, nu_grid=nu_grid, diffmode=0)
     opa.manual_setting(dE, Tref_original, Tmax)
-    lbd_coeff, multi_index_uniqgrid, elower_grid, \
-        ngamma_ref_grid, n_Texp_grid, R, pmarray = opa.opainfo
+    (
+        lbd_coeff,
+        multi_index_uniqgrid,
+        elower_grid,
+        ngamma_ref_grid,
+        n_Texp_grid,
+        R,
+        pmarray,
+    ) = opa.opainfo
     nsigmaD = normalized_doppler_sigma(Tmax, mdb.molmass, R)
-    qt = mdb.qr_interp(Tmax)
+    if mdb.dbtype == "exomol":
+        qt = mdb.qr_interp(Tmax)
+    elif mdb.dbtype == "hitran":
+        qt = mdb.qr_interp(isotope, Tmax)
 
     Tref_broadening = Tref_original
-    xsv_master = xsvector_zeroth(Tmax, Pmin, nsigmaD, lbd_coeff, Tref_original,
-                                 R, pmarray, opa.nu_grid, elower_grid,
-                                 multi_index_uniqgrid, ngamma_ref_grid,
-                                 n_Texp_grid, qt, Tref_broadening)
+    xsv_master = xsvector_zeroth(
+        Tmax,
+        Pmin,
+        nsigmaD,
+        lbd_coeff,
+        Tref_original,
+        R,
+        pmarray,
+        opa.nu_grid,
+        elower_grid,
+        multi_index_uniqgrid,
+        ngamma_ref_grid,
+        n_Texp_grid,
+        qt,
+        Tref_broadening,
+    )
     allow = True
     q = -1
     pbar = tqdm(total=len(elower_grid), desc="opt Emax")
     while allow:
-        xsv = xsvector_zeroth(Tmax, Pmin, nsigmaD, lbd_coeff[:, :, :, :q],
-                              Tref_original, R, pmarray, opa.nu_grid,
-                              elower_grid[:q], multi_index_uniqgrid,
-                              ngamma_ref_grid, n_Texp_grid, qt, Tref_broadening)
+        xsv = xsvector_zeroth(
+            Tmax,
+            Pmin,
+            nsigmaD,
+            lbd_coeff[:, :, :, :q],
+            Tref_original,
+            R,
+            pmarray,
+            opa.nu_grid,
+            elower_grid[:q],
+            multi_index_uniqgrid,
+            ngamma_ref_grid,
+            n_Texp_grid,
+            qt,
+            Tref_broadening,
+        )
         maxdelta = np.max(np.abs(xsv / xsv_master - 1.0))
         if maxdelta > accuracy:
             allow = False
             q = q + 1
         else:
             q = q - 1
         pbar.update(1)
     pbar.close()
     if q == 0:
         return np.max(mdb.elower)
     if display:
-        xsv = xsvector_zeroth(Tmax, Pmin, nsigmaD, lbd_coeff[:, :, :, :q],
-                              Tref_original, R, pmarray, opa.nu_grid,
-                              elower_grid[:q], multi_index_uniqgrid,
-                              ngamma_ref_grid, n_Texp_grid, qt, Tref_broadening)
+        xsv = xsvector_zeroth(
+            Tmax,
+            Pmin,
+            nsigmaD,
+            lbd_coeff[:, :, :, :q],
+            Tref_original,
+            R,
+            pmarray,
+            opa.nu_grid,
+            elower_grid[:q],
+            multi_index_uniqgrid,
+            ngamma_ref_grid,
+            n_Texp_grid,
+            qt,
+            Tref_broadening,
+        )
         _plot_comparison(nu_grid, xsv_master, xsv)
     Emax = elower_grid[:q][-1]
+    print("Found the optimal maximum elower:",Emax,"cm-1")
     return Emax
 
 
 def _plot_comparison(nu_grid, xsv_master, xsv):
     import matplotlib.pyplot as plt
+
     fig = plt.figure()
     ax = fig.add_subplot(211)
     plt.plot(nu_grid, xsv_master)
     plt.plot(nu_grid, xsv)
     plt.yscale("log")
     ax = fig.add_subplot(212)
     plt.plot(nu_grid, xsv / xsv_master - 1.0)
```

## exojax/spec/premodit.py

```diff
@@ -1,14 +1,15 @@
 """Line profile computation using PremoDIT = Precomputation of LSD version of MODIT
 
 """
 import numpy as np
 import jax.numpy as jnp
 from jax import jit, vmap
-from exojax.spec.lsd import npgetix, npadd3D_multi_index, npadd3D_direct1D
+from exojax.utils.indexing import npgetix
+from exojax.spec.lsd import npadd3D_multi_index, npadd3D_direct1D
 from exojax.utils.constants import hcperk
 from exojax.utils.constants import Tref_original
 from exojax.spec.modit_scanfft import calc_xsection_from_lsd_scanfft
 from exojax.spec.set_ditgrid import ditgrid_log_interval, ditgrid_linear_interval
 from exojax.utils.indexing import uniqidx_neibouring
 from exojax.spec import normalized_doppler_sigma
 from exojax.spec.lbd import lbd_coefficients
```

## exojax/spec/qstate.py

```diff
@@ -1,7 +1,11 @@
+"""Quantum States Module
+
+"""
+
 def m_transition_state(jlower, branch):
     """compute m-value of the transition from rotational state
 
     Args:
         jlower (int): lower rotational quantum state
         branch (int): jupper - jlower
```

## exojax/spec/response.py

```diff
@@ -1,55 +1,102 @@
-"""response.
+"""Response
 
 * input nus/wav should be spaced evenly on a log scale (ESLOG).
 * response is a response operation for the wavenumber grid spaced evenly on a log scale.
-* ipgauss2 are faster than default when N >~ 10000, where N is the dimension of the wavenumber grid.
+
 """
 from jax import jit
 import jax.numpy as jnp
 from jax.lax import scan
 from exojax.utils.constants import c
 from exojax.signal.convolve import convolve_same
+from exojax.signal.ola import olaconv, ola_lengths, generate_zeropad
+
+
+@jit
+def ipgauss_ola_sampling(nusd, nus, folded_spectrum, beta, RV, varr_kernel):
+    """Apply the Gaussian IP response using OLA + sampling to a spectrum F.
+    
+    
+    Args:
+        nusd: sampling wavenumber
+        nus: input wavenumber, evenly log-spaced
+        folded_spectrum: original spectrum (F0) folded to (ndiv, div_length) form
+        beta: STD of a Gaussian broadening (IP+microturbulence)
+        RV: radial velocity (km/s)
+        varr_kernel: velocity array for the rotational kernel
+        
+    Return:
+        response-applied spectrum (F)
+    """
+    Fgauss = ipgauss_ola(folded_spectrum, varr_kernel, beta)
+    return sampling(nusd, nus, Fgauss, RV)
+
+@jit
+def ipgauss_ola(folded_spectrum, varr_kernel, beta):
+    """Apply the Gaussian IP response to a spectrum F using OLA.
+
+    Args:
+        folded_spectrum: original spectrum (F0) folded to (ndiv, div_length) form
+        varr_kernel: velocity array for the rotational kernel
+        beta: STD of a Gaussian broadening (IP+microturbulence)
+
+    Return:
+        response-applied spectrum (F)
+    """
+    x = varr_kernel / beta
+    kernel = jnp.exp(-x * x / 2.0)
+    kernel = kernel / jnp.sum(kernel, axis=0)
+    
+    ndiv, div_length, filter_length = ola_lengths(folded_spectrum, kernel)
+    F0_hat, kernel_hat = generate_zeropad(folded_spectrum, kernel)
+    ola = olaconv(F0_hat, kernel_hat, ndiv, div_length, filter_length)
+    
+    edge = int((len(kernel) - 1) / 2)
+    F = ola[edge:-edge]
+    
+    return F
+
 
 @jit
-def ipgauss_sampling(nusd, nus, F0, beta, RV, varr_kernel):
+def ipgauss_sampling(nusd, nus, spectrum, beta, RV, varr_kernel):
     """Apply the Gaussian IP response + sampling to a spectrum F.
     
     
     Args:
         nusd: sampling wavenumber
         nus: input wavenumber, evenly log-spaced
-        F0: original spectrum (F0)
+        spectrum: original spectrum (F0)
         beta: STD of a Gaussian broadening (IP+microturbulence)
         RV: radial velocity (km/s)
         varr_kernel: velocity array for the rotational kernel
         
     Return:
         response-applied spectrum (F)
     """
-    Fgauss = ipgauss(F0, varr_kernel, beta)
+    Fgauss = ipgauss(spectrum, varr_kernel, beta)
     return sampling(nusd, nus, Fgauss, RV)
 
 @jit
-def ipgauss(F0, varr_kernel, beta):
+def ipgauss(spectrum, varr_kernel, beta):
     """Apply the Gaussian IP response to a spectrum F.
 
     Args:
-        F0: original spectrum (F0)
+        spectrum: original spectrum (F0)
         varr_kernel: velocity array for the rotational kernel
         beta: STD of a Gaussian broadening (IP+microturbulence)
 
     Return:
         response-applied spectrum (F)
     """
     x = varr_kernel / beta
     kernel = jnp.exp(-x * x / 2.0)
     kernel = kernel / jnp.sum(kernel, axis=0)
     #F = jnp.convolve(F0, kernel, mode='same')
-    F = convolve_same(F0, kernel)
+    F = convolve_same(spectrum, kernel)
 
     return F
 
 @jit
 def sampling(nusd, nus, F, RV):
     """Sampling w/ RV.
 
@@ -62,33 +109,33 @@
     Returns:
        sampled spectrum
     """
     return jnp.interp(nusd * (1.0 + RV / c), nus, F)
 
 
 @jit
-def ipgauss_variable_sampling(nusd, nus, F0, beta_variable, RV):
+def ipgauss_variable_sampling(nusd, nus, spectrum, beta_variable, RV):
     """Apply the variable Gaussian IP response + sampling to a spectrum F.
 
     Notes:
         STD is a function of nusd
 
     Args:
         nusd: sampling wavenumber
         nus: input wavenumber, evenly log-spaced
-        F0: original spectrum (F0)
+        spectrum: original spectrum (F0)
         beta_variable (1D array): STD of a Gaussian broadening, shape=(len(nusd),)
         RV: radial velocity (km/s)
     Return:
         response-applied spectrum (F)
     """
     def convolve_ipgauss_scan(carry, arr):
         nusd_each = arr[0]
         beta_each = arr[1]
         dvgrid = c * (jnp.log1p(1.0 - nus / nusd_each))
         kernel = jnp.exp(-(dvgrid + RV)**2 / (2.0 * beta_each**2))
         kernel = kernel / jnp.sum(kernel)
-        return carry, kernel @ F0
+        return carry, kernel @ spectrum
     
     mat = jnp.vstack([nusd, beta_variable]).T
     _, F_convolved = scan(convolve_ipgauss_scan, 0, mat)
     return F_convolved
```

## exojax/spec/rtransfer.py

```diff
@@ -1,162 +1,523 @@
-""" radiative transfer
-"""
-from jax import jit
-import jax.numpy as jnp
-from exojax.special.expn import E1
-import warnings
-from exojax.spec.layeropacity import layer_optical_depth
-from exojax.spec.layeropacity import layer_optical_depth_CIA
-from exojax.spec.layeropacity import layer_optical_depth_Hminus
-from exojax.spec.layeropacity import layer_optical_depth_VALD
-
-##################################################################################
-# deprecated features, will be removed by Release v2.0
-##################################################################################
-
-
-def dtauM(dParr, xsm, MR, mass, g):
-    warn_msg = "Use `spec.layeropacity.layer_optical_depth` instead"
-    warnings.warn(warn_msg, FutureWarning)
-    return layer_optical_depth(dParr, xsm, MR, mass, g)
-
-
-def dtauCIA(nus, Tarr, Parr, dParr, vmr1, vmr2, mmw, g, nucia, tcia, logac):
-    warn_msg = "Use `spec.layeropacity.layer_optical_depth_CIA` instead"
-    warnings.warn(warn_msg, FutureWarning)
-    return layer_optical_depth_CIA(nus, Tarr, Parr, dParr, vmr1, vmr2, mmw, g,
-                                   nucia, tcia, logac)
-
-
-def dtauHminus(nus, Tarr, Parr, dParr, vmre, vmrh, mmw, g):
-    warn_msg = "Use `spec.layeropacity.layer_optical_depth_Hminus` instead"
-    warnings.warn(warn_msg, FutureWarning)
-    return layer_optical_depth_Hminus(nus, Tarr, Parr, dParr, vmre, vmrh, mmw,
-                                      g)
-
-
-def dtauVALD(dParr, xsm, VMR, mmw, g):
-    warn_msg = "Use `spec.layeropacity.layer_optical_depth_VALD` instead"
-    warnings.warn(warn_msg, FutureWarning)
-    return layer_optical_depth_VALD(dParr, xsm, VMR, mmw, g)
-
-
-def pressure_layer(log_pressure_top=-8.,
-                   log_pressure_btm=2.,
-                   NP=20,
-                   mode='ascending',
-                   reference_point=0.5,
-                   numpy=False):
-    warn_msg = "Use `atm.atmprof.pressure_layer_logspace` instead"
-    warnings.warn(warn_msg, FutureWarning)
-    from exojax.atm.atmprof import pressure_layer_logspace
-    return pressure_layer_logspace(log_pressure_top, log_pressure_btm, NP,
-                                   mode, reference_point, numpy)
+""" Runs radiative transfer
 
+    The classification of rtrun(s):
 
-def rtrun(dtau, S):
-    warnings.warn("Use rtrun_emis_pure_absorption instead", FutureWarning)
-    return rtrun_emis_pure_absorption(dtau, S)
+    - flux-based emission
+    -- pure absoprtion 
+    --- 2stream: rtrun_emis_pureabs_flux2st, rtrun_emis_pureabs_flux2st_surface
+    -- scattering
+    --- 2stream
+    ---- LART: rtrun_emis_scat_lart_toonhm
+    ---- flux-adding: rtrun_emis_scat_fluxadding_toonhm
+    -- relfection
+    --- 2stream
+    ---- flux-adding: rtrun_reflect_fluxadding_toonhm
+
+    - intensity-based emission
+    -- pure absorption 
+    --- isothermal: rtrun_emis_pureabs_ibased
+    --- linear source approximation: rtrun_emis_pureabs_ibased_linsap
+
+    - transmision: 
+    -- trapezoid integration: rtrun_trans_pureabs_trapezoid
+    -- simpson integration: rtrun_trans_pureabs_simpson
 
+"""
 
-##########################################################################################
+from jax import jit
+import jax.numpy as jnp
+from jax.lax import scan
+from exojax.spec.twostream import solve_lart_twostream
+from exojax.spec.twostream import solve_fluxadding_twostream
+from exojax.spec.toon import reduced_source_function_isothermal_layer
+from exojax.spec.toon import params_hemispheric_mean
+from exojax.spec.toon import zetalambda_coeffs
+from exojax.spec.twostream import compute_tridiag_diagonals_and_vector
+from exojax.spec.twostream import set_scat_trans_coeffs
+from exojax.special.expn import E1
+from exojax.signal.integrate import simpson
+from jax.scipy.integrate import trapezoid
 
 
 @jit
 def trans2E3(x):
     """transmission function 2E3 (two-stream approximation with no scattering)
     expressed by 2 E3(x)
 
     Note:
-       The exponetial integral of the third order E3(x) is computed using Abramowitz Stegun (1970) approximation of E1 (exojax.special.E1).
+        The exponetial integral of the third order E3(x) is computed using Abramowitz Stegun (1970) approximation of E1 (exojax.special.E1).
 
     Args:
-       x: input variable
+        x: input variable
 
     Returns:
-       Transmission function T=2 E3(x)
+        Transmission function T=2 E3(x)
     """
     return (1.0 - x) * jnp.exp(-x) + x**2 * E1(x)
 
 
 @jit
-def rtrun_emis_pure_absorption(dtau, source_matrix):
-    """Radiative Transfer using two-stream approximaion + 2E3 (Helios-R1 type)
-
+def rtrun_emis_pureabs_fbased2st(dtau, source_matrix):
+    """Radiative Transfer for emission spectrum using flux-based two-stream pure absorption with no surface
     Args:
         dtau (2D array): optical depth matrix, dtau  (N_layer, N_nus)
         source_matrix (2D array): source matrix (N_layer, N_nus)
 
     Returns:
         flux in the unit of [erg/cm2/s/cm-1] if using piBarr as a source function.
     """
     Nnus = jnp.shape(dtau)[1]
     TransM = jnp.where(dtau == 0, 1.0, trans2E3(dtau))
     Qv = jnp.vstack([(1 - TransM) * source_matrix, jnp.zeros(Nnus)])
-    return jnp.sum(Qv *
-                   jnp.cumprod(jnp.vstack([jnp.ones(Nnus), TransM]), axis=0),
-                   axis=0)
+    return jnp.nansum(
+        Qv * jnp.cumprod(jnp.vstack([jnp.ones(Nnus), TransM]), axis=0), axis=0
+    )
 
 
 @jit
-def rtrun_emis_pure_absorption_surface(dtau, source_matrix, source_surface):
-    """Radiative Transfer using two-stream approximaion + 2E3 (Helios-R1 type)
-    with a planetary surface.
+def rtrun_emis_pureabs_fbased2st_surface(dtau, source_matrix, source_surface):
+    """Radiative Transfer for emission spectrum using flux-based two-stream pure absorption with a planetary surface.
 
     Args:
         dtau (2D array): optical depth matrix, dtau  (N_layer, N_nus)
         source_matrix (2D array): source matrix (N_layer, N_nus)
         source_surface: source from the surface [N_nus]
 
     Returns:
         flux in the unit of [erg/cm2/s/cm-1] if using piBarr as a source function.
     """
     Nnus = jnp.shape(dtau)[1]
-    TransM = jnp.where(dtau == 0, 1.0, trans2E3(dtau))
-    Qv = jnp.vstack([(1 - TransM) * source_matrix, source_surface])
-    return jnp.sum(Qv *
-                   jnp.cumprod(jnp.vstack([jnp.ones(Nnus), TransM]), axis=0),
-                   axis=0)
+    trans = jnp.where(dtau == 0, 1.0, trans2E3(dtau))
+    Qv = jnp.vstack([(1 - trans) * source_matrix, source_surface])
+    return jnp.nansum(
+        Qv * jnp.cumprod(jnp.vstack([jnp.ones(Nnus), trans]), axis=0), axis=0
+    )
 
 
 @jit
-def rtrun_emis_pure_absorption_direct(dtau, source_matrix):
-    """Radiative Transfer using direct integration.
+def rtrun_emis_pureabs_ibased(dtau, source_matrix, mus, weights):
+    """Radiative Transfer for emission spectrum using intensity-based n-stream pure absorption with no surface (NEMESIS, pRT-like)
+    Args:
+        dtau (2D array): optical depth matrix, dtau  (N_layer, N_nus)
+        source_matrix (2D array): source matrix (N_layer, N_nus)
+        mus (list): mu (cos theta) list for integration
+        weights (list): weight list for mu
 
-    Note:
-        Use dtau/mu instead of dtau when you want to use non-unity, where mu=cos(theta)
+    Returns:
+        flux in the unit of [erg/cm2/s/cm-1] if using piBarr as a source function.
+    """
+
+    Nnus = jnp.shape(dtau)[1]
+    tau = jnp.cumsum(dtau, axis=0)
+
+    # The following scan part is equivalent to this for-loop
+    # spec = jnp.zeros(Nnus)
+    # for i, mu in enumerate(mus):
+    #    dtrans = - jnp.diff(jnp.exp(-tau/mu), prepend=1.0, axis=0)
+    #    spec = spec + weights[i]*2.0*mu*jnp.sum(source_matrix*dtrans, axis=0)
+
+    # scan part
+    muws = [mus, weights]
+
+    def f(carry_fmu, muw):
+        mu, w = muw
+        dtrans = -jnp.diff(jnp.exp(-tau / mu), prepend=1.0, axis=0)
+        carry_fmu = carry_fmu + 2.0 * mu * w * jnp.sum(source_matrix * dtrans, axis=0)
+        return carry_fmu, None
+
+    spec, _ = scan(f, jnp.zeros(Nnus), muws)
+
+    return spec
+
+
+def initialize_gaussian_quadrature(nstream):
+    """Initialization of Gaussian Quadrature
+
+    Args:
+        nstream (int): the number of the stream
+
+    Raises:
+        ValueError: odd nstream error
+
+    Returns:
+        array, array: cosine angle array (mu), weight array
+    """
+    from scipy.special import roots_legendre
+
+    if nstream % 2 == 0:
+        norder = int(nstream / 2)
+    else:
+        raise ValueError("nstream should be even number larger than 2.")
+    mus, weights = roots_legendre(norder)
+
+    # correction because integration should be between 0 to 1, but roots_legendre uses -1 to 1.
+    mus = 0.5 * (mus + 1.0)
+    weights = 0.5 * weights
+    return mus, weights
+
+
+@jit
+def rtrun_emis_pureabs_ibased_linsap(dtau, source_matrix_boundary, mus, weights):
+    """Radiative Transfer for emission spectrum using intensity-based n-stream pure absorption with no surface w/ linear source approximation = linsap (HELIOS-R2 like)
 
     Args:
         dtau (2D array): optical depth matrix, dtau  (N_layer, N_nus)
-        source_matrix (2D array): source matrix (N_layer, N_nus)
+        source_matrix_booundary (2D array): source matrix at the layer upper boundary (N_layer + 1, N_nus)
+        mus (list): mu (cos theta) list for integration
+        weights (list): weight list for mu
 
     Returns:
         flux in the unit of [erg/cm2/s/cm-1] if using piBarr as a source function.
+
+    Notes:
+        See Olson and Kunasz as well as HELIOS-R2 paper (Kitzmann+) for the derivation.
+
+
     """
-    taupmu = jnp.cumsum(dtau, axis=0)
-    return jnp.sum(source_matrix * jnp.exp(-taupmu) * dtau, axis=0)
 
+    Nnus = jnp.shape(dtau)[1]
+    source_matrix_boundary_p1 = jnp.roll(source_matrix_boundary, -1, axis=0)  # S_{n+1}
+
+    # NOT IMPLEMENTED YET
+    # need to replace the last element of the above
+    #
+
+    # scan part
+    muws = [mus, weights]
+
+    def f(carry_fmu, muw):
+        mu, w = muw
+        dtau_per_mu = dtau / mu
+        trans = jnp.exp(-dtau_per_mu)  # hat{T}
+        beta, gamma = coeffs_linsap(dtau_per_mu, trans)
+
+        # adds coeffs at the bottom of the layers
+        beta = jnp.vstack([beta, jnp.ones(Nnus)])
+        gamma = jnp.vstack([gamma, jnp.zeros(Nnus)])
+
+        dI = beta * source_matrix_boundary + gamma * source_matrix_boundary_p1
+        intensity_for_mu = jnp.sum(
+            dI * jnp.cumprod(jnp.vstack([jnp.ones(Nnus), trans]), axis=0), axis=0
+        )
 
-def rtrun_trans_pure_absorption(dtau_chord, radius_lower):
-    """Radiative transfer assuming pure absorption 
+        carry_fmu = carry_fmu + 2.0 * mu * w * intensity_for_mu
+
+        return carry_fmu, None
+
+    spec, _ = scan(f, jnp.zeros(Nnus), muws)
+    return spec
+
+
+def coeffs_linsap(dtau_per_mu, trans):
+    """coefficients of the linsap
 
     Args:
-        dtau_chord (2D array): chord opacity (Nlayer, N_wavenumber)
-        radius_lower (1D array): (normalized) radius at the lower boundary, underline(r) (Nlayer). 
+        dtau_per_mu (_type_): opacity difference divided by mu (cos theta)
+        trans: transmission of the layers
+    Returns:
+        _type_: beta coefficient, gamma coefficient
+    """
+    fac = (1.0 - trans) / dtau_per_mu
+    beta = 1.0 - fac
+    gamma = -trans + fac
+    return beta, gamma
+
+
+@jit
+def rtrun_trans_pureabs_trapezoid(dtau_chord, radius_lower, radius_top):
+    """Radiative transfer for transmission spectrum assuming pure absorption with the trapezoid integration (jax.scipy.integrate.trapezoid)
+
+    Args:
+        dtau_chord (2D array): chord optical depth (Nlayer, N_wavenumber)
+        radius_lower (1D array): (normalized) radius at the lower boundary, underline(r) (Nlayer). R0 = radius_lower[-1] corresponds to the most bottom of the layers.
+        radius_top (float): (normalized) radius at the ToA, i.e. the radius at the most top of the layers
+
+    Returns:
+        1D array: transit squared radius normalized by radius_lower[-1], i.e. it returns (radius/radius_lower[-1])**2
 
     Notes:
-        The n-th radius is defined as the lower boundary of the n-th layer. So, radius[0] corresponds to R0.   
-        
+        This function gives the sqaure of the transit radius.
+        If you would like to obtain the transit radius, take sqaure root of the output.
+        If you would like to compute the transit depth, devide the output by the square of stellar radius
+
+    Notes:
+        We need the edge correction because the trapezoid integration with radius_lower lacks the edge point integration.
+        i.e. the integration of the 0-th layer from radius_lower[0] to radius_top.
+        We assume tau = 0 at the radius_top. then, the edge correction should be (1-T_0)*(delta r_0), but usually negligible though.
+
+    """
+    dr = radius_top - radius_lower[0]
+    edge_cor = (1.0 - jnp.exp(-dtau_chord[0, :])) * radius_top * dr
+
+    # the negative sign is because the radius_lower is in a descending order
+    deltaRp2 = (
+        -2.0
+        * trapezoid(
+            (1.0 - jnp.exp(-dtau_chord)) * radius_lower[:, None], x=radius_lower, axis=0
+        )
+        + edge_cor
+    )
+    return deltaRp2 + radius_lower[-1] ** 2
+
+
+@jit
+def rtrun_trans_pureabs_simpson(
+    dtau_chord_modpoint, dtau_chord_lower, radius_lower, height
+):
+    """Radiative transfer for transmission spectrum assuming pure absorption with the Simpson integration (signals.integration.simpson)
+
+    Args:
+        dtau_chord_midpoint (2D array): chord opatical depth at the midpoint (Nlayer, N_wavenumber)
+        dtau_chord_lower (2D array): chord opatical depth at the lower boundary (Nlayer, N_wavenumber)
+        radius_lower (1D array): (normalized) radius at the lower boundary, underline(r) (Nlayer). R0 = radius_lower[-1] corresponds to the most bottom of the layers.
+        height (1D array): (normalized) height of the layers
+
     Returns:
         1D array: transit squared radius normalized by radius_lower[-1], i.e. it returns (radius/radius_lower[-1])**2
 
     Notes:
         This function gives the sqaure of the transit radius.
         If you would like to obtain the transit radius, take sqaure root of the output.
         If you would like to compute the transit depth, devide the output by the square of stellar radius
 
+    Notes:
+        We need the edge correction because the trapezoid integration with radius_lower lacks the edge point integration.
+        i.e. the integration of the 0-th layer from radius_lower[0] to radius_top.
+        We assume tau = 0 at the radius_top. then, the edge correction should be (1-T_0)*(delta r_0), but usually negligible though.
+
+    """
+    radius_midpoint = radius_lower + 0.5 * height
+    _, Nnus = jnp.shape(dtau_chord_modpoint)
+    f = 2.0 * (1.0 - jnp.exp(-dtau_chord_modpoint)) * radius_midpoint[:, None]
+    f_lower = 2.0 * (1.0 - jnp.exp(-dtau_chord_lower)) * radius_lower[:, None]
+    f_top = jnp.zeros(Nnus)
+    deltaRp2 = simpson(f, f_lower, f_top, height)
+    return deltaRp2 + radius_lower[-1] ** 2
+
+
+@jit
+def rtrun_emis_scat_lart_toonhm(
+    dtau, single_scattering_albedo, asymmetric_parameter, source_matrix
+):
+    """Radiative Transfer for emission spectrum using flux-based two-stream scattering LART solver w/ Toon Hemispheric Mean with no surface.
+
+    Args:
+        dtau (_type_): _description_
+        single_scattering_albedo (_type_): _description_
+        asymmetric_parameter (_type_): _description_
+        source_matrix (_type_): _description_
+
+    Returns:
+        _type_: _description_
+    """
+    trans_coeff, scat_coeff, reduced_piB, zeta_plus, zeta_minus, lambdan = setrt_toonhm(
+        dtau, single_scattering_albedo, asymmetric_parameter, source_matrix
+    )
+
+    # avoids zero
+    epsilon = 1.0e-8
+    scat_coeff = scat_coeff + epsilon
+    trans_coeff = trans_coeff + epsilon
+
+    diagonal, lower_diagonal, upper_diagonal, vector = settridiag_toohm(
+        dtau, zeta_plus, zeta_minus, lambdan, trans_coeff, scat_coeff, reduced_piB
+    )
+    nlayer, Nnus = diagonal.shape
+    cumTtilde, Qtilde, spectrum = solve_lart_twostream(
+        diagonal, lower_diagonal, upper_diagonal, vector, jnp.zeros(Nnus)
+    )
+
+    return spectrum, cumTtilde, Qtilde, trans_coeff, scat_coeff, reduced_piB
+
+
+@jit
+def rtrun_emis_scat_lart_toonhm_surface(
+    dtau, single_scattering_albedo, asymmetric_parameter, source_matrix, source_surface
+):
+    """Radiative Transfer for emission spectrum using flux-based two-stream scattering LART solver w/ Toon Hemispheric Mean with surface.
+
+    Args:
+        dtau (_type_): _description_
+        single_scattering_albedo (_type_): _description_
+        asymmetric_parameter (_type_): _description_
+        source_matrix (_type_): _description_
+        source_surface: source from the surface (N_nus)
+
+    Returns:
+        _type_: _description_
     """
-    deltaRp2 = 2.0 * jnp.trapz(
-        (1.0 - jnp.exp(-dtau_chord)) * radius_lower[::-1, None],
-        x=radius_lower[::-1],
-        axis=0)
-    return deltaRp2 + radius_lower[-1]**2
+    trans_coeff, scat_coeff, piB, zeta_plus, zeta_minus, lambdan = setrt_toonhm(
+        dtau, single_scattering_albedo, asymmetric_parameter, source_matrix
+    )
+    diagonal, lower_diagonal, upper_diagonal, vector = settridiag_toohm(
+        dtau, zeta_plus, zeta_minus, lambdan, trans_coeff, scat_coeff, piB
+    )
+
+    cumTtilde, Qtilde, spectrum = solve_lart_twostream(
+        diagonal, lower_diagonal, upper_diagonal, vector, source_surface
+    )
+
+    return spectrum, cumTtilde, Qtilde, trans_coeff, scat_coeff, piB
+
+
+@jit
+def rtrun_reflect_fluxadding_toonhm(
+    dtau,
+    single_scattering_albedo,
+    asymmetric_parameter,
+    source_matrix,
+    source_surface,
+    reflectivity_surface,
+    incoming_flux,
+):
+    """Radiative Transfer for reflected spectrum the flux adding solver w/ Toon Hemispheric Mean with surface.
+
+    Args:
+        dtau: layer optical depth (Nlayer, N_nus)
+        single_scattering_albedo: single scattering albedo (Nlayer, N_nus)
+        asymmetric_parameter: assymetric parameter (Nlayer, N_nus)
+        source_matrix: source term (Nlayer, N_nus)
+        source_surface: source from the surface (N_nus)
+        reflectivity_surface: reflectivity from the surface (N_nus)
+        incoming flux: incoming flux F_0^- (N_nus)
+
+    Returns:
+        _type_: _description_
+    """
+    trans_coeff, scat_coeff, reduced_piB, zeta_plus, zeta_minus, lambdan = setrt_toonhm(
+        dtau, single_scattering_albedo, asymmetric_parameter, source_matrix
+    )
+
+    Rphat, Sphat = solve_fluxadding_twostream(
+        trans_coeff, scat_coeff, reduced_piB, reflectivity_surface, source_surface
+    )
+    return Rphat * incoming_flux + Sphat
+
+
+@jit
+def rtrun_emis_scat_fluxadding_toonhm(
+    dtau, single_scattering_albedo, asymmetric_parameter, source_matrix
+):
+    """Radiative Transfer for emission spectrum (w/ scattering) using flux-based two-stream scattering the flux adding solver w/ Toon Hemispheric Mean with surface.
+
+    Args:
+        dtau (_type_): _description_
+        single_scattering_albedo (_type_): _description_
+        asymmetric_parameter (_type_): _description_
+        source_matrix (_type_): _description_
+
+    Returns:
+        _type_: _description_
+    """
+    _, Nnus = dtau.shape
+    source_surface = jnp.zeros(Nnus)
+    reflectivity_surface = jnp.zeros(Nnus)
+
+    trans_coeff, scat_coeff, reduced_piB, zeta_plus, zeta_minus, lambdan = setrt_toonhm(
+        dtau, single_scattering_albedo, asymmetric_parameter, source_matrix
+    )
+
+    _, spectrum = solve_fluxadding_twostream(
+        trans_coeff, scat_coeff, reduced_piB, reflectivity_surface, source_surface
+    )
+
+    return spectrum
+
+
+def setrt_toonhm(dtau, single_scattering_albedo, asymmetric_parameter, source_matrix):
+    """sets some coefficients for rtrun assming Toon Hemispheric Mean
+
+    Args:
+        dtau (_type_): _description_
+        single_scattering_albedo (_type_): _description_
+        asymmetric_parameter (_type_): _description_
+        source_matrix (_type_): _description_
+
+    Returns:
+        _type_: _description_
+    """
+    gamma_1, gamma_2, mu1 = params_hemispheric_mean(
+        single_scattering_albedo, asymmetric_parameter
+    )
+    zeta_plus, zeta_minus, lambdan = zetalambda_coeffs(gamma_1, gamma_2)
+    trans_coeff, scat_coeff = set_scat_trans_coeffs(
+        zeta_plus, zeta_minus, lambdan, dtau
+    )
+
+    reduced_piB = reduced_source_function_isothermal_layer(
+        single_scattering_albedo, gamma_1, gamma_2, source_matrix
+    )
+
+    return trans_coeff, scat_coeff, reduced_piB, zeta_plus, zeta_minus, lambdan
+
+
+def settridiag_toohm(
+    dtau, zeta_plus, zeta_minus, lambdan, trans_coeff, scat_coeff, reduced_piB
+):
+    diagonal_top = 1.0 * jnp.ones_like(trans_coeff[0, :])  # setting b0=1
+    upper_diagonal_top = trans_coeff[0, :]
+
+    zeta_plus0 = zeta_plus[0, :]
+    zeta_minus0 = zeta_minus[0, :]
+
+    # emission (no reflection)
+    trans_func0 = jnp.exp(-lambdan[0, :] * dtau[0, :])
+    denom = zeta_plus0**2 - (zeta_minus0 * trans_func0) ** 2
+    omtrans = 1.0 - trans_func0
+    fac = zeta_plus0 * omtrans - zeta_minus0 * trans_func0 * omtrans
+    vector_top = (zeta_plus0**2 - zeta_minus0**2) / denom * fac * reduced_piB[0, :]
+
+    # tridiagonal elements
+    (
+        diagonal,
+        lower_diagonal,
+        upper_diagonal,
+        vector,
+    ) = compute_tridiag_diagonals_and_vector(
+        scat_coeff,
+        trans_coeff,
+        reduced_piB,
+        upper_diagonal_top,
+        diagonal_top,
+        vector_top,
+    )
+
+    return diagonal, lower_diagonal, upper_diagonal, vector
+
+
+##################################################################################
+# Raise Error since v1.5
+# Deprecated features, will be completely removed by Release v2.0
+##################################################################################
+
+
+def dtauM(dParr, xsm, MR, mass, g):
+    warn_msg = "Use `spec.layeropacity.layer_optical_depth` instead"
+    raise ValueError(warn_msg)
+
+
+def dtauCIA(nus, Tarr, Parr, dParr, vmr1, vmr2, mmw, g, nucia, tcia, logac):
+    warn_msg = "Use `spec.layeropacity.layer_optical_depth_CIA` instead"
+    raise ValueError(warn_msg)
+
+
+def dtauHminus(nus, Tarr, Parr, dParr, vmre, vmrh, mmw, g):
+    warn_msg = "Use `spec.layeropacity.layer_optical_depth_Hminus` instead"
+    raise ValueError(warn_msg)
+
+
+def dtauVALD(dParr, xsm, VMR, mmw, g):
+    warn_msg = "Use `spec.layeropacity.layer_optical_depth_VALD` instead"
+    raise ValueError(warn_msg)
+
+
+def pressure_layer(
+    log_pressure_top=-8.0,
+    log_pressure_btm=2.0,
+    NP=20,
+    mode="ascending",
+    reference_point=0.5,
+    numpy=False,
+):
+    warn_msg = "Use `atm.atmprof.pressure_layer_logspace` instead"
+    raise ValueError(warn_msg)
```

## exojax/spec/specop.py

```diff
@@ -1,102 +1,129 @@
 """Spectral Operators (Sop)
+
+    The role of SOP is to apply various operators (essentially convolution) to a single spectrum, such as spin rotation, gaussian IP, RV shift etc.
+    There are several convolution methods:
+    - "exojax.signal.convolve": regular FFT-based convolution
+    - "exojax.signal.ola": Overlap-and-Add based convolution
+
 """
 from exojax.utils.grids import velocity_grid
 from exojax.spec.spin_rotation import convolve_rigid_rotation
+from exojax.spec.spin_rotation import convolve_rigid_rotation_ola
 from exojax.spec.response import ipgauss, sampling
+from exojax.spec.response import ipgauss_ola, sampling
 from exojax.utils.grids import grid_resolution
 
+
 class SopCommon():
     """Common Spectral Operator
     """
-    def __init__(self, nu_grid, resolution, vrmax):
+
+    def __init__(self, nu_grid, vrmax, convolution_method):
         """initialization of Sop
 
         Args:
             nu_grid (nd.array): wavenumber grid in cm-1
             resolution (float): wavenumber grid resolution, defined by nu/delta nu
             vrmax (float): velocity maximum to be applied in km/s
         """
-        self.convolution_method = "exojax.signal.convolve"
+        self.convolution_method_list = [
+            "exojax.signal.convolve", "exojax.signal.ola"]
+        self.convolution_method = convolution_method
         self.nu_grid = nu_grid
         self.vrmax = vrmax
-        self.resolution = resolution
-        self.generate_vrarray()   
         self.resolution = grid_resolution('ESLOG', self.nu_grid)
+        self.generate_vrarray()
+        self.ola_ndiv = 4
 
     def generate_vrarray(self):
         self.vrarray = velocity_grid(self.resolution, self.vrmax)
 
+    def check_ola_reducible(self, spectrum):
+        div_length = int(float(len(spectrum))/float(self.ola_ndiv))
+        if len(spectrum) != self.ola_ndiv*div_length:
+            raise ValueError("len(spectrum) can be reduced by self.ola_ndiv ="+str(self.ola_ndiv))
+        return div_length
+
 
 class SopRotation(SopCommon):
     """Spectral operator on rotation
     """
+
     def __init__(self,
                  nu_grid,
-                 resolution,
                  vsini_max=100.0,
+                 convolution_method="exojax.signal.convolve"
                  ):
-        super().__init__(nu_grid, resolution, vsini_max)
-        
+        super().__init__(nu_grid, vsini_max, convolution_method)
+
     def rigid_rotation(self, spectrum, vsini, u1, u2):
         """apply a rigid rotation
 
         Args:
             spectrum (nd array): 1D spectrum
             vsini (float): V sini in km/s
             u1 (float): Limb darkening parameter u1
             u2 (float): Limb darkening parameter u2
 
         Raises:
             ValueError: _description_
 
         Returns:
-            nd array: rotatinoal broaden spectrum
+            nd array: rotationally broaden spectrum
         """
-        if self.convolution_method == "exojax.signal.convolve":
+        if self.convolution_method == self.convolution_method_list[0]:  # "exojax.signal.convolve"
             return convolve_rigid_rotation(spectrum, self.vrarray, vsini, u1, u2)
+        elif self.convolution_method == self.convolution_method_list[1]:  # "exojax.signal.olaconv"
+            div_length = self.check_ola_reducible(spectrum)
+            folded_spectrum = spectrum.reshape((self.ola_ndiv, div_length))
+            return convolve_rigid_rotation_ola(folded_spectrum, self.vrarray, vsini, u1, u2)
         else:
-            raise ValueError("No convolution_method")
+            raise ValueError("No convolution_method.")
 
+    
 
 class SopInstProfile(SopCommon):
     """Spectral operator on Instrumental profile and sampling
     """
+
     def __init__(self,
                  nu_grid,
-                 resolution,
                  vrmax=100.0,
+                 convolution_method="exojax.signal.convolve"
                  ):
-        super().__init__(nu_grid, resolution, vrmax)
-    
+        super().__init__(nu_grid, vrmax, convolution_method)
+
     def ipgauss(self, spectrum, standard_deviation):
         """Gaussian Instrumental Profile
 
         Args:
             spectrum (nd array): 1D spectrum
             standard_deviation (float): standard deviation of Gaussian in km/s
 
         Raises:
             ValueError: _description_
 
         Returns:
             array: IP applied spectrum
         """
-        if self.convolution_method == "exojax.signal.convolve":
+        if self.convolution_method == self.convolution_method_list[0]:  # "exojax.signal.convolve"
             return ipgauss(spectrum, self.vrarray, standard_deviation)
+        elif self.convolution_method == self.convolution_method_list[1]:  # "exojax.signal.olaconv"
+            div_length = self.check_ola_reducible(spectrum)
+            folded_spectrum = spectrum.reshape((self.ola_ndiv, div_length))
+            return ipgauss_ola(folded_spectrum, self.vrarray, standard_deviation)
         else:
-            raise ValueError("No convolution_method")
+            raise ValueError("No convolution_method.")
 
     def sampling(self, spectrum, radial_velocity, nu_grid_sampling):
         """sampling to instrumental wavenumber grid (not necessary ESLOG nor ESLIN)
 
         Args:
             spectrum (nd array): 1D spectrum
             radial_velocity (float): radial velocity in km/s
             nu_grid_sampling (array): instrumental wavenumber grid 
 
         Returns:
             array: inst sampled spectrum 
         """
         return sampling(nu_grid_sampling, self.nu_grid, spectrum, radial_velocity)
-
-
```

## exojax/spec/spin_rotation.py

```diff
@@ -1,11 +1,41 @@
 from jax import custom_jvp
 import jax.numpy as jnp
 from jax import jit
 from exojax.signal.convolve import convolve_same
+from exojax.signal.ola import olaconv, ola_lengths, generate_zeropad
+
+
+@jit
+def convolve_rigid_rotation_ola(folded_F0, vr_array, vsini, u1=0.0, u2=0.0):
+    """Apply the Rotation response to a spectrum F (No OLA and No cuDNN).
+
+    Args:
+        folded_F0: original spectrum (F0) folded to (ndiv, div_length) form
+        vr_array: fix-sized vr array for kernel, see utils.dvgrid_rigid_rotation
+        vsini: V sini for rotation (km/s)
+        RV: radial velocity
+        u1: Limb-darkening coefficient 1
+        u2: Limb-darkening coefficient 2
+
+    Return:
+        response-applied spectrum (F)
+    """
+    kernel = rotkernel(vr_array/vsini, u1, u2)
+    kernel = kernel / jnp.sum(kernel, axis=0)
+
+    ndiv, div_length, filter_length = ola_lengths(folded_F0, kernel)
+    F0_hat, kernel_hat = generate_zeropad(folded_F0, kernel)
+    ola = olaconv(F0_hat, kernel_hat, ndiv, div_length, filter_length)
+    
+    edge = int((len(kernel) - 1) / 2)
+    convolved_signal = ola[edge:-edge]
+    
+    return convolved_signal
+
 
 @jit
 def convolve_rigid_rotation(F0, vr_array, vsini, u1=0.0, u2=0.0):
     """Apply the Rotation response to a spectrum F (No OLA and No cuDNN).
 
     Args:
         F0: original spectrum (F0)
```

## exojax/spec/twostream.py

```diff
@@ -1,68 +1,76 @@
 """ Two-stream solvers and related methods 
 
+    Note:
+        ExoJAX has two types of the flux-based two-stream solvers for scattering/reflection. 
+        - fluxadding 
+        - LART
+
 """
 
 import jax.numpy as jnp
 from jax.lax import scan
 
 
-def solve_lart_twostream_numpy(diagonal, lower_diagonal, upper_diagonal,
-                               vector):
-    """Two-stream RT solver given tridiagonal system components (LART form) but numpy version
+def solve_fluxadding_twostream(trans_coeff, scat_coeff, reduced_source_function, reflectivity_bottom, source_bottom):
+    """Two-stream RT solver using flux adding
 
     Args:
-        diagonal (_type_): diagonal component of the tridiagonal system (bn)
-        lower_diagonal (_type_): lower diagonal component of the tridiagonal system (cn)
-        upper_diagonal (_type_): upper diagonal component of the tridiagonal system (an)
-        vector (_type_): right-hand side vector (dn)
-
-    Note:
-        Our definition of the tridiagonal components is 
-        an F+_(n+1) + bn F+_n + c_(n-1) F+_(n-1) = dn 
-        Notice that c_(n-1) is not cn
+        trans_coeff (_type_): Transmission coefficient 
+        scat_coeff (_type_): Scattering coefficient 
+        reduced_source_function :  pi \mathcal{B} (Nlayer, Nnus)
+        reflectivity_bottom (_type_): R^+_N (Nnus)
+        source_bottom (_type_): S^+_N (Nnus)
 
     Returns:
-        _type_: cumlative T, hat Q, spectrum 
+        Effective reflectivity (hat(R^plus)), Effective source (hat(S^plus))
     """
-    import numpy as np
-    nlayer, Nnus = diagonal.shape
+    nlayer, _ = trans_coeff.shape
+    pihatB = (1.0 - trans_coeff - scat_coeff)*reduced_source_function
 
-    nlayer, _ = diagonal.shape
-    That = np.zeros_like(diagonal)
-    Qhat = np.zeros_like(diagonal)
-    That[0, :] = upper_diagonal[0, :] / diagonal[0, :]
-    Qhat[0, :] = vector[0, :] / diagonal[0, :]
-
-    for i in range(1, nlayer):  #nlayer - 1 ...
-        gamma = diagonal[i, :] - lower_diagonal[i - 1, :] * That[i - 1, :]
-        That[i, :] = upper_diagonal[i, :] / gamma
-        Qhat[i, :] = (vector[i, :] +
-                      lower_diagonal[i - 1, :] * Qhat[i - 1, :]) / gamma
+    # bottom reflection
+    Rphat0 = scat_coeff[nlayer-1, :] + trans_coeff[nlayer-1, :]**2 * \
+        reflectivity_bottom/(1.0 - scat_coeff[nlayer-1, :]*reflectivity_bottom)
+    Sphat0 = pihatB[nlayer-1, :] + trans_coeff[nlayer-1, :] * \
+        (source_bottom + pihatB[nlayer-1, :]*reflectivity_bottom) / \
+        (1.0 - scat_coeff[nlayer-1, :]*reflectivity_bottom)
 
-    #(no)surface term
-    Qhat = jnp.vstack([Qhat, np.zeros(Nnus)])
-    cumThat = jnp.cumprod(jnp.vstack([jnp.ones(Nnus), That]), axis=0)
-    contribution_function = cumThat * Qhat
-    spectrum = np.nansum(contribution_function, axis=0)
+    def f(carry_ip1, arr):
+        Rphat_prev, Sphat_prev = carry_ip1
+        scat_coeff_i, trans_coeff_i, pihatB_i = arr
+        denom = 1.0 - scat_coeff_i*Rphat_prev
 
-    return cumThat, Qhat, spectrum
+        Sphat_each = pihatB_i + trans_coeff_i * \
+            (Sphat_prev + pihatB_i*Rphat_prev) / denom
+        Rphat_each = scat_coeff_i + trans_coeff_i**2 * Rphat_prev/denom
+
+        RS = [Rphat_each, Sphat_each]
+        return RS, 0
+
+    # main loop
+    arrin = [
+        scat_coeff[nlayer-2::-1],
+        trans_coeff[nlayer-2::-1],
+        pihatB[nlayer-2::-1]
+    ]
+    RS, _ = scan(f, [Rphat0, Sphat0], arrin)
+    return RS
 
 
 def solve_lart_twostream(diagonal, lower_diagonal, upper_diagonal, vector,
                          flux_bottom):
     """Two-stream RT solver given tridiagonal system components (LART form)
 
     Args:
         diagonal (_type_): diagonal component of the tridiagonal system (bn)
         lower_diagonal (_type_): lower diagonal component of the tridiagonal system (cn)
         upper_diagonal (_type_): upper diagonal component of the tridiagonal system (an)
         vector (_type_): right-hand side vector (dn)
         flux_bottom: bottom flux FB
-        
+
     Note:
         Our definition of the tridiagonal components is 
         an F+_(n+1) + bn F+_n + c_(n-1) F+_(n-1) = dn 
         Notice that c_(n-1) is not cn
 
     Returns:
         _type_: cumlative hat{T}, hat{Q}, spectrum 
@@ -78,31 +86,31 @@
         diagonal_i, lower_diagonal_i_1, upper_diagonal_i, vector_i = arr
         gamma = diagonal_i - lower_diagonal_i_1 * That_i_1
         That_each = upper_diagonal_i / gamma
         Qhat_each = (vector_i + lower_diagonal_i_1 * Qhat_i_1) / gamma
         TQ = [That_each, Qhat_each]
         return TQ, TQ
 
-    #top boundary
+    # top boundary
     That0 = upper_diagonal[0, :] / diagonal[0, :]
     Qhat0 = vector[0, :] / diagonal[0, :]
 
-    #main loop
+    # main loop
     arrin = [
         diagonal[1:nlayer, :], lower_diagonal[0:nlayer - 1, :],
         upper_diagonal[1:nlayer, :], vector[1:nlayer, :]
     ]
     _, stackedTQ = scan(f, [That0, Qhat0], arrin)
     That, Qhat = stackedTQ
 
-    #inserts top boundary
+    # inserts top boundary
     That = jnp.insert(jnp.array(That), 0, That0, axis=0)
     Qhat = jnp.insert(jnp.array(Qhat), 0, Qhat0, axis=0)
 
-    #(no)surface term
+    # (no)surface term
     Qhat = jnp.vstack([Qhat, flux_bottom])
     cumThat = jnp.cumprod(jnp.vstack([jnp.ones(Nnus), That]), axis=0)
     spectrum = jnp.nansum(cumThat * Qhat, axis=0)
 
     return cumThat, Qhat, spectrum
 
 
@@ -209,9 +217,9 @@
     return diagonal, lower_diagonal, upper_diagonal, vector
 
 
 def sh2_zetalambda_coeff():
     raise ValueError("not implemented yet.")
 
 
-#if __name__ == "__main__":
+# if __name__ == "__main__":
 #   test_tridiag_coefficients()
```

## exojax/spec/unitconvert.py

```diff
@@ -1,63 +1,65 @@
 """unit conversion for spectrum."""
 
+import warnings
 from exojax.utils.checkarray import is_sorted
 
-def nu2wav(nus, wavelength_order, unit='AA'):
+
+def nu2wav(nus, wavelength_order="descending", unit="AA"):
     """wavenumber to wavelength (AA)
 
     Args:
         nus: wavenumber (cm-1)
-        wavlength order: wavelength order: "ascending" or "descending"
-        unit: unit of wavelength
+        wavlength order: wavelength order: "ascending" or "descending", default to "descending"
+        unit: the unit of the output wavelength, "AA", "nm", or "um"
 
     Returns:
-       wavelength (AA)
+        wavelength (unit)
     """
-    conversion_factors = {
-        'nm': 1.e7,
-        'AA': 1.e8,
-        'um': 1.e4
-    }
+    conversion_factors = {"nm": 1.0e7, "AA": 1.0e8, "um": 1.0e4}
+    wavenumber_order = is_sorted(nus)
 
-    if is_sorted(nus) != "ascending":
+    if wavenumber_order == "descending" or wavenumber_order == "unordered":
         raise ValueError("wavenumber should be in ascending order in ExoJAX.")
 
     try:
-        if wavelength_order=="ascending":
+        if wavelength_order == "ascending":
+            _both_ascending_warning()
             return conversion_factors[unit] / nus[::-1]
-        elif wavelength_order=="descending":
+        elif wavelength_order == "descending" or wavenumber_order == "single":
             return conversion_factors[unit] / nus
         else:
             raise ValueError("order should be ascending or descending")
     except KeyError:
         raise ValueError("unavailable unit")
 
+
 def wav2nu(wav, unit):
     """wavelength to wavenumber.
 
     Args:
-       wav: wavelength array in ascending/descending order
-       unit: unit of wavelength
+        wav: wavelength array in ascending/descending order
+        unit: unit of wavelength
 
     Returns:
-       wavenumber (cm-1) in ascending order
+        wavenumber (cm-1) in ascending order
     """
 
-    conversion_factors = {
-        'nm': 1.e7,
-        'AA': 1.e8,
-        'um': 1.e4
-    }
+    conversion_factors = {"nm": 1.0e7, "AA": 1.0e8, "um": 1.0e4}
 
     order = is_sorted(wav)
-
     try:
-        if order=="ascending":
+        if order == "ascending":
+            _both_ascending_warning()
             return conversion_factors[unit] / wav[::-1]
-        elif order=="descending":
+        elif order == "descending" or order == "single":
             return conversion_factors[unit] / wav
         else:
             raise ValueError("wavelength array should be ascending or descending")
     except KeyError:
         raise ValueError("unavailable unit")
 
+def _both_ascending_warning():
+    warnings.warn(
+        "Both input wavelength and output wavenumber are in ascending order.",
+        UserWarning,
+    )
```

## exojax/test/data.py

```diff
@@ -1,14 +1,11 @@
 """filenames of test data used in unit tests
 
 """
-# exomol moldb template used in unit tests
-# exojax.src.test.generate should make this file
-TESTDATA_moldb_CO_HITEMP = "moldb_co_hitemp.pickle"
-TESTDATA_moldb_CO_HITEMP_SINGLE_ISOTOPE = "moldb_co_hitemp_single_isotope.pickle"
+# exomol moldb template used in unit tests (will be removed)
 TESTDATA_moldb_VALD = "moldb_vald.pickle"
 
 # cross section references
 TESTDATA_CO_EXOMOL_LPF_XS_REF = "lpf_test_ref.txt"
 TESTDATA_CO_EXOMOL_MODIT_XS_REF = "modit_test_ref.txt"
 TESTDATA_CO_EXOMOL_PREMODIT_XS_REF = "premodit_test_ref.txt"
 
@@ -35,8 +32,11 @@
 #sample transmission spectra
 SAMPLE_TRANSMISSION_CH4 = "transmission_ch4.txt"
 
 #test data par file
 TESTDATA_CO_HITEMP_PARFILE = "05_HITEMP_SAMPLE.par"
 
 #test data CIA H2-H2 (4300-4400 cm-1)
-TESTDATA_H2_H2_CIA = "H2-H2_TEST.cia" 
+TESTDATA_H2_H2_CIA = "H2-H2_TEST.cia" 
+
+#test data for refraction index
+TESTDATA_refrind = "test.refrind"
```

## exojax/test/generate.py

```diff
@@ -1,15 +1,15 @@
 """generate test data for exomol
 
 """
 from exojax.spec import api
 from exojax.test.emulate_mdb import mock_wavenumber_grid
 import pathlib
 import os
-from jax.config import config
+from jax import config
 
 config.update("jax_enable_x64", True)
 
 
 def gendata_moldb():
     """generate test data for CO exomol
     """
```

## exojax/test/generate_methane_spectrum.py

```diff
@@ -86,15 +86,15 @@
         #T-P model
         Tarr = art.powerlaw_temperature(T0, alpha)
         gravity = art.gravity_profile(Tarr, mmw, radius_btm, gravity_btm)
         
         #molecule
         xsmatrix = opa.xsmatrix(Tarr, art.pressure)
         mmr_arr = art.constant_mmr_profile(MMR_CH4)
-        dtaumCH4 = art.opacity_profile_lines(xsmatrix, mmr_arr, opa.mdb.molmass, g)
+        dtaumCH4 = art.opacity_profile_xs(xsmatrix, mmr_arr, opa.mdb.molmass, g)
         
         #continuum
         logacia_matrix = opcia.logacia_matrix(Tarr)
         dtaucH2H2 = art.opacity_profile_cia(logacia_matrix, Tarr, vmrH2, vmrH2,
                                             mmw, g)
         
         dtau = dtaumCH4 + dtaucH2H2
```

## exojax/test/generate_methane_trans.py

```diff
@@ -81,15 +81,15 @@
     def flux_model(T0, vsini, RV):
         #T-P model
         Tarr = art.powerlaw_temperature(T0, alpha)
         
         #molecule
         xsmatrix = opa.xsmatrix(Tarr, art.pressure)
         mmr_arr = art.constant_mmr_profile(MMR_CH4)
-        dtaumCH4 = art.opacity_profile_lines(xsmatrix, mmr_arr, opa.mdb.molmass, g)
+        dtaumCH4 = art.opacity_profile_xs(xsmatrix, mmr_arr, opa.mdb.molmass, g)
         
         #continuum
         logacia_matrix = opcia.logacia_matrix(Tarr)
         dtaucH2H2 = art.opacity_profile_cia(logacia_matrix, Tarr, vmrH2, vmrH2,
                                             mmw, g)
         
         dtau = dtaumCH4 + dtaucH2H2
```

## exojax/test/generate_rt.py

```diff
@@ -7,15 +7,15 @@
 from exojax.test.data import TESTDATA_CO_HITEMP_MODIT_EMISSION_REF
     
 from exojax.test.emulate_mdb import mock_mdb
 from exojax.spec.opacalc import OpaDirect
 from exojax.spec.opacalc import OpaModit
 from exojax.spec.atmrt import ArtEmisPure
 
-from jax.config import config
+from jax import config
 
 config.update("jax_enable_x64", True)
 
 testdata_modit={}
 testdata_modit["exomol"]=TESTDATA_CO_EXOMOL_MODIT_EMISSION_REF
 testdata_modit["hitemp"]=TESTDATA_CO_HITEMP_MODIT_EMISSION_REF
 
@@ -42,15 +42,15 @@
     #mdb = api.MdbHitemp('CO', art.nu_grid, gpu_transfer=False, isotope=1)
     opa = OpaModit(mdb=mdb,
                    nu_grid=nu_grid,
                    Tarr_list=Tarr,
                    Parr=art.pressure,
                    dit_grid_resolution=0.2)
     xsmatrix = opa.xsmatrix(Tarr, art.pressure)
-    dtau = art.opacity_profile_lines(xsmatrix, mmr_arr, opa.mdb.molmass,
+    dtau = art.opacity_profile_xs(xsmatrix, mmr_arr, opa.mdb.molmass,
                                      gravity)
     F0 = art.run(dtau, Tarr)
     np.savetxt(testdata_modit[db], np.array([nu_grid, F0]).T, delimiter=",")
     
     return nu_grid, F0
 
 
@@ -69,15 +69,15 @@
 
     mdb = mock_mdb(db)
     #mdb = api.MdbExomol('.database/CO/12C-16O/Li2015',nu_grid,inherit_dataframe=False,gpu_transfer=False)
     #mdb = api.MdbHitemp('CO', art.nu_grid, gpu_transfer=False, isotope=1)
     opa = OpaDirect(mdb=mdb, nu_grid=nu_grid)
 
     xsmatrix = opa.xsmatrix(Tarr, art.pressure)
-    dtau = art.opacity_profile_lines(xsmatrix, mmr_arr, opa.mdb.molmass,
+    dtau = art.opacity_profile_xs(xsmatrix, mmr_arr, opa.mdb.molmass,
                                      gravity)
     F0 = art.run(dtau, Tarr)
     np.savetxt(testdata_lpf[db], np.array([nu_grid, F0]).T, delimiter=",")
     
     return nu_grid, F0
```

## exojax/test/generate_xs.py

```diff
@@ -17,15 +17,15 @@
 from exojax.test.emulate_mdb import mock_wavenumber_grid
 from exojax.test.data import TESTDATA_CO_EXOMOL_LPF_XS_REF
 from exojax.test.data import TESTDATA_CO_HITEMP_LPF_XS_REF
 from exojax.test.emulate_mdb import mock_mdb
 from exojax.spec.opacalc import OpaDirect
 import matplotlib.pyplot as plt
 
-from jax.config import config
+from jax import config
 
 config.update("jax_enable_x64", True)
 
 testdata = {}
 testdata["exomol"] = TESTDATA_CO_EXOMOL_LPF_XS_REF
 testdata["hitemp"] = TESTDATA_CO_HITEMP_LPF_XS_REF
 
@@ -53,15 +53,15 @@
     cont_nu, index_nu, R, pmarray = init_modit(mdbCO.nu_lines, nu_grid)
     qt = mdbCO.qr_interp(Tfix)
     gammaL = gamma_exomol(Pfix, Tfix, mdbCO.n_Texp,
                           mdbCO.alpha_ref) + gamma_natural(mdbCO.A)
     dv_lines = mdbCO.nu_lines / R
     ngammaL = gammaL / dv_lines
     nsigmaD = normalized_doppler_sigma(Tfix, Mmol, R)
-    Sij = line_strength(Tfix, mdbCO.logsij0, mdbCO.nu_lines, mdbCO.elower, qt)
+    Sij = line_strength(Tfix, mdbCO.logsij0, mdbCO.nu_lines, mdbCO.elower, qt, mdbCO.Tref)
 
     ngammaL_grid = ditgrid_log_interval(ngammaL, dit_grid_resolution=0.1)
     xsv = xsvector(cont_nu, index_nu, R, pmarray, nsigmaD, ngammaL, Sij,
                    nu_grid, ngammaL_grid)
 
     #import matplotlib.pyplot as plt
     #plt.plot(nus,xsv)
@@ -103,15 +103,15 @@
     qt = mdbCO.qr_interp(mdbCO.isotope, Tfix)
     gammaL = gamma_hitran(Pfix, Tfix, Pself, mdbCO.n_air, mdbCO.gamma_air,
                           mdbCO.gamma_self) + gamma_natural(mdbCO.A)
 
     dv_lines = mdbCO.nu_lines / R
     ngammaL = gammaL / dv_lines
     nsigmaD = normalized_doppler_sigma(Tfix, Mmol, R)
-    Sij = line_strength(Tfix, mdbCO.logsij0, mdbCO.nu_lines, mdbCO.elower, qt)
+    Sij = line_strength(Tfix, mdbCO.logsij0, mdbCO.nu_lines, mdbCO.elower, qt, mdbCO.Tref)
     cont_nu, index_nu, R, pmarray = init_modit(mdbCO.nu_lines, nu_grid)
     ngammaL_grid = ditgrid_log_interval(ngammaL, dit_grid_resolution=0.1)
 
     xsv = xsvector(cont_nu, index_nu, R, pmarray, nsigmaD, ngammaL, Sij,
                    nu_grid, ngammaL_grid)
 
     #import matplotlib.pyplot as plt
```

## exojax/utils/astrofunc.py

```diff
@@ -4,39 +4,40 @@
 * That's why we need this module.
 """
 
 from exojax.utils.constants import gJ
 import jax.numpy as jnp
 
 
+
 def logg_jupiter(Rp, Mp):
     """logg from radius and mass in the Jovian unit.
 
     Args:
-       Rp: radius in the unit of Jovian radius
-       Mp: radius in the unit of Jovian mass
+        Rp: radius in the unit of Jovian radius
+        Mp: radius in the unit of Jovian mass
 
     Returns:
-       logg
+        logg
 
     Note:
-       Mpcgs=Mp*const.MJ, Rpcgs=Rp*const.RJ,
-       then logg is given by log10(const.G*Mpcgs/Rpcgs**2)
+        Mpcgs=Mp*const.MJ, Rpcgs=Rp*const.RJ,
+        then logg is given by log10(const.G*Mpcgs/Rpcgs**2)
     """
     return jnp.log10(gravity_jupiter(Rp, Mp))
 
 
 def gravity_jupiter(Rp, Mp):
     """gravity in cgs from radius and mass in the Jovian unit.
 
     Args:
-       Rp: radius in the unit of Jovian radius
-       Mp: radius in the unit of Jovian mass
+        Rp: radius in the unit of Jovian radius
+        Mp: radius in the unit of Jovian mass
 
     Returns:
-       gravity (cm/s2)
+        gravity (cm/s2)
 
     Note:
-       Mpcgs=Mp*const.MJ, Rpcgs=Rp*const.RJ
-       then gravity is given by (const.G*Mpcgs/Rpcgs**2)
+        Mpcgs=Mp*const.MJ, Rpcgs=Rp*const.RJ
+        then gravity is given by (const.G*Mpcgs/Rpcgs**2)
     """
     return gJ * Mp / Rp**2
```

## exojax/utils/checkarray.py

```diff
@@ -1,17 +1,47 @@
+import numpy as np
+
+
 def is_sorted(x):
     """Check if a list is sorted in ascending or descending order.
 
     Args:
         x: List to check.
 
     Returns:
+        'single' if x is not list, but a single value
         'ascending' if the list is sorted in ascending order,
         'descending' if the list is sorted in descending order,
         'unordered' otherwise.
     """
-    if all(a <= b for a, b in zip(x, x[1:])):
-        return 'ascending'
+
+    if isinstance(x, (int, float, str, bool)):
+        return "single"
+    elif all(a <= b for a, b in zip(x, x[1:])):
+        return "ascending"
     elif all(a >= b for a, b in zip(x, x[1:])):
-        return 'descending'
+        return "descending"
     else:
-        return 'unordered'
+        return "unordered"
+
+
+def is_outside_range(xarr, xs, xe):
+    """
+    Check if all elements in the array are outside the specified range.
+
+    Args:
+        xarr (numpy.ndarray): An array of numerical values.
+        xs (float): The start of the range (exclusive).
+        xe (float): The end of the range (exclusive).
+
+    Returns:
+        bool: True if all elements in xarr are outside the range (xs, xe), False otherwise.
+
+    Examples:
+        >>> xarr = np.array([1.2, 1.4, 1.7, 1.3, 1.0])
+        >>> xs = 0.7
+        >>> xe = 0.8
+        >>> result = is_outside_range(xarr, xs, xe) #-> True
+
+        
+    """
+    return not np.any((xarr > xs) & (xarr < xe))
```

## exojax/utils/constants.py

```diff
@@ -4,50 +4,59 @@
 * Tref_original: reference temperature used in exojax.spec
 
 """
 
 # original reference temperature used in HITRAN/HITEMP in K
 Tref_original = 296.0
 
-# cgs
+#temperature at water triple point  (K)
+Ttp_water = 273.16 
+# 0 Celsius degree in Kelvin
+Tc_water = 273.15
+
+# cgs unit
 #Rs = 6.957 * 1.e10
 Rs = 6.9551 * 1.e10
 RJ = 7.1492 * 1.e9
 RE = 6.3781 * 1.e8
 au = 1.495978707 * 1.e13
 pc = 3.0856775814913673 * 1.e18
 G = 6.67408e-08
 #MJ = 1.89813 * 1.e30  # Jovian mass
 MJ = 1.8986 * 1.e30  # Jovian mass
 gJ = 2478.57730044555  # Jovian gravity
-m_u = 1.66053904e-24  # amu
+m_u = 1.66053904e-24  # atomic mass unit [g]
 kB = 1.38064852e-16
 logkB = -15.859916868309735  # log10(kB)
 hcperk = 1.4387773538277202  # hc/kB (cm K)
 ccgs = 29979245800.0  # c in cgs
 logm_ucgs = -23.779750909492115  # log(m_u) in cgs unit = np.log10(m_u*1.e3) where m_u = scipy.constants.m_u.
 ecgs = 4.80320450e-10  # [esu]=[dyn^0.5*cm] #elementary charge
 mecgs = 9.10938356e-28  # [g] !electron mass
 eV2wn = 8065.54  # 1[eV]=8065.54[cm^-1]
 hcgs = 6.62607015e-27  # Planck constant [erg*s]
 Rcgs = 1.0973731568e5  # Rydberg constant [cm-1]
 a0 = 5.2917720859e-9  # Bohr radius [cm]
+bar_cgs = 1.e6 # 1 bar in cgs = 1e6 dyn/cm2
+
+
+# in bar unit (1bar = 10**6 dyn/cm2 (cgs))
 Patm = 1.01325  # 1 atm in bar
 
-# km/s
+# in km/s unit
 c = 299792.458
 Gcr = 115.38055682147402  #cuberoot of Gravitaional constant in the unit of [km/s] normalized by day and Msun
-#
 
-#opacity factor
-#opfac=bar_cgs/(m_u (g)). m_u: atomic mass unit. It can be obtained by fac=1.e3/m_u, where m_u = scipy.constants.m_u.
+# opacity factor
+# opfac = bar_cgs/(m_u (g)). m_u: atomic mass unit. bar_cgs: 1 bar in cgs = 1.e6 dyn/cm2
+# obtained as opfac = bar_cgs/m_u(in g) = 1.e6/(m_u(in kg)*1.e3) = 1.e3/m_u(in kg), m_u(in kg) = scipy.constants.m_u.
 opfac = 6.022140858549162e+29
 
 if __name__ == "__main__":
     #derivation of Gcr
-    from astropy.constants import G
+    from astropy.constants import G as G_astropy
     from astropy.constants import M_sun
     from astropy import units as u
     day = 24 * 3600 * u.s
-    Gu = (G * M_sun / day).value
+    Gu = (G_astropy * M_sun / day).value
     Gcr_val = Gu**(1.0 / 3.0) * 1.e-3
     print(Gcr_val)
```

## exojax/utils/grids.py

```diff
@@ -14,15 +14,15 @@
 
     Args:
         x0: start wavenumber (cm-1) or wavelength (nm) or (AA)
         x1: end wavenumber (cm-1) or wavelength (nm) or (AA)
         N: the number of the wavenumber grid (even number)
         xsmode: cross section computation mode (lpf, dit, modit, premodit)
         wavlength order: wavelength order: "ascending" or "descending"
-        unit: unit of the input grid
+        unit: unit of the input grid, "cm-1", "nm", or "AA"
         
     Note:
         The wavenumber (nus) and wavelength (wav) grids are in ascending orders. 
         Therefore, wav[-1] corresponds to the wavelength of nus[0].
         ESLIN sets evenly-spaced linear grid in wavenumber space while ESLOG sets 
         evenly-spaced log grid both in wavenumber and wavelength spaces. 
 
@@ -46,20 +46,17 @@
 def _warning_wavelength_order(wavelength_order):
     """this is temporary special warning on wavelenght order
 
     Args:
         wavlength order: wavelength order: "ascending" or "descending"
     """
     print("======================================================================")
-    print("We changed the policy of the order of wavenumber/wavelength grids")
-    print("wavenumber grid should be in ascending order and now ")
-    print("users can specify the order of the wavelength grid by themselves.")
+    print("The wavenumber grid should be in ascending order.")
+    print("The users can specify the order of the wavelength grid by themselves.")
     print("Your wavelength grid is in *** ", wavelength_order, " *** order")
-    print("This might causes the bug if you update ExoJAX. ")
-    print("Note that the older ExoJAX assumes ascending order as wavelength grid.")
     print("======================================================================")
 
 
 def _set_grid(x0, x1, N, unit, grid_mode):
     if grid_mode == 'ESLOG':
         grid = np.logspace(np.log10(x0), np.log10(x1), N, dtype=np.float64)
     elif grid_mode == 'ESLIN':
```

## exojax/utils/indexing.py

```diff
@@ -1,95 +1,161 @@
+""" index manipulation
+
+* (np)getix provides the contribution and index.
+
+"""
+
 import numpy as np
 import tqdm
 import warnings
+import jax.numpy as jnp
+
+
+def getix(x, xv):
+    """jnp version of getix.
+
+    Args:
+        x: x array
+        xv: x grid, should be ascending order
+
+    Returns:
+        cont (contribution)
+        index (index)
+
+    Note:
+        cont is the contribution for i=index+1. 1 - cont is the contribution for i=index. For other i, the contribution should be zero.
+
+    Example:
+
+        >>> from exojax.utils.indexing import getix
+        >>> import jax.numpy as jnp
+        >>> y=jnp.array([1.1,4.3])
+        >>> yv=jnp.arange(6)
+        >>> getix(y,yv)
+        (DeviceArray([0.10000002, 0.3000002 ], dtype=float32), DeviceArray([1, 4], dtype=int32))
+    """
+    indarr = jnp.arange(len(xv))
+    pos = jnp.interp(x, xv, indarr)
+    cont, index = jnp.modf(pos)
+    return cont, index.astype(int)
+
+
+def npgetix(x, xv):
+    """numpy version of getix.
+
+    Args:
+        x: x array
+        xv: x grid, should be ascending order
+
+    Returns:
+        cont (contribution)
+        index (index)
+
+    Note:
+        cont is the contribution for i=index+1. 1 - cont is the contribution for i=index. For other i, the contribution should be zero.
+    """
+    indarr = np.arange(len(xv))
+    pos = np.interp(x, xv, indarr)
+    cont, index = np.modf(pos)
+    return cont, index.astype(int)
+
 
 def unique_rows(x):
     """memory saved version of np.unique(,axis=0)
 
     Notes:
         Originally from a snippet/Answer #4 (https://discuss.dizzycoding.com/find-unique-rows-in-numpy-array/?amp=1)
 
     Args:
-        x (2D array): 2D array (N x M), need to be C-contiguous    
+        x (2D array): 2D array (N x M), need to be C-contiguous
 
 
     Returns:
         2D array: unique 2D array (N' x M), where N' <= N, removed duplicated M vector.
     """
     if not x.data.contiguous:
-        warnings.warn("input should be contiguous.",UserWarning)
+        warnings.warn("input should be contiguous.", UserWarning)
     uniq = np.unique(x.view(x.dtype.descr * x.shape[1]))
     return uniq.view(x.dtype).reshape(-1, x.shape[1])
 
+
 def uniqidx(input_array):
-    """ compute indices based on uniq values of the input M-dimensional array.                                                   
-                                                                                                                        
-    Args:                                                                                                               
-        input_array: input array (N,M), will use unique M-dim vectors                                                             
-                                                                                                                        
-    Returns:                                                                                                            
-        unique index, unique value                                                                                      
-                                                                                                                        
-    Examples:                                                                                                           
-                                                                                                                        
-        >>> a=np.array([[4,1],[7,1],[7,2],[7,1],[8,0],[4,1]])                                                           
-        >>> uidx, uval=uniqidx(a) #->[0,1,2,1,3,0], [[4,1],[7,1],[7,2],[8,0]]                                        
-                                                                                                                        
+    """compute indices based on uniq values of the input M-dimensional array.
+
+    Args:
+        input_array: input array (N,M), will use unique M-dim vectors
+
+    Returns:
+        unique index, unique value
+
+    Examples:
+
+        >>> a=np.array([[4,1],[7,1],[7,2],[7,1],[8,0],[4,1]])
+        >>> uidx, uval=uniqidx(a) #->[0,1,2,1,3,0], [[4,1],[7,1],[7,2],[8,0]]
+
     """
     N, _ = np.shape(input_array)
-    #uniqvals = np.unique(input_array, axis=0)
+    # uniqvals = np.unique(input_array, axis=0)
     uniqvals = unique_rows(input_array)
     uidx = np.zeros(N, dtype=int)
     uidx_p = np.where(input_array == uniqvals[0], True, False)
     uidx[np.array(np.prod(uidx_p, axis=1), dtype=bool)] = 0
     for i, uv in enumerate(tqdm.tqdm(uniqvals[1:], desc="uniqidx")):
         uidx_p = np.where(input_array == uv, True, False)
         uidx[np.array(np.prod(uidx_p, axis=1), dtype=bool)] = i + 1
     return uidx, uniqvals
 
 
 def uniqidx_neibouring(index_array):
-    """ compute indices based on uniq values of the input index array and input index + one vector  
-                                                                                                                        
-    Args:                                                                                                               
-        index_array: input index array (N,M), will use unique M-dim vectors                                                             
-                                                                                                                        
-    Returns:                                                                                                            
+    """compute indices based on uniq values of the input index array and input index + one vector
+
+    Args:
+        index_array: input index array (N,M), will use unique M-dim vectors
+
+    Returns:
         unique index (udix)
         neibouring index (nidx) for udix [N_uidx, 3]
         multi index as a function of nidx
-                                                                                                                        
+
     """
     uidx, multi_index = uniqidx(index_array)
-    multi_index_update=np.copy(multi_index)
-    Nuidx = np.max(uidx)+1
-    neighbor_indices=np.zeros((Nuidx,3),dtype=int)
+    multi_index_update = np.copy(multi_index)
+    Nuidx = np.max(uidx) + 1
+    neighbor_indices = np.zeros((Nuidx, 3), dtype=int)
     for i in range(0, Nuidx):
-        neighbor_indices[i,0], multi_index_update = find_or_add_index(multi_index[i,:]+np.array([1,0]), multi_index_update)
-        neighbor_indices[i,1], multi_index_update = find_or_add_index(multi_index[i,:]+np.array([0,1]), multi_index_update)
-        neighbor_indices[i,2], multi_index_update = find_or_add_index(multi_index[i,:]+np.array([1,1]), multi_index_update)
-        
+        neighbor_indices[i, 0], multi_index_update = find_or_add_index(
+            multi_index[i, :] + np.array([1, 0]), multi_index_update
+        )
+        neighbor_indices[i, 1], multi_index_update = find_or_add_index(
+            multi_index[i, :] + np.array([0, 1]), multi_index_update
+        )
+        neighbor_indices[i, 2], multi_index_update = find_or_add_index(
+            multi_index[i, :] + np.array([1, 1]), multi_index_update
+        )
+
     return uidx, neighbor_indices, multi_index_update
 
+
 def find_or_add_index(new_index, index_array):
     """find a position of a new index in index_array, if not exisited add the new index in index_array
-    
-    Args: 
+
+    Args:
         new_index: new index investigated
         index_array: index array
-   
+
     Returns:
         position, index_array updated
-        
+
     """
     uidx_p = np.where(index_array == new_index, True, False)
     mask = np.array(np.prod(uidx_p, axis=1), dtype=bool)
     ni = np.where(mask == True)[0]
     if len(ni) == 0:
-        index_array = np.vstack([index_array,new_index])
+        index_array = np.vstack([index_array, new_index])
         return len(index_array) - 1, index_array
     else:
         return ni[0], index_array
 
+
 if __name__ == "__main__":
     a = np.array([[4, 1], [7, 1], [7, 2], [8, 0], [4, 1]])
     udix, neighbor_indices, multi_index_update = uniqidx_neibouring(a)
```

## exojax/utils/jaxstatus.py

```diff
@@ -1,8 +1,8 @@
-from jax.config import config
+from jax import config
 import warnings
 
 def check_jax64bit(allow_32bit):
         """check if the JAX precision mode is 64bit mode
 
         Args:
             allow_32bit (_type_): exception to use 32bit mode. if True, just send warning message
```

## exojax/utils/memuse.py

```diff
@@ -1,8 +1,8 @@
-from jax.config import config
+from jax import config
 
 
 def device_memory_use(opa, art=None, nfree=None, print_summary=True):
     """device memory use given opa and art (optional), n free parameters (optional)
 
     Args:
         opa (opa): opa instance
```

## exojax/utils/url.py

```diff
@@ -1,75 +1,89 @@
 """url.
 
 * This module contains various url for downloading. Because url can be changed by the orner of the site, you might need to change it. Or, if you notice the change, it would be great if you send a pull-request.
 """
 
 
+def url_virga():
+    """return URL for VIRGA refractive index data from ZENODO
+
+    Returns:
+        URL for VIRGA refractive index data
+    """
+    url = "https://zenodo.org/records/5179187/files/virga.zip"
+    return url
+
+
 def url_HITRAN12():
     """return URL for HITRAN 12 parfile.
 
     Returns:
-       URL for HITRAN 12 parfile
+        URL for HITRAN 12 parfile
     """
-    url = u'https://www.cfa.harvard.edu/HITRAN/HITRAN2012/HITRAN2012/By-Molecule/Uncompressed-files/'
+    url = "https://www.cfa.harvard.edu/HITRAN/HITRAN2012/HITRAN2012/By-Molecule/Uncompressed-files/"
     return url
 
 
 def url_HITRANCIA():
     """return URL for HITRAN CIA ciafile.
 
     Returns:
-       URL for HITRAN CIA file
+        URL for HITRAN CIA file
     """
-    url = u'https://hitran.org/data/CIA/'
+    url = "https://hitran.org/data/CIA/"
     return url
 
 
 def url_HITEMP():
     """return URL for HITEMP bz2 parfile.
 
     Returns:
-       URL for HITEMP bz2 file
+        URL for HITEMP bz2 file
     """
-    url = u'https://hitran.org/hitemp/data/bzip2format/'
+    url = "https://hitran.org/hitemp/data/bzip2format/"
     return url
 
 
 def url_HITEMP10():
     """return URL for HITEMP2010.
 
     Returns:
-       URL for HITEMP2010 db
+        URL for HITEMP2010 db
     """
-    url = u'https://hitran.org/hitemp/data/HITEMP-2010/'
+    url = "https://hitran.org/hitemp/data/HITEMP-2010/"
     return url
 
 
 def url_ExoMol():
     """return URL for ExoMol.
 
     Returns:
-       URL for ExoMol db
+        URL for ExoMol db
     """
-    url = u'http://www.exomol.com/db/'
+    url = "http://www.exomol.com/db/"
     return url
 
 
 def url_Exomol_iso(molecule, isotope_full_name):
     """return URL for ExoMol for isotope.
 
     Returns:
-       URL for ExoMol for isotope
+        URL for ExoMol for isotope
     """
-    url = u'https://exomol.com/data/molecules/' + \
-        str(molecule)+'/'+str(isotope_full_name)
+    url = (
+        "https://exomol.com/data/molecules/"
+        + str(molecule)
+        + "/"
+        + str(isotope_full_name)
+    )
     return url
 
 
 def url_developer_data():
     """return URL for data in exojax.
 
     Returns:
-       URL for ExoJAX
+        URL for ExoJAX
     """
-    url = u'http://secondearths.sakura.ne.jp/exojax/data/'
+    url = "http://secondearths.sakura.ne.jp/exojax/data/"
     return url
```

## Comparing `ExoJAX-1.4.2.dist-info/LICENSE` & `ExoJAX-1.5.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `ExoJAX-1.4.2.dist-info/METADATA` & `ExoJAX-1.5.dist-info/METADATA`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: ExoJAX
-Version: 1.4.2
+Version: 1.5
 Summary: Auto-differentiable line-by-line spectral modeling of exoplanets/brown dwarfs using JAX.
 Home-page: http://secondearths.sakura.ne.jp/exojax/
 Author: Hajime Kawahara and collaborators
 Author-email: divrot@gmail.com
 Maintainer: Hajime Kawahara and collaborators
 Maintainer-email: divrot@gmail.com
 License: MIT
@@ -12,41 +12,72 @@
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.9
 Description-Content-Type: text/markdown
 License-File: LICENSE
 License-File: LICENSES_bundled.txt
-Requires-Dist: numpyro
-Requires-Dist: jaxopt
 Requires-Dist: jax
+Requires-Dist: jaxlib
 Requires-Dist: hitran-api
-Requires-Dist: radis
-Requires-Dist: numpy (<=1.22.3)
-Requires-Dist: pygments (>=2.15)
-Requires-Dist: pydantic (<2.0)
+Requires-Dist: hjson
+Requires-Dist: tqdm
+Requires-Dist: lxml
+Requires-Dist: publib (>=0.3.2)
+Requires-Dist: peakutils
+Requires-Dist: ruamel.yaml
+Requires-Dist: json-tricks (>=3.15.0)
+Requires-Dist: mpldatacursor
+Requires-Dist: beautifulsoup4
+Requires-Dist: configparser
+Requires-Dist: cython
+Requires-Dist: termcolor
+Requires-Dist: tables
+Requires-Dist: joblib
+Requires-Dist: pandas
+Requires-Dist: plotly
+Requires-Dist: progressbar2
+Requires-Dist: numba
+Requires-Dist: publib
+Requires-Dist: psutil
+Requires-Dist: seaborn
+Requires-Dist: PyMieScatt
+Requires-Dist: numpy (<2)
 
 # ExoJAX
  [![License](https://img.shields.io/github/license/HajimeKawahara/exojax)](https://github.com/HajimeKawahara/exojax/blob/develop/LICENSE)
  [![Docs](https://img.shields.io/badge/docs-exojax-brightgreen)](http://secondearths.sakura.ne.jp/exojax/)
  [![arxiv](https://img.shields.io/badge/arxiv-2105.14782-blue)](http://arxiv.org/abs/2105.14782)
  [![paper](https://img.shields.io/badge/paper-ApJS_258_31_(2022)-orange)](https://iopscience.iop.org/article/10.3847/1538-4365/ac3b4d) 
  <a href="https://codeclimate.com/github/HajimeKawahara/exojax/maintainability"><img src="https://api.codeclimate.com/v1/badges/97c5e8835f3ef9c4ad7c/maintainability" /></a>
 
-Auto-differentiable line-by-line spectral modelling of exoplanets/brown dwarfs/M dwarfs using JAX. Read [the docs](http://secondearths.sakura.ne.jp/exojax) 🐕. 
-In short, ExoJAX allows you to do gradient based optimisation and HMC NUTS fitting using the latest database.
+Differentiable spectral modelling of exoplanets/brown dwarfs/M dwarfs using JAX!
+Read [the docs](http://secondearths.sakura.ne.jp/exojax/develop) 🐕. 
+In short, ExoJAX allows you to do gradient based optimizations and HMC-NUTS samplings using the latest database.
 
 ExoJAX is at least compatible with
 
-- [NumPyro](https://github.com/pyro-ppl/numpyro) (PPL)
-- BlackJAX
-- [JAXopt](https://github.com/google/jaxopt) (differentiable optimizer)
+- PPLs: [NumPyro](https://github.com/pyro-ppl/numpyro), [blackjax](https://github.com/blackjax-devs/blackjax) 
+- Optimizers: [JAXopt](https://github.com/google/jaxopt), [optax](https://github.com/google-deepmind/optax), [bayeux](https://github.com/jax-ml/bayeux)
+
+<img src="https://github.com/HajimeKawahara/exojax/assets/15956904/8aa9673b-b64b-4b65-a76c-2966ef1edbc7" Titie="exojax" Width=850px>
+
+<details><summary>ExoJAX Classes</summary>
+
+- Databases: *db (mdb: molecular, adb: atomic, cdb:continuum, pdb: particulates)
+- Opacity Calculators: opa  (i.e. Voigt profile)
+- Atmospheric Radiative Transfer: art (emission w, w/o scattering, refelction, transmission)
+- Atompsheric Microphysics: amp (clouds etc)
+
+</details>
+
+## Get Started 
+
+See [this page](http://secondearths.sakura.ne.jp/exojax/develop/tutorials/get_started.html) for the first step!
 
-<img src="https://user-images.githubusercontent.com/15956904/222950543-6de25bb2-48f2-4bc7-a588-77daa105442e.png" Titie="exojax" Width=850px>
- 
 ## Functions
 
 <details open><summary>Voigt Profile :heavy_check_mark: </summary>
 
 ```python3
 from exojax.spec import voigt
 nu=numpy.linspace(-10,10,100)
@@ -57,28 +88,29 @@
 
 <details><summary>Cross Section using HITRAN/HITEMP/ExoMol :heavy_check_mark: </summary>
  
 ```python
 from exojax.utils.grids import wavenumber_grid
 from exojax.spec.api import MdbExomol
 from exojax.spec.opacalc import OpaPremodit
-
-from jax.config import config
+from jax import config
 config.update("jax_enable_x64", True)
 
 nu_grid,wav,res=wavenumber_grid(1900.0,2300.0,200000,xsmode="premodit",unit="cm-1",)
 mdb = MdbExomol(".database/CO/12C-16O/Li2015",nu_grid)
 opa = OpaPremodit(mdb,nu_grid,auto_trange=[900.0,1100.0])
 xsv = opa.xsvector(1000.0, 1.0) # cross section for 1000K, 1 bar
 ```
 
  <img src="https://user-images.githubusercontent.com/15956904/111430765-2eedf180-873e-11eb-9740-9e1a313d590c.png" Titie="exojax auto cross section" Width=850px> 
 
 </details>
 
+
+
 <details><summary>Do you just want to plot the line strength at T=1000K? </summary>
 
 ```python
 mdb.change_reference_temperature(1000.) # at 1000K
 plt.plot(mdb.nu_lines,mdb.line_strength_ref,".")
 ```
 
@@ -91,56 +123,39 @@
 F = art.run(dtau, Tarr)
 ```
 
 <img src="https://user-images.githubusercontent.com/15956904/116488770-286ea000-a8ce-11eb-982d-7884b423592c.png" Titie="exojax auto \emission spectrum" Width=850px> 
 
 </details>
 
-See http://secondearths.sakura.ne.jp/exojax/develop/tutorials/get_started.html for the first step!
+<details><summary>Transmission Spectrum :heavy_check_mark: </summary></details>
+<details><summary>Reflection Spectrum :heavy_check_mark: </summary></details>
 
 ## Installation
 
 ```
 pip install exojax
 ```
 
 or
 
 ```
 python setup.py install
 ```
 
-<details><summary> Note on installation w/ GPU support</summary>
-
-:books: You need to install CUDA, NumPyro, JAX w/ NVIDIA GPU support, and cuDNN. 
+<details><summary>Note on installation w/ GPU support</summary>
 
-- NumPyro
+:books: You need to install CUDA, JAX w/ NVIDIA GPU support.
 
-ExoJAX supports NumPyro >=0.7.0. Please check the required JAX version by NumPyro. In May 2021, it seems the recent version of [NumPyro](https://github.com/pyro-ppl/numpyro) requires jaxlib>=0.1.62 (see [setup.py](https://github.com/pyro-ppl/numpyro/blob/master/setup.py) of NumPyro for instance). 
-
-- JAX
-
-Check you cuda version:
-
-```
-nvcc -V
-```
-
-Install such as
-
-```
-pip install --upgrade pip
-pip install --upgrade "jax[cuda]" -f https://storage.googleapis.com/jax-releases/jax_releases.html
-```
-
-Please visit [here](https://github.com/google/jax) for details.
+Visit [here](https://github.com/google/jax) for the installation of GPU supported JAX.
 
 </details>
 
+
 ## References
 [![paper](https://img.shields.io/badge/paper_I-ApJS_258_31_(2022)-orange)](https://iopscience.iop.org/article/10.3847/1538-4365/ac3b4d) 
 
 - Paper I: Kawahara, Kawashima, Masuda, Crossfield, Pannier, van den Bekerom, [ApJS 258, 31 (2022)](https://iopscience.iop.org/article/10.3847/1538-4365/ac3b4d)
 
 ## License
 
-🐈 Copyright 2020-2023 ExoJAX contributors. exojax is publicly available under the MIT license.
+🐈 Copyright 2020-2024 ExoJAX contributors. ExoJAX is publicly available under the MIT license.
```

### html2text {}

```diff
@@ -1,61 +1,67 @@
-Metadata-Version: 2.1 Name: ExoJAX Version: 1.4.2 Summary: Auto-differentiable
+Metadata-Version: 2.1 Name: ExoJAX Version: 1.5 Summary: Auto-differentiable
 line-by-line spectral modeling of exoplanets/brown dwarfs using JAX. Home-page:
 http://secondearths.sakura.ne.jp/exojax/ Author: Hajime Kawahara and
 collaborators Author-email: divrot@gmail.com Maintainer: Hajime Kawahara and
 collaborators Maintainer-email: divrot@gmail.com License: MIT Classifier:
 Programming Language :: Python Classifier: Programming Language :: Python ::
 3.9 Classifier: Programming Language :: Python :: 3.10 Classifier: Operating
 System :: OS Independent Requires-Python: >=3.9 Description-Content-Type: text/
 markdown License-File: LICENSE License-File: LICENSES_bundled.txt Requires-
-Dist: numpyro Requires-Dist: jaxopt Requires-Dist: jax Requires-Dist: hitran-
-api Requires-Dist: radis Requires-Dist: numpy (<=1.22.3) Requires-Dist:
-pygments (>=2.15) Requires-Dist: pydantic (<2.0) # ExoJAX [![License](https://
-img.shields.io/github/license/HajimeKawahara/exojax)](https://github.com/
-HajimeKawahara/exojax/blob/develop/LICENSE) [![Docs](https://img.shields.io/
-badge/docs-exojax-brightgreen)](http://secondearths.sakura.ne.jp/exojax/) [!
-[arxiv](https://img.shields.io/badge/arxiv-2105.14782-blue)](http://arxiv.org/
-abs/2105.14782) [![paper](https://img.shields.io/badge/paper-ApJS_258_31_
-(2022)-orange)](https://iopscience.iop.org/article/10.3847/1538-4365/ac3b4d)
-_[_h_t_t_p_s_:_/_/_a_p_i_._c_o_d_e_c_l_i_m_a_t_e_._c_o_m_/_v_1_/_b_a_d_g_e_s_/_9_7_c_5_e_8_8_3_5_f_3_e_f_9_c_4_a_d_7_c_/
-_m_a_i_n_t_a_i_n_a_b_i_l_i_t_y_]Auto-differentiable line-by-line spectral modelling of
-exoplanets/brown dwarfs/M dwarfs using JAX. Read [the docs](http://
-secondearths.sakura.ne.jp/exojax) ð. In short, ExoJAX allows you to do
-gradient based optimisation and HMC NUTS fitting using the latest database.
-ExoJAX is at least compatible with - [NumPyro](https://github.com/pyro-ppl/
-numpyro) (PPL) - BlackJAX - [JAXopt](https://github.com/google/jaxopt)
-(differentiable optimizer) [https://user-images.githubusercontent.com/15956904/
-222950543-6de25bb2-48f2-4bc7-a588-77daa105442e.png]## Functions Voigt Profile :
-heavy_check_mark: ```python3 from exojax.spec import voigt nu=numpy.linspace(-
-10,10,100) voigt(nu,1.0,2.0) #sigma_D=1.0, gamma_L=2.0 ``` Cross Section using
-HITRAN/HITEMP/ExoMol :heavy_check_mark: ```python from exojax.utils.grids
-import wavenumber_grid from exojax.spec.api import MdbExomol from
-exojax.spec.opacalc import OpaPremodit from jax.config import config
-config.update("jax_enable_x64", True) nu_grid,wav,res=wavenumber_grid
+Dist: jax Requires-Dist: jaxlib Requires-Dist: hitran-api Requires-Dist: hjson
+Requires-Dist: tqdm Requires-Dist: lxml Requires-Dist: publib (>=0.3.2)
+Requires-Dist: peakutils Requires-Dist: ruamel.yaml Requires-Dist: json-tricks
+(>=3.15.0) Requires-Dist: mpldatacursor Requires-Dist: beautifulsoup4 Requires-
+Dist: configparser Requires-Dist: cython Requires-Dist: termcolor Requires-
+Dist: tables Requires-Dist: joblib Requires-Dist: pandas Requires-Dist: plotly
+Requires-Dist: progressbar2 Requires-Dist: numba Requires-Dist: publib
+Requires-Dist: psutil Requires-Dist: seaborn Requires-Dist: PyMieScatt
+Requires-Dist: numpy (<2) # ExoJAX [![License](https://img.shields.io/github/
+license/HajimeKawahara/exojax)](https://github.com/HajimeKawahara/exojax/blob/
+develop/LICENSE) [![Docs](https://img.shields.io/badge/docs-exojax-
+brightgreen)](http://secondearths.sakura.ne.jp/exojax/) [![arxiv](https://
+img.shields.io/badge/arxiv-2105.14782-blue)](http://arxiv.org/abs/2105.14782)
+[![paper](https://img.shields.io/badge/paper-ApJS_258_31_(2022)-orange)](https:
+//iopscience.iop.org/article/10.3847/1538-4365/ac3b4d) _[_h_t_t_p_s_:_/_/
+_a_p_i_._c_o_d_e_c_l_i_m_a_t_e_._c_o_m_/_v_1_/_b_a_d_g_e_s_/_9_7_c_5_e_8_8_3_5_f_3_e_f_9_c_4_a_d_7_c_/
+_m_a_i_n_t_a_i_n_a_b_i_l_i_t_y_]Differentiable spectral modelling of exoplanets/brown dwarfs/
+M dwarfs using JAX! Read [the docs](http://secondearths.sakura.ne.jp/exojax/
+develop) ð. In short, ExoJAX allows you to do gradient based optimizations
+and HMC-NUTS samplings using the latest database. ExoJAX is at least compatible
+with - PPLs: [NumPyro](https://github.com/pyro-ppl/numpyro), [blackjax](https:/
+/github.com/blackjax-devs/blackjax) - Optimizers: [JAXopt](https://github.com/
+google/jaxopt), [optax](https://github.com/google-deepmind/optax), [bayeux]
+(https://github.com/jax-ml/bayeux) [https://github.com/HajimeKawahara/exojax/
+assets/15956904/8aa9673b-b64b-4b65-a76c-2966ef1edbc7]ExoJAX Classes -
+Databases: *db (mdb: molecular, adb: atomic, cdb:continuum, pdb: particulates)
+- Opacity Calculators: opa (i.e. Voigt profile) - Atmospheric Radiative
+Transfer: art (emission w, w/o scattering, refelction, transmission) -
+Atompsheric Microphysics: amp (clouds etc) ## Get Started See [this page](http:
+//secondearths.sakura.ne.jp/exojax/develop/tutorials/get_started.html) for the
+first step! ## Functions Voigt Profile :heavy_check_mark: ```python3 from
+exojax.spec import voigt nu=numpy.linspace(-10,10,100) voigt(nu,1.0,2.0)
+#sigma_D=1.0, gamma_L=2.0 ``` Cross Section using HITRAN/HITEMP/ExoMol :
+heavy_check_mark: ```python from exojax.utils.grids import wavenumber_grid from
+exojax.spec.api import MdbExomol from exojax.spec.opacalc import OpaPremodit
+from jax import config config.update("jax_enable_x64", True)
+nu_grid,wav,res=wavenumber_grid
 (1900.0,2300.0,200000,xsmode="premodit",unit="cm-1",) mdb = MdbExomol
 (".database/CO/12C-16O/Li2015",nu_grid) opa = OpaPremodit
 (mdb,nu_grid,auto_trange=[900.0,1100.0]) xsv = opa.xsvector(1000.0, 1.0) #
 cross section for 1000K, 1 bar ``` [https://user-images.githubusercontent.com/
 15956904/111430765-2eedf180-873e-11eb-9740-9e1a313d590c.png]Do you just want to
 plot the line strength at T=1000K? ```python mdb.change_reference_temperature
 (1000.) # at 1000K plt.plot(mdb.nu_lines,mdb.line_strength_ref,".") ```
 Emission Spectrum :heavy_check_mark: ```python art = ArtEmisPure
 (nu_grid=nu_grid, pressure_btm=1.e2, pressure_top=1.e-8, nlayer=100) F =
 art.run(dtau, Tarr) ``` [https://user-images.githubusercontent.com/15956904/
-116488770-286ea000-a8ce-11eb-982d-7884b423592c.png]See http://
-secondearths.sakura.ne.jp/exojax/develop/tutorials/get_started.html for the
-first step! ## Installation ``` pip install exojax ``` or ``` python setup.py
-install ``` Note on installation w/ GPU support :books: You need to install
-CUDA, NumPyro, JAX w/ NVIDIA GPU support, and cuDNN. - NumPyro ExoJAX supports
-NumPyro >=0.7.0. Please check the required JAX version by NumPyro. In May 2021,
-it seems the recent version of [NumPyro](https://github.com/pyro-ppl/numpyro)
-requires jaxlib>=0.1.62 (see [setup.py](https://github.com/pyro-ppl/numpyro/
-blob/master/setup.py) of NumPyro for instance). - JAX Check you cuda version:
-``` nvcc -V ``` Install such as ``` pip install --upgrade pip pip install --
-upgrade "jax[cuda]" -f https://storage.googleapis.com/jax-releases/
-jax_releases.html ``` Please visit [here](https://github.com/google/jax) for
-details. ## References [![paper](https://img.shields.io/badge/paper_I-
+116488770-286ea000-a8ce-11eb-982d-7884b423592c.png]Transmission Spectrum :
+heavy_check_mark: Reflection Spectrum :heavy_check_mark: ## Installation ```
+pip install exojax ``` or ``` python setup.py install ``` Note on installation
+w/ GPU support :books: You need to install CUDA, JAX w/ NVIDIA GPU support.
+Visit [here](https://github.com/google/jax) for the installation of GPU
+supported JAX. ## References [![paper](https://img.shields.io/badge/paper_I-
 ApJS_258_31_(2022)-orange)](https://iopscience.iop.org/article/10.3847/1538-
 4365/ac3b4d) - Paper I: Kawahara, Kawashima, Masuda, Crossfield, Pannier, van
 den Bekerom, [ApJS 258, 31 (2022)](https://iopscience.iop.org/article/10.3847/
-1538-4365/ac3b4d) ## License ð Copyright 2020-2023 ExoJAX contributors.
-exojax is publicly available under the MIT license.
+1538-4365/ac3b4d) ## License ð Copyright 2020-2024 ExoJAX contributors.
+ExoJAX is publicly available under the MIT license.
```

## Comparing `ExoJAX-1.4.2.dist-info/RECORD` & `ExoJAX-1.5.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,177 +1,160 @@
 exojax/__init__.py,sha256=DPZ2zGzGwyQLF7AqLPxBpRo0BO0d-hUAo44wIAASOL8,298
-exojax/data.py,sha256=uY9nQDUwE74CmNBHQ_h4x57f6ap_hI3igqB8VNtgwS4,1745
-exojax/emulate_broadpar.py,sha256=dUgFnfukgL28dP1rzszs-Jo4mLWMWM3FpDmO3HJQHwo,807
 exojax/atm/__init__.py,sha256=oCqxYLSKBXFGyDe_KkfIDZLCc7Ei7lusAEMEwrPI_O8,213
-exojax/atm/amclouds.py,sha256=bIIvAxHEnSp_P4YuNB8Wn7_Xn1JnPHXomXfR2ThTFmo,3023
-exojax/atm/atmprof.py,sha256=9DLuityqaQz0xFjlKZCTqayXGf1AQzP9uOWqwEMASE0,6834
-exojax/atm/condinfo.py,sha256=C2tFdOtYOJQqfE5yTEM5nPp5CYlDhyYbs-z1J2A2vUM,676
-exojax/atm/fastchem2_call.py,sha256=Mnz37clCTABiUCXcMVemkQLVDo8b6OcdCgUc3Ex7JhA,10719
-exojax/atm/idealgas.py,sha256=ELflr6UYznj9oDaEJVjW434RnSRYlj_dxcNFLBua6Ns,315
-exojax/atm/psat.py,sha256=DNU8qsEgcM1r4YbjsmMP0XVZGy4aatr7DxVSknXqVJM,972
+exojax/atm/amclouds.py,sha256=mGEaRARgy65Yz9cB3cLkW5MA6BDTqybAglNgm7OGeQg,4717
+exojax/atm/atmconvert.py,sha256=a5PKD7gPlGGly4gIEoftbb39a5jUoSMawskC1nV-ceY,857
+exojax/atm/atmphys.py,sha256=xDXnCJwiRZWWA2KBnSdwaQD1V4ouYfsCu6IZG89NbwA,4716
+exojax/atm/atmprof.py,sha256=SCcgoTZRQWUl7AWiApqt8Y-ure3roP6y4rdzYFvpHz8,9398
+exojax/atm/condensate.py,sha256=_Uu_NmwB8vEovjXqobhRIIwS0B1d43SJaLBZLJa5-Xw,2257
+exojax/atm/idealgas.py,sha256=4qQStR5zNSrGq3S-oseZxW4npK5gg3Tak0v68nmzexw,325
+exojax/atm/lorentz_lorenz.py,sha256=97b7NzcJL506Aj3PzHk3xsRiLSWkY4e2fwpsyVjSWr0,475
+exojax/atm/mixratio.py,sha256=FGts5jKJP4M0Oen7bJcJZD__RQUvQu6s6J8VsshG134,998
+exojax/atm/polarizability.py,sha256=9Vi3w0q8ui1PzAA7A_LF0zzOFT0wnKpVDM5GoSLhHsE,1648
+exojax/atm/psat.py,sha256=4GCcW_3kedOGU614NFo4pliyzsGsO1w8AZXRny-WmKw,4033
 exojax/atm/simple_clouds.py,sha256=2oTBSZgRINkS4BB7ue27i3jwbgGgOPWZuL0Y7TNtkac,434
-exojax/atm/viscosity.py,sha256=zS0uWnifUscH-lR0jYdmmgd3KbGVLbifcmG4EHBQ9Cg,3002
-exojax/atm/vterm.py,sha256=FBsHgmR2gLhr_lHVB98E2IDMhLVgOb591IHCpEBr1Ok,4056
+exojax/atm/viscosity.py,sha256=b_PINj1XdttIKJW67mjKdija6ohEbyoBZLsqYo_7Wss,3086
+exojax/atm/vterm.py,sha256=Z19Lskuas-BTbGJ_pKx9FzgO7kjMe6ZkGqiMGFttobM,4295
 exojax/data/__init__.py,sha256=RES1PJq2tq1LOuqRFrRUhvsEaFtYTi7L9-A1tdcV1-0,171
 exojax/data/abundance/AAG2021.dat,sha256=52KZu1_KFmlwRiskXZYDNAjJyDryw9iEPSZaWLiENCU,2403
 exojax/data/atom/HITRAN_molparam.txt,sha256=BcsR5XxvIFWztx51AuwarD8HEqsqePMamzY40PLqZhQ,9614
 exojax/data/atom/NIST_Atomic_Ionization_Energies.txt,sha256=8B20dLpA-PcvJP-yVsCu8KFVyoh1bDNvHduHpHRiDpo,819291
 exojax/data/atom/atomic.txt,sha256=pTH_g7dcYwhXdva7ABEiR5d9FbmU019e-ZGjwwx9qOc,6044
 exojax/data/atom/barklem_collet_2016_pff.txt,sha256=bHkQKYg4rd88Nm9dhphfGmTIZs71zmVhPpoSb-8xJlA,171536
 exojax/data/atom/iso_mn.txt,sha256=CXQXM4sDBKDhgH9C8gT7M5R-GLcZRrUF4479ktqkRSE,8322
+exojax/data/clouds/ammonia_liquid_density.csv,sha256=Tv1FP7VCBlmCodFXmk7Ch2MWLNBkjJrCS_NzWdDcNRU,665
 exojax/data/clouds/drag_force.txt,sha256=wNV8EgLt-gBX2EM7xjvFSIS5WYOthy_L8J3HxbLbra0,188
 exojax/data/premodit/elower_grid_trange.npz,sha256=bQsETC65VddggGchG9MVku4FNblMXCcCGb_zhNXTKfc,3483224
+exojax/data/premodit/elower_grid_trange_v2.npz,sha256=pay0Aal_xOPvmqTm8E98hagV9wZkKdeBBcH9YuSVs3Q,10533704
 exojax/data/testdata/H2-H2_TEST.cia,sha256=z2Pw1kMtZZJEkrCaHbY2z2MQquzZ9Y4REIPM3PfTsMw,2300
 exojax/data/testdata/lpf_rt_test_hitemp_ref.txt,sha256=e4k4oej4IbxJuA7UriX_j1T7D0MVbFG205yfPpdjZh4,1000000
 exojax/data/testdata/lpf_rt_test_ref.txt,sha256=CJzxganI4HFkApoIG49G6e5DQdIYfr0Xc9UCarZTp0I,1000000
 exojax/data/testdata/lpf_test_hitemp_ref.txt,sha256=onN2m3nyzcaBjOz7znW0UnkFGqm-Zlqx9KMxQURstmo,1000000
 exojax/data/testdata/lpf_test_ref.txt,sha256=r-xhIYMAOX2hQyQOoIIHza1nzFb_-Tb-72Akz6CWSVA,1000000
+exojax/data/testdata/miegrid_lognorm_test.mg.npz,sha256=Y-r6l6g3RU3rIC4VfM1QUeFVqd4tB6Szdurtchf0Yag,85036
 exojax/data/testdata/modit_rt_test_hitemp_ref.txt,sha256=11yudQayXqougustubZG6yb5CU0x8NszAjdAUQNv7Yk,1000000
 exojax/data/testdata/modit_rt_test_ref.txt,sha256=oj0O4Dmr1hNUGNP-MQOZkh3UTEv7xefDNuQcAH8kDLs,1000000
 exojax/data/testdata/modit_rt_test_vald_ref.txt,sha256=5v-E9l1L0BX95qPQNQskp0WI_e24J33mgwqbLzHj_RE,100000
 exojax/data/testdata/modit_test_hitemp_ref.txt,sha256=AorD1zRsmDtwn8gUzs46MZ-JpzJSVrNtuiwAnKXUKlA,1000000
 exojax/data/testdata/modit_test_hitemp_ref_air.txt,sha256=CM8qHaCdhevu74MV45gFRT8oBt4C1dZuxRTZWWj78cc,1000000
 exojax/data/testdata/modit_test_ref.txt,sha256=QedyHtS5UjyIpZFlxGHtYHL07xe45KSbux4vWc0jV7M,1000000
-exojax/data/testdata/moldb_co_exomol.pickle,sha256=3JmVAA7iyJTEvE-n6aUHjQu-p0Q1it30BcpY6XomzmI,157039
-exojax/data/testdata/moldb_co_hitemp.pickle,sha256=iF4y0sUv5Gq7HNb2cfnJ8yr-wXILjUMHeWayFJogtFk,49346
-exojax/data/testdata/moldb_co_hitemp_single_isotope.pickle,sha256=BPI1Bv9qtiy7hCfAQKc-YCkGSvAGAgryEB7bD-NJgvg,16092
-exojax/data/testdata/moldb_h2o_exomol.pickle,sha256=4xg9CqJglqA8BQt-VpaVYilbIrKw_776Q7lFETFfkxw,34576741
 exojax/data/testdata/moldb_vald.pickle,sha256=qXZbKluJJaL0qZXro3QowtdOcqoqQcBhVgiv4B8owfc,151554
 exojax/data/testdata/premodit_rt_test_hitemp_ref.txt,sha256=RdOYokoeA5_LVN7ttXfXWLSmqYPJLEKB6CI69C_2ry8,750000
 exojax/data/testdata/premodit_rt_test_ref.txt,sha256=uE5do13u933ZTOe85UvL9YxRqpcRubu8cdlvoo5DtmU,750000
-exojax/data/testdata/premodit_test_hitemp_ref.txt,sha256=ptQ0nenjqt1cHPPv65UJVm2rHXM-IA77tk7F72PUcP4,250000
-exojax/data/testdata/premodit_test_ref.txt,sha256=6mRRvVcW1hkwloW3qCewwqCIZtG7JrT8-HQSF1Ewzb8,250000
 exojax/data/testdata/spectrum.txt,sha256=JM3S_ivKYtl54lLO_jTHTK62RELeo47zFJ-fHKexwFQ,25000
 exojax/data/testdata/spectrum_ch4.txt,sha256=vg8BD_hh961pchwQVIgtRidX5jQbuuhBVePEV3K8RDo,75000
 exojax/data/testdata/spectrum_ch4_new.txt,sha256=Y_Nv655yr_nYx-mRAoBFO0qA1MhSiZGNrDVmmo_Vjvo,75000
 exojax/data/testdata/spectrum_co.txt,sha256=yCZ938_dM08xh-ydw68z9mltXLYb1XC82b3bsKyKPVM,75000
+exojax/data/testdata/test.refrind,sha256=be3rHBkxa0HLMOFJTJ6quNSkVv4ONqoGHfzoRKGszQk,2303
 exojax/data/testdata/CO/05_HITEMP_SAMPLE.par,sha256=3g1nO0IyTi-_WpaDwxo8jKIcI1DKEtQCUEzjroA27Qc,2104704
 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__H2.broad,sha256=UHejsfAfe8Oarv585ocPGv9T_g3SUmgTfn_b1ZFGygY,1944
 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__He.broad,sha256=1cMh4t0zdp5IZfmeuVyKF0jwPjxNQgqvXZmiW-gQV9M,1680
 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.def,sha256=O4KNHBnqTH1p6WMoagrF3_49vKZx9NQA-OPCN20vqhU,5074
 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.pf,sha256=CmxWMYh1pM9r_H-KqbVgmGUCXJIr8Mz0L2sBfB7Sm0M,234000
 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.states.bz2,sha256=E68tkqHkYiMqXY7alsJKUJn1ftdoWwPONijSd2VvL9w,54318
 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.states.hdf5,sha256=rsl7-jNT1HgJfyzvxmKHfGR1g9Va0_61929RhkxtOcY,217080
 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.trans.bz2,sha256=f3vSsBGHehvWysK3Djmi8tV8aS7D68hcE5N0jdZQuDM,3105
 exojax/data/testdata/CO/12C-16O/SAMPLE/12C-16O__SAMPLE.trans.hdf5,sha256=Di0GAGB-OdDNozm0aJS5riHelHLAY64fZPw9JZ3vhno,134416
 exojax/dynamics/__init__.py,sha256=krHKAyvStrSCEVL1sd8Sjd8ufya4incPemfXq19_cZ0,167
 exojax/dynamics/getE.py,sha256=Nx1OUfGZwvArZ77lrlVxv8Z-T0jVCn2M5bKLNj0a2DY,2646
 exojax/dynamics/rvfunc.py,sha256=Pgn3MJEdkVFXaLSg8l8Z1jIt_LWFtkiOCQSxdVojWfA,2806
 exojax/plot/__init__.py,sha256=PcUVHDKDbgxxYLWA1GlqMCqjmoVShXmOH35kYDKAwfU,242
-exojax/plot/atmplot.py,sha256=I6UU-18kLi9qeJNvWbO2LH4nkqV2kvBTux9anw9iG8Y,5963
+exojax/plot/atmplot.py,sha256=9dDaswEbHYv3YDVq6oD2VU5JIP4UVTjJ7hNtMzNSZe8,6378
 exojax/plot/ditplot.py,sha256=L8lLDS5_lKVZEujXv2aNpKzjd2TjyCPWqmP-sXRfjpM,2124
 exojax/plot/opaplot.py,sha256=z6kE-BoluhYFSfwPMZFK12fIrDLZDzUtn3s3pgF7TeI,1507
-exojax/plot/rtplot.py,sha256=bAPeUyBVLTocw9yexIGnTzckAJIMiBTt7ikhZh_vaMg,1651
+exojax/plot/rtplot.py,sha256=nTRU7_nbMnNzephVKHHpyD3_ZE5GpDejPXC2uSKrRyA,1666
 exojax/signal/__init__.py,sha256=pSwnnlcvQI8dwwMqxKBaUOVquJ18yK8WMDsyUm5WWIs,65
 exojax/signal/convolve.py,sha256=jPk7cEr-J9NzEYKvxp1676_CGpqeQ7mirnivDbThQC4,698
+exojax/signal/integrate.py,sha256=tKIzM_7XRvDpCvB7qHiMrxJT9ugf-s-H0AWO4flUHYE,616
 exojax/signal/ola.py,sha256=XV9a2jCunt-ZikCiBtHhmOFV-dnqbAmppRjUZ4iNlyc,6552
 exojax/spec/__init__.py,sha256=V6rQSdgIqbiqSqHhGBt8PyIjUQ94ZosuoQyO3NnxIdg,479
-exojax/spec/api.py,sha256=xeUTw8P7_NSIs6a7ijmhZebRFOFXRUkNHvN4z1usXks,42325
-exojax/spec/api_current.py,sha256=quZ1HaYDUzARQerfY6eBLStVZO_WsmJjC-jMW8r431Y,36096
-exojax/spec/atmrt.py,sha256=6L2GZC5IuTELfh1AUwB9Vk0OawP_hmr8jEPOt4HjMk8,12084
+exojax/spec/api.py,sha256=56_fOOeXkY4hsEHV3EjB3J72Z5qOBHlpuk6RQcehtuc,40618
+exojax/spec/atmrt.py,sha256=Djc38eOptxb4krsa58zubUOpH2ou3XFRvbeZtmXBlOY,27898
 exojax/spec/atomll.py,sha256=Astb4CGg9Pzm-frG8XtJsiDWC-kaa1SQJh-IJ4q7jvg,28504
 exojax/spec/atomllapi.py,sha256=ok7uX-ezqyvD59O40o0SVn3_VK1tuH8vw6qdm584PFM,16616
-exojax/spec/autospec.py,sha256=mxKS1O0cijrMsl76f5Q9X-AgNKpJCKJ3xX4gEx9Lbto,18377
-exojax/spec/check_nugrid.py,sha256=NA7MLeJCdOIkBJj5Fn5mdRoY8aaWX3KToXOpm9WkCZc,3004
-exojax/spec/contdb.py,sha256=Ls5InTQ96VD4fn0dteHel-OuHyctQtyXg3G3iucXivs,1614
-exojax/spec/defcia.py,sha256=SFDOA5MGUGk6hFmYOVFEsEU4_jb_tf7NM_pMaCRbH2g,1682
-exojax/spec/defmol.py,sha256=PAFjLuhQXN6dBaLztDJTYDCmAOonrf4jThCBPkKs6Io,3707
+exojax/spec/contdb.py,sha256=u06EIvoNVUwZsQ1wtii3aWliVrFLepID_upfPY9TC-w,1746
 exojax/spec/dit.py,sha256=oXxBProSe6_Rt_MMZJQvwoSQ31QFeBFtSnUTy5xhJ-o,11359
 exojax/spec/ditkernel.py,sha256=xQ-Lft7eH1wMDMbR-bfaOqKFE7P-pOzmvjzmLScWT34,4499
 exojax/spec/dtau_mmwl.py,sha256=s2CtpRHf2rCg2wI0ScH21IIuOEXNmNXjx4BH5bXLe1A,3560
-exojax/spec/evalline.py,sha256=RwCFDx87jOhCsUIdFj9lvF0_xkLW-kKPJqDVjkAw6-0,6071
 exojax/spec/exomol.py,sha256=tET7brE5e1LFDlwajO3_fbtnXdhgrsqfQ-UZ7BNAdtI,1340
-exojax/spec/exomolapi.py,sha256=LBJcHdqCvuFmwT8i8zJCRoTBEuAmtIB0qQYBvUydmdM,15387
-exojax/spec/hapi.py,sha256=yb-9GT0IOhnbm2gsEW5uzottM6PPvA535ALzFAnLHb8,1267866
-exojax/spec/hitran.py,sha256=n6StD38DGVT4nLVVxw4hue71LFfxwKIZepfW8kJdH2U,3546
+exojax/spec/generate_elower_grid_trange.py,sha256=CTYJGJimlhjlzUNn7flaMIJPijzQ6HbyHIn69SknNAE,5030
+exojax/spec/hitran.py,sha256=Tvear1vldproEsq8x7vec78WwNyFLI2Ilxb5ApdlNVU,3439
 exojax/spec/hitranapi.py,sha256=OBaSXVDSngAD1-IaHc0_hRLYs3sVZXRGmR_jGmJrxu8,1916
 exojax/spec/hitrancia.py,sha256=QSU3B1oWovpUjdDo40SSb3SataaGHNpfgmHWdOVlseA,3357
-exojax/spec/hminus.py,sha256=glKtP_h896f3o4kUKiGXsTFpM1VsG9eFeIOK2cXglzU,5845
-exojax/spec/initspec.py,sha256=J9Ot2_ApR3dg7kYE2azi8YtXONsvFo8sXYlGPCYTrLg,11602
-exojax/spec/layeropacity.py,sha256=uKpYX6kqFvgjaTBvIz1FM7ZoQZ4ueg7-IJgQB4pa7Tg,4219
-exojax/spec/lbd.py,sha256=vy5k8TZTz7yDaLodj6yo1jb0U9iWIan9jGhzRiLsZsQ,3979
-exojax/spec/lbderror.py,sha256=dZPmfR1DBnoiaSVoRwTIhA2U6mVMdv3ujMYpxAfkfOY,9993
+exojax/spec/hminus.py,sha256=1MfEcv8c4XN1XsmBJYw_GHelfcET8BD9_9A_qbh_hpQ,6042
+exojax/spec/initspec.py,sha256=sR3bm9qXUzUsVkzqQamSi5TbBonA63vV4wQp08AncR8,11608
+exojax/spec/layeropacity.py,sha256=fSQ6uXST_cNhXxqR6x1juxh0mTEm3RXgxsVil79lmts,6698
+exojax/spec/lbd.py,sha256=Npm203CHgWruDEOKfz_vNBRZvQZEmOXnoLl4bj_MZDI,3985
+exojax/spec/lbderror.py,sha256=UpoDysKPJpot4zsHT4gV1l9mUjNzl-iJ5vGy_4TFLaw,10411
 exojax/spec/limb_darkening.py,sha256=TAW1Z3eVxVeLaFu9Z3jIO3fXzVzaNhPuzbJWNxFxbZw,405
-exojax/spec/linefilter.py,sha256=x7iAZJnj0tGZSdQV9gI7R6DUHs4phD6aRjj7fWOuD3c,121
-exojax/spec/lpf.py,sha256=YsnfdoMv7I5oOzaUGGTY1E74xACryDkW7Uiquf6fJmY,12592
-exojax/spec/lsd.py,sha256=gbfx8P_w3j4EjZQm1U30Ir6-vL964mor2Wf1sn0F44A,8566
+exojax/spec/lpf.py,sha256=NUngrPu4ZeIXfbBJQXIL_g3w8O0oFOT_9DSMnyL7y-c,12650
+exojax/spec/lsd.py,sha256=10Ykhe3_g5clCjKL_SiXETo3VYqdhTfhq08JNrPTVnM,7319
 exojax/spec/make_numatrix.py,sha256=tiAqoQ3Mvp1HLrPHuRLeydHE8VSmq9NVmtpp5nbGdPM,3852
-exojax/spec/modit.py,sha256=Gb9re-LymsmCNr9R4VlZdQHVufRmQNWrYe091T3UPgU,25279
+exojax/spec/mie.py,sha256=K1XaeVDacwBfkDEvlI2kg0VyfUbn7801Geg3bdqhccM,12973
+exojax/spec/modit.py,sha256=EsLyfNdzSO4gGFMSaOWjS1_0dVkWc5ZXVrCEGJZ2NGc,25499
 exojax/spec/modit_scanfft.py,sha256=67XIx8QS3SGe1obvxvsu7Kyli_760wOB2qofJ-8OYwk,5095
 exojax/spec/moldb.py,sha256=xnSpCEMDGXDMXr-Ctf9hK2gd4paqhEaummVcPp4BcAE,24786
-exojax/spec/moldf.py,sha256=l47tqdLGQfiSnkz4-Rki9Cs8GwZ1fxw32OSekpJeapI,62169
-exojax/spec/molinfo.py,sha256=fxoYnyw5I3DEFamNLZ5zrLKdfCbPzmrlKeIEXlom89k,5970
-exojax/spec/multimol.py,sha256=JvyTOiSaEyOWJV-nC7haUi5MJalx3gz8fhLDwsU1j8Q,10523
+exojax/spec/molinfo.py,sha256=NWf0pQAjvk4uHxqFHFiehQt5kGkcJDhXKW4dnFOza5A,5966
+exojax/spec/multimol.py,sha256=C_W3Rx0ajAyoP1rDqb13DzIpOU9bGCO-8ASduVtaG4o,10993
 exojax/spec/nonair.py,sha256=KFvydwBHKkrXbmIJqrDEpzr1LOBBovj5cKvzkKDFS3k,2320
-exojax/spec/opacalc.py,sha256=5U1Uvux8RjNUiBQDyWg9sWqj_wrq6HqOide5JKj1RUY,28380
-exojax/spec/opachord.py,sha256=aADyjK1kMDCBNzxsR9PK89_11qNiPMXS-ZQfwSohfMo,1668
-exojax/spec/opacity.py,sha256=pK4whhqIZQXvXqzA1_7wsQi2P9S6oYpJqO0jcK2aW4s,3123
+exojax/spec/opacalc.py,sha256=nRqCQQa-bz5jS1wEKboLxfPgqqxSxmoRBdgl2GVC_PM,30108
+exojax/spec/opachord.py,sha256=9S3FwwaxEXHHte1Mv_VlaDwnl4shopXNoGyLvgP5-Y0,2590
 exojax/spec/opacitytools.py,sha256=rx_Gxh3TawhlodAnleRyKLxxTypKU7CctKcoBOmsCrc,847
-exojax/spec/opacont.py,sha256=PtHjjfYBo3Hu8yJPv_svLUIyiD7fD5OCeaIoZI8ouCs,1369
-exojax/spec/opspec.py,sha256=SZfdZo7l3d9vMLLqYueEd2ljjQpXVrCYP0QjEBuq-xU,1110
-exojax/spec/optgrid.py,sha256=T0IRApMxcZEBevnRL9iyQK8GIDrcd_1s0ck7_xXIqKI,3526
+exojax/spec/opacont.py,sha256=3VMIPwJ8ma48W4VJtnPe9rWT7iNNjHnbLdYAxtkEpFc,10847
+exojax/spec/optgrid.py,sha256=0u1jB5MpTKXX3IbrG-gmlcYvVBv_PgmCR0ITZaJ__8Q,4051
+exojax/spec/pardb.py,sha256=qGI_Yyz5ewVJWT4Za06AhGyocBaqXvyTRMDkToeylRs,11604
 exojax/spec/planck.py,sha256=rM6x_j0gSAUNk31Vo-cJvSm4YvwGHxy30deHtRjmUFQ,663
-exojax/spec/plg.py,sha256=xhaJx-a_w863OzxHmRlmJFC5oKRRji5QJPOCi1stA1s,21813
-exojax/spec/premodit.py,sha256=m7saT2dhPDCHl6CehAe3avIwRAONQC1tovHmRKb3iF8,25815
+exojax/spec/premodit.py,sha256=n90zEKJjoi5cHsK8sO8f0eGGLaKJa_90_Pex7tO6aeU,25848
 exojax/spec/presolar.py,sha256=K3Qe5thBEe5HoSJehklYUfnu-fG8v93UttcJ5wm7c30,3295
-exojax/spec/presolar_scanola.py,sha256=4rCwb_OqSDF6LAs7q5S9JRVO3EZXyx9PXoYYVix90O8,91
-exojax/spec/qstate.py,sha256=2mqLe004V7_Q9mygKWa1-OMJ5MdKPb7K0RNuo6spgfk,399
-exojax/spec/radis_test.py,sha256=xTz4yIESOrO60bXh4OsRHYquYIKeulyb8SaKRl9Xvbk,164
-exojax/spec/response.py,sha256=6WnFNUzHbL1CTFzndKa_Lu3WAZpRz-e03j_zJpCz8-Q,2763
-exojax/spec/rtcheck.py,sha256=L9EInOU4Mj9xXQdrnF_oyna7970HcDN8ZONRi3_y2tM,1384
-exojax/spec/rtransfer.py,sha256=FhDHFOdvmeLVguJSAYno6FUXCQw-1MbK92X26kvDGvk,5882
+exojax/spec/qstate.py,sha256=xxfvlDvWxxRPnqK-wa-41NZesRDHJZFYvz9pRqYriUg,430
+exojax/spec/rayleigh.py,sha256=Pfb-JE6VgsZ63MXGmrCBIMf-Dzt2zoF6L_yV1-b8n3w,1888
+exojax/spec/response.py,sha256=toakJQ1Qzndk10M9ZjZcmCVqWvEvv2MRTfTpWErJ7AE,4276
+exojax/spec/rtransfer.py,sha256=ewp9Lrh9SYTEZgWOAx5ojehHPe4kA0ZVVRJZdV2fI84,18273
 exojax/spec/set_ditgrid.py,sha256=Bt3q8Z8XetVqYEBj6hdqUJISF3JFGsrN6xR2jkwFwDI,5573
-exojax/spec/set_ditgrid_matrix.py,sha256=tbQUBgiJnDEOo1CJtyOcn0zCF2YyNkUXDNxDDBsIHvY,1325
-exojax/spec/setdit.py,sha256=123Ivej4FYhZSGnReHl9iGlQ0lAAajn1ZAfTsOw7eMc,4168
-exojax/spec/setrt.py,sha256=ef5bORXxZg2CEIPV2GDfyhPxmwFh-miGrGZsxf_U2Hg,313
 exojax/spec/shapefilter.py,sha256=s5m-1nXkRB0uf9YUuiZ5Aqi90RkGbNCn0Hs3FXRk0BE,1700
-exojax/spec/specop.py,sha256=y2M0QBUGkLWW2IDrsTYD5dD_xuZ9DVqxE5saMyW5nT4,3237
-exojax/spec/spin_rotation.py,sha256=bo3p_lV9JRMMOHx7IpBXN8g--XSXdsojPFZOMl6xBt4,2185
-exojax/spec/tau1height.py,sha256=rx_Gxh3TawhlodAnleRyKLxxTypKU7CctKcoBOmsCrc,847
+exojax/spec/specop.py,sha256=B1RUgUFLZ32PzN0REmOFjh-vZAtSQPdq9DmdR7PShIg,4851
+exojax/spec/spin_rotation.py,sha256=V-0v4CXG9gDwtrx7l0Zepc-R4wxqK52a15sJCvlijXw,3202
 exojax/spec/toon.py,sha256=2PQj7lc_v1SEUsaXf07mU4qJBfQHqnHErnFDDfVJFPw,3857
-exojax/spec/twostream.py,sha256=tCKddAR5Z_MTw3-vyxrQQ6BsakDfA88Fnw8wpc1_ybY,7835
-exojax/spec/unitconvert.py,sha256=e1N20eqFYJReAkE_YyHbIESvD-3bPcYvI5_rIAF3vFc,1614
+exojax/spec/twostream.py,sha256=gi33QsVK6t_NLhxsP6fBU4LRtkuASVF8jasHaEVlYu0,8019
+exojax/spec/unitconvert.py,sha256=MPqACNYjp0vCubsJpX5nFu6EqA_FHpLXheRzl7-Cbfw,2026
 exojax/special/__init__.py,sha256=HAM7KeZ_Rsu8DftDK91ahIHTIq2jAV2tXyl80HCqVaA,332
-exojax/special/_special.py,sha256=ZzZzy5lz72kqjflZYWJkE20sutzCodmia0zkHG3Gik4,10399
 exojax/special/erfcx.py,sha256=7azKnX6RRjCJ_lxDVbvA4vDgAW4VFiwgUfR4Lm6BKcM,1067
 exojax/special/expn.py,sha256=6rgXJcmxpKBLhAip8eB7QfpaRd5ixfGAt3DAOrCL0Jo,836
 exojax/special/faddeeva.py,sha256=8dS7nUgkE2COVcvlSXCQd8FGMbCxKlxs7hM9gn2cMpQ,3939
 exojax/special/j0.py,sha256=MLORPILcMbio5O7t2GBxY7bwGa9jj_LXWK596y1VOTU,2129
+exojax/special/lognormal.py,sha256=c61kGcuYVfBMCRgSMyi0H-eEOQH8CLT0xE_lEtotdbg,2226
 exojax/test/__init__.py,sha256=8DDvq0Peb__lGVcurhl4UvirKbOlgwleoZit4kOpYd4,14
-exojax/test/data.py,sha256=uY9nQDUwE74CmNBHQ_h4x57f6ap_hI3igqB8VNtgwS4,1745
+exojax/test/data.py,sha256=w3XLLtb4JwbhlV_51B2HUH73RD6AKKoWWtslF8nEYMA,1647
 exojax/test/emulate_broadpar.py,sha256=nDK7mflN_nZ91F_6fZIYHR8Q_wcxTTPc3_N5SIlmvco,1271
 exojax/test/emulate_mdb.py,sha256=zh0bWrGpZlXsAdmQx6_QPdfp4k1LfVol6zOI6S33egY,2839
-exojax/test/emulate_mdb_current.py,sha256=9GBSUUatu7e5PGyr20ntCWonFh9fdEE9yZaivC2IEN0,1509
-exojax/test/generate.py,sha256=rB4l75yuOc3hJKlho1el0aFQ_PLZGi9aVpYbvy_pHOk,1843
-exojax/test/generate_mdb.py,sha256=m-dUc6vtno7WgcjEdZxA8ZL7KdvztHTDIw-8YhTjzng,2591
-exojax/test/generate_methane_spectrum.py,sha256=VAIev3V2BInxOK3_BlUFjLBDBwrCC5vHsnRSdOm2MOk,3776
-exojax/test/generate_methane_trans.py,sha256=1CA9laa0L2XbaCQ8uKFRGowmKOAlRJwWiKBOX8FxkZo,3736
-exojax/test/generate_rt.py,sha256=wXjnv7FaMXD5p27PO9vuomnQFm1CGbyoBq_wltkJ4_E,3946
-exojax/test/generate_xs.py,sha256=YzU6KrH2uNOdgUbVmOLFoBpi1e-An2K4PxPL9v6zquk,4958
+exojax/test/emulate_pdb.py,sha256=ow1Ip29qIyja0lGFE8NbMCGP15Ma07IsYdwnbOjgaa8,870
+exojax/test/generate.py,sha256=eIrbDgx_ebLa73ypT5M6hkryrZ3L8L-TJHXz0W6nJW0,1836
+exojax/test/generate_methane_spectrum.py,sha256=mPRkB0EVdHMMUe2Y3CRffM-9CgqMzzwBVDCLz3kKmT4,3773
+exojax/test/generate_methane_trans.py,sha256=2SNPmYogU539DBakQ5NZECNdU9R-P-0THqvee1hXsCk,3733
+exojax/test/generate_pdb.py,sha256=F8JvT7NGlzj-DJMU8t-O9N87rwyxCIFVB1792Py34xo,729
+exojax/test/generate_rt.py,sha256=YIvY31FX0qYg73BiKEBrBrCFzbfORj3gaQ1bWL-65_s,3933
+exojax/test/generate_xs.py,sha256=CfbovEgoxs-4blIYUrXHZjBfOKEdaz1s58Jzh9GIRIY,4975
 exojax/utils/__init__.py,sha256=4458I7mzfguRYrNv6mffnjESTkm7qiBdsOJp1GRVTvM,178
-exojax/utils/afunc.py,sha256=YzqXOU0cV_16CBwyZjEg0j2gPBlSuNoyJrzq4J7SR8U,973
-exojax/utils/astrofunc.py,sha256=QamtI7JuvAs3ody2oa-d8s0bNePJWJ10wmoJ5V3MQSo,943
-exojax/utils/checkarray.py,sha256=uS_rvmfQLWgOCMBBng58RB8JzPQMXgoz6uNFoDFt3f4,487
-exojax/utils/chopstacks.py,sha256=2g9w20laLAm7cXCSsUnhUfmTNKwzWfhqdWKlLiYa9OE,650
-exojax/utils/constants.py,sha256=AQhDhWky2zd8kM33GhTGwl0jJSubZ-kVkzABTDFIAqo,1631
-exojax/utils/delta_velocity.py,sha256=_BprY_4whpGWUJPWlAnWP0NAiADqRpgloX0nume67RY,876
-exojax/utils/exofile.py,sha256=KN2SZ1-92oYIBkM7aqqnJcuuSxBUZvylIyn0-89h8N4,1970
+exojax/utils/astrofunc.py,sha256=XsccVPSuZx12FUOzKF9TGtd7xoiM1i93AShGJ39JlEE,954
+exojax/utils/checkarray.py,sha256=tv3j0SPA68E1DVZhWzXoEmlVCF_j-U0CmlbPWT5SzbA,1281
+exojax/utils/constants.py,sha256=y7NbjOK6zqV4fsL-pvAbURwAeZJmexY-FvuhdB5NKHU,1967
+exojax/utils/files.py,sha256=cEkk8gY3byyJNIFQ97vDLp5xqWBvLrzl9p3NapFoz5I,1256
 exojax/utils/gpkernel.py,sha256=idyvKdM-l1C7D62fd6gEAzY8UEJCNbPtXQCDjuAYPxo,422
-exojax/utils/grids.py,sha256=4D2o4rtltEcCBZD1AKsHYyPe1T5M5C3GT3KdSDMCwko,6490
-exojax/utils/indexing.py,sha256=6fiyBQH7PF_hOZ0n32Ubk-pL6AXus42kkKlLwZt0dR0,5206
+exojax/utils/grids.py,sha256=lQcsYfgsAdZ-bbzQ91oMdMI7fQ5R2AWSy3ODXr6zVC0,6288
+exojax/utils/indexing.py,sha256=TQSeWd88qx_FlEp0k5vZSo2ZbOhkfxS03xG5v7MB9TY,4759
 exojax/utils/instfunc.py,sha256=PCcUFgArh4LWpDjX6NPq507lyJ2znrp88nbvLuatcsw,1554
+exojax/utils/interp.py,sha256=ZO7P0v9XZ3sUVfBbCReaPiNPVhagE8-YGo7ef8_D_i8,796
 exojax/utils/isodata.py,sha256=jGQbHmSWRSSW9nYZgn_Dpc45uR2lnCo11uUyBNdaOvc,902
 exojax/utils/isotopes.py,sha256=AG5rMmwUdxoTlxBvcpUbcNUgAw6W8pMX_jw_yW4hBu0,3326
-exojax/utils/jaxstatus.py,sha256=fxM9CwhrJNYRVdByEa3cgWcKZGpUeTNwu85EXz4neVo,900
-exojax/utils/memuse.py,sha256=pKitsDnorelKqnQka4AjfJ0DDDjffuYb61p93NEciPQ,5019
+exojax/utils/jaxstatus.py,sha256=jS4j724IQQMOYwtNJNscle9qgSa8svb1HEJFs4V2HZE,893
+exojax/utils/memuse.py,sha256=A2QGGjnSOiU0mhnciJaCaDRjYZ8Y5aTU6WpKVD61nT8,5012
 exojax/utils/mollabel.py,sha256=pF1e-Fl2QMtBPzYXT_bITt9SUmDjRvg_hnnhnGGD09I,4797
 exojax/utils/molname.py,sha256=pY6VlN-y90RGFRQ2GsDbB7oPBQxPC6mST2aSiTa2Pzc,7962
 exojax/utils/progbar.py,sha256=f5oHwikeCc0biWCCR2hPHjl6Hi1IC65-MHoFrw4VKgQ,565
 exojax/utils/recexomol.py,sha256=DHAFRGHLyzt5-KKTPdddhklk6xawUw3tY4Lw8nGTupY,1772
-exojax/utils/url.py,sha256=v3DLzjcX9NghAqvPmrfFp0nZKT8cdQf_ZNLoZQbRyyA,1599
+exojax/utils/url.py,sha256=suLnTzNp2Y8F2Eon7k-mIL6UYJsQvzbUuOT7Zx4TZt4,1858
 exojax/utils/zsol.py,sha256=qXYWRgp6wC16XT2SDqnzbKKyLt-dhSk_ZbbMHjBJXJI,4017
-ExoJAX-1.4.2.dist-info/LICENSE,sha256=B2rEBRqC5Oj9GvWxQICaSN_AogTm_zVmxr1ScJaxoXs,1081
-ExoJAX-1.4.2.dist-info/LICENSES_bundled.txt,sha256=pB2tFzmPh3jyMEFJ0LqQaHwe6jEWbqm3RV0dDlRXvzE,1635
-ExoJAX-1.4.2.dist-info/METADATA,sha256=gzvcU5AfAvBrtBYzgEbyKkKJGdYi8xrFDGtxilSFkWQ,5022
-ExoJAX-1.4.2.dist-info/WHEEL,sha256=bb2Ot9scclHKMOLDEHY6B2sicWOgugjFKaJsT7vwMQo,110
-ExoJAX-1.4.2.dist-info/top_level.txt,sha256=HtgN9sM-pSokm1nWRkfKTzgps-BOabizYbbHoqxcsvA,7
-ExoJAX-1.4.2.dist-info/RECORD,,
+ExoJAX-1.5.dist-info/LICENSE,sha256=B2rEBRqC5Oj9GvWxQICaSN_AogTm_zVmxr1ScJaxoXs,1081
+ExoJAX-1.5.dist-info/LICENSES_bundled.txt,sha256=-L2D15qWqjSBEklKd-MOFKLdicdb2ohg235F9D_y5uE,48407
+ExoJAX-1.5.dist-info/METADATA,sha256=wYNctVMyG1eXd59qAGeBg-t0_WCsyDRh7k4Z_GQfWCo,5561
+ExoJAX-1.5.dist-info/WHEEL,sha256=bb2Ot9scclHKMOLDEHY6B2sicWOgugjFKaJsT7vwMQo,110
+ExoJAX-1.5.dist-info/top_level.txt,sha256=HtgN9sM-pSokm1nWRkfKTzgps-BOabizYbbHoqxcsvA,7
+ExoJAX-1.5.dist-info/RECORD,,
```

