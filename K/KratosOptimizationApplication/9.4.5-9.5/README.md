# Comparing `tmp/KratosOptimizationApplication-9.4.5-cp39-cp39-win_amd64.whl.zip` & `tmp/KratosOptimizationApplication-9.5-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip`

## zipinfo -v {}

 * *Differences in extra fields detected; using output from zipinfo -v*

```diff
@@ -1,2192 +1,3549 @@
 There is no zipfile comment.
 
 End-of-central-directory record:
 -------------------------------
 
-  Zip archive file size:                   1520443 (000000000017333Bh)
-  Actual end-cent-dir record offset:       1520421 (0000000000173325h)
-  Expected end-cent-dir record offset:     1520421 (0000000000173325h)
+  Zip archive file size:                   4149848 (00000000003F5258h)
+  Actual end-cent-dir record offset:       4149826 (00000000003F5242h)
+  Expected end-cent-dir record offset:     4149826 (00000000003F5242h)
   (based on the length of the central directory and its expected offset)
 
   This zipfile constitutes the sole disk of a single-part archive; its
-  central directory contains 75 entries.
-  The central directory is 9178 (00000000000023DAh) bytes long,
+  central directory contains 96 entries.
+  The central directory is 13781 (00000000000035D5h) bytes long,
   and its (expected) offset in bytes from the beginning of the zipfile
-  is 1511243 (0000000000170F4Bh).
+  is 4136045 (00000000003F1C6Dh).
 
 
 Central directory entry #1:
 ---------------------------
 
-  KratosMultiphysics/.libs/KratosOptimizationApplication.pyd
+  KratosMultiphysics/
 
   offset of local header from start of archive:   0
                                                   (0000000000000000h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 10:30:28
-  32-bit CRC value (hex):                         ccccdcb4
-  compressed size:                                539292 bytes
-  uncompressed size:                              1787904 bytes
-  length of filename:                             58 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             19 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #2:
 ---------------------------
 
-  KratosMultiphysics/.libs/KratosOptimizationCore.dll
+  KratosMultiphysics/OptimizationApplication/
 
-  offset of local header from start of archive:   539380
-                                                  (0000000000083AF4h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   77
+                                                  (000000000000004Dh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 10:30:28
-  32-bit CRC value (hex):                         43d37145
-  compressed size:                                804872 bytes
-  uncompressed size:                              2697728 bytes
-  length of filename:                             51 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             43 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #3:
 ---------------------------
 
-  KratosMultiphysics/.libs/KratosOptimizationCore.lib
+  KratosMultiphysics/OptimizationApplication/controls_controller.py
 
-  offset of local header from start of archive:   1344333
-                                                  (000000000014834Dh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   178
+                                                  (00000000000000B2h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 10:30:28
-  32-bit CRC value (hex):                         1b7e0964
-  compressed size:                                56267 bytes
-  uncompressed size:                              902258 bytes
-  length of filename:                             51 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         c55d21be
+  compressed size:                                1881 bytes
+  uncompressed size:                              12333 bytes
+  length of filename:                             65 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #4:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/__init__.py
+  KratosMultiphysics/OptimizationApplication/processes/
 
-  offset of local header from start of archive:   1400681
-                                                  (0000000000155F69h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   2182
+                                                  (0000000000000886h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         aa76d121
-  compressed size:                                214 bytes
-  uncompressed size:                              797 bytes
-  length of filename:                             54 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             53 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #5:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/analyses_controller.py
+  KratosMultiphysics/OptimizationApplication/processes/optimization_problem_vtu_output_process.py
 
-  offset of local header from start of archive:   1400979
-                                                  (0000000000156093h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   2293
+                                                  (00000000000008F5h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         48f411a5
-  compressed size:                                953 bytes
-  uncompressed size:                              4205 bytes
-  length of filename:                             65 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         10916386
+  compressed size:                                2946 bytes
+  uncompressed size:                              13622 bytes
+  length of filename:                             95 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #6:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls_controller.py
+  KratosMultiphysics/OptimizationApplication/processes/optimization_problem_graph_output_process.py
 
-  offset of local header from start of archive:   1402027
-                                                  (00000000001564ABh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   5392
+                                                  (0000000000001510h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         5ec1eca0
-  compressed size:                                1897 bytes
-  uncompressed size:                              12537 bytes
-  length of filename:                             65 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         93426c24
+  compressed size:                                2297 bytes
+  uncompressed size:                              8614 bytes
+  length of filename:                             97 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #7:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/model_parts_controller.py
+  KratosMultiphysics/OptimizationApplication/processes/optimization_problem_ascii_output_process.py
 
-  offset of local header from start of archive:   1404019
-                                                  (0000000000156C73h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   7844
+                                                  (0000000000001EA4h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         9358bfbf
-  compressed size:                                989 bytes
-  uncompressed size:                              5354 bytes
-  length of filename:                             68 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         2699efff
+  compressed size:                                2450 bytes
+  uncompressed size:                              10644 bytes
+  length of filename:                             97 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #8:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/optimization_analysis.py
+  KratosMultiphysics/OptimizationApplication/model_part_controllers/
 
-  offset of local header from start of archive:   1405106
-                                                  (00000000001570B2h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   10449
+                                                  (00000000000028D1h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         b330af0f
-  compressed size:                                1316 bytes
-  uncompressed size:                              8423 bytes
-  length of filename:                             67 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             66 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #9:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/optimizations_controller.py
+  KratosMultiphysics/OptimizationApplication/model_part_controllers/mdpa_model_part_controller.py
 
-  offset of local header from start of archive:   1406519
-                                                  (0000000000157637h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   10573
+                                                  (000000000000294Dh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         6ce9d1ad
-  compressed size:                                2108 bytes
-  uncompressed size:                              12820 bytes
-  length of filename:                             70 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         cbb24a57
+  compressed size:                                689 bytes
+  uncompressed size:                              2190 bytes
+  length of filename:                             95 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #10:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/optimizer.py
+  KratosMultiphysics/OptimizationApplication/model_part_controllers/model_part_controller.py
 
-  offset of local header from start of archive:   1408727
-                                                  (0000000000157ED7h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   11415
+                                                  (0000000000002C97h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         5b7c4c17
-  compressed size:                                694 bytes
-  uncompressed size:                              3108 bytes
-  length of filename:                             55 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         436f48c7
+  compressed size:                                157 bytes
+  uncompressed size:                              355 bytes
+  length of filename:                             90 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #11:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses_controller.py
+  KratosMultiphysics/OptimizationApplication/model_part_controllers/connectivity_preserving_model_part_controller.py
 
-  offset of local header from start of archive:   1409506
-                                                  (00000000001581E2h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   11720
+                                                  (0000000000002DC8h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         389b5359
-  compressed size:                                3233 bytes
-  uncompressed size:                              23372 bytes
-  length of filename:                             66 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         c1a57344
+  compressed size:                                943 bytes
+  uncompressed size:                              3717 bytes
+  length of filename:                             114 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #12:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/algorithms/NLOPT_algorithms.py
+  KratosMultiphysics/OptimizationApplication/analyses_controller.py
 
-  offset of local header from start of archive:   1412835
-                                                  (0000000000158EE3h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   12835
+                                                  (0000000000003223h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         e1462591
-  compressed size:                                3009 bytes
-  uncompressed size:                              13643 bytes
-  length of filename:                             73 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         a4bb6dbf
+  compressed size:                                942 bytes
+  uncompressed size:                              4130 bytes
+  length of filename:                             65 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #13:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/algorithms/__init__.py
+  KratosMultiphysics/OptimizationApplication/model_parts_controller.py
 
-  offset of local header from start of archive:   1415947
-                                                  (0000000000159B0Bh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   13900
+                                                  (000000000000364Ch) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                2 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             65 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         0897c6af
+  compressed size:                                978 bytes
+  uncompressed size:                              5262 bytes
+  length of filename:                             68 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #14:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/algorithms/algorithm.py
+  KratosMultiphysics/OptimizationApplication/filtering/
 
-  offset of local header from start of archive:   1416044
-                                                  (0000000000159B6Ch) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   15004
+                                                  (0000000000003A9Ch) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         9631d540
-  compressed size:                                360 bytes
-  uncompressed size:                              1015 bytes
-  length of filename:                             66 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             53 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #15:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/algorithms/algorithm_base.py
+  KratosMultiphysics/OptimizationApplication/filtering/explicit_filter.py
 
-  offset of local header from start of archive:   1416500
-                                                  (0000000000159D34h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   15115
+                                                  (0000000000003B0Bh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         29e201d9
-  compressed size:                                3644 bytes
-  uncompressed size:                              24169 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         ade9754a
+  compressed size:                                1604 bytes
+  uncompressed size:                              6460 bytes
   length of filename:                             71 characters
-  length of extra field:                          0 bytes
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #16:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/algorithms/algorithm_gradient_projection.py
+  KratosMultiphysics/OptimizationApplication/filtering/filter_utils.py
 
-  offset of local header from start of archive:   1420245
-                                                  (000000000015ABD5h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   16848
+                                                  (00000000000041D0h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         4ebb0c67
-  compressed size:                                2569 bytes
-  uncompressed size:                              11993 bytes
-  length of filename:                             86 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         961b8367
+  compressed size:                                869 bytes
+  uncompressed size:                              3855 bytes
+  length of filename:                             68 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #17:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/algorithms/algorithm_steepest_descent.py
+  KratosMultiphysics/OptimizationApplication/filtering/helmholtz_scalar_solver.py
 
-  offset of local header from start of archive:   1422930
-                                                  (000000000015B652h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   17843
+                                                  (00000000000045B3h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         66111bf2
-  compressed size:                                1551 bytes
-  uncompressed size:                              6617 bytes
-  length of filename:                             83 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         9baa2d5b
+  compressed size:                                795 bytes
+  uncompressed size:                              2326 bytes
+  length of filename:                             79 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #18:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_constraint.py
+  KratosMultiphysics/OptimizationApplication/filtering/helmholtz_vector_solver.py
 
-  offset of local header from start of archive:   1424594
-                                                  (000000000015BCD2h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   18775
+                                                  (0000000000004957h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         ff265c3d
-  compressed size:                                2207 bytes
-  uncompressed size:                              9467 bytes
-  length of filename:                             86 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         d89770de
+  compressed size:                                799 bytes
+  uncompressed size:                              2346 bytes
+  length of filename:                             79 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #19:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_objective.py
+  KratosMultiphysics/OptimizationApplication/filtering/helmholtz_analysis.py
 
-  offset of local header from start of archive:   1426917
-                                                  (000000000015C5E5h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   19711
+                                                  (0000000000004CFFh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         fa918e8a
-  compressed size:                                2374 bytes
-  uncompressed size:                              9797 bytes
-  length of filename:                             85 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         91713ed1
+  compressed size:                                1678 bytes
+  uncompressed size:                              7080 bytes
+  length of filename:                             74 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #20:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/algorithms/standardized_constraint.py
+  KratosMultiphysics/OptimizationApplication/filtering/python_solvers_wrapper_implicit_filters.py
 
-  offset of local header from start of archive:   1429406
-                                                  (000000000015CF9Eh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   21521
+                                                  (0000000000005411h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         2856d098
-  compressed size:                                2090 bytes
-  uncompressed size:                              9272 bytes
-  length of filename:                             80 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         53173443
+  compressed size:                                683 bytes
+  uncompressed size:                              2809 bytes
+  length of filename:                             95 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #21:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/algorithms/standardized_objective.py
+  KratosMultiphysics/OptimizationApplication/filtering/filter.py
 
-  offset of local header from start of archive:   1431606
-                                                  (000000000015D836h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   22357
+                                                  (0000000000005755h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         5261057a
-  compressed size:                                1664 bytes
-  uncompressed size:                              6788 bytes
-  length of filename:                             79 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         5f8c7fda
+  compressed size:                                1872 bytes
+  uncompressed size:                              7742 bytes
+  length of filename:                             62 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #22:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/control.py
+  KratosMultiphysics/OptimizationApplication/filtering/helmholtz_solver_base.py
 
-  offset of local header from start of archive:   1433379
-                                                  (000000000015DF23h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   24349
+                                                  (0000000000005F1Dh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         4ee74e87
-  compressed size:                                1685 bytes
-  uncompressed size:                              6203 bytes
-  length of filename:                             62 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         6a03aa28
+  compressed size:                                3039 bytes
+  uncompressed size:                              12319 bytes
+  length of filename:                             77 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #23:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/master_control.py
+  KratosMultiphysics/OptimizationApplication/filtering/implicit_filter.py
 
-  offset of local header from start of archive:   1435156
-                                                  (000000000015E614h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   27523
+                                                  (0000000000006B83h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         5891bb83
-  compressed size:                                2234 bytes
-  uncompressed size:                              10153 bytes
-  length of filename:                             69 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         389072be
+  compressed size:                                2457 bytes
+  uncompressed size:                              11012 bytes
+  length of filename:                             71 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #24:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/material/__init__.py
+  KratosMultiphysics/OptimizationApplication/filtering/helmholtz_shape_solver.py
 
-  offset of local header from start of archive:   1437489
-                                                  (000000000015EF31h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   30109
+                                                  (000000000000759Dh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                2 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             72 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         56cb82b1
+  compressed size:                                1313 bytes
+  uncompressed size:                              3995 bytes
+  length of filename:                             78 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #25:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_material.py
+  KratosMultiphysics/OptimizationApplication/controls/
 
-  offset of local header from start of archive:   1437593
-                                                  (000000000015EF99h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   31558
+                                                  (0000000000007B46h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         e0c0db99
-  compressed size:                                1160 bytes
-  uncompressed size:                              4112 bytes
-  length of filename:                             82 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             52 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #26:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_partition.py
+  KratosMultiphysics/OptimizationApplication/controls/shape/
 
-  offset of local header from start of archive:   1438865
-                                                  (000000000015F491h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   31668
+                                                  (0000000000007BB4h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         ef40704c
-  compressed size:                                1040 bytes
-  uncompressed size:                              3564 bytes
-  length of filename:                             83 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             58 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #27:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/material/material_control.py
+  KratosMultiphysics/OptimizationApplication/controls/shape/vertex_morphing_shape_control.py
 
-  offset of local header from start of archive:   1440018
-                                                  (000000000015F912h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   31784
+                                                  (0000000000007C28h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         4b5c597b
-  compressed size:                                784 bytes
-  uncompressed size:                              3424 bytes
-  length of filename:                             80 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         ccbc284a
+  compressed size:                                3640 bytes
+  uncompressed size:                              16048 bytes
+  length of filename:                             90 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #28:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/material/material_properties_control.py
+  KratosMultiphysics/OptimizationApplication/controls/control.py
 
-  offset of local header from start of archive:   1440912
-                                                  (000000000015FC90h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   35572
+                                                  (0000000000008AF4h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         47e4878e
-  compressed size:                                1703 bytes
-  uncompressed size:                              6636 bytes
-  length of filename:                             91 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         c8b5e0ba
+  compressed size:                                1673 bytes
+  uncompressed size:                              6069 bytes
+  length of filename:                             62 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #29:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/shape/__init__.py
+  KratosMultiphysics/OptimizationApplication/controls/master_control.py
 
-  offset of local header from start of archive:   1442736
-                                                  (00000000001603B0h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   37365
+                                                  (00000000000091F5h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                2 bytes
-  uncompressed size:                              0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         b1bc470a
+  compressed size:                                2255 bytes
+  uncompressed size:                              10257 bytes
   length of filename:                             69 characters
-  length of extra field:                          0 bytes
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #30:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/shape/explicit_vertex_morphing.py
+  KratosMultiphysics/OptimizationApplication/controls/thickness/
 
-  offset of local header from start of archive:   1442837
-                                                  (0000000000160415h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   39747
+                                                  (0000000000009B43h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         fcdbad0f
-  compressed size:                                800 bytes
-  uncompressed size:                              2778 bytes
-  length of filename:                             85 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             62 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #31:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/shape/implicit_vertex_morphing.py
+  KratosMultiphysics/OptimizationApplication/controls/thickness/shell_thickness_control.py
 
-  offset of local header from start of archive:   1443752
-                                                  (00000000001607A8h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   39867
+                                                  (0000000000009BBBh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         8ef901db
-  compressed size:                                1711 bytes
-  uncompressed size:                              7395 bytes
-  length of filename:                             85 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         160e303d
+  compressed size:                                2782 bytes
+  uncompressed size:                              12544 bytes
+  length of filename:                             88 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #32:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/shape/shape_control.py
+  KratosMultiphysics/OptimizationApplication/controls/material/
 
-  offset of local header from start of archive:   1445578
-                                                  (0000000000160ECAh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   42795
+                                                  (000000000000A72Bh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         710ef7d1
-  compressed size:                                880 bytes
-  uncompressed size:                              3734 bytes
-  length of filename:                             74 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             61 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #33:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/shape/vertex_morphing_shape_control.py
+  KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_material.py
 
-  offset of local header from start of archive:   1446562
-                                                  (00000000001612A2h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   42914
+                                                  (000000000000A7A2h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         3d748d0f
-  compressed size:                                4079 bytes
-  uncompressed size:                              20431 bytes
-  length of filename:                             90 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         4d7f2d35
+  compressed size:                                1149 bytes
+  uncompressed size:                              4019 bytes
+  length of filename:                             82 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #34:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/thickness/helmholtz_thickness.py
+  KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_partition.py
 
-  offset of local header from start of archive:   1450761
-                                                  (0000000000162309h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   44203
+                                                  (000000000000ACABh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         e1efed7f
-  compressed size:                                1310 bytes
-  uncompressed size:                              4852 bytes
-  length of filename:                             84 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         01d39ba4
+  compressed size:                                1027 bytes
+  uncompressed size:                              3483 bytes
+  length of filename:                             83 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #35:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/thickness/shell_thickness_control.py
+  KratosMultiphysics/OptimizationApplication/controls/material/material_control.py
 
-  offset of local header from start of archive:   1452185
-                                                  (0000000000162899h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   45371
+                                                  (000000000000B13Bh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         f9ea6c74
-  compressed size:                                3319 bytes
-  uncompressed size:                              15302 bytes
-  length of filename:                             88 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         aecb306c
+  compressed size:                                777 bytes
+  uncompressed size:                              3353 bytes
+  length of filename:                             80 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #36:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/controls/thickness/thickness_control.py
+  KratosMultiphysics/OptimizationApplication/controls/material/material_properties_control.py
 
-  offset of local header from start of archive:   1455622
-                                                  (0000000000163606h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   46286
+                                                  (000000000000B4CEh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         687b7a02
-  compressed size:                                785 bytes
-  uncompressed size:                              3432 bytes
-  length of filename:                             82 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         e68edd15
+  compressed size:                                1691 bytes
+  uncompressed size:                              6537 bytes
+  length of filename:                             91 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #37:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy.py
+  KratosMultiphysics/OptimizationApplication/controls/material/__init__.py
 
-  offset of local header from start of archive:   1456519
-                                                  (0000000000163987h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  offset of local header from start of archive:   48126
+                                                  (000000000000BBFEh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         5858e367
-  compressed size:                                236 bytes
-  uncompressed size:                              642 bytes
-  length of filename:                             81 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             72 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #38:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy_decorator.py
+  KratosMultiphysics/OptimizationApplication/execution_policies/
 
-  offset of local header from start of archive:   1456866
-                                                  (0000000000163AE2h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   48256
+                                                  (000000000000BC80h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         6fd053cf
-  compressed size:                                854 bytes
-  uncompressed size:                              3332 bytes
-  length of filename:                             91 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             62 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #39:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/execution_policies/independent_analysis_execution_policy.py
+  KratosMultiphysics/OptimizationApplication/execution_policies/kratos_analysis_execution_policy.py
 
-  offset of local header from start of archive:   1457841
-                                                  (0000000000163EB1h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   48376
+                                                  (000000000000BCF8h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         c7f92a34
-  compressed size:                                1038 bytes
-  uncompressed size:                              4192 bytes
-  length of filename:                             102 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         609463eb
+  compressed size:                                1390 bytes
+  uncompressed size:                              6339 bytes
+  length of filename:                             97 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #40:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/execution_policies/kratos_analysis_execution_policy.py
+  KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy.py
 
-  offset of local header from start of archive:   1459011
-                                                  (0000000000164343h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   49921
+                                                  (000000000000C301h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         ba142c8f
-  compressed size:                                1400 bytes
-  uncompressed size:                              6449 bytes
-  length of filename:                             97 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         f589ca60
+  compressed size:                                458 bytes
+  uncompressed size:                              1199 bytes
+  length of filename:                             81 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #41:
 ---------------------------
 
   KratosMultiphysics/OptimizationApplication/execution_policies/stepping_analysis_execution_policy.py
 
-  offset of local header from start of archive:   1460538
-                                                  (000000000016493Ah) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   50518
+                                                  (000000000000C556h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         a1ef3095
-  compressed size:                                1105 bytes
-  uncompressed size:                              4191 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         6b1a39b1
+  compressed size:                                1091 bytes
+  uncompressed size:                              4103 bytes
   length of filename:                             99 characters
-  length of extra field:                          0 bytes
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #42:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/filtering/helmholtz_analysis.py
+  KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy_decorator.py
 
-  offset of local header from start of archive:   1461772
-                                                  (0000000000164E0Ch) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   51766
+                                                  (000000000000CA36h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         d2874ef7
-  compressed size:                                1781 bytes
-  uncompressed size:                              7361 bytes
-  length of filename:                             74 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         062639d8
+  compressed size:                                847 bytes
+  uncompressed size:                              3265 bytes
+  length of filename:                             91 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #43:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/filtering/helmholtz_scalar_solver.py
+  KratosMultiphysics/OptimizationApplication/execution_policies/independent_analysis_execution_policy.py
 
-  offset of local header from start of archive:   1463657
-                                                  (0000000000165569h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   52762
+                                                  (000000000000CE1Ah) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         a83c68f8
-  compressed size:                                786 bytes
-  uncompressed size:                              2512 bytes
-  length of filename:                             79 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         8486f9a6
+  compressed size:                                1029 bytes
+  uncompressed size:                              4114 bytes
+  length of filename:                             102 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #44:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/filtering/helmholtz_solver_base.py
+  KratosMultiphysics/OptimizationApplication/utilities/
 
-  offset of local header from start of archive:   1464552
-                                                  (00000000001658E8h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   53951
+                                                  (000000000000D2BFh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         becb4084
-  compressed size:                                2143 bytes
-  uncompressed size:                              8579 bytes
-  length of filename:                             77 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             53 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #45:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/filtering/helmholtz_vector_solver.py
+  KratosMultiphysics/OptimizationApplication/utilities/timer.py
 
-  offset of local header from start of archive:   1466802
-                                                  (00000000001661B2h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   54062
+                                                  (000000000000D32Eh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         ce22594b
-  compressed size:                                1542 bytes
-  uncompressed size:                              6510 bytes
-  length of filename:                             79 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         c490b171
+  compressed size:                                350 bytes
+  uncompressed size:                              1724 bytes
+  length of filename:                             61 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #46:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/filtering/python_solvers_wrapper_implicit_filters.py
+  KratosMultiphysics/OptimizationApplication/utilities/opt_convergence.py
 
-  offset of local header from start of archive:   1468453
-                                                  (0000000000166825h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   54531
+                                                  (000000000000D503h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         6bf84c3c
-  compressed size:                                667 bytes
-  uncompressed size:                              2597 bytes
-  length of filename:                             95 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         47712dd9
+  compressed size:                                1308 bytes
+  uncompressed size:                              8154 bytes
+  length of filename:                             71 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #47:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/model_part_controllers/mdpa_model_part_controller.py
+  KratosMultiphysics/OptimizationApplication/utilities/opt_line_search.py
 
-  offset of local header from start of archive:   1469245
-                                                  (0000000000166B3Dh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   55968
+                                                  (000000000000DAA0h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         f8705ed0
-  compressed size:                                696 bytes
-  uncompressed size:                              2234 bytes
-  length of filename:                             95 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         02eb05d3
+  compressed size:                                1399 bytes
+  uncompressed size:                              7247 bytes
+  length of filename:                             71 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #48:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/model_part_controllers/model_part_controller.py
+  KratosMultiphysics/OptimizationApplication/utilities/union_utilities.py
 
-  offset of local header from start of archive:   1470066
-                                                  (0000000000166E72h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   57496
+                                                  (000000000000E098h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         7db0946f
-  compressed size:                                165 bytes
-  uncompressed size:                              374 bytes
-  length of filename:                             90 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         c891d9d8
+  compressed size:                                218 bytes
+  uncompressed size:                              488 bytes
+  length of filename:                             71 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #49:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/processes/optimization_problem_ascii_output_process.py
+  KratosMultiphysics/OptimizationApplication/utilities/list_collective_expression_utilities.py
 
-  offset of local header from start of archive:   1470351
-                                                  (0000000000166F8Fh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   57843
+                                                  (000000000000E1F3h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         8eb4c023
-  compressed size:                                2466 bytes
-  uncompressed size:                              10851 bytes
-  length of filename:                             97 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         9b985861
+  compressed size:                                368 bytes
+  uncompressed size:                              1107 bytes
+  length of filename:                             92 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #50:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/processes/optimization_problem_vtu_output_process.py
+  KratosMultiphysics/OptimizationApplication/utilities/helper_utilities.py
 
-  offset of local header from start of archive:   1472944
-                                                  (00000000001679B0h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   58361
+                                                  (000000000000E3F9h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         a1dce922
-  compressed size:                                2965 bytes
-  uncompressed size:                              13852 bytes
-  length of filename:                             95 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         e07e9903
+  compressed size:                                1628 bytes
+  uncompressed size:                              6002 bytes
+  length of filename:                             72 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #51:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/__init__.py
+  KratosMultiphysics/OptimizationApplication/utilities/buffered_dict.py
 
-  offset of local header from start of archive:   1476034
-                                                  (00000000001685C2h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   60119
+                                                  (000000000000EAD7h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                2 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             64 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         0f2ade1e
+  compressed size:                                3854 bytes
+  uncompressed size:                              18108 bytes
+  length of filename:                             69 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #52:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/additive_manufacturing_responses.py
+  KratosMultiphysics/OptimizationApplication/utilities/logger_utilities.py
 
-  offset of local header from start of archive:   1476130
-                                                  (0000000000168622h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   64100
+                                                  (000000000000FA64h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         c878d782
-  compressed size:                                1946 bytes
-  uncompressed size:                              22408 bytes
-  length of filename:                             88 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         af6b6107
+  compressed size:                                1835 bytes
+  uncompressed size:                              7170 bytes
+  length of filename:                             72 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #53:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/analysis_based_response_function_factory.py
+  KratosMultiphysics/OptimizationApplication/utilities/optimization_problem.py
 
-  offset of local header from start of archive:   1478194
-                                                  (0000000000168E32h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   66065
+                                                  (0000000000010211h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         54a578fe
-  compressed size:                                239 bytes
-  uncompressed size:                              739 bytes
-  length of filename:                             96 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         2e7d026f
+  compressed size:                                1753 bytes
+  uncompressed size:                              7795 bytes
+  length of filename:                             76 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #54:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/analysis_free_response_function_factory.py
+  KratosMultiphysics/OptimizationApplication/utilities/model_part_utilities.py
 
-  offset of local header from start of archive:   1478559
-                                                  (0000000000168F9Fh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   67952
+                                                  (0000000000010970h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         03819a6f
-  compressed size:                                237 bytes
-  uncompressed size:                              820 bytes
-  length of filename:                             95 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         1deb8109
+  compressed size:                                2005 bytes
+  uncompressed size:                              7833 bytes
+  length of filename:                             76 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #55:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/base_response.py
+  KratosMultiphysics/OptimizationApplication/utilities/component_data_view.py
 
-  offset of local header from start of archive:   1478921
-                                                  (0000000000169109h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   70091
+                                                  (00000000000111CBh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         de58a10e
-  compressed size:                                733 bytes
-  uncompressed size:                              3342 bytes
-  length of filename:                             69 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         c01469c6
+  compressed size:                                896 bytes
+  uncompressed size:                              3385 bytes
+  length of filename:                             75 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #56:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/geometric_centroid_deviation_response_function.py
+  KratosMultiphysics/OptimizationApplication/responses_controller.py
 
-  offset of local header from start of archive:   1479753
-                                                  (0000000000169449h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   71120
+                                                  (00000000000115D0h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         cdd89411
-  compressed size:                                1544 bytes
-  uncompressed size:                              5940 bytes
-  length of filename:                             102 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         12e2f602
+  compressed size:                                3218 bytes
+  uncompressed size:                              22982 bytes
+  length of filename:                             66 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #57:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/linear_strain_energy_response_function.py
+  KratosMultiphysics/OptimizationApplication/responses/
 
-  offset of local header from start of archive:   1481429
-                                                  (0000000000169AD5h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   74462
+                                                  (00000000000122DEh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         d074f478
-  compressed size:                                1330 bytes
-  uncompressed size:                              4963 bytes
-  length of filename:                             94 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             53 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
-  MS-DOS file attributes (00 hex):                none
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
   There is no file comment.
 
 Central directory entry #58:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/mass_response_function.py
+  KratosMultiphysics/OptimizationApplication/responses/response_routine.py
 
-  offset of local header from start of archive:   1482883
-                                                  (000000000016A083h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   74573
+                                                  (000000000001234Dh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         1689fe59
-  compressed size:                                1161 bytes
-  uncompressed size:                              4143 bytes
-  length of filename:                             78 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         b223fdf7
+  compressed size:                                2049 bytes
+  uncompressed size:                              7447 bytes
+  length of filename:                             72 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #59:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/response_function.py
+  KratosMultiphysics/OptimizationApplication/responses/structural_responses.py
 
-  offset of local header from start of archive:   1484152
-                                                  (000000000016A578h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   76752
+                                                  (0000000000012BD0h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         9e489e43
-  compressed size:                                1314 bytes
-  uncompressed size:                              4826 bytes
-  length of filename:                             73 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         c5f9347d
+  compressed size:                                2292 bytes
+  uncompressed size:                              18372 bytes
+  length of filename:                             76 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #60:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/response_routine.py
+  KratosMultiphysics/OptimizationApplication/responses/analysis_based_response_function_factory.py
 
-  offset of local header from start of archive:   1485569
-                                                  (000000000016AB01h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   79178
+                                                  (000000000001354Ah) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         bae014f3
-  compressed size:                                2058 bytes
-  uncompressed size:                              7551 bytes
-  length of filename:                             72 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         437f6194
+  compressed size:                                235 bytes
+  uncompressed size:                              725 bytes
+  length of filename:                             96 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #61:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/responses/structural_responses.py
+  KratosMultiphysics/OptimizationApplication/responses/linear_strain_energy_response_function.py
 
-  offset of local header from start of archive:   1487729
-                                                  (000000000016B371h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   79567
+                                                  (00000000000136CFh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         188e537b
-  compressed size:                                2315 bytes
-  uncompressed size:                              18706 bytes
-  length of filename:                             76 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         5bad9206
+  compressed size:                                1321 bytes
+  uncompressed size:                              4879 bytes
+  length of filename:                             94 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #62:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/utilities/buffered_dict.py
+  KratosMultiphysics/OptimizationApplication/responses/base_response.py
 
-  offset of local header from start of archive:   1490150
-                                                  (000000000016BCE6h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   81040
+                                                  (0000000000013C90h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         8ce5647f
-  compressed size:                                3880 bytes
-  uncompressed size:                              18507 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         f4d4c7fa
+  compressed size:                                726 bytes
+  uncompressed size:                              3277 bytes
   length of filename:                             69 characters
-  length of extra field:                          0 bytes
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #63:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/utilities/component_data_view.py
+  KratosMultiphysics/OptimizationApplication/responses/geometric_centroid_deviation_response_function.py
 
-  offset of local header from start of archive:   1494129
-                                                  (000000000016CC71h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   81893
+                                                  (0000000000013FE5h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         648bcc04
-  compressed size:                                904 bytes
-  uncompressed size:                              3455 bytes
-  length of filename:                             75 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         7ac794a2
+  compressed size:                                1534 bytes
+  uncompressed size:                              5835 bytes
+  length of filename:                             102 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #64:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/utilities/helper_utilities.py
+  KratosMultiphysics/OptimizationApplication/responses/response_function.py
 
-  offset of local header from start of archive:   1495138
-                                                  (000000000016D062h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   83587
+                                                  (0000000000014683h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         2537f33f
-  compressed size:                                1640 bytes
-  uncompressed size:                              6120 bytes
-  length of filename:                             72 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         f6a6642b
+  compressed size:                                1301 bytes
+  uncompressed size:                              4712 bytes
+  length of filename:                             73 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #65:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/utilities/logger_utilities.py
+  KratosMultiphysics/OptimizationApplication/responses/additive_manufacturing_responses.py
 
-  offset of local header from start of archive:   1496880
-                                                  (000000000016D730h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   85019
+                                                  (0000000000014C1Bh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         9ac03f9b
-  compressed size:                                1847 bytes
-  uncompressed size:                              7350 bytes
-  length of filename:                             72 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         63fb549c
+  compressed size:                                1946 bytes
+  uncompressed size:                              21998 bytes
+  length of filename:                             88 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #66:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/utilities/model_part_utilities.py
+  KratosMultiphysics/OptimizationApplication/responses/mass_response_function.py
 
-  offset of local header from start of archive:   1498829
-                                                  (000000000016DECDh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   87111
+                                                  (0000000000015447h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         792b52bf
-  compressed size:                                2010 bytes
-  uncompressed size:                              7937 bytes
-  length of filename:                             76 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         308b3d7c
+  compressed size:                                1200 bytes
+  uncompressed size:                              4344 bytes
+  length of filename:                             78 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
 Central directory entry #67:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/utilities/opt_convergence.py
+  KratosMultiphysics/OptimizationApplication/responses/__init__.py
+
+  offset of local header from start of archive:   88447
+                                                  (000000000001597Fh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             64 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             binary
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #68:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/responses/analysis_free_response_function_factory.py
 
-  offset of local header from start of archive:   1500945
-                                                  (000000000016E711h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   88569
+                                                  (00000000000159F9h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         95e2350e
-  compressed size:                                888 bytes
-  uncompressed size:                              3728 bytes
-  length of filename:                             71 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         67f1fe82
+  compressed size:                                234 bytes
+  uncompressed size:                              807 bytes
+  length of filename:                             95 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
-Central directory entry #68:
+Central directory entry #69:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/utilities/opt_line_search.py
+  KratosMultiphysics/OptimizationApplication/optimization_analysis.py
 
-  offset of local header from start of archive:   1501934
-                                                  (000000000016EAEEh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   88956
+                                                  (0000000000015B7Ch) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         39a41ae7
-  compressed size:                                1429 bytes
-  uncompressed size:                              7553 bytes
-  length of filename:                             71 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         a4cd32d0
+  compressed size:                                1264 bytes
+  uncompressed size:                              7739 bytes
+  length of filename:                             67 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #70:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/
+
+  offset of local header from start of archive:   90345
+                                                  (00000000000160E9h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             54 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #71:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/NLOPT_algorithms.py
+
+  offset of local header from start of archive:   90457
+                                                  (0000000000016159h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         fb6957eb
+  compressed size:                                3007 bytes
+  uncompressed size:                              13524 bytes
+  length of filename:                             73 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
-Central directory entry #69:
+Central directory entry #72:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/utilities/optimization_problem.py
+  KratosMultiphysics/OptimizationApplication/algorithms/algorithm_momentum_relaxed_gradient_projection.py
 
-  offset of local header from start of archive:   1503464
-                                                  (000000000016F0E8h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   93595
+                                                  (0000000000016D9Bh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         1446eed4
-  compressed size:                                1767 bytes
-  uncompressed size:                              7970 bytes
-  length of filename:                             76 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         83dec7ee
+  compressed size:                                1001 bytes
+  uncompressed size:                              3131 bytes
+  length of filename:                             103 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
-Central directory entry #70:
+Central directory entry #73:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/utilities/timer.py
+  KratosMultiphysics/OptimizationApplication/algorithms/algorithm_nesterov_accelarated_gradient.py
 
-  offset of local header from start of archive:   1505337
-                                                  (000000000016F839h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   94757
+                                                  (0000000000017225h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         257f40f2
-  compressed size:                                355 bytes
-  uncompressed size:                              1769 bytes
-  length of filename:                             61 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         8c4455bf
+  compressed size:                                883 bytes
+  uncompressed size:                              2722 bytes
+  length of filename:                             96 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
-Central directory entry #71:
+Central directory entry #74:
 ---------------------------
 
-  KratosMultiphysics/OptimizationApplication/utilities/union_utilities.py
+  KratosMultiphysics/OptimizationApplication/algorithms/standardized_constraint.py
+
+  offset of local header from start of archive:   95794
+                                                  (0000000000017632h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         66b5a394
+  compressed size:                                2074 bytes
+  uncompressed size:                              9105 bytes
+  length of filename:                             80 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #75:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_constraint.py
+
+  offset of local header from start of archive:   98006
+                                                  (0000000000017ED6h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         2dcb8a07
+  compressed size:                                2193 bytes
+  uncompressed size:                              9283 bytes
+  length of filename:                             86 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #76:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/algorithm_steepest_descent.py
+
+  offset of local header from start of archive:   100343
+                                                  (00000000000187F7h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         08aed5f6
+  compressed size:                                1545 bytes
+  uncompressed size:                              6538 bytes
+  length of filename:                             83 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
 
-  offset of local header from start of archive:   1505783
-                                                  (000000000016F9F7h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  There is no file comment.
+
+Central directory entry #77:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/algorithm.py
+
+  offset of local header from start of archive:   102029
+                                                  (0000000000018E8Dh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 09:09:32
-  32-bit CRC value (hex):                         bd13d6a8
-  compressed size:                                225 bytes
-  uncompressed size:                              498 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         3acd0bc5
+  compressed size:                                983 bytes
+  uncompressed size:                              3185 bytes
+  length of filename:                             66 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #78:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/algorithm_gradient_projection.py
+
+  offset of local header from start of archive:   103136
+                                                  (00000000000192E0h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         21080d9b
+  compressed size:                                2369 bytes
+  uncompressed size:                              11017 bytes
+  length of filename:                             86 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #79:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/algorithm_relaxed_gradient_projection.py
+
+  offset of local header from start of archive:   105649
+                                                  (0000000000019CB1h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         4d134bd3
+  compressed size:                                3268 bytes
+  uncompressed size:                              15556 bytes
+  length of filename:                             94 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #80:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/algorithm_base.py
+
+  offset of local header from start of archive:   109069
+                                                  (000000000001AA0Dh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         9d3af030
+  compressed size:                                3635 bytes
+  uncompressed size:                              23776 bytes
   length of filename:                             71 characters
-  length of extra field:                          0 bytes
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #81:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/standardized_rgp_constraint.py
+
+  offset of local header from start of archive:   112833
+                                                  (000000000001B8C1h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         a5b9153b
+  compressed size:                                2863 bytes
+  uncompressed size:                              12915 bytes
+  length of filename:                             84 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #82:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/standardized_objective.py
+
+  offset of local header from start of archive:   115838
+                                                  (000000000001C47Eh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         c9483223
+  compressed size:                                1659 bytes
+  uncompressed size:                              6717 bytes
+  length of filename:                             79 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #83:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/algorithms/__init__.py
+
+  offset of local header from start of archive:   117634
+                                                  (000000000001CB82h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             65 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
-Central directory entry #72:
+Central directory entry #84:
 ---------------------------
 
-  KratosOptimizationApplication-9.4.5.dist-info/METADATA
+  KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_objective.py
 
-  offset of local header from start of archive:   1506109
-                                                  (000000000016FB3Dh) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   117757
+                                                  (000000000001CBFDh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 10:30:28
-  32-bit CRC value (hex):                         95cc373c
-  compressed size:                                993 bytes
-  uncompressed size:                              2399 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         2e1e4f5c
+  compressed size:                                2359 bytes
+  uncompressed size:                              9617 bytes
+  length of filename:                             85 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #85:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/__init__.py
+
+  offset of local header from start of archive:   120259
+                                                  (000000000001D5C3h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         4d4ccb40
+  compressed size:                                210 bytes
+  uncompressed size:                              779 bytes
   length of filename:                             54 characters
-  length of extra field:                          0 bytes
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
-Central directory entry #73:
+Central directory entry #86:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/optimizations_controller.py
+
+  offset of local header from start of archive:   120581
+                                                  (000000000001D705h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         a607d049
+  compressed size:                                2095 bytes
+  uncompressed size:                              12597 bytes
+  length of filename:                             70 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #87:
+---------------------------
+
+  KratosMultiphysics/OptimizationApplication/optimizer.py
+
+  offset of local header from start of archive:   122804
+                                                  (000000000001DFB4h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         505f50f6
+  compressed size:                                682 bytes
+  uncompressed size:                              3047 bytes
+  length of filename:                             55 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #88:
+---------------------------
+
+  KratosMultiphysics/.libs/
+
+  offset of local header from start of archive:   123599
+                                                  (000000000001E2CFh) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:56
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:55 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:55 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             25 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             binary
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #89:
 ---------------------------
 
-  KratosOptimizationApplication-9.4.5.dist-info/WHEEL
+  KratosMultiphysics/.libs/KratosOptimizationApplication.cpython-39-x86_64-linux-gnu.so
 
-  offset of local header from start of archive:   1507186
-                                                  (000000000016FF72h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   123682
+                                                  (000000000001E322h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 10:30:28
-  32-bit CRC value (hex):                         1ad59a98
-  compressed size:                                96 bytes
-  uncompressed size:                              100 bytes
-  length of filename:                             51 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         736692c6
+  compressed size:                                1447088 bytes
+  uncompressed size:                              4162097 bytes
+  length of filename:                             85 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  Unix file attributes (100755 octal):            -rwxr-xr-x
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
-Central directory entry #74:
+Central directory entry #90:
+---------------------------
+
+  KratosOptimizationApplication-9.5.dist-info/
+
+  offset of local header from start of archive:   1570913
+                                                  (000000000017F861h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:56
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:55 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:55 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             44 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             binary
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #91:
 ---------------------------
 
-  KratosOptimizationApplication-9.4.5.dist-info/top_level.txt
+  KratosOptimizationApplication-9.5.dist-info/METADATA
 
-  offset of local header from start of archive:   1507363
-                                                  (0000000000170023h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   1571015
+                                                  (000000000017F8C7h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 10:30:28
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         51dc494e
+  compressed size:                                974 bytes
+  uncompressed size:                              2353 bytes
+  length of filename:                             52 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #92:
+---------------------------
+
+  KratosOptimizationApplication-9.5.dist-info/WHEEL
+
+  offset of local header from start of archive:   1572099
+                                                  (000000000017FD03h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         90d34e0d
+  compressed size:                                116 bytes
+  uncompressed size:                              148 bytes
+  length of filename:                             49 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #93:
+---------------------------
+
+  KratosOptimizationApplication-9.5.dist-info/top_level.txt
+
+  offset of local header from start of archive:   1572322
+                                                  (000000000017FDE2h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
   32-bit CRC value (hex):                         f32d789f
-  compressed size:                                21 bytes
+  compressed size:                                19 bytes
   uncompressed size:                              19 bytes
-  length of filename:                             59 characters
-  length of extra field:                          0 bytes
+  length of filename:                             57 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  non-MSDOS external file attributes:             81B600 hex
+  apparent file type:                             text
+  Unix file attributes (100644 octal):            -rw-r--r--
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
 
-Central directory entry #75:
+Central directory entry #94:
 ---------------------------
 
-  KratosOptimizationApplication-9.4.5.dist-info/RECORD
+  KratosOptimizationApplication-9.5.dist-info/RECORD
 
-  offset of local header from start of archive:   1507473
-                                                  (0000000000170091h) bytes
-  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
-  version of encoding software:                   2.0
+  offset of local header from start of archive:   1572456
+                                                  (000000000017FE68h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Jan 10 10:30:28
-  32-bit CRC value (hex):                         d943909f
-  compressed size:                                3688 bytes
-  uncompressed size:                              9950 bytes
-  length of filename:                             52 characters
-  length of extra field:                          0 bytes
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:56
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:55 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:55 UTC
+  32-bit CRC value (hex):                         7e97f3aa
+  compressed size:                                4129 bytes
+  uncompressed size:                              10977 bytes
+  length of filename:                             50 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             text
+  Unix file attributes (100664 octal):            -rw-rw-r--
+  MS-DOS file attributes (00 hex):                none
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #95:
+---------------------------
+
+  KratosOptimizationApplication.libs/
+
+  offset of local header from start of archive:   1576693
+                                                  (0000000000180EF5h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   1.0
+  compression method:                             none (stored)
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:56
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:55 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:55 UTC
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                0 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             35 characters
+  length of extra field:                          24 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  non-MSDOS external file attributes:             01B400 hex
+  Unix file attributes (040755 octal):            drwxr-xr-x
+  MS-DOS file attributes (10 hex):                dir 
+
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
+  There is no file comment.
+
+Central directory entry #96:
+---------------------------
+
+  KratosOptimizationApplication.libs/libKratosOptimizationCore-c5761cae.so
+
+  offset of local header from start of archive:   1576786
+                                                  (0000000000180F52h) bytes
+  file system or operating system of origin:      Unix
+  version of encoding software:                   3.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
+  file security status:                           not encrypted
+  extended local header:                          no
+  file last modified on (DOS date/time):          2024 Apr 25 16:00:48
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 local
+  file last modified on (UT extra field modtime): 2024 Apr 25 16:00:48 UTC
+  32-bit CRC value (hex):                         ad5e03ab
+  compressed size:                                2559129 bytes
+  uncompressed size:                              10895897 bytes
+  length of filename:                             72 characters
+  length of extra field:                          24 bytes
+  length of file comment:                         0 characters
+  disk number on which file begins:               disk 1
+  apparent file type:                             binary
+  Unix file attributes (100755 octal):            -rwxr-xr-x
   MS-DOS file attributes (00 hex):                none
 
+  The central-directory extra field contains:
+  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
+    The local extra field has UTC/GMT modification/access times.
+  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
+    01 04 00 00 00 00 04 00 00 00 00.
+
   There is no file comment.
```

## zipnote {}

```diff
@@ -1,226 +1,289 @@
-Filename: KratosMultiphysics/.libs/KratosOptimizationApplication.pyd
+Filename: KratosMultiphysics/
 Comment: 
 
-Filename: KratosMultiphysics/.libs/KratosOptimizationCore.dll
+Filename: KratosMultiphysics/OptimizationApplication/
 Comment: 
 
-Filename: KratosMultiphysics/.libs/KratosOptimizationCore.lib
+Filename: KratosMultiphysics/OptimizationApplication/controls_controller.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/__init__.py
+Filename: KratosMultiphysics/OptimizationApplication/processes/
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/analyses_controller.py
+Filename: KratosMultiphysics/OptimizationApplication/processes/optimization_problem_vtu_output_process.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/controls_controller.py
+Filename: KratosMultiphysics/OptimizationApplication/processes/optimization_problem_graph_output_process.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/processes/optimization_problem_ascii_output_process.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/model_part_controllers/
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/model_part_controllers/mdpa_model_part_controller.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/model_part_controllers/model_part_controller.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/model_part_controllers/connectivity_preserving_model_part_controller.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/analyses_controller.py
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/model_parts_controller.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/optimization_analysis.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/optimizations_controller.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/explicit_filter.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/optimizer.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/filter_utils.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/responses_controller.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/helmholtz_scalar_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/algorithms/NLOPT_algorithms.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/helmholtz_vector_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/algorithms/__init__.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/helmholtz_analysis.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/python_solvers_wrapper_implicit_filters.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm_base.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/filter.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm_gradient_projection.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/helmholtz_solver_base.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm_steepest_descent.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/implicit_filter.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_constraint.py
+Filename: KratosMultiphysics/OptimizationApplication/filtering/helmholtz_shape_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_objective.py
+Filename: KratosMultiphysics/OptimizationApplication/controls/
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/algorithms/standardized_constraint.py
+Filename: KratosMultiphysics/OptimizationApplication/controls/shape/
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/algorithms/standardized_objective.py
+Filename: KratosMultiphysics/OptimizationApplication/controls/shape/vertex_morphing_shape_control.py
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/controls/control.py
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/controls/master_control.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/controls/material/__init__.py
+Filename: KratosMultiphysics/OptimizationApplication/controls/thickness/
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/controls/thickness/shell_thickness_control.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/controls/material/
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_material.py
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_partition.py
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/controls/material/material_control.py
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/controls/material/material_properties_control.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/controls/shape/__init__.py
-Comment: 
-
-Filename: KratosMultiphysics/OptimizationApplication/controls/shape/explicit_vertex_morphing.py
+Filename: KratosMultiphysics/OptimizationApplication/controls/material/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/controls/shape/implicit_vertex_morphing.py
+Filename: KratosMultiphysics/OptimizationApplication/execution_policies/
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/controls/shape/shape_control.py
+Filename: KratosMultiphysics/OptimizationApplication/execution_policies/kratos_analysis_execution_policy.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/controls/shape/vertex_morphing_shape_control.py
+Filename: KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/controls/thickness/helmholtz_thickness.py
+Filename: KratosMultiphysics/OptimizationApplication/execution_policies/stepping_analysis_execution_policy.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/controls/thickness/shell_thickness_control.py
+Filename: KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy_decorator.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/controls/thickness/thickness_control.py
+Filename: KratosMultiphysics/OptimizationApplication/execution_policies/independent_analysis_execution_policy.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy_decorator.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/timer.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/execution_policies/independent_analysis_execution_policy.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/opt_convergence.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/execution_policies/kratos_analysis_execution_policy.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/opt_line_search.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/execution_policies/stepping_analysis_execution_policy.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/union_utilities.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/filtering/helmholtz_analysis.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/list_collective_expression_utilities.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/filtering/helmholtz_scalar_solver.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/helper_utilities.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/filtering/helmholtz_solver_base.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/buffered_dict.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/filtering/helmholtz_vector_solver.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/logger_utilities.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/filtering/python_solvers_wrapper_implicit_filters.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/optimization_problem.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/model_part_controllers/mdpa_model_part_controller.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/model_part_utilities.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/model_part_controllers/model_part_controller.py
+Filename: KratosMultiphysics/OptimizationApplication/utilities/component_data_view.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/processes/optimization_problem_ascii_output_process.py
+Filename: KratosMultiphysics/OptimizationApplication/responses_controller.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/processes/optimization_problem_vtu_output_process.py
+Filename: KratosMultiphysics/OptimizationApplication/responses/
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/responses/__init__.py
+Filename: KratosMultiphysics/OptimizationApplication/responses/response_routine.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/responses/additive_manufacturing_responses.py
+Filename: KratosMultiphysics/OptimizationApplication/responses/structural_responses.py
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/responses/analysis_based_response_function_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/responses/analysis_free_response_function_factory.py
+Filename: KratosMultiphysics/OptimizationApplication/responses/linear_strain_energy_response_function.py
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/responses/base_response.py
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/responses/geometric_centroid_deviation_response_function.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/responses/linear_strain_energy_response_function.py
+Filename: KratosMultiphysics/OptimizationApplication/responses/response_function.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/responses/additive_manufacturing_responses.py
 Comment: 
 
 Filename: KratosMultiphysics/OptimizationApplication/responses/mass_response_function.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/responses/response_function.py
+Filename: KratosMultiphysics/OptimizationApplication/responses/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/responses/response_routine.py
+Filename: KratosMultiphysics/OptimizationApplication/responses/analysis_free_response_function_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/responses/structural_responses.py
+Filename: KratosMultiphysics/OptimizationApplication/optimization_analysis.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/utilities/buffered_dict.py
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/utilities/component_data_view.py
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/NLOPT_algorithms.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/utilities/helper_utilities.py
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm_momentum_relaxed_gradient_projection.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/utilities/logger_utilities.py
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm_nesterov_accelarated_gradient.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/utilities/model_part_utilities.py
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/standardized_constraint.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/utilities/opt_convergence.py
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_constraint.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/utilities/opt_line_search.py
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm_steepest_descent.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/utilities/optimization_problem.py
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/utilities/timer.py
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm_gradient_projection.py
 Comment: 
 
-Filename: KratosMultiphysics/OptimizationApplication/utilities/union_utilities.py
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm_relaxed_gradient_projection.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/algorithm_base.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/standardized_rgp_constraint.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/standardized_objective.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/__init__.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_objective.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/__init__.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/optimizations_controller.py
+Comment: 
+
+Filename: KratosMultiphysics/OptimizationApplication/optimizer.py
+Comment: 
+
+Filename: KratosMultiphysics/.libs/
+Comment: 
+
+Filename: KratosMultiphysics/.libs/KratosOptimizationApplication.cpython-39-x86_64-linux-gnu.so
+Comment: 
+
+Filename: KratosOptimizationApplication-9.5.dist-info/
+Comment: 
+
+Filename: KratosOptimizationApplication-9.5.dist-info/METADATA
+Comment: 
+
+Filename: KratosOptimizationApplication-9.5.dist-info/WHEEL
 Comment: 
 
-Filename: KratosOptimizationApplication-9.4.5.dist-info/METADATA
+Filename: KratosOptimizationApplication-9.5.dist-info/top_level.txt
 Comment: 
 
-Filename: KratosOptimizationApplication-9.4.5.dist-info/WHEEL
+Filename: KratosOptimizationApplication-9.5.dist-info/RECORD
 Comment: 
 
-Filename: KratosOptimizationApplication-9.4.5.dist-info/top_level.txt
+Filename: KratosOptimizationApplication.libs/
 Comment: 
 
-Filename: KratosOptimizationApplication-9.4.5.dist-info/RECORD
+Filename: KratosOptimizationApplication.libs/libKratosOptimizationCore-c5761cae.so
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v1.0 to extract, compression method=store
```

## KratosMultiphysics/OptimizationApplication/__init__.py

 * *Ordering differences only*

```diff
@@ -1,19 +1,19 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ==============================================================================
-
-# ------------------------------------------------------------------------------
-# Imports
-# ------------------------------------------------------------------------------
-from KratosMultiphysics import _ImportApplication
-from KratosOptimizationApplication import *
-application = KratosOptimizationApplication()
-application_name = "KratosOptimizationApplication"
-
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ==============================================================================
+
+# ------------------------------------------------------------------------------
+# Imports
+# ------------------------------------------------------------------------------
+from KratosMultiphysics import _ImportApplication
+from KratosOptimizationApplication import *
+application = KratosOptimizationApplication()
+application_name = "KratosOptimizationApplication"
+
 _ImportApplication(application, application_name)
```

## KratosMultiphysics/OptimizationApplication/analyses_controller.py

 * *Ordering differences only*

```diff
@@ -1,75 +1,75 @@
-#    |  /           |
-#    ' /   __| _` | __|  _ \   __|
-#    . \  |   (   | |   (   |\__ `
-#   _|\_\_|  \__,_|\__|\___/ ____/
-#                   Multi-Physics
-#
-#  License:		 BSD License
-#					 license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#                   Suneth Warnakulasuriya
-#
-
-# additional imports
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy_decorator import ExecutionPolicyDecorator
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
-
-# ==============================================================================
-def CreateController(execution_policies_settings,model,model_parts_controller):
-    return AnalysesController(execution_policies_settings,model,model_parts_controller)
-
-# ==============================================================================
-class AnalysesController:
-    # --------------------------------------------------------------------------
-    def __init__(self, execution_policies_settings, model, model_parts_controller):
-        self.execution_policies_settings = execution_policies_settings
-        self.model_parts_controller = model_parts_controller
-        self.model = model
-
-        self.execution_policy_decorators = {}
-        for execution_policy_settings in self.execution_policies_settings:
-            execution_policy_wrapper = ExecutionPolicyDecorator(self.model, execution_policy_settings, OptimizationProblem())
-            if not execution_policy_wrapper.GetName() in self.execution_policy_decorators.keys():
-                self.execution_policy_decorators[execution_policy_wrapper.GetName()] = execution_policy_wrapper
-            else:
-                raise RuntimeError(f"Found already existing execution policy with the name \"{execution_policy_wrapper.GetExecutionPolicyName()}\". Please provide unique names.")
-
-    # --------------------------------------------------------------------------
-    def GetExecutionPolicyDecorator(self, execution_policy_name: str) -> ExecutionPolicyDecorator:
-        if not execution_policy_name in self.execution_policy_decorators.keys():
-            raise RuntimeError("AnalysesController: Try to get an execution policy {} which does not exist.".format(execution_policy_name))
-        else:
-            return self.execution_policy_decorators[execution_policy_name]
-
-    # --------------------------------------------------------------------------
-    def GetAnalysis(self, execution_policy_name: str):
-        return self.GetExecutionPolicyDecorator(execution_policy_name).GetExecutionPolicy().analysis
-
-    # --------------------------------------------------------------------------
-    def Initialize(self):
-        for execution_policy_wrapper in self.execution_policy_decorators.values():
-            execution_policy_name = execution_policy_wrapper.GetName()
-            with TimeLogger(self.__class__.__name__, f"Initializing {execution_policy_name}...", f"Finished initializing {execution_policy_name}"):
-                execution_policy_wrapper.Initialize()
-
-    # --------------------------------------------------------------------------
-    def RunAnalysis(self, execution_policy_name: str):
-        with TimeLogger(self.__class__.__name__, f"Starting {execution_policy_name}...", f"Finished execution of {execution_policy_name}."):
-            self.GetExecutionPolicyDecorator(execution_policy_name).Execute()
-
-    # --------------------------------------------------------------------------
-    def RunAll(self):
-        for name in self.analyses.keys():
-            self.RunAnalysis(name)
-
-    # --------------------------------------------------------------------------
-    def RunAnalyses(self, analyses_name):
-        if not isinstance(analyses_name, list):
-            raise RuntimeError("AnalysesController: RunAnalyses requires list of analysis names")
-        for analysis_name in analyses_name:
-            self.RunAnalysis(analysis_name)
-
-
-
+#    |  /           |
+#    ' /   __| _` | __|  _ \   __|
+#    . \  |   (   | |   (   |\__ `
+#   _|\_\_|  \__,_|\__|\___/ ____/
+#                   Multi-Physics
+#
+#  License:		 BSD License
+#					 license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#                   Suneth Warnakulasuriya
+#
+
+# additional imports
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy_decorator import ExecutionPolicyDecorator
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
+
+# ==============================================================================
+def CreateController(execution_policies_settings,model,model_parts_controller):
+    return AnalysesController(execution_policies_settings,model,model_parts_controller)
+
+# ==============================================================================
+class AnalysesController:
+    # --------------------------------------------------------------------------
+    def __init__(self, execution_policies_settings, model, model_parts_controller):
+        self.execution_policies_settings = execution_policies_settings
+        self.model_parts_controller = model_parts_controller
+        self.model = model
+
+        self.execution_policy_decorators = {}
+        for execution_policy_settings in self.execution_policies_settings:
+            execution_policy_wrapper = ExecutionPolicyDecorator(self.model, execution_policy_settings, OptimizationProblem())
+            if not execution_policy_wrapper.GetName() in self.execution_policy_decorators.keys():
+                self.execution_policy_decorators[execution_policy_wrapper.GetName()] = execution_policy_wrapper
+            else:
+                raise RuntimeError(f"Found already existing execution policy with the name \"{execution_policy_wrapper.GetExecutionPolicyName()}\". Please provide unique names.")
+
+    # --------------------------------------------------------------------------
+    def GetExecutionPolicyDecorator(self, execution_policy_name: str) -> ExecutionPolicyDecorator:
+        if not execution_policy_name in self.execution_policy_decorators.keys():
+            raise RuntimeError("AnalysesController: Try to get an execution policy {} which does not exist.".format(execution_policy_name))
+        else:
+            return self.execution_policy_decorators[execution_policy_name]
+
+    # --------------------------------------------------------------------------
+    def GetAnalysis(self, execution_policy_name: str):
+        return self.GetExecutionPolicyDecorator(execution_policy_name).GetExecutionPolicy().analysis
+
+    # --------------------------------------------------------------------------
+    def Initialize(self):
+        for execution_policy_wrapper in self.execution_policy_decorators.values():
+            execution_policy_name = execution_policy_wrapper.GetName()
+            with TimeLogger(self.__class__.__name__, f"Initializing {execution_policy_name}...", f"Finished initializing {execution_policy_name}"):
+                execution_policy_wrapper.Initialize()
+
+    # --------------------------------------------------------------------------
+    def RunAnalysis(self, execution_policy_name: str):
+        with TimeLogger(self.__class__.__name__, f"Starting {execution_policy_name}...", f"Finished execution of {execution_policy_name}."):
+            self.GetExecutionPolicyDecorator(execution_policy_name).Execute()
+
+    # --------------------------------------------------------------------------
+    def RunAll(self):
+        for name in self.analyses.keys():
+            self.RunAnalysis(name)
+
+    # --------------------------------------------------------------------------
+    def RunAnalyses(self, analyses_name):
+        if not isinstance(analyses_name, list):
+            raise RuntimeError("AnalysesController: RunAnalyses requires list of analysis names")
+        for analysis_name in analyses_name:
+            self.RunAnalysis(analysis_name)
+
+
+
```

## KratosMultiphysics/OptimizationApplication/controls_controller.py

 * *Ordering differences only*

```diff
@@ -1,205 +1,205 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ==============================================================================
-
-# additional imports
-import KratosMultiphysics as KM 
-import KratosMultiphysics.OptimizationApplication.controls.shape.explicit_vertex_morphing as evm
-import KratosMultiphysics.OptimizationApplication.controls.shape.implicit_vertex_morphing as ivm
-import KratosMultiphysics.OptimizationApplication.controls.thickness.helmholtz_thickness as hlt
-import KratosMultiphysics.OptimizationApplication.controls.material.helmholtz_material as hlm
-import KratosMultiphysics.OptimizationApplication.controls.material.helmholtz_partition as hlp
-
-# ==============================================================================
-def CreateController(controls_settings,model,model_parts_controller):
-    return ControlsController(controls_settings,model,model_parts_controller)
-
-# ==============================================================================
-class ControlsController:
-    # --------------------------------------------------------------------------
-    def __init__(self,controls_settings,model,model_parts_controller):
-        
-        self.controls_settings = controls_settings
-        self.model_parts_controller = model_parts_controller
-        self.model = model
-
-        default_settings = KM.Parameters("""
-        {
-            "name"       : "CONTROL_NAME",
-            "type"       : "CONTROL_TYPE",
-            "settings"       : {
-                "technique"  : "CONTROL_TECHNIQUE",
-                "technique_settings"       : {},
-                "controlling_objects"  : []             
-            }
-        }""")
-
-
-        for itr in range(self.controls_settings.size()):
-            for key in default_settings.keys():
-                if not self.controls_settings[itr].Has(key):
-                    raise RuntimeError("ControlsController: Required setting '{}' missing in 'control Nr.{}'!".format(key,itr+1))  
-            self.controls_settings[itr].ValidateAndAssignDefaults(default_settings)
-            for key in default_settings["settings"].keys():
-                if not self.controls_settings[itr]["settings"].Has(key):
-                    raise RuntimeError("ControlsController: Required setting '{}' missing in 'settings' of 'control Nr.{}' !".format(key,itr+1))             
-            self.controls_settings[itr]["settings"].ValidateAndAssignDefaults(default_settings["settings"])  
-
-
-        self.supported_control_types_techniques = {"shape":["explicit_vertex_morphing","implicit_vertex_morphing"],"material":["helmholtz_material","helmholtz_partition"],"thickness":["helmholtz_thickness"]}
-        # sanity checks
-        self.controls_types_vars_dict = {"shape":[],"material":[],"thickness":[]}
-        self.controls = {}
-        self.controls_type = {}
-        self.controls_controlling_objects = {}
-        for itr in range(self.controls_settings.size()):
-            control_settings = self.controls_settings[itr]
-            
-            # check for name
-            control_name = control_settings["name"].GetString()
-            if  control_name in self.controls.keys():  
-                raise RuntimeError("ControlsController: Control name {} already exists.".format(control_name))            
-            # check control type
-            control_type = control_settings["type"].GetString()
-            if not control_type in self.supported_control_types_techniques.keys():
-                raise RuntimeError("ControlsController: control type '{}' in control {} is not supported!, we support {} ".format(control_type,control_name,self.supported_control_types_techniques))
-            self.controls_type[control_name] = control_type              
-            # check control technique
-            control_technique = control_settings["settings"]["technique"].GetString()
-            if not control_technique in self.supported_control_types_techniques[control_type]:
-                raise RuntimeError("ControlsController: control technique '{}' for control type {} in control {} is not supported!, we support {}".format(control_technique,control_type,control_name,self.supported_control_types_techniques))
-
-            # check for repetitious control over variables
-            control_controlling_objects_list = control_settings["settings"]["controlling_objects"].GetStringArray()
-            control_controlling_objects_list_set = set(control_controlling_objects_list)
-            if len(control_controlling_objects_list_set) != len(control_controlling_objects_list):
-                raise RuntimeError("ControlsController: control '{}' has duplicated control variables!".format(control_name))
-            if control_controlling_objects_list_set.issubset(set(self.controls_types_vars_dict[control_type])):
-                raise RuntimeError("ControlsController: there are duplicated {} control over {}!".format(control_type,control_controlling_objects_list))
-            if control_name in self.controls.keys():
-                raise RuntimeError("ControlsController: control name {} is duplicated !",control_name) 
-            self.controls_controlling_objects[control_name] = control_controlling_objects_list
-
-            # check if root model parts exist
-            self.model_parts_controller.CheckIfRootModelPartsExist(control_controlling_objects_list,True)
-
-            # now checks passed and create the control
-            if control_type == "shape":
-                if control_technique == "explicit_vertex_morphing":
-                    control = evm.ExplicitVertexMorphing(control_name,model,control_settings["settings"])   
-                elif control_technique == "implicit_vertex_morphing":
-                    control = ivm.ImplicitVertexMorphing(control_name,model,control_settings["settings"])  
-            elif control_type == "thickness":
-                if control_technique == "helmholtz_thickness":
-                    control = hlt.HelmholtzThickness(control_name,model,control_settings["settings"])    
-            elif control_type == "material":
-                if control_technique == "helmholtz_material":
-                    control = hlm.HelmholtzMaterial(control_name,model,control_settings["settings"])     
-                elif control_technique == "helmholtz_partition":
-                    control = hlp.HelmholtzPartition(control_name,model,control_settings["settings"])                                                      
-
-            self.controls[control_name] = control
-            self.controls_types_vars_dict[control_type].extend(control_controlling_objects_list)
-                            
-    # --------------------------------------------------------------------------
-    def Initialize(self):
-        for key,value in self.controls.items():
-            value.Initialize()
-
-    # --------------------------------------------------------------------------
-    def ControlMapFirstDerivative(self,control_name,derivative_name,mapped_derivative_name,raise_error=True):
-        if raise_error:
-            if not control_name in self.controls.keys():
-                raise RuntimeError("ControlsController:ControlMapFirstDerivative: Control {} does not exist.".format(control_name))
-
-        self.controls[control_name].MapFirstDerivative(derivative_name,mapped_derivative_name)
-
-    # --------------------------------------------------------------------------
-    def CheckIfControlExists(self,control_name,raise_error=True):
-        if not control_name in self.controls.keys():
-            if raise_error:
-                raise RuntimeError("ControlsController:CheckIfControlExists: Control {} does not exist.".format(control_name))
-            else: 
-                return False
-        else:
-            return True
-    # --------------------------------------------------------------------------
-    def CheckIfControlsExist(self,controls_name,raise_error=True):
-        if type(controls_name) is not list:
-            raise RuntimeError("ControlsController:CheckIfControlsExist requires list of control names")
-        
-        if_exist = True
-        for control_name in controls_name:
-            if not control_name in self.controls.keys():
-                if raise_error:
-                    raise RuntimeError("ControlsController:CheckIfControlsExist: Control {} does not exist!".format(control_name))
-                else:
-                    if_exist = False
-                    break
-        return if_exist      
-
-    # --------------------------------------------------------------------------
-    def GetControlType(self,control_name,raise_error=True):
-        if not control_name in self.controls_type.keys():
-            if raise_error:
-                raise RuntimeError("ControlsController:GetControlType: Control {} does not exist.".format(control_name))
-        else:
-            return self.controls_type[control_name]           
-    # --------------------------------------------------------------------------
-    def GetControlVariableName(self,control_name,raise_error=True):
-        if not control_name in self.controls_type.keys():
-            if raise_error:
-                raise RuntimeError("ControlsController:GetControlVariableName: Control {} does not exist.".format(control_name))
-        else:
-            return self.controls[control_name].GetVariableName() 
-    # --------------------------------------------------------------------------
-    def GetControlUpdateName(self,control_name,raise_error=True):
-        if not control_name in self.controls_type.keys():
-            if raise_error:
-                raise RuntimeError("ControlsController:GetControlUpdateName: Control {} does not exist.".format(control_name))
-        else:
-            return self.controls[control_name].GetUpdateName()  
-    # --------------------------------------------------------------------------
-    def GetControlOutputNames(self,control_name,raise_error=True):
-        if not control_name in self.controls_type.keys():
-            if raise_error:
-                raise RuntimeError("ControlsController:GetControlOutputNames: Control {} does not exist.".format(control_name))
-        else:
-            return self.controls[control_name].GetOutputNames() 
-    # --------------------------------------------------------------------------
-    def GetControlControllingObjects(self,control_name,raise_error=True):
-        if raise_error:
-            if not control_name in self.controls_controlling_objects.keys():
-                raise RuntimeError("ControlsController:GetControlControllingObjects: Control {} does not exist.".format(control_name))
-       
-        return self.controls[control_name].GetControllingObjects()            
-
-    # --------------------------------------------------------------------------
-    def MapControlFirstDerivative(self, control_name, derivative_variable_name, mapped_derivative_variable_name, raise_error=True):   
-        if raise_error:
-            if not control_name in self.controls_controlling_objects.keys():
-                raise RuntimeError("ControlsController:MapControlFirstDerivative: Control {} does not exist.".format(control_name)) 
-
-        self.controls[control_name].MapFirstDerivative(derivative_variable_name,mapped_derivative_variable_name)       
-
-    # --------------------------------------------------------------------------
-    def UpdateControl(self, control_name, raise_error=True):   
-        if raise_error:
-            if not control_name in self.controls_controlling_objects.keys():
-                raise RuntimeError("ControlsController:UpdateControl: Control {} does not exist.".format(control_name)) 
-
-        self.controls[control_name].Update()  
-
-    # --------------------------------------------------------------------------
-    def ComputeControl(self, control_name, raise_error=True):   
-        if raise_error:
-            if not control_name in self.controls_controlling_objects.keys():
-                raise RuntimeError("ControlsController:ComputeControl: Control {} does not exist.".format(control_name)) 
-
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ==============================================================================
+
+# additional imports
+import KratosMultiphysics as KM 
+import KratosMultiphysics.OptimizationApplication.controls.shape.explicit_vertex_morphing as evm
+import KratosMultiphysics.OptimizationApplication.controls.shape.implicit_vertex_morphing as ivm
+import KratosMultiphysics.OptimizationApplication.controls.thickness.helmholtz_thickness as hlt
+import KratosMultiphysics.OptimizationApplication.controls.material.helmholtz_material as hlm
+import KratosMultiphysics.OptimizationApplication.controls.material.helmholtz_partition as hlp
+
+# ==============================================================================
+def CreateController(controls_settings,model,model_parts_controller):
+    return ControlsController(controls_settings,model,model_parts_controller)
+
+# ==============================================================================
+class ControlsController:
+    # --------------------------------------------------------------------------
+    def __init__(self,controls_settings,model,model_parts_controller):
+        
+        self.controls_settings = controls_settings
+        self.model_parts_controller = model_parts_controller
+        self.model = model
+
+        default_settings = KM.Parameters("""
+        {
+            "name"       : "CONTROL_NAME",
+            "type"       : "CONTROL_TYPE",
+            "settings"       : {
+                "technique"  : "CONTROL_TECHNIQUE",
+                "technique_settings"       : {},
+                "controlling_objects"  : []             
+            }
+        }""")
+
+
+        for itr in range(self.controls_settings.size()):
+            for key in default_settings.keys():
+                if not self.controls_settings[itr].Has(key):
+                    raise RuntimeError("ControlsController: Required setting '{}' missing in 'control Nr.{}'!".format(key,itr+1))  
+            self.controls_settings[itr].ValidateAndAssignDefaults(default_settings)
+            for key in default_settings["settings"].keys():
+                if not self.controls_settings[itr]["settings"].Has(key):
+                    raise RuntimeError("ControlsController: Required setting '{}' missing in 'settings' of 'control Nr.{}' !".format(key,itr+1))             
+            self.controls_settings[itr]["settings"].ValidateAndAssignDefaults(default_settings["settings"])  
+
+
+        self.supported_control_types_techniques = {"shape":["explicit_vertex_morphing","implicit_vertex_morphing"],"material":["helmholtz_material","helmholtz_partition"],"thickness":["helmholtz_thickness"]}
+        # sanity checks
+        self.controls_types_vars_dict = {"shape":[],"material":[],"thickness":[]}
+        self.controls = {}
+        self.controls_type = {}
+        self.controls_controlling_objects = {}
+        for itr in range(self.controls_settings.size()):
+            control_settings = self.controls_settings[itr]
+            
+            # check for name
+            control_name = control_settings["name"].GetString()
+            if  control_name in self.controls.keys():  
+                raise RuntimeError("ControlsController: Control name {} already exists.".format(control_name))            
+            # check control type
+            control_type = control_settings["type"].GetString()
+            if not control_type in self.supported_control_types_techniques.keys():
+                raise RuntimeError("ControlsController: control type '{}' in control {} is not supported!, we support {} ".format(control_type,control_name,self.supported_control_types_techniques))
+            self.controls_type[control_name] = control_type              
+            # check control technique
+            control_technique = control_settings["settings"]["technique"].GetString()
+            if not control_technique in self.supported_control_types_techniques[control_type]:
+                raise RuntimeError("ControlsController: control technique '{}' for control type {} in control {} is not supported!, we support {}".format(control_technique,control_type,control_name,self.supported_control_types_techniques))
+
+            # check for repetitious control over variables
+            control_controlling_objects_list = control_settings["settings"]["controlling_objects"].GetStringArray()
+            control_controlling_objects_list_set = set(control_controlling_objects_list)
+            if len(control_controlling_objects_list_set) != len(control_controlling_objects_list):
+                raise RuntimeError("ControlsController: control '{}' has duplicated control variables!".format(control_name))
+            if control_controlling_objects_list_set.issubset(set(self.controls_types_vars_dict[control_type])):
+                raise RuntimeError("ControlsController: there are duplicated {} control over {}!".format(control_type,control_controlling_objects_list))
+            if control_name in self.controls.keys():
+                raise RuntimeError("ControlsController: control name {} is duplicated !",control_name) 
+            self.controls_controlling_objects[control_name] = control_controlling_objects_list
+
+            # check if root model parts exist
+            self.model_parts_controller.CheckIfRootModelPartsExist(control_controlling_objects_list,True)
+
+            # now checks passed and create the control
+            if control_type == "shape":
+                if control_technique == "explicit_vertex_morphing":
+                    control = evm.ExplicitVertexMorphing(control_name,model,control_settings["settings"])   
+                elif control_technique == "implicit_vertex_morphing":
+                    control = ivm.ImplicitVertexMorphing(control_name,model,control_settings["settings"])  
+            elif control_type == "thickness":
+                if control_technique == "helmholtz_thickness":
+                    control = hlt.HelmholtzThickness(control_name,model,control_settings["settings"])    
+            elif control_type == "material":
+                if control_technique == "helmholtz_material":
+                    control = hlm.HelmholtzMaterial(control_name,model,control_settings["settings"])     
+                elif control_technique == "helmholtz_partition":
+                    control = hlp.HelmholtzPartition(control_name,model,control_settings["settings"])                                                      
+
+            self.controls[control_name] = control
+            self.controls_types_vars_dict[control_type].extend(control_controlling_objects_list)
+                            
+    # --------------------------------------------------------------------------
+    def Initialize(self):
+        for key,value in self.controls.items():
+            value.Initialize()
+
+    # --------------------------------------------------------------------------
+    def ControlMapFirstDerivative(self,control_name,derivative_name,mapped_derivative_name,raise_error=True):
+        if raise_error:
+            if not control_name in self.controls.keys():
+                raise RuntimeError("ControlsController:ControlMapFirstDerivative: Control {} does not exist.".format(control_name))
+
+        self.controls[control_name].MapFirstDerivative(derivative_name,mapped_derivative_name)
+
+    # --------------------------------------------------------------------------
+    def CheckIfControlExists(self,control_name,raise_error=True):
+        if not control_name in self.controls.keys():
+            if raise_error:
+                raise RuntimeError("ControlsController:CheckIfControlExists: Control {} does not exist.".format(control_name))
+            else: 
+                return False
+        else:
+            return True
+    # --------------------------------------------------------------------------
+    def CheckIfControlsExist(self,controls_name,raise_error=True):
+        if type(controls_name) is not list:
+            raise RuntimeError("ControlsController:CheckIfControlsExist requires list of control names")
+        
+        if_exist = True
+        for control_name in controls_name:
+            if not control_name in self.controls.keys():
+                if raise_error:
+                    raise RuntimeError("ControlsController:CheckIfControlsExist: Control {} does not exist!".format(control_name))
+                else:
+                    if_exist = False
+                    break
+        return if_exist      
+
+    # --------------------------------------------------------------------------
+    def GetControlType(self,control_name,raise_error=True):
+        if not control_name in self.controls_type.keys():
+            if raise_error:
+                raise RuntimeError("ControlsController:GetControlType: Control {} does not exist.".format(control_name))
+        else:
+            return self.controls_type[control_name]           
+    # --------------------------------------------------------------------------
+    def GetControlVariableName(self,control_name,raise_error=True):
+        if not control_name in self.controls_type.keys():
+            if raise_error:
+                raise RuntimeError("ControlsController:GetControlVariableName: Control {} does not exist.".format(control_name))
+        else:
+            return self.controls[control_name].GetVariableName() 
+    # --------------------------------------------------------------------------
+    def GetControlUpdateName(self,control_name,raise_error=True):
+        if not control_name in self.controls_type.keys():
+            if raise_error:
+                raise RuntimeError("ControlsController:GetControlUpdateName: Control {} does not exist.".format(control_name))
+        else:
+            return self.controls[control_name].GetUpdateName()  
+    # --------------------------------------------------------------------------
+    def GetControlOutputNames(self,control_name,raise_error=True):
+        if not control_name in self.controls_type.keys():
+            if raise_error:
+                raise RuntimeError("ControlsController:GetControlOutputNames: Control {} does not exist.".format(control_name))
+        else:
+            return self.controls[control_name].GetOutputNames() 
+    # --------------------------------------------------------------------------
+    def GetControlControllingObjects(self,control_name,raise_error=True):
+        if raise_error:
+            if not control_name in self.controls_controlling_objects.keys():
+                raise RuntimeError("ControlsController:GetControlControllingObjects: Control {} does not exist.".format(control_name))
+       
+        return self.controls[control_name].GetControllingObjects()            
+
+    # --------------------------------------------------------------------------
+    def MapControlFirstDerivative(self, control_name, derivative_variable_name, mapped_derivative_variable_name, raise_error=True):   
+        if raise_error:
+            if not control_name in self.controls_controlling_objects.keys():
+                raise RuntimeError("ControlsController:MapControlFirstDerivative: Control {} does not exist.".format(control_name)) 
+
+        self.controls[control_name].MapFirstDerivative(derivative_variable_name,mapped_derivative_variable_name)       
+
+    # --------------------------------------------------------------------------
+    def UpdateControl(self, control_name, raise_error=True):   
+        if raise_error:
+            if not control_name in self.controls_controlling_objects.keys():
+                raise RuntimeError("ControlsController:UpdateControl: Control {} does not exist.".format(control_name)) 
+
+        self.controls[control_name].Update()  
+
+    # --------------------------------------------------------------------------
+    def ComputeControl(self, control_name, raise_error=True):   
+        if raise_error:
+            if not control_name in self.controls_controlling_objects.keys():
+                raise RuntimeError("ControlsController:ComputeControl: Control {} does not exist.".format(control_name)) 
+
         self.controls[control_name].Compute()
```

## KratosMultiphysics/OptimizationApplication/model_parts_controller.py

 * *Ordering differences only*

```diff
@@ -1,92 +1,92 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ==============================================================================
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics.OptimizationApplication.model_part_controllers.mdpa_model_part_controller import MdpaModelPartController
-
-# ==============================================================================
-def CreateController(model_parts_settings: KM.Parameters, model: KM.Model):
-    return ModelPartsController(model_parts_settings, model)
-
-# ==============================================================================
-class ModelPartsController:
-    # --------------------------------------------------------------------------
-    def __init__(self, model_parts_settings: KM.Parameters, model: KM.Model):
-
-        self.model_parts_settings = model_parts_settings
-        self.model = model
-
-        self.mdpa_model_part_controllers: 'list[MdpaModelPartController]' = []
-        for params in self.model_parts_settings:
-            params["settings"].AddString("model_part_name", params["name"].GetString())
-            self.mdpa_model_part_controllers.append(MdpaModelPartController(model, params["settings"]))
-
-    # --------------------------------------------------------------------------
-    def Initialize(self) -> None:
-        for mdpa_model_part_controller in self.mdpa_model_part_controllers:
-            mdpa_model_part_controller.ImportModelPart()
-
-    # --------------------------------------------------------------------------
-    def CheckIfRootModelPartsExist(self, root_model_parts_name: 'list[str]', raise_error = True) -> bool:
-        if not isinstance(root_model_parts_name, list):
-            raise RuntimeError("ModelPartsController: CheckIfRootModelPartsExist requires list of model parts")
-
-        if_exist = True
-        for root_model_part_name in root_model_parts_name:
-            extracted_root_model_part_name = root_model_part_name.split(".")[0]
-            if not self.model.HasModelPart(extracted_root_model_part_name):
-                if raise_error:
-                    raise RuntimeError("ModelPartsController: CheckIfRootModelPartsExist: Root model part {} does not exist!".format(extracted_root_model_part_name))
-                else:
-                    if_exist = False
-                    break
-
-        return if_exist
-    # --------------------------------------------------------------------------
-    def GetModelPart(self, model_part_name: str) -> KM.ModelPart:
-        if not model_part_name in self.model.GetModelPartNames():
-            raise RuntimeError("ModelPartsController: Try to get model part {} which does not exist.".format(model_part_name))
-        else:
-            return self.model.GetModelPart(model_part_name)
-    # --------------------------------------------------------------------------
-    def GetRootModelPart(self, root_model_part_name: str) -> KM.ModelPart:
-        extracted_root_model_part_name = root_model_part_name.split(".")[0]
-        if not self.model.HasModelPart(extracted_root_model_part_name):
-            raise RuntimeError("ModelPartsController: Try to get root model part {} which does not exist.".format(root_model_part_name))
-        else:
-            return self.model[extracted_root_model_part_name]
-    # --------------------------------------------------------------------------
-    def GetRootModelParts(self, root_model_parts_name: 'list[str]') -> 'list[KM.ModelPart]':
-        if not isinstance(root_model_parts_name, list):
-            raise RuntimeError("ModelPartsController: GetRootModelParts requires list of model parts name")
-
-        list_root_model_parts = []
-        for root_model_part_name in root_model_parts_name:
-            extracted_root_model_part_name = root_model_part_name.split(".")[0]
-            if not self.model.HasModelPart(extracted_root_model_part_name):
-                raise RuntimeError("ModelPartsController: GetRootModelParts: Root model part {} does not exist!".format(extracted_root_model_part_name))
-            else:
-                list_root_model_parts.append(self.model[extracted_root_model_part_name])
-
-        return list_root_model_parts
-
-    # --------------------------------------------------------------------------
-    def UpdateTimeStep(self, step: int) -> None:
-        for mdpa_odel_part_controller in self.mdpa_model_part_controllers:
-            mdpa_odel_part_controller.GetModelPart().CloneTimeStep(step)
-            mdpa_odel_part_controller.GetModelPart().ProcessInfo.SetValue(KM.STEP, step)
-    # --------------------------------------------------------------------------
-    def SetMinimalBufferSize(self, buffer_size: int) -> None:
-        for mdpa_odel_part_controller in self.mdpa_model_part_controllers:
-            if mdpa_odel_part_controller.GetModelPart().GetBufferSize() < buffer_size:
-                mdpa_odel_part_controller.GetModelPart().SetBufferSize(buffer_size)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ==============================================================================
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics.OptimizationApplication.model_part_controllers.mdpa_model_part_controller import MdpaModelPartController
+
+# ==============================================================================
+def CreateController(model_parts_settings: KM.Parameters, model: KM.Model):
+    return ModelPartsController(model_parts_settings, model)
+
+# ==============================================================================
+class ModelPartsController:
+    # --------------------------------------------------------------------------
+    def __init__(self, model_parts_settings: KM.Parameters, model: KM.Model):
+
+        self.model_parts_settings = model_parts_settings
+        self.model = model
+
+        self.mdpa_model_part_controllers: 'list[MdpaModelPartController]' = []
+        for params in self.model_parts_settings:
+            params["settings"].AddString("model_part_name", params["name"].GetString())
+            self.mdpa_model_part_controllers.append(MdpaModelPartController(model, params["settings"]))
+
+    # --------------------------------------------------------------------------
+    def Initialize(self) -> None:
+        for mdpa_model_part_controller in self.mdpa_model_part_controllers:
+            mdpa_model_part_controller.ImportModelPart()
+
+    # --------------------------------------------------------------------------
+    def CheckIfRootModelPartsExist(self, root_model_parts_name: 'list[str]', raise_error = True) -> bool:
+        if not isinstance(root_model_parts_name, list):
+            raise RuntimeError("ModelPartsController: CheckIfRootModelPartsExist requires list of model parts")
+
+        if_exist = True
+        for root_model_part_name in root_model_parts_name:
+            extracted_root_model_part_name = root_model_part_name.split(".")[0]
+            if not self.model.HasModelPart(extracted_root_model_part_name):
+                if raise_error:
+                    raise RuntimeError("ModelPartsController: CheckIfRootModelPartsExist: Root model part {} does not exist!".format(extracted_root_model_part_name))
+                else:
+                    if_exist = False
+                    break
+
+        return if_exist
+    # --------------------------------------------------------------------------
+    def GetModelPart(self, model_part_name: str) -> KM.ModelPart:
+        if not model_part_name in self.model.GetModelPartNames():
+            raise RuntimeError("ModelPartsController: Try to get model part {} which does not exist.".format(model_part_name))
+        else:
+            return self.model.GetModelPart(model_part_name)
+    # --------------------------------------------------------------------------
+    def GetRootModelPart(self, root_model_part_name: str) -> KM.ModelPart:
+        extracted_root_model_part_name = root_model_part_name.split(".")[0]
+        if not self.model.HasModelPart(extracted_root_model_part_name):
+            raise RuntimeError("ModelPartsController: Try to get root model part {} which does not exist.".format(root_model_part_name))
+        else:
+            return self.model[extracted_root_model_part_name]
+    # --------------------------------------------------------------------------
+    def GetRootModelParts(self, root_model_parts_name: 'list[str]') -> 'list[KM.ModelPart]':
+        if not isinstance(root_model_parts_name, list):
+            raise RuntimeError("ModelPartsController: GetRootModelParts requires list of model parts name")
+
+        list_root_model_parts = []
+        for root_model_part_name in root_model_parts_name:
+            extracted_root_model_part_name = root_model_part_name.split(".")[0]
+            if not self.model.HasModelPart(extracted_root_model_part_name):
+                raise RuntimeError("ModelPartsController: GetRootModelParts: Root model part {} does not exist!".format(extracted_root_model_part_name))
+            else:
+                list_root_model_parts.append(self.model[extracted_root_model_part_name])
+
+        return list_root_model_parts
+
+    # --------------------------------------------------------------------------
+    def UpdateTimeStep(self, step: int) -> None:
+        for mdpa_odel_part_controller in self.mdpa_model_part_controllers:
+            mdpa_odel_part_controller.GetModelPart().CloneTimeStep(step)
+            mdpa_odel_part_controller.GetModelPart().ProcessInfo.SetValue(KM.STEP, step)
+    # --------------------------------------------------------------------------
+    def SetMinimalBufferSize(self, buffer_size: int) -> None:
+        for mdpa_odel_part_controller in self.mdpa_model_part_controllers:
+            if mdpa_odel_part_controller.GetModelPart().GetBufferSize() < buffer_size:
+                mdpa_odel_part_controller.GetModelPart().SetBufferSize(buffer_size)
+
+# ==============================================================================
```

## KratosMultiphysics/OptimizationApplication/optimization_analysis.py

```diff
@@ -1,150 +1,144 @@
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.process_factory import KratosProcessFactory
-from KratosMultiphysics.OptimizationApplication.algorithms.algorithm import Algorithm
-from KratosMultiphysics.OptimizationApplication.model_part_controllers.model_part_controller import ModelPartController
-from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy_decorator import ExecutionPolicyDecorator
-from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
-from KratosMultiphysics.OptimizationApplication.controls.control import Control
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import OptimizationComponentFactory
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import OptimizationAnalysisTimeLogger
-
-class OptimizationAnalysis:
-    @classmethod
-    def GetDefaultParameters(cls) -> Kratos.Parameters:
-        return Kratos.Parameters("""{
-            "problem_data"      : {},
-            "model_parts"       : [],
-            "analyses"          : [],
-            "responses"         : [],
-            "controls"          : [],
-            "algorithm_settings": {},
-            "processes"  : {
-                "kratos_processes"           : {},
-                "optimization_data_processes": {}
-            }
-        }""")
-
-    def __init__(self, model: Kratos.Model, project_parameters: Kratos.Parameters):
-        self.model = model
-        self.project_parameters = project_parameters
-        self.project_parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
-
-        self.optimization_problem = OptimizationProblem(self.project_parameters["problem_data"]["echo_level"].GetInt())
-
-        self.__list_of_model_part_controllers: 'list[ModelPartController]' = []
-        self.__algorithm: Algorithm = None
-
-        self._CreateModelPartControllers()
-        self._CreateAnalyses()
-        self._CreateControls()
-        self._CreateResponses()
-        self._CreateAlgorithm()
-        self._CreateProcesses()
-
-    def Initialize(self):
-        CallOnAll(self.__list_of_model_part_controllers, ModelPartController.ImportModelPart)
-        CallOnAll(self.__list_of_model_part_controllers, ModelPartController.Initialize)
-        for process_type in self.__algorithm.GetProcessesOrder():
-            CallOnAll(self.optimization_problem.GetListOfProcesses(process_type), Kratos.Process.ExecuteInitialize)
-        CallOnAll(self.optimization_problem.GetListOfExecutionPolicies(), ExecutionPolicyDecorator.Initialize)
-        CallOnAll(self.optimization_problem.GetListOfControls(), Control.Initialize)
-        CallOnAll(self.optimization_problem.GetListOfResponses(), ResponseFunction.Initialize)
-
-        self.__algorithm.Initialize()
-
-    def Check(self):
-        for process_type in self.__algorithm.GetProcessesOrder():
-            CallOnAll(self.optimization_problem.GetListOfProcesses(process_type), Kratos.Process.Check)
-        CallOnAll(self.optimization_problem.GetListOfExecutionPolicies(), ExecutionPolicyDecorator.Check)
-        CallOnAll(self.optimization_problem.GetListOfControls(), Control.Check)
-        CallOnAll(self.optimization_problem.GetListOfResponses(), ResponseFunction.Check)
-
-        self.__algorithm.Check()
-
-    def Finalize(self):
-        self.__algorithm.Finalize()
-
-        CallOnAll(self.__list_of_model_part_controllers, ModelPartController.Finalize)
-        for process_type in self.__algorithm.GetProcessesOrder():
-            CallOnAll(self.optimization_problem.GetListOfProcesses(process_type), Kratos.Process.ExecuteFinalize)
-        CallOnAll(self.optimization_problem.GetListOfExecutionPolicies(), ExecutionPolicyDecorator.Finalize)
-        CallOnAll(self.optimization_problem.GetListOfControls(), Control.Finalize)
-        CallOnAll(self.optimization_problem.GetListOfResponses(), ResponseFunction.Finalize)
-
-    def Run(self):
-        with OptimizationAnalysisTimeLogger():
-            self.Initialize()
-            self.Check()
-            self.__algorithm.Solve()
-            self.Finalize()
-
-    def _CreateModelPartControllers(self):
-        default_settings = Kratos.Parameters("""{
-            "type": "mdpa_model_part_controller",
-            "module": "KratosMultiphysics.OptimizationApplication.model_part_controllers"
-        }""")        
-        for model_part_controller_settings in self.project_parameters["model_parts"]:
-            model_part_controller_settings.AddMissingParameters(default_settings)
-            model_part_controller: ModelPartController = OptimizationComponentFactory(self.model, model_part_controller_settings, self.optimization_problem)
-            self.__list_of_model_part_controllers.append(model_part_controller)
-
-    def _CreateAnalyses(self):
-        default_settings = Kratos.Parameters("""{
-            "module": "KratosMultiphysics.OptimizationApplication.execution_policies"
-        }""")
-        for analyses_settings in self.project_parameters["analyses"]:
-            analyses_settings.AddMissingParameters(default_settings)
-            execution_policy = OptimizationComponentFactory(self.model, analyses_settings, self.optimization_problem)
-            self.optimization_problem.AddComponent(execution_policy)
-
-    def _CreateResponses(self):
-        default_settings = Kratos.Parameters("""{
-            "module": "KratosMultiphysics.OptimizationApplication.responses"
-        }""")
-        for response_settings in self.project_parameters["responses"]:
-            response_settings.AddMissingParameters(default_settings)
-            response_function: ResponseFunction = OptimizationComponentFactory(self.model, response_settings, self.optimization_problem)
-            self.optimization_problem.AddComponent(response_function)
-
-    def _CreateControls(self):
-        default_settings = Kratos.Parameters("""{
-            "module" : "KratosMultiphysics.OptimizationApplication.controls"
-        }""")
-        for control_settings in self.project_parameters["controls"]:
-            control_settings.AddMissingParameters(default_settings)
-            control = OptimizationComponentFactory(self.model, control_settings, self.optimization_problem)
-            self.optimization_problem.AddComponent(control)
-
-    def _CreateProcesses(self):
-        process_settings = self.project_parameters["processes"]
-        process_settings.ValidateAndAssignDefaults(self.GetDefaultParameters()["processes"])
-
-        kratos_processes = process_settings["kratos_processes"]
-        optimization_data_processes = process_settings["optimization_data_processes"]
-
-        factory = KratosProcessFactory(self.model)
-
-        optimization_data_process_default_settings = Kratos.Parameters("""{
-            "module" : "KratosMultiphysics.OptimizationApplication.optimization_data_processes"
-        }""")
-
-        for process_type in self.__algorithm.GetProcessesOrder():
-            self.optimization_problem.AddProcessType(process_type)
-            if kratos_processes.Has(process_type):
-                for process in factory.ConstructListOfProcesses(kratos_processes[process_type]):
-                    self.optimization_problem.AddProcess(process_type, process)
-            if optimization_data_processes.Has(process_type):
-                for process_settings in optimization_data_processes[process_type]:
-                    process_settings.AddMissingParameters(optimization_data_process_default_settings)
-                    process = OptimizationComponentFactory(self.model, process_settings, self.optimization_problem)
-                    self.optimization_problem.AddProcess(process_type, process)
-
-    def _CreateAlgorithm(self):
-        default_settings = Kratos.Parameters("""{
-            "module" : "KratosMultiphysics.OptimizationApplication.algorithms"
-        }""")
-        algorithm_settings = self.project_parameters["algorithm_settings"]
-        algorithm_settings.AddMissingParameters(default_settings)
-        self.__algorithm = OptimizationComponentFactory(self.model, algorithm_settings, self.optimization_problem)
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.process_factory import KratosProcessFactory
+from KratosMultiphysics.OptimizationApplication.algorithms.algorithm import Algorithm
+from KratosMultiphysics.OptimizationApplication.model_part_controllers.model_part_controller import ModelPartController
+from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy_decorator import ExecutionPolicyDecorator
+from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
+from KratosMultiphysics.OptimizationApplication.controls.control import Control
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import OptimizationComponentFactory
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import OptimizationAnalysisTimeLogger
+
+class OptimizationAnalysis:
+    @classmethod
+    def GetDefaultParameters(cls) -> Kratos.Parameters:
+        return Kratos.Parameters("""{
+            "problem_data"      : {},
+            "model_parts"       : [],
+            "analyses"          : [],
+            "responses"         : [],
+            "controls"          : [],
+            "algorithm_settings": {},
+            "processes"  : {
+                "kratos_processes"           : {},
+                "optimization_data_processes": {}
+            }
+        }""")
+
+    def __init__(self, model: Kratos.Model, project_parameters: Kratos.Parameters):
+        self.model = model
+        self.project_parameters = project_parameters
+        self.project_parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+
+        self.optimization_problem = OptimizationProblem(self.project_parameters["problem_data"]["echo_level"].GetInt())
+
+        self.__list_of_model_part_controllers: 'list[ModelPartController]' = []
+        self.__algorithm: Algorithm = None
+
+        self._CreateModelPartControllers()
+        self._CreateAnalyses()
+        self._CreateControls()
+        self._CreateResponses()
+        self._CreateAlgorithm()
+        self._CreateProcesses()
+
+    def Initialize(self):
+        CallOnAll(self.__list_of_model_part_controllers, ModelPartController.ImportModelPart)
+        CallOnAll(self.__list_of_model_part_controllers, ModelPartController.Initialize)
+        for process_type in self.__algorithm.GetProcessesOrder():
+            CallOnAll(self.optimization_problem.GetListOfProcesses(process_type), Kratos.Process.ExecuteInitialize)
+        CallOnAll(self.optimization_problem.GetListOfExecutionPolicies(), ExecutionPolicyDecorator.Initialize)
+
+        self.__algorithm.Initialize()
+
+    def Check(self):
+        for process_type in self.__algorithm.GetProcessesOrder():
+            CallOnAll(self.optimization_problem.GetListOfProcesses(process_type), Kratos.Process.Check)
+        CallOnAll(self.optimization_problem.GetListOfExecutionPolicies(), ExecutionPolicyDecorator.Check)
+
+        self.__algorithm.Check()
+
+    def Finalize(self):
+        self.__algorithm.Finalize()
+
+        CallOnAll(self.__list_of_model_part_controllers, ModelPartController.Finalize)
+        for process_type in self.__algorithm.GetProcessesOrder():
+            CallOnAll(self.optimization_problem.GetListOfProcesses(process_type), Kratos.Process.ExecuteFinalize)
+        CallOnAll(self.optimization_problem.GetListOfExecutionPolicies(), ExecutionPolicyDecorator.Finalize)
+
+    def Run(self):
+        with OptimizationAnalysisTimeLogger():
+            self.Initialize()
+            self.Check()
+            self.__algorithm.Solve()
+            self.Finalize()
+
+    def _CreateModelPartControllers(self):
+        default_settings = Kratos.Parameters("""{
+            "type": "mdpa_model_part_controller",
+            "module": "KratosMultiphysics.OptimizationApplication.model_part_controllers"
+        }""")
+        for model_part_controller_settings in self.project_parameters["model_parts"]:
+            model_part_controller_settings.AddMissingParameters(default_settings)
+            model_part_controller: ModelPartController = OptimizationComponentFactory(self.model, model_part_controller_settings, self.optimization_problem)
+            self.__list_of_model_part_controllers.append(model_part_controller)
+
+    def _CreateAnalyses(self):
+        default_settings = Kratos.Parameters("""{
+            "module": "KratosMultiphysics.OptimizationApplication.execution_policies"
+        }""")
+        for analyses_settings in self.project_parameters["analyses"]:
+            analyses_settings.AddMissingParameters(default_settings)
+            execution_policy = OptimizationComponentFactory(self.model, analyses_settings, self.optimization_problem)
+            self.optimization_problem.AddComponent(execution_policy)
+
+    def _CreateResponses(self):
+        default_settings = Kratos.Parameters("""{
+            "module": "KratosMultiphysics.OptimizationApplication.responses"
+        }""")
+        for response_settings in self.project_parameters["responses"]:
+            response_settings.AddMissingParameters(default_settings)
+            response_function: ResponseFunction = OptimizationComponentFactory(self.model, response_settings, self.optimization_problem)
+            self.optimization_problem.AddComponent(response_function)
+
+    def _CreateControls(self):
+        default_settings = Kratos.Parameters("""{
+            "module" : "KratosMultiphysics.OptimizationApplication.controls"
+        }""")
+        for control_settings in self.project_parameters["controls"]:
+            control_settings.AddMissingParameters(default_settings)
+            control = OptimizationComponentFactory(self.model, control_settings, self.optimization_problem)
+            self.optimization_problem.AddComponent(control)
+
+    def _CreateProcesses(self):
+        process_settings = self.project_parameters["processes"]
+        process_settings.ValidateAndAssignDefaults(self.GetDefaultParameters()["processes"])
+
+        kratos_processes = process_settings["kratos_processes"]
+        optimization_data_processes = process_settings["optimization_data_processes"]
+
+        factory = KratosProcessFactory(self.model)
+
+        optimization_data_process_default_settings = Kratos.Parameters("""{
+            "module" : "KratosMultiphysics.OptimizationApplication.optimization_data_processes"
+        }""")
+
+        for process_type in self.__algorithm.GetProcessesOrder():
+            self.optimization_problem.AddProcessType(process_type)
+            if kratos_processes.Has(process_type):
+                for process in factory.ConstructListOfProcesses(kratos_processes[process_type]):
+                    self.optimization_problem.AddProcess(process_type, process)
+            if optimization_data_processes.Has(process_type):
+                for process_settings in optimization_data_processes[process_type]:
+                    process_settings.AddMissingParameters(optimization_data_process_default_settings)
+                    process = OptimizationComponentFactory(self.model, process_settings, self.optimization_problem)
+                    self.optimization_problem.AddProcess(process_type, process)
+
+    def _CreateAlgorithm(self):
+        default_settings = Kratos.Parameters("""{
+            "module" : "KratosMultiphysics.OptimizationApplication.algorithms"
+        }""")
+        algorithm_settings = self.project_parameters["algorithm_settings"]
+        algorithm_settings.AddMissingParameters(default_settings)
+        self.__algorithm = OptimizationComponentFactory(self.model, algorithm_settings, self.optimization_problem)
```

## KratosMultiphysics/OptimizationApplication/optimizations_controller.py

 * *Ordering differences only*

```diff
@@ -1,223 +1,223 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ==============================================================================
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-
-# Additional imports
-import KratosMultiphysics.OptimizationApplication.algorithms.algorithm_steepest_descent as steepest_descent
-import KratosMultiphysics.OptimizationApplication.algorithms.algorithm_gradient_projection as gradient_projection
-import time as timer
-
-# ==============================================================================
-def CreateController(optimizations_settings,model,model_parts_controller,analyses_controller,responses_controller,controls_controller):
-    return OptimizationsController(optimizations_settings,model,model_parts_controller,analyses_controller,responses_controller,controls_controller)
-
-# ==============================================================================
-class OptimizationsController:
-    # --------------------------------------------------------------------------
-    def __init__(self,optimizations_settings,model,model_parts_controller,analyses_controller,responses_controller,controls_controller):
-        
-        self.optimizations_settings = optimizations_settings
-        self.controls_controller = controls_controller
-        self.responses_controller = responses_controller
-        self.model = model
-
-        default_settings = KM.Parameters("""
-        {
-            "name"                : "OPT_NAME",
-            "type"                : "OPT_TYPE",
-            "settings"                : {
-                "objectives": [],
-                "objectives_improvements": [],
-                "constraints": [],
-                "constraints_types": [],
-                "constraints_ref_values": [],
-                "controls": [],
-                "objectives_controls_weights": [],
-                "constraints_controls_weights": [],
-                "controls_lower_bounds": [],
-                "controls_lower_bounds_values": [],
-                "controls_upper_bounds": [],
-                "controls_upper_bounds_values": [],                
-                "algorithm" : "ALG_NAME",
-                "algorithm_settings" : {
-                    "max_iterations"     : 100,
-                    "step_size"  : 0.1,
-                    "relative_tolerance" : 1e-3
-                }
-            }
-        }""")
-
-        if not self.optimizations_settings.size()>0:
-            raise RuntimeError("OptimizationsController: optimizations list in optimizer's parameters can not be empty !") 
-
-
-        self.optimizations = {}
-        self.optimizations_types={}
-
-
-        self.optimizations_objectives={}
-        self.optimizations_objectives_improvements={}
-
-
-        self.optimizations_constraints={}
-        self.optimizations_constraints_types={}
-        self.optimizations_constraints_ref_values={}
-        
-        
-        self.optimizations_controls={}
-        self.optimizations_objectives_controls_weights={}
-        self.optimizations_constraints_controls_weights={}
-
-
-        self.optimizations_algorithm={}
-        self.supported_opt_types = ["gradient_based"]
-        self.supported_algorithms = ["gradient_projection"]
-
-
-
-        for itr in range(self.optimizations_settings.size()):
-            opt_settings = self.optimizations_settings[itr]
-            opt_name = opt_settings["name"].GetString()
-            opt_type = opt_settings["type"].GetString()   
-            # check for name
-            if opt_name in self.optimizations.keys():  
-                raise RuntimeError("OptimizationsController: Optimization name '{}' already exists.".format(opt_name))    
-
-
-            # check for type
-            if not opt_type in self.supported_opt_types:  
-                raise RuntimeError("OptimizationsController: Optimization type '{}' is not supported, supprted types {}.".format(opt_type,self.supported_opt_types))                  
-            self.optimizations_types[opt_name]=opt_type
-
-
-            # checks for objectives
-            objectives_names = opt_settings["settings"]["objectives"].GetStringArray()
-            if not len(objectives_names)>0:  
-                raise RuntimeError("OptimizationsController: Objectives list of optimization '{}' can not be empty.".format(opt_name))   
-            if len(set(objectives_names)) != len(objectives_names):
-                raise RuntimeError("OptimizationsController: Objectives list of optimization '{}' has duplicate response names '{}'.".format(opt_name,objectives_names))
-            self.responses_controller.CheckIfResponsesExist(objectives_names)
-            self.optimizations_objectives[opt_name]=objectives_names
-
-
-            # check for objectives improvements
-            if not opt_settings["settings"]["objectives_improvements"].IsVector():  
-                raise RuntimeError("OptimizationsController:'objectives_improvements' of optimization '{}' should be vector of doubles.".format(opt_name)) 
-            objectives_improvements = opt_settings["settings"]["objectives_improvements"].GetVector()     
-            if not len(objectives_improvements) == len(objectives_names):
-                raise RuntimeError("OptimizationsController:'objectives_improvements' of optimization '{}' should be of the same size of objectives list.".format(opt_name))
-            self.optimizations_objectives_improvements[opt_name]=objectives_improvements
-
-
-            # checks for constraints
-            if opt_settings["settings"]["constraints"].size()>0:
-                constraints_names = opt_settings["settings"]["constraints"].GetStringArray()
-                if len(set(constraints_names)) != len(constraints_names):
-                    raise RuntimeError("OptimizationsController: Constraint list of optimization '{}' has duplicate response names .".format(opt_name))
-                self.responses_controller.CheckIfResponsesExist(constraints_names)
-
-                for constraints_name in constraints_names:
-                    if constraints_name in objectives_names:
-                        raise RuntimeError("OptimizationsController: Response {} in optimization {} is used as both objective and constraint.".format(constraints_name,opt_name))
-                self.optimizations_constraints[opt_name]=constraints_names
-
-                constraints_types = opt_settings["settings"]["constraints_types"].GetStringArray()  
-                if not len(constraints_types) == len(constraints_names):
-                    raise RuntimeError("OptimizationsController:'constraints_types' of optimization '{}' should be of the same size of constraint list.".format(opt_name))
-                for index, type in enumerate(constraints_types):
-                    if not type in ["equality","smaller_than","bigger_than","initial_value_equality","smaller_than_initial_value","bigger_than_initial_value"]: 
-                        raise RuntimeError("OptimizationsController: constraint type {} of constraint {} of optimization '{}' should be either 'equality' or 'inequality'.".format(type,constraints_names[index],opt_name,))
-                self.optimizations_constraints_types[opt_name]=constraints_types                
-
-                if not opt_settings["settings"]["constraints_ref_values"].IsVector():  
-                    raise RuntimeError("OptimizationsController:'constraints_ref_values' of optimization '{}' should be vector of doubles.".format(opt_name)) 
-                constraints_ref_values = opt_settings["settings"]["constraints_ref_values"].GetVector() 
-                if not len(constraints_ref_values) == len(constraints_names):
-                    raise RuntimeError("OptimizationsController:'constraints_ref_values' of optimization '{}' should be of the same size of constraint list.".format(opt_name))
-                self.optimizations_constraints_ref_values[opt_name]=constraints_ref_values
-                
-            
-            # checks for controls
-            controls_names = opt_settings["settings"]["controls"].GetStringArray()
-            if not len(controls_names)>0:  
-                raise RuntimeError("OptimizationsController: Controls list of optimization '{}' can not be empty.".format(opt_name))   
-            if len(set(controls_names)) != len(controls_names):
-                raise RuntimeError("OptimizationsController: Controls list of optimization '{}' has duplicate control names .".format(opt_name))
-            self.controls_controller.CheckIfControlsExist(controls_names)
-
-            for key,values in self.optimizations_controls.items():
-                compare_results = set(controls_names) & set(values)
-                if len(compare_results):
-                    raise RuntimeError("OptimizationsController: Controls {} can not be shared between optimizations '{}' and '{}' .".format(compare_results,key,opt_name))
-            
-            self.optimizations_controls[opt_name]=controls_names            
-
-
-            # checks for objectives controls weights
-            if opt_settings["settings"]["objectives_controls_weights"].size() != len(controls_names):
-                raise RuntimeError("OptimizationsController: 'objectives_controls_weights' of optimization '{}' should be of the same size of control list .".format(opt_name))            
-
-            objectives_controls_weights=[]
-            for i in range(opt_settings["settings"]["objectives_controls_weights"].size()):
-                if not opt_settings["settings"]["objectives_controls_weights"][i].IsNumber():
-                    raise RuntimeError("OptimizationsController: entry {} of 'objectives_controls_weights' of optimization '{}' should be a number .".format(i+1,opt_name))
-                else:
-                    objectives_controls_weights.append(opt_settings["settings"]["objectives_controls_weights"][i].GetDouble())
-
-            self.optimizations_objectives_controls_weights[opt_name] = objectives_controls_weights
-
-
-            # checks for constraints controls weights
-            if opt_settings["settings"]["constraints_controls_weights"].size() != len(controls_names):
-                raise RuntimeError("OptimizationsController: 'constraints_controls_weights' of optimization '{}' should be of the same size of control list .".format(opt_name))            
-
-            constraints_controls_weights=[]
-            for i in range(opt_settings["settings"]["constraints_controls_weights"].size()):
-                if not opt_settings["settings"]["constraints_controls_weights"][i].IsNumber():
-                    raise RuntimeError("OptimizationsController: entry {} of 'constraints_controls_weights' of optimization '{}' should be a number .".format(i+1,opt_name))
-                else:
-                    constraints_controls_weights.append(opt_settings["settings"]["constraints_controls_weights"][i].GetDouble())
-
-            self.optimizations_constraints_controls_weights[opt_name] = constraints_controls_weights
-
-            
-            # checks for algorithms settings
-            algorithm = opt_settings["settings"]["algorithm"].GetString()
-            if not algorithm in self.supported_algorithms:
-                raise RuntimeError("OptimizationsController: Optimization algorithm '{}' is not supported, supprted types {}.".format(algorithm,self.supported_algorithms))                  
-
-            if algorithm == "gradient_projection":
-                self.optimizations[opt_name] = gradient_projection.AlgorithmGradientProjection(opt_name,opt_settings["settings"],model,model_parts_controller,analyses_controller,responses_controller,controls_controller)
-    
-        
-    # --------------------------------------------------------------------------
-    def Initialize(self):
-        for opt in self.optimizations.values():
-            opt.InitializeOptimizationLoop()
-
-    # --------------------------------------------------------------------------
-    def Optimize(self,opt_name):
-        if not opt_name in self.optimizations.keys():
-            raise RuntimeError("OptimizationsController:Optimize: Optimization {} doesn not exist !.".format(opt_name))
-        
-        self.optimizations[opt_name].RunOptimizationLoop()
-    # --------------------------------------------------------------------------
-    def OptimizeAll(self):
-        for opt in self.optimizations.values():
-            opt.RunOptimizationLoop()
-
-
-
-            
-
-               
-
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ==============================================================================
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+
+# Additional imports
+import KratosMultiphysics.OptimizationApplication.algorithms.algorithm_steepest_descent as steepest_descent
+import KratosMultiphysics.OptimizationApplication.algorithms.algorithm_gradient_projection as gradient_projection
+import time as timer
+
+# ==============================================================================
+def CreateController(optimizations_settings,model,model_parts_controller,analyses_controller,responses_controller,controls_controller):
+    return OptimizationsController(optimizations_settings,model,model_parts_controller,analyses_controller,responses_controller,controls_controller)
+
+# ==============================================================================
+class OptimizationsController:
+    # --------------------------------------------------------------------------
+    def __init__(self,optimizations_settings,model,model_parts_controller,analyses_controller,responses_controller,controls_controller):
+        
+        self.optimizations_settings = optimizations_settings
+        self.controls_controller = controls_controller
+        self.responses_controller = responses_controller
+        self.model = model
+
+        default_settings = KM.Parameters("""
+        {
+            "name"                : "OPT_NAME",
+            "type"                : "OPT_TYPE",
+            "settings"                : {
+                "objectives": [],
+                "objectives_improvements": [],
+                "constraints": [],
+                "constraints_types": [],
+                "constraints_ref_values": [],
+                "controls": [],
+                "objectives_controls_weights": [],
+                "constraints_controls_weights": [],
+                "controls_lower_bounds": [],
+                "controls_lower_bounds_values": [],
+                "controls_upper_bounds": [],
+                "controls_upper_bounds_values": [],                
+                "algorithm" : "ALG_NAME",
+                "algorithm_settings" : {
+                    "max_iterations"     : 100,
+                    "step_size"  : 0.1,
+                    "relative_tolerance" : 1e-3
+                }
+            }
+        }""")
+
+        if not self.optimizations_settings.size()>0:
+            raise RuntimeError("OptimizationsController: optimizations list in optimizer's parameters can not be empty !") 
+
+
+        self.optimizations = {}
+        self.optimizations_types={}
+
+
+        self.optimizations_objectives={}
+        self.optimizations_objectives_improvements={}
+
+
+        self.optimizations_constraints={}
+        self.optimizations_constraints_types={}
+        self.optimizations_constraints_ref_values={}
+        
+        
+        self.optimizations_controls={}
+        self.optimizations_objectives_controls_weights={}
+        self.optimizations_constraints_controls_weights={}
+
+
+        self.optimizations_algorithm={}
+        self.supported_opt_types = ["gradient_based"]
+        self.supported_algorithms = ["gradient_projection"]
+
+
+
+        for itr in range(self.optimizations_settings.size()):
+            opt_settings = self.optimizations_settings[itr]
+            opt_name = opt_settings["name"].GetString()
+            opt_type = opt_settings["type"].GetString()   
+            # check for name
+            if opt_name in self.optimizations.keys():  
+                raise RuntimeError("OptimizationsController: Optimization name '{}' already exists.".format(opt_name))    
+
+
+            # check for type
+            if not opt_type in self.supported_opt_types:  
+                raise RuntimeError("OptimizationsController: Optimization type '{}' is not supported, supprted types {}.".format(opt_type,self.supported_opt_types))                  
+            self.optimizations_types[opt_name]=opt_type
+
+
+            # checks for objectives
+            objectives_names = opt_settings["settings"]["objectives"].GetStringArray()
+            if not len(objectives_names)>0:  
+                raise RuntimeError("OptimizationsController: Objectives list of optimization '{}' can not be empty.".format(opt_name))   
+            if len(set(objectives_names)) != len(objectives_names):
+                raise RuntimeError("OptimizationsController: Objectives list of optimization '{}' has duplicate response names '{}'.".format(opt_name,objectives_names))
+            self.responses_controller.CheckIfResponsesExist(objectives_names)
+            self.optimizations_objectives[opt_name]=objectives_names
+
+
+            # check for objectives improvements
+            if not opt_settings["settings"]["objectives_improvements"].IsVector():  
+                raise RuntimeError("OptimizationsController:'objectives_improvements' of optimization '{}' should be vector of doubles.".format(opt_name)) 
+            objectives_improvements = opt_settings["settings"]["objectives_improvements"].GetVector()     
+            if not len(objectives_improvements) == len(objectives_names):
+                raise RuntimeError("OptimizationsController:'objectives_improvements' of optimization '{}' should be of the same size of objectives list.".format(opt_name))
+            self.optimizations_objectives_improvements[opt_name]=objectives_improvements
+
+
+            # checks for constraints
+            if opt_settings["settings"]["constraints"].size()>0:
+                constraints_names = opt_settings["settings"]["constraints"].GetStringArray()
+                if len(set(constraints_names)) != len(constraints_names):
+                    raise RuntimeError("OptimizationsController: Constraint list of optimization '{}' has duplicate response names .".format(opt_name))
+                self.responses_controller.CheckIfResponsesExist(constraints_names)
+
+                for constraints_name in constraints_names:
+                    if constraints_name in objectives_names:
+                        raise RuntimeError("OptimizationsController: Response {} in optimization {} is used as both objective and constraint.".format(constraints_name,opt_name))
+                self.optimizations_constraints[opt_name]=constraints_names
+
+                constraints_types = opt_settings["settings"]["constraints_types"].GetStringArray()  
+                if not len(constraints_types) == len(constraints_names):
+                    raise RuntimeError("OptimizationsController:'constraints_types' of optimization '{}' should be of the same size of constraint list.".format(opt_name))
+                for index, type in enumerate(constraints_types):
+                    if not type in ["equality","smaller_than","bigger_than","initial_value_equality","smaller_than_initial_value","bigger_than_initial_value"]: 
+                        raise RuntimeError("OptimizationsController: constraint type {} of constraint {} of optimization '{}' should be either 'equality' or 'inequality'.".format(type,constraints_names[index],opt_name,))
+                self.optimizations_constraints_types[opt_name]=constraints_types                
+
+                if not opt_settings["settings"]["constraints_ref_values"].IsVector():  
+                    raise RuntimeError("OptimizationsController:'constraints_ref_values' of optimization '{}' should be vector of doubles.".format(opt_name)) 
+                constraints_ref_values = opt_settings["settings"]["constraints_ref_values"].GetVector() 
+                if not len(constraints_ref_values) == len(constraints_names):
+                    raise RuntimeError("OptimizationsController:'constraints_ref_values' of optimization '{}' should be of the same size of constraint list.".format(opt_name))
+                self.optimizations_constraints_ref_values[opt_name]=constraints_ref_values
+                
+            
+            # checks for controls
+            controls_names = opt_settings["settings"]["controls"].GetStringArray()
+            if not len(controls_names)>0:  
+                raise RuntimeError("OptimizationsController: Controls list of optimization '{}' can not be empty.".format(opt_name))   
+            if len(set(controls_names)) != len(controls_names):
+                raise RuntimeError("OptimizationsController: Controls list of optimization '{}' has duplicate control names .".format(opt_name))
+            self.controls_controller.CheckIfControlsExist(controls_names)
+
+            for key,values in self.optimizations_controls.items():
+                compare_results = set(controls_names) & set(values)
+                if len(compare_results):
+                    raise RuntimeError("OptimizationsController: Controls {} can not be shared between optimizations '{}' and '{}' .".format(compare_results,key,opt_name))
+            
+            self.optimizations_controls[opt_name]=controls_names            
+
+
+            # checks for objectives controls weights
+            if opt_settings["settings"]["objectives_controls_weights"].size() != len(controls_names):
+                raise RuntimeError("OptimizationsController: 'objectives_controls_weights' of optimization '{}' should be of the same size of control list .".format(opt_name))            
+
+            objectives_controls_weights=[]
+            for i in range(opt_settings["settings"]["objectives_controls_weights"].size()):
+                if not opt_settings["settings"]["objectives_controls_weights"][i].IsNumber():
+                    raise RuntimeError("OptimizationsController: entry {} of 'objectives_controls_weights' of optimization '{}' should be a number .".format(i+1,opt_name))
+                else:
+                    objectives_controls_weights.append(opt_settings["settings"]["objectives_controls_weights"][i].GetDouble())
+
+            self.optimizations_objectives_controls_weights[opt_name] = objectives_controls_weights
+
+
+            # checks for constraints controls weights
+            if opt_settings["settings"]["constraints_controls_weights"].size() != len(controls_names):
+                raise RuntimeError("OptimizationsController: 'constraints_controls_weights' of optimization '{}' should be of the same size of control list .".format(opt_name))            
+
+            constraints_controls_weights=[]
+            for i in range(opt_settings["settings"]["constraints_controls_weights"].size()):
+                if not opt_settings["settings"]["constraints_controls_weights"][i].IsNumber():
+                    raise RuntimeError("OptimizationsController: entry {} of 'constraints_controls_weights' of optimization '{}' should be a number .".format(i+1,opt_name))
+                else:
+                    constraints_controls_weights.append(opt_settings["settings"]["constraints_controls_weights"][i].GetDouble())
+
+            self.optimizations_constraints_controls_weights[opt_name] = constraints_controls_weights
+
+            
+            # checks for algorithms settings
+            algorithm = opt_settings["settings"]["algorithm"].GetString()
+            if not algorithm in self.supported_algorithms:
+                raise RuntimeError("OptimizationsController: Optimization algorithm '{}' is not supported, supprted types {}.".format(algorithm,self.supported_algorithms))                  
+
+            if algorithm == "gradient_projection":
+                self.optimizations[opt_name] = gradient_projection.AlgorithmGradientProjection(opt_name,opt_settings["settings"],model,model_parts_controller,analyses_controller,responses_controller,controls_controller)
+    
+        
+    # --------------------------------------------------------------------------
+    def Initialize(self):
+        for opt in self.optimizations.values():
+            opt.InitializeOptimizationLoop()
+
+    # --------------------------------------------------------------------------
+    def Optimize(self,opt_name):
+        if not opt_name in self.optimizations.keys():
+            raise RuntimeError("OptimizationsController:Optimize: Optimization {} doesn not exist !.".format(opt_name))
+        
+        self.optimizations[opt_name].RunOptimizationLoop()
+    # --------------------------------------------------------------------------
+    def OptimizeAll(self):
+        for opt in self.optimizations.values():
+            opt.RunOptimizationLoop()
+
+
+
+            
+
+               
+
```

## KratosMultiphysics/OptimizationApplication/optimizer.py

 * *Ordering differences only*

```diff
@@ -1,61 +1,61 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ==============================================================================
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-from KratosMultiphysics.OptimizationApplication import model_parts_controller
-from KratosMultiphysics.OptimizationApplication import analyses_controller
-from KratosMultiphysics.OptimizationApplication import responses_controller
-from KratosMultiphysics.OptimizationApplication import controls_controller
-from KratosMultiphysics.OptimizationApplication import optimizations_controller
-
-# additional imports
-
-
-## Purely for backward compatibility, should be removed soon.
-def CreateOptimizer(optimization_settings,model):
-    return Optimizer(optimization_settings,model)
-
-def Create(optimization_settings,model):
-    return Optimizer(optimization_settings,model)
-
-# ==============================================================================
-class Optimizer:
-    # --------------------------------------------------------------------------
-    def __init__(self, optimization_settings,model):
-        self._ValidateSettings(optimization_settings)
-        self.optimization_settings = optimization_settings
-        self.model_parts_controller = model_parts_controller.CreateController(optimization_settings["model_parts"],model)
-        self.analyses_controller = analyses_controller.CreateController(optimization_settings["analyses"],model,self.model_parts_controller)
-        self.responses_controller = responses_controller.CreateController(optimization_settings["responses"],model,self.model_parts_controller,self.analyses_controller)
-        self.controls_controller = controls_controller.CreateController(optimization_settings["controls"],model,self.model_parts_controller)
-        self.optimizations_controller = optimizations_controller.CreateController(optimization_settings["optimizations"],model,self.model_parts_controller,self.analyses_controller,self.responses_controller,self.controls_controller)
-
-
-    def _ValidateSettings(self, optimization_settings):
-        self._ValidateTopLevelSettings(optimization_settings)
-    # ------------------------------------------------------------------------------
-    def _ValidateTopLevelSettings(self, optimization_settings):
-        default_settings = KM.Parameters("""
-        {
-            "model_parts" : [ ],
-            "analyses" : [ ],
-            "responses" : [ ],            
-            "controls" : [ ],
-            "optimizations" : [ ]
-        }""")
-
-        for key in default_settings.keys():
-            if not optimization_settings.Has(key):
-                raise RuntimeError("Optimizer: Required setting '{}' missing in optimizer's input parameters !".format(key))
-
-        optimization_settings.ValidateAndAssignDefaults(default_settings)
-
-       
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ==============================================================================
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+from KratosMultiphysics.OptimizationApplication import model_parts_controller
+from KratosMultiphysics.OptimizationApplication import analyses_controller
+from KratosMultiphysics.OptimizationApplication import responses_controller
+from KratosMultiphysics.OptimizationApplication import controls_controller
+from KratosMultiphysics.OptimizationApplication import optimizations_controller
+
+# additional imports
+
+
+## Purely for backward compatibility, should be removed soon.
+def CreateOptimizer(optimization_settings,model):
+    return Optimizer(optimization_settings,model)
+
+def Create(optimization_settings,model):
+    return Optimizer(optimization_settings,model)
+
+# ==============================================================================
+class Optimizer:
+    # --------------------------------------------------------------------------
+    def __init__(self, optimization_settings,model):
+        self._ValidateSettings(optimization_settings)
+        self.optimization_settings = optimization_settings
+        self.model_parts_controller = model_parts_controller.CreateController(optimization_settings["model_parts"],model)
+        self.analyses_controller = analyses_controller.CreateController(optimization_settings["analyses"],model,self.model_parts_controller)
+        self.responses_controller = responses_controller.CreateController(optimization_settings["responses"],model,self.model_parts_controller,self.analyses_controller)
+        self.controls_controller = controls_controller.CreateController(optimization_settings["controls"],model,self.model_parts_controller)
+        self.optimizations_controller = optimizations_controller.CreateController(optimization_settings["optimizations"],model,self.model_parts_controller,self.analyses_controller,self.responses_controller,self.controls_controller)
+
+
+    def _ValidateSettings(self, optimization_settings):
+        self._ValidateTopLevelSettings(optimization_settings)
+    # ------------------------------------------------------------------------------
+    def _ValidateTopLevelSettings(self, optimization_settings):
+        default_settings = KM.Parameters("""
+        {
+            "model_parts" : [ ],
+            "analyses" : [ ],
+            "responses" : [ ],            
+            "controls" : [ ],
+            "optimizations" : [ ]
+        }""")
+
+        for key in default_settings.keys():
+            if not optimization_settings.Has(key):
+                raise RuntimeError("Optimizer: Required setting '{}' missing in optimizer's input parameters !".format(key))
+
+        optimization_settings.ValidateAndAssignDefaults(default_settings)
+
+
```

## KratosMultiphysics/OptimizationApplication/responses_controller.py

 * *Ordering differences only*

```diff
@@ -1,390 +1,390 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ==============================================================================
-
-# additional imports
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-from KratosMultiphysics import Logger
-
-# Additional imports
-import KratosMultiphysics.OptimizationApplication.responses.analysis_based_response_function_factory as analysis_based_response_function_factory
-import KratosMultiphysics.OptimizationApplication.responses.analysis_free_response_function_factory as analysis_free_response_function_factory
-import time as timer
-
-# ==============================================================================
-def CreateController(reponses_settings,model,model_parts_controller,analyses_controller):
-    return ResponsesController(reponses_settings,model,model_parts_controller,analyses_controller)
-
-# ==============================================================================
-class ResponsesController:
-    # --------------------------------------------------------------------------
-    def __init__(self,reponses_settings,model,model_parts_controller,analyses_controller):
-        
-        self.reponses_settings = reponses_settings
-        self.analyses_controller = analyses_controller
-        self.model_parts_controller = model_parts_controller
-        self.model = model
-
-        required_settings = KM.Parameters("""
-        {
-            "name"                : "REPONSE_NAME",
-            "type"                : "RESPONSE_TYPE",
-            "settings"                : {
-                "evaluated_objects": [],
-                "controlled_objects": [],
-                "control_types": []                
-            }
-        }""")
-
-      
-        for itr in range(self.reponses_settings.size()):
-            for key in required_settings.keys():
-                if not self.reponses_settings[itr].Has(key):
-                    raise RuntimeError("ResponsesController: Required entry '{}' missing in 'response Nr.{}'!".format(key,itr+1))     
-
-            for key in required_settings["settings"].keys():
-                if not self.reponses_settings[itr]["settings"].Has(key):
-                    raise RuntimeError("ResponsesController: Required entry '{}' missing in settings of 'response Nr.{}'!".format(key,itr+1)) 
-
-
-        analysis_based_responses = ["partition_interface_stress"]
-        structural_responses = ["strain_energy", "stress"]        
-        analysis_based_responses.extend(structural_responses)
-
-        analysis_free_responses = ["mass","linear","plane_symmetry","interface","partition_mass","am_max_overhang_angle"]
-        shape_opt_responses = ["plane_based_packaging","mesh_based_packaging","surface_normal_shape_change","face_angle","airfoil_chord_length",
-                               "airfoil_perimeter","total_volume"]                                
-        analysis_free_responses.extend(shape_opt_responses)
-
-        self.supported_responses = []
-        self.supported_responses.extend(analysis_based_responses) 
-        self.supported_responses.extend(analysis_free_responses)
-
-
-        self.responses = {}
-        self.responses_type = {}
-        self.responses_analyses = {}
-        self.responses_evaluated_objects = {}
-        self.responses_controlled_objects = {}
-        self.responses_control_types = {}
-        for itr in range(self.reponses_settings.size()):
-            response_settings = self.reponses_settings[itr]
-            response_name = response_settings["name"].GetString()            
-            response_type = response_settings["type"].GetString()
-
-            # check for name
-            if  response_name in self.responses.keys():  
-                raise RuntimeError("ResponsesController: Response name {} already exists.".format(response_name))
-
-            # check for evaluated_objects
-            evaluated_objects = response_settings["settings"]["evaluated_objects"].GetStringArray()                  
-            if len(evaluated_objects)>0:
-                self.model_parts_controller.CheckIfRootModelPartsExist(evaluated_objects,True)
-            else:
-                raise RuntimeError("ResponsesController: 'evaluated_objects' of response {} can not be empty.".format(response_name))
-
-            self.responses_evaluated_objects[response_name] = evaluated_objects
-            
-            # check for controlled_objects   
-            controlled_objects = response_settings["settings"]["controlled_objects"].GetStringArray()                      
-            if len(controlled_objects)>0:
-                self.model_parts_controller.CheckIfRootModelPartsExist(controlled_objects,True)
-            else:
-                raise RuntimeError("ResponsesController: 'controlled_objects' of response {} can not be empty.".format(response_name))                
-            self.responses_controlled_objects[response_name] = controlled_objects
-
-            # check if controlled_objects and evaluated_objects have the same root model parts
-            first_root_evaluated_model_part = evaluated_objects[0].split(".")[0]
-
-            for model_part in evaluated_objects:
-                if model_part.split(".")[0] != first_root_evaluated_model_part:
-                    raise RuntimeError("ResponsesController: 'evaluated_objects' of response {} must have the same root model part.".format(response_name))                     
-
-            first_root_controlled_model_part = controlled_objects[0].split(".")[0]
-            for model_part in controlled_objects:
-                if model_part.split(".")[0] != first_root_controlled_model_part:
-                    raise RuntimeError("ResponsesController: 'controlled_objects' of response {} must have the same root model part.".format(response_name))  
-
-            if first_root_controlled_model_part != first_root_evaluated_model_part:
-                raise RuntimeError("ResponsesController: 'controlled_objects' and 'evaluated_objects' of response {} must have the same root model parts.".format(response_name))                  
-
-            # check for control_types
-            control_types = response_settings["settings"]["control_types"].GetStringArray()
-            if len(control_types) != len(controlled_objects):
-                raise RuntimeError("ResponsesController: 'control_types' of response {} must be of the same size as controlled_objects .".format(response_name)) 
-            self.responses_control_types[response_name] = control_types              
-
-            response = None
-            if response_type in analysis_based_responses:
-                if not response_settings["settings"].Has("analysis_name"):
-                    raise RuntimeError("ResponsesController: Response {} of type {} requires analysis with analysis_name entry in settings".format(response_name,response_type)) 
-                response_analysis_name = response_settings["settings"]["analysis_name"].GetString()
-                response_analysis = analyses_controller.GetAnalysis(response_analysis_name)
-                response = analysis_based_response_function_factory.CreateResponseFunction(response_name,response_type,response_settings["settings"],response_analysis,model)
-                self.responses_analyses[response_name] = response_analysis_name
-            elif response_type in analysis_free_responses:
-                response = analysis_free_response_function_factory.CreateResponseFunction(response_name,response_type,response_settings["settings"],model)
-                self.responses_analyses[response_name] = None
-            else:
-                raise RuntimeError("ResponsesController: Response {} of type {} is not supported, supported responses are {}".format(response_name,response_type,self.supported_responses)) 
-            
-            self.responses[response_name] = response
-
-            self.responses_type[response_name] = response_type
-            
-        # here we do dependency checks
-        for itr1 in range(self.reponses_settings.size()):
-            response_settings1 = self.reponses_settings[itr1]
-            response_name1 = response_settings1["name"].GetString()            
-            response_type1 = response_settings1["type"].GetString()
-            response_analysis1 = None
-            if response_settings1["settings"].Has("analysis_name"):
-                response_analysis1 = response_settings1["settings"]["analysis_name"].GetString()
-            evaluated_objects1 = response_settings1["settings"]["evaluated_objects"].GetStringArray()
-            controlled_objects1 = response_settings1["settings"]["controlled_objects"].GetStringArray() 
-            control_types1 = response_settings1["settings"]["control_types"].GetStringArray()
-
-            for itr2 in range(self.reponses_settings.size()):
-                if itr1 != itr2:
-                    response_settings2 = self.reponses_settings[itr2]
-                    response_name2 = response_settings2["name"].GetString()            
-                    response_type2 = response_settings2["type"].GetString()    
-                    response_analysis2 = None
-                    if response_settings2["settings"].Has("analysis_name"):
-                        response_analysis2 = response_settings2["settings"]["analysis_name"].GetString()                                    
-                    evaluated_objects2 = response_settings2["settings"]["evaluated_objects"].GetStringArray()
-                    controlled_objects2 = response_settings2["settings"]["controlled_objects"].GetStringArray() 
-                    control_types2 = response_settings2["settings"]["control_types"].GetStringArray()
-                    if response_name1 == response_name2:
-                        raise RuntimeError("ResponsesController: Response name {} is duplicated.".format(response_name1))
-                    if response_type1 == response_type2 and response_analysis1 == response_analysis2:
-                        overlap_evaluated_objects =  list(set(evaluated_objects1) & set(evaluated_objects2))
-                        if len(overlap_evaluated_objects)>0:
-                            overlap_controlled_objects =  list(set(controlled_objects1) & set(controlled_objects2))
-                            if len(overlap_controlled_objects)>0:
-                                for control_obj in overlap_controlled_objects:
-                                    index_1 = controlled_objects1.index(control_obj)
-                                    index_2 = controlled_objects2.index(control_obj)
-                                    type_1 = control_types1[index_1]
-                                    type_2 = control_types2[index_2]
-                                    if type_1 == type_2:
-                                        raise RuntimeError("ResponsesController: found dependencies between Response {} and Response {}".format(response_name1,response_name2))
-
-
-    # --------------------------------------------------------------------------
-    def Initialize(self):
-        for response in self.responses.values():
-            response.Initialize()
-
-    # --------------------------------------------------------------------------
-    def CheckIfResponseExists(self,response_name,raise_error=True):
-        if not response_name in self.responses.keys():
-            if raise_error:
-                raise RuntimeError("ResponsesController:CheckIfResponseExists: Response name {} does not exist.".format(response_name))
-            else: 
-                return False
-        else:
-            return True
-
-    # --------------------------------------------------------------------------
-    def CheckIfResponsesExist(self,responses_name,raise_error=True):
-        if type(responses_name) is not list:
-            raise RuntimeError("ResponsesController:CheckIfResponsesExist requires list of response names")
-        
-        if_exist = True
-        for response_name in responses_name:
-            if not response_name in self.responses.keys():
-                if raise_error:
-                    raise RuntimeError("ResponsesController:CheckIfResponsesExist: Response {} does not exist!".format(response_name))
-                else:
-                    if_exist = False
-                    break
-
-        return if_exist                    
-
-    # --------------------------------------------------------------------------
-    def CalculateResponseValue(self,response_name):
-        if not response_name in self.responses.keys():
-            raise RuntimeError("ResponsesController:CalculateResponseValue: Try to calculate response {} which does not exist.".format(response_name))
-        else:
-            response_value = self.responses[response_name].CalculateValue()
-        return response_value
-
-    # --------------------------------------------------------------------------
-    def CalculateResponsesValue(self,responses_name):
-        if type(responses_name) is not list:
-            raise RuntimeError("ResponsesController:CalculateResponsesValue requires list of response names")
-
-        responses_value = {}
-        for response_name in responses_name:
-            if not response_name in self.responses.keys():
-                raise RuntimeError("ResponsesController:CalculateResponsesValue: Try to calculate response {} which does not exist.".format(response_name))            
-            responses_value[response_name] = self.responses[response_name].CalculateValue()
-
-        return responses_value        
-
-    # --------------------------------------------------------------------------
-    def CalculateAllValues(self):
-        responses_values = []
-        Logger.PrintInfo("ResponsesController:CalculateAllValues: Starting calculation of values of responses ")
-        startTime = timer.time()          
-        for name,response in self.responses.items():          
-            response_value = response.CalculateValue()
-            responses_values.append(response_value)
-        Logger.PrintInfo("ResponsesController:CalculateAllValues: Time needed for all response values calculation ",round(timer.time() - startTime,2),"s")            
-        return responses_values
-    # --------------------------------------------------------------------------
-    def CalculateResponseGradients(self,response_name):
-        if not response_name in self.responses.keys():
-            raise RuntimeError("ResponsesController:CalculateResponseGradient: Try to calculate all gradients of response {} which does not exist ".format(response_name))
-        else:
-            self.responses[response_name].CalculateGradients()
-
-    # --------------------------------------------------------------------------
-    def CalculateResponsesGradients(self,responses_name):
-
-        if type(responses_name) is not list:
-            raise RuntimeError("ResponsesController:CalculateResponsesGradients requires list of response names")
-
-        for response_name in responses_name:
-            if not response_name in self.responses.keys():
-                raise RuntimeError("ResponsesController:CalculateResponsesGradients: Try to calculate gradients of response {} which does not exist.".format(response_name))            
-            self.responses[response_name].CalculateGradients()
-
-    # --------------------------------------------------------------------------
-    def GetResponseGradients(self,response_name):
-        if not response_name in self.responses.keys():
-            raise RuntimeError("ResponsesController:GetResponseGradients: Try to calculate all gradients of response {} which does not exist ".format(response_name))
-        else:
-            return self.responses[response_name].GetGradients()
-
-    # --------------------------------------------------------------------------
-    def GetResponseAnalysis(self,response_name):
-
-        if not response_name in self.responses.keys():
-            raise RuntimeError("ResponsesController:GetResponseAnalysis: Try to get analysis of response {} which does not exist ".format(response_name))
-        
-        return self.responses_analyses[response_name]
-    # --------------------------------------------------------------------------
-    def GetResponsesAnalyses(self,responses_name):
-        if type(responses_name) is not list:
-            raise RuntimeError("ResponsesController:GetResponsesAnalyses requires list of response names")        
-
-        analyses_list = []
-        for response_name in responses_name:
-            if self.responses_analyses[response_name] != None:
-                analyses_list.append(self.responses_analyses[response_name])
-        
-        return list(set(analyses_list)) # here we remove duplicates     
-    # --------------------------------------------------------------------------
-    def GetResponsesForControl(self,control_type,controlled_objects):
-   
-
-        if type(controlled_objects) is not list:
-            raise RuntimeError("ResponsesController:GetResponsesForControl requires a control type and list of controlled objects")  
-
-        response_dict = {}
-        for response_name in self.responses_controlled_objects.keys():
-            response_control_types = self.responses_control_types[response_name]
-            response_controlled_objects = self.responses_controlled_objects[response_name]
-            overlap_objects =  list(set(controlled_objects) & set(response_controlled_objects))
-            if len(overlap_objects)>0:
-                for object in overlap_objects:
-                    index = response_controlled_objects.index(object)
-                    object_control_type = response_control_types[index]
-                    if object_control_type == control_type:
-                        if response_name in response_dict.keys():
-                            response_dict[response_name].append(object)
-                        else:
-                            response_dict[response_name] = [object]
-
-
-        return response_dict
-
-
-    # --------------------------------------------------------------------------
-    def CalculateResponseGradientsForTypesAndObjects(self,response_name,control_types,controlled_objects,raise_error=True):
-
-        if type(controlled_objects) is not list:
-            raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypesAndObjects requires list of controlled objects") 
-
-        if type(control_types) is not list:
-            raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypesAndObjects requires list of control types")
-
-        if len(control_types) != len(controlled_objects):
-            raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypesAndObjects control types and control object lists should have the same size !")
-
-        if raise_error:
-            if response_name not in self.responses.keys():
-                raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypesAndObjects: response {} does not exist".format(response_name))
-            
-            for i_index in range(len(controlled_objects)):
-                controlled_object = controlled_objects[i_index]
-                control_type = control_types[i_index]
-                found = False
-                for r_index in range(len(self.responses_controlled_objects[response_name])):
-                    response_controlled_object = self.responses_controlled_objects[response_name][r_index]
-                    response_controlled_type = self.responses_control_types[response_name][r_index]
-                    if response_controlled_object==controlled_object and control_type==response_controlled_type:
-                        found = True
-                        break
-                if not found:
-                    raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypesAndObjects: response {} does not have controlled objects {}".format(response_name,controlled_objects))   
-
-        self.responses[response_name].CalculateGradientsForTypesAndObjects(control_types,controlled_objects,not raise_error)
-    # --------------------------------------------------------------------------
-    def GetResponseType(self,response_name,raise_error=True): 
-        if raise_error:
-            if response_name not in self.responses.keys():
-                raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypeAndObjects: response {} does not exist".format(response_name))   
-
-        return self.responses_type[response_name]
-    # --------------------------------------------------------------------------
-    def GetResponseVariableName(self, response_name, raise_error=True): 
-        if raise_error:
-            if response_name not in self.responses.keys():
-                raise RuntimeError("ResponsesController:GetResponseVariableName: response {} does not exist".format(response_name))           
-        return self.responses[response_name].GetVariableName()
-
-    # --------------------------------------------------------------------------
-    def GetResponseControlledObjects(self, response_name, raise_error=True): 
-        if raise_error:
-            if response_name not in self.responses.keys():
-                raise RuntimeError("ResponsesController:GetResponseControlledObjects: response {} does not exist".format(response_name)) 
-
-        return self.responses_controlled_objects[response_name]
-    # --------------------------------------------------------------------------
-    def GetResponseControlTypes(self, response_name, raise_error=True): 
-        if raise_error:
-            if response_name not in self.responses.keys():
-                raise RuntimeError("ResponsesController:GetResponseControlTypes: response {} does not exist".format(response_name)) 
-
-        return self.responses_control_types[response_name]
-    # --------------------------------------------------------------------------
-    def GetResponseGradientsVariablesName(self, response_name, raise_error=True): 
-        if raise_error:
-            if response_name not in self.responses.keys():
-                raise RuntimeError("ResponsesController:GetResponseGradientsVariablesName: response {} does not exist".format(response_name))           
-        return self.responses[response_name].GetGradientsVariablesName() 
-
-    # --------------------------------------------------------------------------
-    def GetResponseGradientVariableNameForType(self, response_name, control_type, raise_error=True): 
-        if raise_error:
-            if response_name not in self.responses.keys():
-                raise RuntimeError("ResponsesController:GetGradientsVariablesName: response {} does not exist".format(response_name))           
-        return self.responses[response_name].GetGradientVariableNameForType(control_type)      
-                
-
-
-
-            
-
-               
-
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ==============================================================================
+
+# additional imports
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+from KratosMultiphysics import Logger
+
+# Additional imports
+import KratosMultiphysics.OptimizationApplication.responses.analysis_based_response_function_factory as analysis_based_response_function_factory
+import KratosMultiphysics.OptimizationApplication.responses.analysis_free_response_function_factory as analysis_free_response_function_factory
+import time as timer
+
+# ==============================================================================
+def CreateController(reponses_settings,model,model_parts_controller,analyses_controller):
+    return ResponsesController(reponses_settings,model,model_parts_controller,analyses_controller)
+
+# ==============================================================================
+class ResponsesController:
+    # --------------------------------------------------------------------------
+    def __init__(self,reponses_settings,model,model_parts_controller,analyses_controller):
+        
+        self.reponses_settings = reponses_settings
+        self.analyses_controller = analyses_controller
+        self.model_parts_controller = model_parts_controller
+        self.model = model
+
+        required_settings = KM.Parameters("""
+        {
+            "name"                : "REPONSE_NAME",
+            "type"                : "RESPONSE_TYPE",
+            "settings"                : {
+                "evaluated_objects": [],
+                "controlled_objects": [],
+                "control_types": []                
+            }
+        }""")
+
+      
+        for itr in range(self.reponses_settings.size()):
+            for key in required_settings.keys():
+                if not self.reponses_settings[itr].Has(key):
+                    raise RuntimeError("ResponsesController: Required entry '{}' missing in 'response Nr.{}'!".format(key,itr+1))     
+
+            for key in required_settings["settings"].keys():
+                if not self.reponses_settings[itr]["settings"].Has(key):
+                    raise RuntimeError("ResponsesController: Required entry '{}' missing in settings of 'response Nr.{}'!".format(key,itr+1)) 
+
+
+        analysis_based_responses = ["partition_interface_stress"]
+        structural_responses = ["strain_energy", "stress"]        
+        analysis_based_responses.extend(structural_responses)
+
+        analysis_free_responses = ["mass","linear","plane_symmetry","interface","partition_mass","am_max_overhang_angle"]
+        shape_opt_responses = ["plane_based_packaging","mesh_based_packaging","surface_normal_shape_change","face_angle","airfoil_chord_length",
+                               "airfoil_perimeter","total_volume"]                                
+        analysis_free_responses.extend(shape_opt_responses)
+
+        self.supported_responses = []
+        self.supported_responses.extend(analysis_based_responses) 
+        self.supported_responses.extend(analysis_free_responses)
+
+
+        self.responses = {}
+        self.responses_type = {}
+        self.responses_analyses = {}
+        self.responses_evaluated_objects = {}
+        self.responses_controlled_objects = {}
+        self.responses_control_types = {}
+        for itr in range(self.reponses_settings.size()):
+            response_settings = self.reponses_settings[itr]
+            response_name = response_settings["name"].GetString()            
+            response_type = response_settings["type"].GetString()
+
+            # check for name
+            if  response_name in self.responses.keys():  
+                raise RuntimeError("ResponsesController: Response name {} already exists.".format(response_name))
+
+            # check for evaluated_objects
+            evaluated_objects = response_settings["settings"]["evaluated_objects"].GetStringArray()                  
+            if len(evaluated_objects)>0:
+                self.model_parts_controller.CheckIfRootModelPartsExist(evaluated_objects,True)
+            else:
+                raise RuntimeError("ResponsesController: 'evaluated_objects' of response {} can not be empty.".format(response_name))
+
+            self.responses_evaluated_objects[response_name] = evaluated_objects
+            
+            # check for controlled_objects   
+            controlled_objects = response_settings["settings"]["controlled_objects"].GetStringArray()                      
+            if len(controlled_objects)>0:
+                self.model_parts_controller.CheckIfRootModelPartsExist(controlled_objects,True)
+            else:
+                raise RuntimeError("ResponsesController: 'controlled_objects' of response {} can not be empty.".format(response_name))                
+            self.responses_controlled_objects[response_name] = controlled_objects
+
+            # check if controlled_objects and evaluated_objects have the same root model parts
+            first_root_evaluated_model_part = evaluated_objects[0].split(".")[0]
+
+            for model_part in evaluated_objects:
+                if model_part.split(".")[0] != first_root_evaluated_model_part:
+                    raise RuntimeError("ResponsesController: 'evaluated_objects' of response {} must have the same root model part.".format(response_name))                     
+
+            first_root_controlled_model_part = controlled_objects[0].split(".")[0]
+            for model_part in controlled_objects:
+                if model_part.split(".")[0] != first_root_controlled_model_part:
+                    raise RuntimeError("ResponsesController: 'controlled_objects' of response {} must have the same root model part.".format(response_name))  
+
+            if first_root_controlled_model_part != first_root_evaluated_model_part:
+                raise RuntimeError("ResponsesController: 'controlled_objects' and 'evaluated_objects' of response {} must have the same root model parts.".format(response_name))                  
+
+            # check for control_types
+            control_types = response_settings["settings"]["control_types"].GetStringArray()
+            if len(control_types) != len(controlled_objects):
+                raise RuntimeError("ResponsesController: 'control_types' of response {} must be of the same size as controlled_objects .".format(response_name)) 
+            self.responses_control_types[response_name] = control_types              
+
+            response = None
+            if response_type in analysis_based_responses:
+                if not response_settings["settings"].Has("analysis_name"):
+                    raise RuntimeError("ResponsesController: Response {} of type {} requires analysis with analysis_name entry in settings".format(response_name,response_type)) 
+                response_analysis_name = response_settings["settings"]["analysis_name"].GetString()
+                response_analysis = analyses_controller.GetAnalysis(response_analysis_name)
+                response = analysis_based_response_function_factory.CreateResponseFunction(response_name,response_type,response_settings["settings"],response_analysis,model)
+                self.responses_analyses[response_name] = response_analysis_name
+            elif response_type in analysis_free_responses:
+                response = analysis_free_response_function_factory.CreateResponseFunction(response_name,response_type,response_settings["settings"],model)
+                self.responses_analyses[response_name] = None
+            else:
+                raise RuntimeError("ResponsesController: Response {} of type {} is not supported, supported responses are {}".format(response_name,response_type,self.supported_responses)) 
+            
+            self.responses[response_name] = response
+
+            self.responses_type[response_name] = response_type
+            
+        # here we do dependency checks
+        for itr1 in range(self.reponses_settings.size()):
+            response_settings1 = self.reponses_settings[itr1]
+            response_name1 = response_settings1["name"].GetString()            
+            response_type1 = response_settings1["type"].GetString()
+            response_analysis1 = None
+            if response_settings1["settings"].Has("analysis_name"):
+                response_analysis1 = response_settings1["settings"]["analysis_name"].GetString()
+            evaluated_objects1 = response_settings1["settings"]["evaluated_objects"].GetStringArray()
+            controlled_objects1 = response_settings1["settings"]["controlled_objects"].GetStringArray() 
+            control_types1 = response_settings1["settings"]["control_types"].GetStringArray()
+
+            for itr2 in range(self.reponses_settings.size()):
+                if itr1 != itr2:
+                    response_settings2 = self.reponses_settings[itr2]
+                    response_name2 = response_settings2["name"].GetString()            
+                    response_type2 = response_settings2["type"].GetString()    
+                    response_analysis2 = None
+                    if response_settings2["settings"].Has("analysis_name"):
+                        response_analysis2 = response_settings2["settings"]["analysis_name"].GetString()                                    
+                    evaluated_objects2 = response_settings2["settings"]["evaluated_objects"].GetStringArray()
+                    controlled_objects2 = response_settings2["settings"]["controlled_objects"].GetStringArray() 
+                    control_types2 = response_settings2["settings"]["control_types"].GetStringArray()
+                    if response_name1 == response_name2:
+                        raise RuntimeError("ResponsesController: Response name {} is duplicated.".format(response_name1))
+                    if response_type1 == response_type2 and response_analysis1 == response_analysis2:
+                        overlap_evaluated_objects =  list(set(evaluated_objects1) & set(evaluated_objects2))
+                        if len(overlap_evaluated_objects)>0:
+                            overlap_controlled_objects =  list(set(controlled_objects1) & set(controlled_objects2))
+                            if len(overlap_controlled_objects)>0:
+                                for control_obj in overlap_controlled_objects:
+                                    index_1 = controlled_objects1.index(control_obj)
+                                    index_2 = controlled_objects2.index(control_obj)
+                                    type_1 = control_types1[index_1]
+                                    type_2 = control_types2[index_2]
+                                    if type_1 == type_2:
+                                        raise RuntimeError("ResponsesController: found dependencies between Response {} and Response {}".format(response_name1,response_name2))
+
+
+    # --------------------------------------------------------------------------
+    def Initialize(self):
+        for response in self.responses.values():
+            response.Initialize()
+
+    # --------------------------------------------------------------------------
+    def CheckIfResponseExists(self,response_name,raise_error=True):
+        if not response_name in self.responses.keys():
+            if raise_error:
+                raise RuntimeError("ResponsesController:CheckIfResponseExists: Response name {} does not exist.".format(response_name))
+            else: 
+                return False
+        else:
+            return True
+
+    # --------------------------------------------------------------------------
+    def CheckIfResponsesExist(self,responses_name,raise_error=True):
+        if type(responses_name) is not list:
+            raise RuntimeError("ResponsesController:CheckIfResponsesExist requires list of response names")
+        
+        if_exist = True
+        for response_name in responses_name:
+            if not response_name in self.responses.keys():
+                if raise_error:
+                    raise RuntimeError("ResponsesController:CheckIfResponsesExist: Response {} does not exist!".format(response_name))
+                else:
+                    if_exist = False
+                    break
+
+        return if_exist                    
+
+    # --------------------------------------------------------------------------
+    def CalculateResponseValue(self,response_name):
+        if not response_name in self.responses.keys():
+            raise RuntimeError("ResponsesController:CalculateResponseValue: Try to calculate response {} which does not exist.".format(response_name))
+        else:
+            response_value = self.responses[response_name].CalculateValue()
+        return response_value
+
+    # --------------------------------------------------------------------------
+    def CalculateResponsesValue(self,responses_name):
+        if type(responses_name) is not list:
+            raise RuntimeError("ResponsesController:CalculateResponsesValue requires list of response names")
+
+        responses_value = {}
+        for response_name in responses_name:
+            if not response_name in self.responses.keys():
+                raise RuntimeError("ResponsesController:CalculateResponsesValue: Try to calculate response {} which does not exist.".format(response_name))            
+            responses_value[response_name] = self.responses[response_name].CalculateValue()
+
+        return responses_value        
+
+    # --------------------------------------------------------------------------
+    def CalculateAllValues(self):
+        responses_values = []
+        Logger.PrintInfo("ResponsesController:CalculateAllValues: Starting calculation of values of responses ")
+        startTime = timer.time()          
+        for name,response in self.responses.items():          
+            response_value = response.CalculateValue()
+            responses_values.append(response_value)
+        Logger.PrintInfo("ResponsesController:CalculateAllValues: Time needed for all response values calculation ",round(timer.time() - startTime,2),"s")            
+        return responses_values
+    # --------------------------------------------------------------------------
+    def CalculateResponseGradients(self,response_name):
+        if not response_name in self.responses.keys():
+            raise RuntimeError("ResponsesController:CalculateResponseGradient: Try to calculate all gradients of response {} which does not exist ".format(response_name))
+        else:
+            self.responses[response_name].CalculateGradients()
+
+    # --------------------------------------------------------------------------
+    def CalculateResponsesGradients(self,responses_name):
+
+        if type(responses_name) is not list:
+            raise RuntimeError("ResponsesController:CalculateResponsesGradients requires list of response names")
+
+        for response_name in responses_name:
+            if not response_name in self.responses.keys():
+                raise RuntimeError("ResponsesController:CalculateResponsesGradients: Try to calculate gradients of response {} which does not exist.".format(response_name))            
+            self.responses[response_name].CalculateGradients()
+
+    # --------------------------------------------------------------------------
+    def GetResponseGradients(self,response_name):
+        if not response_name in self.responses.keys():
+            raise RuntimeError("ResponsesController:GetResponseGradients: Try to calculate all gradients of response {} which does not exist ".format(response_name))
+        else:
+            return self.responses[response_name].GetGradients()
+
+    # --------------------------------------------------------------------------
+    def GetResponseAnalysis(self,response_name):
+
+        if not response_name in self.responses.keys():
+            raise RuntimeError("ResponsesController:GetResponseAnalysis: Try to get analysis of response {} which does not exist ".format(response_name))
+        
+        return self.responses_analyses[response_name]
+    # --------------------------------------------------------------------------
+    def GetResponsesAnalyses(self,responses_name):
+        if type(responses_name) is not list:
+            raise RuntimeError("ResponsesController:GetResponsesAnalyses requires list of response names")        
+
+        analyses_list = []
+        for response_name in responses_name:
+            if self.responses_analyses[response_name] != None:
+                analyses_list.append(self.responses_analyses[response_name])
+        
+        return list(set(analyses_list)) # here we remove duplicates     
+    # --------------------------------------------------------------------------
+    def GetResponsesForControl(self,control_type,controlled_objects):
+   
+
+        if type(controlled_objects) is not list:
+            raise RuntimeError("ResponsesController:GetResponsesForControl requires a control type and list of controlled objects")  
+
+        response_dict = {}
+        for response_name in self.responses_controlled_objects.keys():
+            response_control_types = self.responses_control_types[response_name]
+            response_controlled_objects = self.responses_controlled_objects[response_name]
+            overlap_objects =  list(set(controlled_objects) & set(response_controlled_objects))
+            if len(overlap_objects)>0:
+                for object in overlap_objects:
+                    index = response_controlled_objects.index(object)
+                    object_control_type = response_control_types[index]
+                    if object_control_type == control_type:
+                        if response_name in response_dict.keys():
+                            response_dict[response_name].append(object)
+                        else:
+                            response_dict[response_name] = [object]
+
+
+        return response_dict
+
+
+    # --------------------------------------------------------------------------
+    def CalculateResponseGradientsForTypesAndObjects(self,response_name,control_types,controlled_objects,raise_error=True):
+
+        if type(controlled_objects) is not list:
+            raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypesAndObjects requires list of controlled objects") 
+
+        if type(control_types) is not list:
+            raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypesAndObjects requires list of control types")
+
+        if len(control_types) != len(controlled_objects):
+            raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypesAndObjects control types and control object lists should have the same size !")
+
+        if raise_error:
+            if response_name not in self.responses.keys():
+                raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypesAndObjects: response {} does not exist".format(response_name))
+            
+            for i_index in range(len(controlled_objects)):
+                controlled_object = controlled_objects[i_index]
+                control_type = control_types[i_index]
+                found = False
+                for r_index in range(len(self.responses_controlled_objects[response_name])):
+                    response_controlled_object = self.responses_controlled_objects[response_name][r_index]
+                    response_controlled_type = self.responses_control_types[response_name][r_index]
+                    if response_controlled_object==controlled_object and control_type==response_controlled_type:
+                        found = True
+                        break
+                if not found:
+                    raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypesAndObjects: response {} does not have controlled objects {}".format(response_name,controlled_objects))   
+
+        self.responses[response_name].CalculateGradientsForTypesAndObjects(control_types,controlled_objects,not raise_error)
+    # --------------------------------------------------------------------------
+    def GetResponseType(self,response_name,raise_error=True): 
+        if raise_error:
+            if response_name not in self.responses.keys():
+                raise RuntimeError("ResponsesController:CalculateResponseGradientsForTypeAndObjects: response {} does not exist".format(response_name))   
+
+        return self.responses_type[response_name]
+    # --------------------------------------------------------------------------
+    def GetResponseVariableName(self, response_name, raise_error=True): 
+        if raise_error:
+            if response_name not in self.responses.keys():
+                raise RuntimeError("ResponsesController:GetResponseVariableName: response {} does not exist".format(response_name))           
+        return self.responses[response_name].GetVariableName()
+
+    # --------------------------------------------------------------------------
+    def GetResponseControlledObjects(self, response_name, raise_error=True): 
+        if raise_error:
+            if response_name not in self.responses.keys():
+                raise RuntimeError("ResponsesController:GetResponseControlledObjects: response {} does not exist".format(response_name)) 
+
+        return self.responses_controlled_objects[response_name]
+    # --------------------------------------------------------------------------
+    def GetResponseControlTypes(self, response_name, raise_error=True): 
+        if raise_error:
+            if response_name not in self.responses.keys():
+                raise RuntimeError("ResponsesController:GetResponseControlTypes: response {} does not exist".format(response_name)) 
+
+        return self.responses_control_types[response_name]
+    # --------------------------------------------------------------------------
+    def GetResponseGradientsVariablesName(self, response_name, raise_error=True): 
+        if raise_error:
+            if response_name not in self.responses.keys():
+                raise RuntimeError("ResponsesController:GetResponseGradientsVariablesName: response {} does not exist".format(response_name))           
+        return self.responses[response_name].GetGradientsVariablesName() 
+
+    # --------------------------------------------------------------------------
+    def GetResponseGradientVariableNameForType(self, response_name, control_type, raise_error=True): 
+        if raise_error:
+            if response_name not in self.responses.keys():
+                raise RuntimeError("ResponsesController:GetGradientsVariablesName: response {} does not exist".format(response_name))           
+        return self.responses[response_name].GetGradientVariableNameForType(control_type)      
+                
+
+
+
+            
+
+               
+
```

## KratosMultiphysics/OptimizationApplication/algorithms/NLOPT_algorithms.py

```diff
@@ -1,249 +1,252 @@
-try:
-    import nlopt
-except ImportError:
-    raise Exception("NLOPT python library is not available")
-
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.algorithms.standardized_NLOPT_objective import StandardizedNLOPTObjective
-from KratosMultiphysics.OptimizationApplication.algorithms.standardized_NLOPT_constraint import StandardizedNLOPTConstraint
-from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
-from KratosMultiphysics.OptimizationApplication.algorithms.algorithm import Algorithm
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
-
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-    return NLOPTAlgorithms(model, parameters, optimization_problem)
-
-class NLOPTAlgorithms(Algorithm):
-    """
-        A classical steepest descent algorithm to solve unconstrainted optimization problems.
-    """
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        return Kratos.Parameters("""{
-            "module"            : "KratosMultiphysics.OptimizationApplication.algorithms",
-            "type"              : "PLEASE_PROVIDE_AN_ALGORITHM_CLASS_NAME",
-            "objective"         : {},
-            "constraints"         : [],
-            "controls"          : [],
-            "echo_level"        : 0,
-            "NLOPT_settings"          : {
-                "algorithm_name"      : "mma",
-                "subsidiary_algorithm_name" : "",
-                "verbosity"           : 0,
-                "controls_lower_bound": "",
-                "controls_upper_bound": "",
-                "stopping_criteria"   : {
-                   "rel_obj_tol": 1e-3,
-                   "abs_obj_tol": 1e-3,
-                   "rel_contr_tol": 1e-3,
-                   "abs_contr_tol": 1e-3,
-                   "maximum_function_evalualtion": 10
-                },
-                "algorithm_specific_settings"   : {}
-            }
-        }""")
-
-    def __init__(self, model:Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        self.model = model
-        self.parameters = parameters
-        self._optimization_problem = optimization_problem
-
-        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
-
-        # controls
-        self.master_control = MasterControl()
-        for control_name in parameters["controls"].GetStringArray():
-            control = optimization_problem.GetControl(control_name)
-            self.master_control.AddControl(control)
-        self.__control_field = None
-
-        # objective & constraints
-        self.__objective = StandardizedNLOPTObjective(parameters["objective"], self.master_control, self._optimization_problem)
-        self.__constraints = []
-        for constraint_settings in parameters["constraints"]:
-            self.__constraints.append(StandardizedNLOPTConstraint(constraint_settings, self.master_control, self._optimization_problem))
-
-        # nlopt settings
-        NLOPT_settings = parameters["NLOPT_settings"]
-        NLOPT_settings.ValidateAndAssignDefaults(self.GetDefaultParameters()["NLOPT_settings"])
-
-        # nlopt verbosity
-        self.nlopt_verbosity = NLOPT_settings["verbosity"].GetInt()
-
-        # upper and lower bounds
-        self.nlopt_controls_lower_bound = NLOPT_settings["controls_lower_bound"].GetString()
-        self.nlopt_controls_upper_bound = NLOPT_settings["controls_upper_bound"].GetString()
-
-        # nlopt algorithm
-        self.algorithm_name = NLOPT_settings["algorithm_name"].GetString()
-        if len(self.__constraints)==0:
-            self.CheckOptimizerSupport(self.algorithm_name,None)
-        else:
-            for constraint in self.__constraints:
-                if constraint.IsEqualityType():
-                    self.CheckOptimizerSupport(self.algorithm_name,"equality")
-                else:
-                    self.CheckOptimizerSupport(self.algorithm_name,"inequality")
-
-        # nlopt subsidiary algorithm
-        self.subsidiary_algorithm_name = NLOPT_settings["subsidiary_algorithm_name"].GetString()
-        if self.algorithm_name == "augmented_lagrangian":
-            if self.subsidiary_algorithm_name == "":
-                raise ValueError(f"The algorithm {self.algorithm_name} requires a subsidiary optimizer to be provided.")
-            else:
-                self.CheckOptimizerSupport(self.subsidiary_algorithm_name,None)
-
-        # stopping
-        self.stopping_criteria = NLOPT_settings["stopping_criteria"]
-        self.stopping_criteria.ValidateAndAssignDefaults(self.GetDefaultParameters()["NLOPT_settings"]["stopping_criteria"])
-
-        # alg specific settings
-        self.opt_algorithm_specific_settings = NLOPT_settings["algorithm_specific_settings"]
-
-    def GetMinimumBufferSize(self) -> int:
-        return 2
-
-    def Check(self):
-        pass
-
-    def Initialize(self):
-        self.converged = False
-        self.__objective.Initialize()
-        self.__objective.Check()
-        for constraint in self.__constraints:
-            constraint.Initialize()
-            constraint.Check()
-        self.master_control.Initialize()
-        self.__control_field = self.master_control.GetControlField()
-        self.algorithm_data = ComponentDataView("algorithm", self._optimization_problem)
-
-        # create nlopt optimizer
-        self.x0 = self.__control_field.Evaluate()
-        self.x0 = self.x0.reshape(-1)
-        self.nlopt_optimizer = nlopt.opt(self.GetOptimizer(self.algorithm_name), self.x0.size)
-
-        # add subsidiary optimization algorithm
-        if self.subsidiary_algorithm_name != "":
-            self.nlopt_subsidiary_optimizer = nlopt.opt(self.GetOptimizer(self.subsidiary_algorithm_name), self.x0.size)
-            self.nlopt_optimizer.set_local_optimizer(self.nlopt_subsidiary_optimizer)
-        else:
-            self.nlopt_subsidiary_optimizer = None
-
-        # set nlopt verbosity
-        self.nlopt_optimizer.set_param("verbosity",self.nlopt_verbosity)
-
-        # assign objectives and constarints
-        self.nlopt_optimizer.set_min_objective(self.__objective.CalculateStandardizedValueAndGradients)
-        for constraint in self.__constraints:
-            if constraint.IsEqualityType():
-                self.nlopt_optimizer.add_equality_constraint(constraint.CalculateStandardizedValueAndGradients,1e-8)
-            else:
-                self.nlopt_optimizer.add_inequality_constraint(constraint.CalculateStandardizedValueAndGradients,1e-8)
-
-        # now set stopping criteria
-        self.SetOptimizerStoppingCriteria(self.nlopt_optimizer)
-        if self.nlopt_subsidiary_optimizer is not None:
-            self.SetOptimizerStoppingCriteria(self.nlopt_subsidiary_optimizer)
-
-        # set bounds if exist
-        if self.nlopt_controls_lower_bound != "":
-            self.nlopt_optimizer.set_lower_bounds(float(self.nlopt_controls_lower_bound))
-        if self.nlopt_controls_upper_bound != "":
-            self.nlopt_optimizer.set_upper_bounds(float(self.nlopt_controls_upper_bound))
-
-        # now add algorithm specific settings
-        self.SetOptimizerSepcificSettings(self.nlopt_optimizer)
-        if self.nlopt_subsidiary_optimizer is not None:
-            self.SetOptimizerSepcificSettings(self.nlopt_subsidiary_optimizer)
-
-    def Finalize(self):
-        self.__objective.Finalize()
-        for constraint in self.__constraints:
-            constraint.Finalize()
-        self.master_control.Finalize()
-
-    def Solve(self):
-        self.nlopt_optimizer.optimize(self.x0)
-        CallOnAll(self._optimization_problem.GetListOfProcesses("output_processes"), Kratos.OutputProcess.PrintOutput)
-        self.LogTermination()
-
-    def LogTermination(self):
-        stopval = self.nlopt_optimizer.get_stopval()
-        maxtime = self.nlopt_optimizer.get_maxtime()
-        nlopt_result_map = {
-            nlopt.SUCCESS: 'Generic success return value.',
-            nlopt.STOPVAL_REACHED: f'Optimization stopped because stopval ({stopval}) was reached.',
-            nlopt.FTOL_REACHED: f'Optimization stopped because ftol_rel ({self.stopping_criteria["rel_obj_tol"].GetDouble()}) or ftol_abs ({self.stopping_criteria["abs_obj_tol"].GetDouble()}) was reached.',
-            nlopt.XTOL_REACHED: f'Optimization stopped because xtol_rel ({self.stopping_criteria["rel_contr_tol"].GetDouble()}) or xtol_abs ({self.stopping_criteria["abs_contr_tol"].GetDouble()}) was reached.',
-            nlopt.MAXEVAL_REACHED: f'Optimization stopped because maxeval ({self.stopping_criteria["maximum_function_evalualtion"].GetInt()}) was reached.',
-            nlopt.MAXTIME_REACHED: f'Optimization stopped because maxtime ({maxtime}) was reached.',
-            nlopt.FAILURE: 'Generic failure return value.',
-            nlopt.INVALID_ARGS: 'Invalid arguments (e.g. lower bounds are bigger than upper bounds, an unknown algorithm was specified, etcetera).',
-            nlopt.OUT_OF_MEMORY: 'Ran out of memory.',
-            nlopt.ROUNDOFF_LIMITED: 'Halted because roundoff errors limited progress. (In this case, the optimization still typically returns a useful result.)',
-            nlopt.FORCED_STOP: 'Halted because of a forced termination: the user called nlopt_force_stop(opt) on the optimizations nlopt_opt object opt from the users objective function or constraints.'
-        }
-        info = {"Termination":nlopt_result_map[self.nlopt_optimizer.last_optimize_result()]}
-        DictLogger(f"NLOPT-{self.algorithm_name}",info)
-
-    def CheckOptimizerSupport(self, algorithm_name, constraint_type):
-        # Unconstrained gradient-based optimizers
-        unconstrained_optimizers = {"lbfgs","mma","ccsaq","tnewton_precond_restart",
-                                    "tnewton_precond","tnewton_restart","augmented_lagrangian",
-                                    "neldermead","evolutionary"}
-
-        # Constrained gradient-based optimizers with equality constraints
-        equality_constrained_optimizers = {"slsqp","augmented_lagrangian"}
-
-        # Constrained gradient-based optimizers with inequality constraints
-        inequality_constrained_optimizers = {"mma","slsqp","ccsaq","augmented_lagrangian"}
-
-        if constraint_type == "equality":
-            if algorithm_name not in equality_constrained_optimizers:
-                raise ValueError(f"The algorithm {algorithm_name} does not support equality constraints, support {equality_constrained_optimizers}.")
-        elif constraint_type == "inequality":
-            if algorithm_name not in inequality_constrained_optimizers:
-                raise ValueError(f"The algorithm {algorithm_name} does not support inequality constraints, support {inequality_constrained_optimizers}.")
-        else:
-            if algorithm_name not in unconstrained_optimizers:
-                raise ValueError(f"The algorithm {algorithm_name} does not support unconstrained optimization, support {unconstrained_optimizers}.")
-        return True
-
-    def GetOptimizer(self,name):
-        nlopt_algorithm_dict = {
-            "mma": nlopt.LD_MMA,
-            "slsqp": nlopt.LD_SLSQP,
-            "lbfgs": nlopt.LD_LBFGS,
-            "ccsaq": nlopt.LD_CCSAQ,
-            "tnewton_precond_restart": nlopt.LD_TNEWTON_PRECOND_RESTART,
-            "tnewton_precond": nlopt.LD_TNEWTON_PRECOND,
-            "tnewton_restart": nlopt.LD_TNEWTON_RESTART,
-            "augmented_lagrangian": nlopt.AUGLAG,
-            "neldermead": nlopt.LN_NELDERMEAD,
-            "evolutionary": nlopt.GN_ESCH
-        }
-        return nlopt_algorithm_dict[name]
-
-    def SetOptimizerStoppingCriteria(self,nlopt_optimizer):
-        nlopt_optimizer.set_ftol_rel(self.stopping_criteria["rel_obj_tol"].GetDouble())
-        nlopt_optimizer.set_ftol_abs(self.stopping_criteria["abs_obj_tol"].GetDouble())
-        nlopt_optimizer.set_xtol_rel(self.stopping_criteria["rel_contr_tol"].GetDouble())
-        nlopt_optimizer.set_xtol_abs(self.stopping_criteria["abs_contr_tol"].GetDouble())
-        nlopt_optimizer.set_maxeval(self.stopping_criteria["maximum_function_evalualtion"].GetInt())
-
-    def SetOptimizerSepcificSettings(self,nlopt_optimizer):
-        if self.opt_algorithm_specific_settings.Has("inner_maxeval"):
-            nlopt_optimizer.set_param("inner_maxeval",self.opt_algorithm_specific_settings["inner_maxeval"].GetInt())
-        if self.opt_algorithm_specific_settings.Has("dual_ftol_rel"):
-            nlopt_optimizer.set_param("dual_ftol_rel",self.opt_algorithm_specific_settings["dual_ftol_rel"].GetDouble())
-        if self.opt_algorithm_specific_settings.Has("initial_step"):
-            nlopt_optimizer.set_initial_step(self.opt_algorithm_specific_settings["initial_step"].GetDouble())
-        if self.opt_algorithm_specific_settings.Has("population"):
-            nlopt_optimizer.set_population(self.opt_algorithm_specific_settings["population"].GetInt())
-        if self.opt_algorithm_specific_settings.Has("number_of_stored_vectors"):
+try:
+    import nlopt
+except ImportError:
+    raise Exception("NLOPT python library is not available")
+
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.algorithms.standardized_NLOPT_objective import StandardizedNLOPTObjective
+from KratosMultiphysics.OptimizationApplication.algorithms.standardized_NLOPT_constraint import StandardizedNLOPTConstraint
+from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
+from KratosMultiphysics.OptimizationApplication.algorithms.algorithm import Algorithm
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
+
+
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+    return NLOPTAlgorithms(model, parameters, optimization_problem)
+
+class NLOPTAlgorithms(Algorithm):
+    """
+        A classical steepest descent algorithm to solve unconstrainted optimization problems.
+    """
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        return Kratos.Parameters("""{
+            "module"            : "KratosMultiphysics.OptimizationApplication.algorithms",
+            "type"              : "PLEASE_PROVIDE_AN_ALGORITHM_CLASS_NAME",
+            "objective"         : {},
+            "constraints"         : [],
+            "controls"          : [],
+            "echo_level"        : 0,
+            "NLOPT_settings"          : {
+                "algorithm_name"      : "mma",
+                "subsidiary_algorithm_name" : "",
+                "verbosity"           : 0,
+                "controls_lower_bound": "",
+                "controls_upper_bound": "",
+                "stopping_criteria"   : {
+                   "rel_obj_tol": 1e-3,
+                   "abs_obj_tol": 1e-3,
+                   "rel_contr_tol": 1e-3,
+                   "abs_contr_tol": 1e-3,
+                   "maximum_function_evalualtion": 10
+                },
+                "algorithm_specific_settings"   : {}
+            }
+        }""")
+
+    def __init__(self, model:Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        self.model = model
+        self.parameters = parameters
+        self._optimization_problem = optimization_problem
+
+        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+
+        # controls
+        self.master_control = MasterControl()
+        for control_name in parameters["controls"].GetStringArray():
+            control = optimization_problem.GetControl(control_name)
+            self.master_control.AddControl(control)
+        self.__control_field = None
+
+        # objective & constraints
+        self.__objective = StandardizedNLOPTObjective(parameters["objective"], self.master_control, self._optimization_problem)
+        self.__constraints = []
+        for constraint_settings in parameters["constraints"]:
+            self.__constraints.append(StandardizedNLOPTConstraint(constraint_settings, self.master_control, self._optimization_problem))
+
+        # nlopt settings
+        NLOPT_settings = parameters["NLOPT_settings"]
+        NLOPT_settings.ValidateAndAssignDefaults(self.GetDefaultParameters()["NLOPT_settings"])
+
+        # nlopt verbosity
+        self.nlopt_verbosity = NLOPT_settings["verbosity"].GetInt()
+
+        # upper and lower bounds
+        self.nlopt_controls_lower_bound = NLOPT_settings["controls_lower_bound"].GetString()
+        self.nlopt_controls_upper_bound = NLOPT_settings["controls_upper_bound"].GetString()
+
+        # nlopt algorithm
+        self.algorithm_name = NLOPT_settings["algorithm_name"].GetString()
+        if len(self.__constraints)==0:
+            self.CheckOptimizerSupport(self.algorithm_name,None)
+        else:
+            for constraint in self.__constraints:
+                if constraint.IsEqualityType():
+                    self.CheckOptimizerSupport(self.algorithm_name,"equality")
+                else:
+                    self.CheckOptimizerSupport(self.algorithm_name,"inequality")
+
+        # nlopt subsidiary algorithm
+        self.subsidiary_algorithm_name = NLOPT_settings["subsidiary_algorithm_name"].GetString()
+        if self.algorithm_name == "augmented_lagrangian":
+            if self.subsidiary_algorithm_name == "":
+                raise ValueError(f"The algorithm {self.algorithm_name} requires a subsidiary optimizer to be provided.")
+            else:
+                self.CheckOptimizerSupport(self.subsidiary_algorithm_name,None)
+
+        # stopping
+        self.stopping_criteria = NLOPT_settings["stopping_criteria"]
+        self.stopping_criteria.ValidateAndAssignDefaults(self.GetDefaultParameters()["NLOPT_settings"]["stopping_criteria"])
+
+        # alg specific settings
+        self.opt_algorithm_specific_settings = NLOPT_settings["algorithm_specific_settings"]
+
+    def GetMinimumBufferSize(self) -> int:
+        return 2
+
+    def Check(self):
+        pass
+
+    @time_decorator()
+    def Initialize(self):
+        self.converged = False
+        self.master_control.Initialize()
+        self.__objective.Initialize()
+        self.__objective.Check()
+        CallOnAll(self.__constraints, StandardizedNLOPTConstraint.Initialize)
+        self.__control_field = self.master_control.GetControlField()
+        self.algorithm_data = ComponentDataView("algorithm", self._optimization_problem)
+
+        # create nlopt optimizer
+        self.x0 = self.__control_field.Evaluate()
+        self.x0 = self.x0.reshape(-1)
+        self.nlopt_optimizer = nlopt.opt(self.GetOptimizer(self.algorithm_name), self.x0.size)
+
+        # add subsidiary optimization algorithm
+        if self.subsidiary_algorithm_name != "":
+            self.nlopt_subsidiary_optimizer = nlopt.opt(self.GetOptimizer(self.subsidiary_algorithm_name), self.x0.size)
+            self.nlopt_optimizer.set_local_optimizer(self.nlopt_subsidiary_optimizer)
+        else:
+            self.nlopt_subsidiary_optimizer = None
+
+        # set nlopt verbosity
+        self.nlopt_optimizer.set_param("verbosity",self.nlopt_verbosity)
+
+        # assign objectives and constarints
+        self.nlopt_optimizer.set_min_objective(self.__objective.CalculateStandardizedValueAndGradients)
+        for constraint in self.__constraints:
+            if constraint.IsEqualityType():
+                self.nlopt_optimizer.add_equality_constraint(constraint.CalculateStandardizedValueAndGradients,1e-8)
+            else:
+                self.nlopt_optimizer.add_inequality_constraint(constraint.CalculateStandardizedValueAndGradients,1e-8)
+
+        # now set stopping criteria
+        self.SetOptimizerStoppingCriteria(self.nlopt_optimizer)
+        if self.nlopt_subsidiary_optimizer is not None:
+            self.SetOptimizerStoppingCriteria(self.nlopt_subsidiary_optimizer)
+
+        # set bounds if exist
+        if self.nlopt_controls_lower_bound != "":
+            self.nlopt_optimizer.set_lower_bounds(float(self.nlopt_controls_lower_bound))
+        if self.nlopt_controls_upper_bound != "":
+            self.nlopt_optimizer.set_upper_bounds(float(self.nlopt_controls_upper_bound))
+
+        # now add algorithm specific settings
+        self.SetOptimizerSepcificSettings(self.nlopt_optimizer)
+        if self.nlopt_subsidiary_optimizer is not None:
+            self.SetOptimizerSepcificSettings(self.nlopt_subsidiary_optimizer)
+
+    @time_decorator()
+    def Finalize(self):
+        self.__objective.Finalize()
+        for constraint in self.__constraints:
+            constraint.Finalize()
+        self.master_control.Finalize()
+
+    @time_decorator()
+    def Solve(self):
+        self.nlopt_optimizer.optimize(self.x0)
+        CallOnAll(self._optimization_problem.GetListOfProcesses("output_processes"), Kratos.OutputProcess.PrintOutput)
+        self.LogTermination()
+
+    def LogTermination(self):
+        stopval = self.nlopt_optimizer.get_stopval()
+        maxtime = self.nlopt_optimizer.get_maxtime()
+        nlopt_result_map = {
+            nlopt.SUCCESS: 'Generic success return value.',
+            nlopt.STOPVAL_REACHED: f'Optimization stopped because stopval ({stopval}) was reached.',
+            nlopt.FTOL_REACHED: f'Optimization stopped because ftol_rel ({self.stopping_criteria["rel_obj_tol"].GetDouble()}) or ftol_abs ({self.stopping_criteria["abs_obj_tol"].GetDouble()}) was reached.',
+            nlopt.XTOL_REACHED: f'Optimization stopped because xtol_rel ({self.stopping_criteria["rel_contr_tol"].GetDouble()}) or xtol_abs ({self.stopping_criteria["abs_contr_tol"].GetDouble()}) was reached.',
+            nlopt.MAXEVAL_REACHED: f'Optimization stopped because maxeval ({self.stopping_criteria["maximum_function_evalualtion"].GetInt()}) was reached.',
+            nlopt.MAXTIME_REACHED: f'Optimization stopped because maxtime ({maxtime}) was reached.',
+            nlopt.FAILURE: 'Generic failure return value.',
+            nlopt.INVALID_ARGS: 'Invalid arguments (e.g. lower bounds are bigger than upper bounds, an unknown algorithm was specified, etcetera).',
+            nlopt.OUT_OF_MEMORY: 'Ran out of memory.',
+            nlopt.ROUNDOFF_LIMITED: 'Halted because roundoff errors limited progress. (In this case, the optimization still typically returns a useful result.)',
+            nlopt.FORCED_STOP: 'Halted because of a forced termination: the user called nlopt_force_stop(opt) on the optimizations nlopt_opt object opt from the users objective function or constraints.'
+        }
+        info = {"Termination":nlopt_result_map[self.nlopt_optimizer.last_optimize_result()]}
+        DictLogger(f"NLOPT-{self.algorithm_name}",info)
+
+    def CheckOptimizerSupport(self, algorithm_name, constraint_type):
+        # Unconstrained gradient-based optimizers
+        unconstrained_optimizers = {"lbfgs","mma","ccsaq","tnewton_precond_restart",
+                                    "tnewton_precond","tnewton_restart","augmented_lagrangian",
+                                    "neldermead","evolutionary"}
+
+        # Constrained gradient-based optimizers with equality constraints
+        equality_constrained_optimizers = {"slsqp","augmented_lagrangian"}
+
+        # Constrained gradient-based optimizers with inequality constraints
+        inequality_constrained_optimizers = {"mma","slsqp","ccsaq","augmented_lagrangian"}
+
+        if constraint_type == "equality":
+            if algorithm_name not in equality_constrained_optimizers:
+                raise ValueError(f"The algorithm {algorithm_name} does not support equality constraints, support {equality_constrained_optimizers}.")
+        elif constraint_type == "inequality":
+            if algorithm_name not in inequality_constrained_optimizers:
+                raise ValueError(f"The algorithm {algorithm_name} does not support inequality constraints, support {inequality_constrained_optimizers}.")
+        else:
+            if algorithm_name not in unconstrained_optimizers:
+                raise ValueError(f"The algorithm {algorithm_name} does not support unconstrained optimization, support {unconstrained_optimizers}.")
+        return True
+
+    def GetOptimizer(self,name):
+        nlopt_algorithm_dict = {
+            "mma": nlopt.LD_MMA,
+            "slsqp": nlopt.LD_SLSQP,
+            "lbfgs": nlopt.LD_LBFGS,
+            "ccsaq": nlopt.LD_CCSAQ,
+            "tnewton_precond_restart": nlopt.LD_TNEWTON_PRECOND_RESTART,
+            "tnewton_precond": nlopt.LD_TNEWTON_PRECOND,
+            "tnewton_restart": nlopt.LD_TNEWTON_RESTART,
+            "augmented_lagrangian": nlopt.AUGLAG,
+            "neldermead": nlopt.LN_NELDERMEAD,
+            "evolutionary": nlopt.GN_ESCH
+        }
+        return nlopt_algorithm_dict[name]
+
+    def SetOptimizerStoppingCriteria(self,nlopt_optimizer):
+        nlopt_optimizer.set_ftol_rel(self.stopping_criteria["rel_obj_tol"].GetDouble())
+        nlopt_optimizer.set_ftol_abs(self.stopping_criteria["abs_obj_tol"].GetDouble())
+        nlopt_optimizer.set_xtol_rel(self.stopping_criteria["rel_contr_tol"].GetDouble())
+        nlopt_optimizer.set_xtol_abs(self.stopping_criteria["abs_contr_tol"].GetDouble())
+        nlopt_optimizer.set_maxeval(self.stopping_criteria["maximum_function_evalualtion"].GetInt())
+
+    def SetOptimizerSepcificSettings(self,nlopt_optimizer):
+        if self.opt_algorithm_specific_settings.Has("inner_maxeval"):
+            nlopt_optimizer.set_param("inner_maxeval",self.opt_algorithm_specific_settings["inner_maxeval"].GetInt())
+        if self.opt_algorithm_specific_settings.Has("dual_ftol_rel"):
+            nlopt_optimizer.set_param("dual_ftol_rel",self.opt_algorithm_specific_settings["dual_ftol_rel"].GetDouble())
+        if self.opt_algorithm_specific_settings.Has("initial_step"):
+            nlopt_optimizer.set_initial_step(self.opt_algorithm_specific_settings["initial_step"].GetDouble())
+        if self.opt_algorithm_specific_settings.Has("population"):
+            nlopt_optimizer.set_population(self.opt_algorithm_specific_settings["population"].GetInt())
+        if self.opt_algorithm_specific_settings.Has("number_of_stored_vectors"):
             nlopt_optimizer.set_vector_storage(self.opt_algorithm_specific_settings["number_of_stored_vectors"].GetInt())
```

## KratosMultiphysics/OptimizationApplication/algorithms/algorithm.py

```diff
@@ -1,32 +1,78 @@
-from abc import ABC, abstractmethod
-
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
-
-class Algorithm(ABC):
-    def __init__(self, optimization_problem: OptimizationProblem) -> None:
-        self._optimization_problem = optimization_problem
-
-    @abstractmethod
-    def Initialize(self) -> None:
-        pass
-
-    @abstractmethod
-    def Check(self) -> None:
-        pass
-
-    @abstractmethod
-    def Finalize(self) -> None:
-        pass
-
-    @abstractmethod
-    def Solve(self) -> bool:
-        pass
-
-    def GetProcessesOrder(self) -> 'list[str]':
-        return ["auxiliary_processes", "output_processes"]
-
-    def CallOnAllProcesses(self, process_types: 'list[str]', *args, **kwargs):
-        for process_type in process_types:
-            CallOnAll(self._optimization_problem.GetListOfProcesses(process_type), *args, **kwargs)
-
+from abc import ABC, abstractmethod
+
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
+
+class Algorithm(ABC):
+    """Base class for algorithm.
+
+    Algorithm works purely in the control space. Hence, the ResponseRoutine which
+    the algorithm is associated with should convert all physical space gradients to
+    control space and control space designs to physical space designs.
+
+    The purpose of the algorithm is to solve a minimization problem. Hence, the used
+    ResponseRoutine should standardize the values and gradients it computes accordingly.
+
+    Algorithm should create one MasterControl from all the require controls, and share
+    it among all the ResponseRoutines.
+
+    Once it received the objective/constraint values and their gradients, the algorithm
+    will compute the new design and request new objective/constraints values and their
+    gradients until the specified convergence criteria is met.
+    """
+    def __init__(self, optimization_problem: OptimizationProblem) -> None:
+        self._optimization_problem = optimization_problem
+
+    @abstractmethod
+    def Initialize(self) -> None:
+        """Initializes the algorithm, ResponseRoutines and MasterControl.
+        """
+        pass
+
+    @abstractmethod
+    def Check(self) -> None:
+        """Checks algorithm, ResponseRoutines and MasterControl.
+        """
+        pass
+
+    @abstractmethod
+    def Finalize(self) -> None:
+        """Finalizes algorithm ResponseRoutines and MasterControl.
+        """
+        pass
+
+    @abstractmethod
+    def Solve(self) -> bool:
+        """Solves the optimization problem.
+
+        This method will have a loop which iterates until the specified
+        convergence for the given optimization problem.
+
+        Returns:
+            bool: Convergence status. True for converged, False for non-converged.
+        """
+        pass
+
+    def GetProcessesOrder(self) -> 'list[str]':
+        """The order of execution of the process categories.
+
+        This defines the order of execution of the processes defined under "processes"
+        in either "kratos_process" or "optimization_data_processes".
+
+        Returns:
+            list[str]: List of strings for process categories.
+        """
+        return ["auxiliary_processes", "output_processes"]
+
+    def CallOnAllProcesses(self, process_types: 'list[str]', *args, **kwargs):
+        for process_type in process_types:
+            CallOnAll(self._optimization_problem.GetListOfProcesses(process_type), *args, **kwargs)
+
+    def _InitializeIteration(self) -> None:
+        for process_type in self._optimization_problem.GetAvailableProcessTypes():
+            list(map(lambda x: x.ExecuteInitializeSolutionStep(), self._optimization_problem.GetListOfProcesses(process_type)))
+
+    def _FinalizeIteration(self) -> None:
+        for process_type in self._optimization_problem.GetAvailableProcessTypes():
+            list(map(lambda x: x.ExecuteFinalizeSolutionStep(), self._optimization_problem.GetListOfProcesses(process_type)))
```

## KratosMultiphysics/OptimizationApplication/algorithms/algorithm_base.py

 * *Ordering differences only*

```diff
@@ -1,393 +1,393 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ===============================================================================
-
-import KratosMultiphysics as KM
-from KratosMultiphysics import Parameters, Logger
-from KratosMultiphysics.vtk_output_process import VtkOutputProcess
-
-# Additional imports
-import csv
-# ==============================================================================
-class OptimizationAlgorithm:
-    def __init__(self,name,opt_settings,model,model_parts_controller,analyses_controller,responses_controller,controls_controller):
-
-        self.name = name
-        self.opt_settings =  opt_settings
-        self.model=model
-        self.model_parts_controller = model_parts_controller
-        self.analyses_controller = analyses_controller
-        self.responses_controller = responses_controller
-        self.controls_controller = controls_controller
-
-        # objectives
-        self.objectives = self.opt_settings["objectives"].GetStringArray()
-        self.objectives_improvements = self.opt_settings["objectives_improvements"].GetVector()
-
-        # constraints
-        self.constraints = self.opt_settings["constraints"].GetStringArray()
-        self.constraints_types = self.opt_settings["constraints_types"].GetStringArray()
-        self.constraints_ref_values = self.opt_settings["constraints_ref_values"].GetVector()
-        # all responses
-        self.responses = self.objectives + self.constraints
-
-        # now extract analyses belong to responses
-        self.analyses = self.responses_controller.GetResponsesAnalyses(self.responses)        
-
-        # controls
-        self.controls = opt_settings["controls"].GetStringArray()
-        self.objectives_controls_weights = opt_settings["objectives_controls_weights"].GetVector()
-        self.constraints_controls_weights = opt_settings["constraints_controls_weights"].GetVector()
-
-        # algorithm_settings
-        self.max_iterations = self.opt_settings["algorithm_settings"]["max_iterations"].GetInt()
-        self.projection_step_size = self.opt_settings["algorithm_settings"]["projection_step_size"].GetDouble()
-        self.correction_step_size = self.opt_settings["algorithm_settings"]["correction_step_size"].GetDouble()
-
-        # compile settings for responses
-        self.responses_controls = {}
-        self.responses_types = {}
-        self.responses_controlled_objects = {}
-        self.responses_control_gradient_names = {}
-        self.responses_control_types = {}
-        self.responses_control_var_names = {}
-        self.responses_var_names = {}
-        self.controls_responses={}
-        self.controls_response_var_names = {}
-        self.controls_response_gradient_names = {}
-        self.controls_response_control_gradient_names = {}
-        self.root_model_part_data_field_names = {}
-        self.analyses_responses = {}
-        self.analysis_free_responses = []
-        for response in self.responses:
-            response_type = self.responses_controller.GetResponseType(response)
-            response_analysis = self.responses_controller.GetResponseAnalysis(response)
-            if response_analysis != None:
-                if response_analysis in self.analyses_responses.keys():
-                    self.analyses_responses[response_analysis].append(response)
-                else:
-                    self.analyses_responses[response_analysis] = [response]
-            else:
-                self.analysis_free_responses.append(response)
-
-            self.responses_types[response] = response_type
-            response_controlled_objects = self.responses_controller.GetResponseControlledObjects(response)
-            response_control_types = self.responses_controller.GetResponseControlTypes(response)
-            response_variable_name = self.responses_controller.GetResponseVariableName(response)
-            self.responses_var_names[response] = response_variable_name
-            for control in self.controls:
-                control_type = self.controls_controller.GetControlType(control)
-                control_variable_name = self.controls_controller.GetControlVariableName(control)
-                control_update_name = self.controls_controller.GetControlUpdateName(control)
-                control_output_names = self.controls_controller.GetControlOutputNames(control)
-                control_controlling_objects = self.controls_controller.GetControlControllingObjects(control)
-                for control_controlling_object in control_controlling_objects:
-                    response_controlled_object_index = 0
-                    for response_controlled_object in response_controlled_objects:
-                        response_controlled_object_type = response_control_types[response_controlled_object_index]
-                        if control_controlling_object == response_controlled_object and response_controlled_object_type == control_type:
-                            response_gradient_name = self.responses_controller.GetResponseGradientVariableNameForType(response,control_type)
-                            response_control_gradient_field = "D_"+response_variable_name+"_D_"+control_variable_name
-                            if response in self.responses_controlled_objects.keys():
-                                self.responses_controlled_objects[response].append(control_controlling_object)
-                                self.responses_controls[response].append(control)
-                                self.responses_control_types[response].append(control_type)
-                                self.responses_control_var_names[response].append(control_variable_name)
-                                self.responses_control_gradient_names[response].append(response_control_gradient_field)
-                            else:
-                                self.responses_controlled_objects[response]=[control_controlling_object]
-                                self.responses_control_types[response]=[control_type]
-                                self.responses_control_var_names[response]=[control_variable_name]
-                                self.responses_control_gradient_names[response]=[response_control_gradient_field]
-                                self.responses_controls[response]=[control]   
-
-                            
-                            control_controlling_root_model_part = self.model_parts_controller.GetRootModelPart(control_controlling_object)
-                            extracted_root_model_part_name = control_controlling_object.split(".")[0]
-                            
-                            if extracted_root_model_part_name in self.root_model_part_data_field_names.keys():
-                                if not response_control_gradient_field in self.root_model_part_data_field_names[extracted_root_model_part_name]:
-                                    self.root_model_part_data_field_names[extracted_root_model_part_name].append(response_control_gradient_field)
-                                    self.root_model_part_data_field_names[extracted_root_model_part_name].append(response_gradient_name)
-                                    self.root_model_part_data_field_names[extracted_root_model_part_name].extend(control_output_names)
-                                    control_controlling_root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(response_control_gradient_field))
-                            else:
-                                self.root_model_part_data_field_names[extracted_root_model_part_name] = [response_control_gradient_field,response_gradient_name]
-                                self.root_model_part_data_field_names[extracted_root_model_part_name].extend(control_output_names)
-                                control_controlling_root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(response_control_gradient_field))
-
-                            if control in self.controls_responses.keys():
-                                if not response in self.controls_responses[control]:
-                                    self.controls_responses[control].append(response)
-                                    self.controls_response_var_names[control].append(response_variable_name)
-                                    self.controls_response_gradient_names[control].append(response_gradient_name)
-                                    self.controls_response_control_gradient_names[control].append(response_control_gradient_field)                                   
-                            else:
-                                self.controls_responses[control] = [response]
-                                self.controls_response_var_names[control] = [response_variable_name]
-                                self.controls_response_gradient_names[control]= [response_gradient_name]
-                                self.controls_response_control_gradient_names[control] = [response_control_gradient_field]  
-                        
-                        response_controlled_object_index +=1                          
-        
-        # compile settings for c++ optimizer
-        self.opt_parameters = Parameters()
-        self.opt_parameters.AddEmptyArray("objectives")
-        self.opt_parameters.AddEmptyArray("constraints")
-        self.opt_parameters.AddInt("opt_itr",0)
-        self.opt_parameters.AddInt("max_opt_itr",self.max_iterations)
-        self.opt_parameters.AddDouble("projection_step_size",self.projection_step_size)
-        self.opt_parameters.AddDouble("correction_step_size",self.correction_step_size)
-        self.opt_parameters.AddInt("num_active_consts",0)
-        self.opt_parameters.AddDouble("sin_alpha",0)
-        self.opt_parameters.AddBool("opt_converged",False)
-        for response in self.responses_controlled_objects.keys():
-            response_settings = Parameters()
-            response_settings.AddString("name",response)
-            response_settings.AddString("response_type",self.responses_types[response])
-            response_settings.AddString("variable_name",self.responses_var_names[response])
-            response_settings.AddDouble("value",0.0)
-            response_settings.AddDouble("weight",1.0)
-            response_settings.AddDouble("init_value",0.0)
-            response_settings.AddDouble("prev_itr_value",0.0)
-            response_settings.AddEmptyArray("controlled_objects")
-            response_settings.AddEmptyArray("control_types")
-            response_settings.AddEmptyArray("control_gradient_names")
-            response_settings.AddEmptyArray("control_variable_names")
-            response_settings.AddEmptyArray("controls")
-                
-            for control_obj in self.responses_controlled_objects[response]:
-                response_settings["controlled_objects"].Append(control_obj)
-
-            for control_type in self.responses_control_types[response]:
-                response_settings["control_types"].Append(control_type)
-
-            for control_variable in self.responses_control_var_names[response]:
-                response_settings["control_variable_names"].Append(control_variable)
-
-            for control_gradient_name in self.responses_control_gradient_names[response]:
-                response_settings["control_gradient_names"].Append(control_gradient_name)
-
-            for control in self.responses_controls[response]:
-                response_settings["controls"].Append(control)
-
-            if response in self.objectives:
-                index = self.objectives.index(response)
-                response_settings.AddDouble("objective_improvement",self.objectives_improvements[index])
-                self.opt_parameters["objectives"].Append(response_settings)
-            elif response in self.constraints:
-                index = self.constraints.index(response)
-                response_settings.AddString("type",self.constraints_types[index])
-                response_settings.AddDouble("ref_value",self.constraints_ref_values[index])
-                response_settings.AddBool("is_active",True)
-                response_settings.AddBool("prev_itr_is_active",False)
-                self.opt_parameters["constraints"].Append(response_settings)
-            else:
-                raise RuntimeError("OptimizationAlgorithm:__init__:error in compile settings for c++ optimizer")
-
-        self.opt_parameters.AddEmptyArray("controls")
-        for control in self.controls:
-            control_index = self.controls.index(control)
-            control_objectives_weight = self.objectives_controls_weights[control_index]
-            control_constraints_weight = self.constraints_controls_weights[control_index]
-            control_type = self.controls_controller.GetControlType(control)
-            control_update_name = self.controls_controller.GetControlUpdateName(control)
-            control_variable_name = self.controls_controller.GetControlVariableName(control)
-            control_settings = Parameters()
-            control_settings.AddString("name",control)
-            control_settings.AddString("type",control_type)
-            control_settings.AddString("update_name",control_update_name)
-            control_settings.AddString("variable_name",control_variable_name)
-            control_settings.AddDouble("objectives_weight",control_objectives_weight)
-            control_settings.AddDouble("constraints_weight",control_constraints_weight)
-            if control_type == "shape":
-                control_settings.AddInt("size",3)
-            elif control_type == "thickness":
-                control_settings.AddInt("size",1)
-            elif control_type == "material":
-                control_settings.AddInt("size",1)
-            else:
-                raise RuntimeError("OptimizationAlgorithm:__init__:error in compile settings for c++ optimizer")
-
-            control_settings.AddEmptyArray("controlling_objects")
-
-            control_controlling_objects = self.controls_controller.GetControlControllingObjects(control)
-            for control_controlling_object in control_controlling_objects:
-                control_settings["controlling_objects"].Append(control_controlling_object) 
-
-            self.opt_parameters["controls"].Append(control_settings) 
-
-        Logger.PrintInfo("::[OptimizationAlgorithm]:: ", "Variables ADDED")
-
-    # --------------------------------------------------------------------------
-    def InitializeOptimizationLoop( self ):
-
-        # create vtkIOs
-        self.root_model_parts_vtkIOs = {}
-        for root_model_part,data_fields in self.root_model_part_data_field_names.items():
-            vtk_parameters = Parameters()
-            root_controlling_model_part = self.model_parts_controller.GetRootModelPart(root_model_part)
-            vtk_parameters.AddString("model_part_name",root_controlling_model_part.Name)
-            vtk_parameters.AddBool("write_ids",False)
-            vtk_parameters.AddString("file_format","ascii")
-            vtk_parameters.AddBool("output_sub_model_parts",False)
-            vtk_parameters.AddString("output_path","Optimization_Results")
-            vtk_parameters.AddEmptyArray("nodal_solution_step_data_variables")
-            for nodal_result in data_fields:
-                vtk_parameters["nodal_solution_step_data_variables"].Append(nodal_result)
-            
-            controlling_model_part_vtkIO = VtkOutputProcess(self.model, vtk_parameters)
-            controlling_model_part_vtkIO.ExecuteInitialize()
-            controlling_model_part_vtkIO.ExecuteBeforeSolutionLoop()
-            self.root_model_parts_vtkIOs[root_model_part] = controlling_model_part_vtkIO
-
-    # --------------------------------------------------------------------------
-    def RunOptimizationLoop( self ):
-        raise RuntimeError("Algorithm base class is called. Please check your implementation of the function >> RunOptimizationLoop << .")
-
-    # --------------------------------------------------------------------------
-    def FinalizeOptimizationLoop( self ):
-        for vtkIO in self.root_model_parts_vtkIOs.values():
-            vtkIO.ExecuteFinalize() 
-
-    # --------------------------------------------------------------------------
-    def SetResponseValue( self,response,value ):
-
-        for objective in self.opt_parameters["objectives"]:
-            if objective["name"].GetString() == response:
-                objective["prev_itr_value"].SetDouble(objective["value"].GetDouble())
-                objective["value"].SetDouble(value)
-                if self.opt_parameters["opt_itr"].GetInt()<2:
-                   objective["init_value"].SetDouble(value)   
-                
-                return  True
-
-        for constraint in self.opt_parameters["constraints"]:
-            if constraint["name"].GetString() == response:
-                constraint["prev_itr_value"].SetDouble(constraint["value"].GetDouble())
-                constraint["value"].SetDouble(value) 
-                if self.opt_parameters["opt_itr"].GetInt()<2:
-                    constraint["init_value"].SetDouble(value)
-                    valid_types = ["initial_value_equality","smaller_than_initial_value","bigger_than_initial_value"]
-                    if constraint["type"].GetString() in valid_types:
-                        constraint["ref_value"].SetDouble(value)
-
-                ref_value = constraint["ref_value"].GetDouble()
-
-                type = constraint["type"].GetString()
-                is_active = False
-                if type == "equality" or type == "initial_value_equality":
-                    is_active = True
-                elif (type == "smaller_than" or type == "smaller_than_initial_value") and value>ref_value:
-                    is_active = True
-                elif (type == "bigger_than" or type == "bigger_than_initial_value")  and value<ref_value:
-                    is_active = True
-
-                if is_active:
-                    self.num_active_consts += 1
-
-                constraint["prev_itr_is_active"].SetBool(constraint["is_active"].GetBool())
-                constraint["is_active"].SetBool(is_active)
-
-                return is_active       
-
-    # --------------------------------------------------------------------------
-    def _InitializeCSVLogger(self):
-        self.complete_log_file_name = "optimization_log.csv"
-        with open(self.complete_log_file_name, 'w') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4s}".format("itr"))
-            for objective in self.opt_parameters["objectives"]:
-                row.append("{:>4s}".format("f: "+str(objective["name"].GetString())))
-                row.append("{:>4s}".format("abs[%]"))
-                row.append("{:>4s}".format("rel[%]"))
-                row.append("{:>4s}".format("weight"))
-
-            for constraint in self.opt_parameters["constraints"]:
-                row.append("{:>4s}".format("g: "+str(constraint["name"].GetString())))
-                row.append("{:>4s}".format("ref_val "))
-                row.append("{:>4s}".format("ref_diff[%]"))
-                row.append("{:>4s}".format("weight"))
-                row.append("{:>4s}".format("is_active"))
-
-
-            row.append("{:>4s}".format("projection_step_size"))
-            if self.opt_parameters["constraints"].size() > 0:
-                row.append("{:>4s}".format("correction_step_size"))
-                row.append("{:>4s}".format("sin_alpha"))
-
-            historyWriter.writerow(row)
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentOptItrToCSVFile( self ):
-        
-        with open(self.complete_log_file_name, 'a') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4d}".format(self.optimization_iteration))
-
-            Logger.Print("")
-
-            for objective in self.opt_parameters["objectives"]:
-                objectivs_current_value = objective["value"].GetDouble()
-                objectivs_weight = objective["weight"].GetDouble()
-                objective_initial_value = objectivs_current_value
-                objective_previous_value = objectivs_current_value
-
-                if self.optimization_iteration>1:                
-                    objective_initial_value = objective["init_value"].GetDouble() 
-                    objective_previous_value = objective["prev_itr_value"].GetDouble() 
-
-                rel_change = 100 * (objectivs_current_value-objective_previous_value)/objective_previous_value
-                abs_change = 100 * (objectivs_current_value-objective_initial_value)/objective_initial_value
-
-                Logger.Print("  ===== objective: ",objective["name"].GetString())
-                Logger.Print("                   current value: ",objectivs_current_value)
-                Logger.Print("                   rel_change: ",rel_change)
-                Logger.Print("                   abs_change: ",abs_change)
-                Logger.Print("                   weight: ",objectivs_weight)
-                row.append(" {:> .5E}".format(objectivs_current_value))
-                row.append(" {:> .5E}".format(abs_change))
-                row.append(" {:> .5E}".format(rel_change)) 
-                row.append(" {:> .5E}".format(objectivs_weight))
-
-            for constraint in self.opt_parameters["constraints"]:
-                constraint_current_value = constraint["value"].GetDouble() 
-                constraint_ref_val = constraint["ref_value"].GetDouble()
-                constraint_weight = constraint["weight"].GetDouble()
-                is_active = constraint["is_active"].GetBool()
-                abs_change = 100 * abs(constraint_current_value-constraint_ref_val)/abs(constraint_ref_val)
-
-                Logger.Print("  ===== constraint: ",constraint["name"].GetString())
-                Logger.Print("                   current value: ",constraint_current_value)
-                Logger.Print("                   ref value: ",constraint_ref_val)
-                Logger.Print("                   change: ",abs_change)
-                Logger.Print("                   weight: ",constraint_weight)
-                Logger.Print("                   is_active: ",is_active)
-
-                row.append(" {:> .5E}".format(constraint_current_value))
-                row.append(" {:> .5E}".format(constraint_ref_val))
-                row.append(" {:> .5E}".format(abs_change))
-                row.append(" {:> .5E}".format(constraint_weight))
-                row.append(" {:> .5E}".format(is_active))
-                
-
-            Logger.Print("  ===== projection_step_size: ",self.opt_parameters["projection_step_size"].GetDouble())            
-            row.append(" {:> .5E}".format(self.opt_parameters["projection_step_size"].GetDouble()))
-
-            if self.opt_parameters["constraints"].size() > 0 and self.opt_parameters["num_active_consts"].GetInt()>0:
-                Logger.Print("  ===== correction_step_size: ",self.opt_parameters["correction_step_size"].GetDouble())
-                row.append(" {:> .5E}".format(self.opt_parameters["correction_step_size"].GetDouble()))
-                Logger.Print("  ===== sin alpha: ",self.opt_parameters["sin_alpha"].GetDouble())
-                row.append(" {:> .5E}".format(self.opt_parameters["sin_alpha"].GetDouble()))
-
-            historyWriter.writerow(row)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ===============================================================================
+
+import KratosMultiphysics as KM
+from KratosMultiphysics import Parameters, Logger
+from KratosMultiphysics.vtk_output_process import VtkOutputProcess
+
+# Additional imports
+import csv
+# ==============================================================================
+class OptimizationAlgorithm:
+    def __init__(self,name,opt_settings,model,model_parts_controller,analyses_controller,responses_controller,controls_controller):
+
+        self.name = name
+        self.opt_settings =  opt_settings
+        self.model=model
+        self.model_parts_controller = model_parts_controller
+        self.analyses_controller = analyses_controller
+        self.responses_controller = responses_controller
+        self.controls_controller = controls_controller
+
+        # objectives
+        self.objectives = self.opt_settings["objectives"].GetStringArray()
+        self.objectives_improvements = self.opt_settings["objectives_improvements"].GetVector()
+
+        # constraints
+        self.constraints = self.opt_settings["constraints"].GetStringArray()
+        self.constraints_types = self.opt_settings["constraints_types"].GetStringArray()
+        self.constraints_ref_values = self.opt_settings["constraints_ref_values"].GetVector()
+        # all responses
+        self.responses = self.objectives + self.constraints
+
+        # now extract analyses belong to responses
+        self.analyses = self.responses_controller.GetResponsesAnalyses(self.responses)        
+
+        # controls
+        self.controls = opt_settings["controls"].GetStringArray()
+        self.objectives_controls_weights = opt_settings["objectives_controls_weights"].GetVector()
+        self.constraints_controls_weights = opt_settings["constraints_controls_weights"].GetVector()
+
+        # algorithm_settings
+        self.max_iterations = self.opt_settings["algorithm_settings"]["max_iterations"].GetInt()
+        self.projection_step_size = self.opt_settings["algorithm_settings"]["projection_step_size"].GetDouble()
+        self.correction_step_size = self.opt_settings["algorithm_settings"]["correction_step_size"].GetDouble()
+
+        # compile settings for responses
+        self.responses_controls = {}
+        self.responses_types = {}
+        self.responses_controlled_objects = {}
+        self.responses_control_gradient_names = {}
+        self.responses_control_types = {}
+        self.responses_control_var_names = {}
+        self.responses_var_names = {}
+        self.controls_responses={}
+        self.controls_response_var_names = {}
+        self.controls_response_gradient_names = {}
+        self.controls_response_control_gradient_names = {}
+        self.root_model_part_data_field_names = {}
+        self.analyses_responses = {}
+        self.analysis_free_responses = []
+        for response in self.responses:
+            response_type = self.responses_controller.GetResponseType(response)
+            response_analysis = self.responses_controller.GetResponseAnalysis(response)
+            if response_analysis != None:
+                if response_analysis in self.analyses_responses.keys():
+                    self.analyses_responses[response_analysis].append(response)
+                else:
+                    self.analyses_responses[response_analysis] = [response]
+            else:
+                self.analysis_free_responses.append(response)
+
+            self.responses_types[response] = response_type
+            response_controlled_objects = self.responses_controller.GetResponseControlledObjects(response)
+            response_control_types = self.responses_controller.GetResponseControlTypes(response)
+            response_variable_name = self.responses_controller.GetResponseVariableName(response)
+            self.responses_var_names[response] = response_variable_name
+            for control in self.controls:
+                control_type = self.controls_controller.GetControlType(control)
+                control_variable_name = self.controls_controller.GetControlVariableName(control)
+                control_update_name = self.controls_controller.GetControlUpdateName(control)
+                control_output_names = self.controls_controller.GetControlOutputNames(control)
+                control_controlling_objects = self.controls_controller.GetControlControllingObjects(control)
+                for control_controlling_object in control_controlling_objects:
+                    response_controlled_object_index = 0
+                    for response_controlled_object in response_controlled_objects:
+                        response_controlled_object_type = response_control_types[response_controlled_object_index]
+                        if control_controlling_object == response_controlled_object and response_controlled_object_type == control_type:
+                            response_gradient_name = self.responses_controller.GetResponseGradientVariableNameForType(response,control_type)
+                            response_control_gradient_field = "D_"+response_variable_name+"_D_"+control_variable_name
+                            if response in self.responses_controlled_objects.keys():
+                                self.responses_controlled_objects[response].append(control_controlling_object)
+                                self.responses_controls[response].append(control)
+                                self.responses_control_types[response].append(control_type)
+                                self.responses_control_var_names[response].append(control_variable_name)
+                                self.responses_control_gradient_names[response].append(response_control_gradient_field)
+                            else:
+                                self.responses_controlled_objects[response]=[control_controlling_object]
+                                self.responses_control_types[response]=[control_type]
+                                self.responses_control_var_names[response]=[control_variable_name]
+                                self.responses_control_gradient_names[response]=[response_control_gradient_field]
+                                self.responses_controls[response]=[control]   
+
+                            
+                            control_controlling_root_model_part = self.model_parts_controller.GetRootModelPart(control_controlling_object)
+                            extracted_root_model_part_name = control_controlling_object.split(".")[0]
+                            
+                            if extracted_root_model_part_name in self.root_model_part_data_field_names.keys():
+                                if not response_control_gradient_field in self.root_model_part_data_field_names[extracted_root_model_part_name]:
+                                    self.root_model_part_data_field_names[extracted_root_model_part_name].append(response_control_gradient_field)
+                                    self.root_model_part_data_field_names[extracted_root_model_part_name].append(response_gradient_name)
+                                    self.root_model_part_data_field_names[extracted_root_model_part_name].extend(control_output_names)
+                                    control_controlling_root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(response_control_gradient_field))
+                            else:
+                                self.root_model_part_data_field_names[extracted_root_model_part_name] = [response_control_gradient_field,response_gradient_name]
+                                self.root_model_part_data_field_names[extracted_root_model_part_name].extend(control_output_names)
+                                control_controlling_root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(response_control_gradient_field))
+
+                            if control in self.controls_responses.keys():
+                                if not response in self.controls_responses[control]:
+                                    self.controls_responses[control].append(response)
+                                    self.controls_response_var_names[control].append(response_variable_name)
+                                    self.controls_response_gradient_names[control].append(response_gradient_name)
+                                    self.controls_response_control_gradient_names[control].append(response_control_gradient_field)                                   
+                            else:
+                                self.controls_responses[control] = [response]
+                                self.controls_response_var_names[control] = [response_variable_name]
+                                self.controls_response_gradient_names[control]= [response_gradient_name]
+                                self.controls_response_control_gradient_names[control] = [response_control_gradient_field]  
+                        
+                        response_controlled_object_index +=1                          
+        
+        # compile settings for c++ optimizer
+        self.opt_parameters = Parameters()
+        self.opt_parameters.AddEmptyArray("objectives")
+        self.opt_parameters.AddEmptyArray("constraints")
+        self.opt_parameters.AddInt("opt_itr",0)
+        self.opt_parameters.AddInt("max_opt_itr",self.max_iterations)
+        self.opt_parameters.AddDouble("projection_step_size",self.projection_step_size)
+        self.opt_parameters.AddDouble("correction_step_size",self.correction_step_size)
+        self.opt_parameters.AddInt("num_active_consts",0)
+        self.opt_parameters.AddDouble("sin_alpha",0)
+        self.opt_parameters.AddBool("opt_converged",False)
+        for response in self.responses_controlled_objects.keys():
+            response_settings = Parameters()
+            response_settings.AddString("name",response)
+            response_settings.AddString("response_type",self.responses_types[response])
+            response_settings.AddString("variable_name",self.responses_var_names[response])
+            response_settings.AddDouble("value",0.0)
+            response_settings.AddDouble("weight",1.0)
+            response_settings.AddDouble("init_value",0.0)
+            response_settings.AddDouble("prev_itr_value",0.0)
+            response_settings.AddEmptyArray("controlled_objects")
+            response_settings.AddEmptyArray("control_types")
+            response_settings.AddEmptyArray("control_gradient_names")
+            response_settings.AddEmptyArray("control_variable_names")
+            response_settings.AddEmptyArray("controls")
+                
+            for control_obj in self.responses_controlled_objects[response]:
+                response_settings["controlled_objects"].Append(control_obj)
+
+            for control_type in self.responses_control_types[response]:
+                response_settings["control_types"].Append(control_type)
+
+            for control_variable in self.responses_control_var_names[response]:
+                response_settings["control_variable_names"].Append(control_variable)
+
+            for control_gradient_name in self.responses_control_gradient_names[response]:
+                response_settings["control_gradient_names"].Append(control_gradient_name)
+
+            for control in self.responses_controls[response]:
+                response_settings["controls"].Append(control)
+
+            if response in self.objectives:
+                index = self.objectives.index(response)
+                response_settings.AddDouble("objective_improvement",self.objectives_improvements[index])
+                self.opt_parameters["objectives"].Append(response_settings)
+            elif response in self.constraints:
+                index = self.constraints.index(response)
+                response_settings.AddString("type",self.constraints_types[index])
+                response_settings.AddDouble("ref_value",self.constraints_ref_values[index])
+                response_settings.AddBool("is_active",True)
+                response_settings.AddBool("prev_itr_is_active",False)
+                self.opt_parameters["constraints"].Append(response_settings)
+            else:
+                raise RuntimeError("OptimizationAlgorithm:__init__:error in compile settings for c++ optimizer")
+
+        self.opt_parameters.AddEmptyArray("controls")
+        for control in self.controls:
+            control_index = self.controls.index(control)
+            control_objectives_weight = self.objectives_controls_weights[control_index]
+            control_constraints_weight = self.constraints_controls_weights[control_index]
+            control_type = self.controls_controller.GetControlType(control)
+            control_update_name = self.controls_controller.GetControlUpdateName(control)
+            control_variable_name = self.controls_controller.GetControlVariableName(control)
+            control_settings = Parameters()
+            control_settings.AddString("name",control)
+            control_settings.AddString("type",control_type)
+            control_settings.AddString("update_name",control_update_name)
+            control_settings.AddString("variable_name",control_variable_name)
+            control_settings.AddDouble("objectives_weight",control_objectives_weight)
+            control_settings.AddDouble("constraints_weight",control_constraints_weight)
+            if control_type == "shape":
+                control_settings.AddInt("size",3)
+            elif control_type == "thickness":
+                control_settings.AddInt("size",1)
+            elif control_type == "material":
+                control_settings.AddInt("size",1)
+            else:
+                raise RuntimeError("OptimizationAlgorithm:__init__:error in compile settings for c++ optimizer")
+
+            control_settings.AddEmptyArray("controlling_objects")
+
+            control_controlling_objects = self.controls_controller.GetControlControllingObjects(control)
+            for control_controlling_object in control_controlling_objects:
+                control_settings["controlling_objects"].Append(control_controlling_object) 
+
+            self.opt_parameters["controls"].Append(control_settings) 
+
+        Logger.PrintInfo("::[OptimizationAlgorithm]:: ", "Variables ADDED")
+
+    # --------------------------------------------------------------------------
+    def InitializeOptimizationLoop( self ):
+
+        # create vtkIOs
+        self.root_model_parts_vtkIOs = {}
+        for root_model_part,data_fields in self.root_model_part_data_field_names.items():
+            vtk_parameters = Parameters()
+            root_controlling_model_part = self.model_parts_controller.GetRootModelPart(root_model_part)
+            vtk_parameters.AddString("model_part_name",root_controlling_model_part.Name)
+            vtk_parameters.AddBool("write_ids",False)
+            vtk_parameters.AddString("file_format","ascii")
+            vtk_parameters.AddBool("output_sub_model_parts",False)
+            vtk_parameters.AddString("output_path","Optimization_Results")
+            vtk_parameters.AddEmptyArray("nodal_solution_step_data_variables")
+            for nodal_result in data_fields:
+                vtk_parameters["nodal_solution_step_data_variables"].Append(nodal_result)
+            
+            controlling_model_part_vtkIO = VtkOutputProcess(self.model, vtk_parameters)
+            controlling_model_part_vtkIO.ExecuteInitialize()
+            controlling_model_part_vtkIO.ExecuteBeforeSolutionLoop()
+            self.root_model_parts_vtkIOs[root_model_part] = controlling_model_part_vtkIO
+
+    # --------------------------------------------------------------------------
+    def RunOptimizationLoop( self ):
+        raise RuntimeError("Algorithm base class is called. Please check your implementation of the function >> RunOptimizationLoop << .")
+
+    # --------------------------------------------------------------------------
+    def FinalizeOptimizationLoop( self ):
+        for vtkIO in self.root_model_parts_vtkIOs.values():
+            vtkIO.ExecuteFinalize() 
+
+    # --------------------------------------------------------------------------
+    def SetResponseValue( self,response,value ):
+
+        for objective in self.opt_parameters["objectives"]:
+            if objective["name"].GetString() == response:
+                objective["prev_itr_value"].SetDouble(objective["value"].GetDouble())
+                objective["value"].SetDouble(value)
+                if self.opt_parameters["opt_itr"].GetInt()<2:
+                   objective["init_value"].SetDouble(value)   
+                
+                return  True
+
+        for constraint in self.opt_parameters["constraints"]:
+            if constraint["name"].GetString() == response:
+                constraint["prev_itr_value"].SetDouble(constraint["value"].GetDouble())
+                constraint["value"].SetDouble(value) 
+                if self.opt_parameters["opt_itr"].GetInt()<2:
+                    constraint["init_value"].SetDouble(value)
+                    valid_types = ["initial_value_equality","smaller_than_initial_value","bigger_than_initial_value"]
+                    if constraint["type"].GetString() in valid_types:
+                        constraint["ref_value"].SetDouble(value)
+
+                ref_value = constraint["ref_value"].GetDouble()
+
+                type = constraint["type"].GetString()
+                is_active = False
+                if type == "equality" or type == "initial_value_equality":
+                    is_active = True
+                elif (type == "smaller_than" or type == "smaller_than_initial_value") and value>ref_value:
+                    is_active = True
+                elif (type == "bigger_than" or type == "bigger_than_initial_value")  and value<ref_value:
+                    is_active = True
+
+                if is_active:
+                    self.num_active_consts += 1
+
+                constraint["prev_itr_is_active"].SetBool(constraint["is_active"].GetBool())
+                constraint["is_active"].SetBool(is_active)
+
+                return is_active       
+
+    # --------------------------------------------------------------------------
+    def _InitializeCSVLogger(self):
+        self.complete_log_file_name = "optimization_log.csv"
+        with open(self.complete_log_file_name, 'w') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4s}".format("itr"))
+            for objective in self.opt_parameters["objectives"]:
+                row.append("{:>4s}".format("f: "+str(objective["name"].GetString())))
+                row.append("{:>4s}".format("abs[%]"))
+                row.append("{:>4s}".format("rel[%]"))
+                row.append("{:>4s}".format("weight"))
+
+            for constraint in self.opt_parameters["constraints"]:
+                row.append("{:>4s}".format("g: "+str(constraint["name"].GetString())))
+                row.append("{:>4s}".format("ref_val "))
+                row.append("{:>4s}".format("ref_diff[%]"))
+                row.append("{:>4s}".format("weight"))
+                row.append("{:>4s}".format("is_active"))
+
+
+            row.append("{:>4s}".format("projection_step_size"))
+            if self.opt_parameters["constraints"].size() > 0:
+                row.append("{:>4s}".format("correction_step_size"))
+                row.append("{:>4s}".format("sin_alpha"))
+
+            historyWriter.writerow(row)
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentOptItrToCSVFile( self ):
+        
+        with open(self.complete_log_file_name, 'a') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4d}".format(self.optimization_iteration))
+
+            Logger.Print("")
+
+            for objective in self.opt_parameters["objectives"]:
+                objectivs_current_value = objective["value"].GetDouble()
+                objectivs_weight = objective["weight"].GetDouble()
+                objective_initial_value = objectivs_current_value
+                objective_previous_value = objectivs_current_value
+
+                if self.optimization_iteration>1:                
+                    objective_initial_value = objective["init_value"].GetDouble() 
+                    objective_previous_value = objective["prev_itr_value"].GetDouble() 
+
+                rel_change = 100 * (objectivs_current_value-objective_previous_value)/objective_previous_value
+                abs_change = 100 * (objectivs_current_value-objective_initial_value)/objective_initial_value
+
+                Logger.Print("  ===== objective: ",objective["name"].GetString())
+                Logger.Print("                   current value: ",objectivs_current_value)
+                Logger.Print("                   rel_change: ",rel_change)
+                Logger.Print("                   abs_change: ",abs_change)
+                Logger.Print("                   weight: ",objectivs_weight)
+                row.append(" {:> .5E}".format(objectivs_current_value))
+                row.append(" {:> .5E}".format(abs_change))
+                row.append(" {:> .5E}".format(rel_change)) 
+                row.append(" {:> .5E}".format(objectivs_weight))
+
+            for constraint in self.opt_parameters["constraints"]:
+                constraint_current_value = constraint["value"].GetDouble() 
+                constraint_ref_val = constraint["ref_value"].GetDouble()
+                constraint_weight = constraint["weight"].GetDouble()
+                is_active = constraint["is_active"].GetBool()
+                abs_change = 100 * abs(constraint_current_value-constraint_ref_val)/abs(constraint_ref_val)
+
+                Logger.Print("  ===== constraint: ",constraint["name"].GetString())
+                Logger.Print("                   current value: ",constraint_current_value)
+                Logger.Print("                   ref value: ",constraint_ref_val)
+                Logger.Print("                   change: ",abs_change)
+                Logger.Print("                   weight: ",constraint_weight)
+                Logger.Print("                   is_active: ",is_active)
+
+                row.append(" {:> .5E}".format(constraint_current_value))
+                row.append(" {:> .5E}".format(constraint_ref_val))
+                row.append(" {:> .5E}".format(abs_change))
+                row.append(" {:> .5E}".format(constraint_weight))
+                row.append(" {:> .5E}".format(is_active))
+                
+
+            Logger.Print("  ===== projection_step_size: ",self.opt_parameters["projection_step_size"].GetDouble())            
+            row.append(" {:> .5E}".format(self.opt_parameters["projection_step_size"].GetDouble()))
+
+            if self.opt_parameters["constraints"].size() > 0 and self.opt_parameters["num_active_consts"].GetInt()>0:
+                Logger.Print("  ===== correction_step_size: ",self.opt_parameters["correction_step_size"].GetDouble())
+                row.append(" {:> .5E}".format(self.opt_parameters["correction_step_size"].GetDouble()))
+                Logger.Print("  ===== sin alpha: ",self.opt_parameters["sin_alpha"].GetDouble())
+                row.append(" {:> .5E}".format(self.opt_parameters["sin_alpha"].GetDouble()))
+
+            historyWriter.writerow(row)
+
+# ==============================================================================
```

## KratosMultiphysics/OptimizationApplication/algorithms/algorithm_gradient_projection.py

```diff
@@ -1,230 +1,217 @@
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.algorithms.standardized_objective import StandardizedObjective
-from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
-from KratosMultiphysics.OptimizationApplication.algorithms.algorithm import Algorithm
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.opt_convergence import CreateConvergenceCriteria
-from KratosMultiphysics.OptimizationApplication.utilities.opt_line_search import CreateLineSearch
-from KratosMultiphysics.OptimizationApplication.algorithms.standardized_constraint import StandardizedConstraint
-from KratosMultiphysics.LinearSolversApplication.dense_linear_solver_factory import ConstructSolver
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import OptimizationAlgorithmTimeLogger
-
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-    return AlgorithmGradientProjection(model, parameters, optimization_problem)
-
-class AlgorithmGradientProjection(Algorithm):
-    """
-        A classical steepest descent algorithm to solve unconstrainted optimization problems.
-    """
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        return Kratos.Parameters("""{
-            "module"            : "KratosMultiphysics.OptimizationApplication.algorithms",
-            "type"              : "PLEASE_PROVIDE_AN_ALGORITHM_CLASS_NAME",
-            "objective"         : {},
-            "constraints"       : [],
-            "controls"          : [],
-            "echo_level"        : 0,
-            "settings"          : {
-                "echo_level"      : 0,
-                "line_search"     : {},
-                "conv_settings"   : {},
-                "linear_solver_settings" : {},
-                "correction_size" : 0.0
-            }
-        }""")
-
-    def __init__(self, model:Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        self.model = model
-        self.parameters = parameters
-        self._optimization_problem = optimization_problem
-        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
-
-        self.master_control = MasterControl() # Need to fill it with controls
-
-        for control_name in parameters["controls"].GetStringArray():
-            control = optimization_problem.GetControl(control_name)
-            self.master_control.AddControl(control)
-
-
-        settings = parameters["settings"]
-        settings.ValidateAndAssignDefaults(self.GetDefaultParameters()["settings"])
-
-        self.echo_level = settings["echo_level"].GetInt()
-
-        ComponentDataView("algorithm", self._optimization_problem).SetDataBuffer(self.GetMinimumBufferSize())
-
-        self.__convergence_criteria = CreateConvergenceCriteria(settings["conv_settings"], self._optimization_problem)
-        self.__line_search_method = CreateLineSearch(settings["line_search"], self._optimization_problem)
-
-        self.__objective = StandardizedObjective(parameters["objective"], self.master_control, self._optimization_problem)
-        self.__constraints_list: 'list[StandardizedConstraint]' = []
-        for constraint_param in parameters["constraints"].values():
-            constraint = StandardizedConstraint(constraint_param, self.master_control, self._optimization_problem)
-            self.__constraints_list.append(constraint)
-        self.__control_field = None
-        self.__obj_val = None
-
-        default_linear_solver_settings = Kratos.Parameters("""{
-            "solver_type": "LinearSolversApplication.dense_col_piv_householder_qr"
-        }""")
-        settings["linear_solver_settings"].ValidateAndAssignDefaults(default_linear_solver_settings)
-        self.linear_solver = ConstructSolver(settings["linear_solver_settings"])
-        self.correction_size = settings["correction_size"].GetDouble()
-
-    def GetMinimumBufferSize(self) -> int:
-        return 2
-
-    def Check(self):
-        pass
-
-    @time_decorator()
-    def Initialize(self):
-        self.converged = False
-        self.__obj_val = None
-        self.__objective.Initialize()
-        self.__objective.Check()
-        CallOnAll(self.__constraints_list, StandardizedConstraint.Initialize)
-        CallOnAll(self.__constraints_list, StandardizedConstraint.Check)
-        self.master_control.Initialize()
-        self.__control_field = self.master_control.GetControlField()
-        self.algorithm_data = ComponentDataView("algorithm", self._optimization_problem)
-
-    @time_decorator()
-    def Finalize(self):
-        pass
-
-    @time_decorator()
-    def ComputeSearchDirection(self, obj_grad: KratosOA.CollectiveExpression, constr_grad: 'list[KratosOA.CollectiveExpression]') -> KratosOA.CollectiveExpression:
-        active_constraints_list = [self.__constraints_list[i] for i in range(len(self.__constraints_list)) if self.__constr_value[i] >= 0.0]
-        number_of_active_constraints = len(active_constraints_list)
-        if not number_of_active_constraints:
-            search_direction = obj_grad * -1.0
-            correction = obj_grad * 0.0
-        else:
-            constraint_violations = Kratos.Vector(number_of_active_constraints)
-            for i, active_constraint in enumerate(active_constraints_list):
-                    constraint_violations[i] = active_constraint.GetScaledViolationValue()
-
-            # compute the projected search direction and correction
-            ntn = Kratos.Matrix(number_of_active_constraints, number_of_active_constraints)
-            for i in range(number_of_active_constraints):
-                for j in range(i, number_of_active_constraints):
-                    ntn[i, j] = KratosOA.ExpressionUtils.InnerProduct(constr_grad[i], constr_grad[j])
-                    ntn[j, i] = ntn[i, j]
-
-                # get the inverse of ntn
-                ntn_inverse = Kratos.Matrix(number_of_active_constraints, number_of_active_constraints)
-
-                # create the identity matrix
-                identity_matrix = Kratos.Matrix(number_of_active_constraints, number_of_active_constraints, 0.0)
-                for i in range(number_of_active_constraints):
-                    identity_matrix[i, i] = 1.0
-
-                # solve for inverse of ntn
-                self.linear_solver.Solve(ntn, ntn_inverse, identity_matrix)
-
-                search_direction = - (obj_grad - self.__CollectiveListVectorProduct(constr_grad, ntn_inverse * self.__CollectiveListCollectiveProduct(constr_grad, obj_grad)))
-                correction = - self.__CollectiveListVectorProduct(constr_grad, ntn_inverse * constraint_violations)
-        correction_norm = KratosOA.ExpressionUtils.NormInf(correction)
-        if correction_norm > self.correction_size:
-            correction *= self.correction_size / correction_norm
-        self.algorithm_data.GetBufferedData()["search_direction"] = search_direction.Clone()
-        self.algorithm_data.GetBufferedData()["correction"] = correction.Clone()
-
-    def __CollectiveListCollectiveProduct(self, collective_list: 'list[KratosOA.CollectiveExpression]', other_collective: KratosOA.CollectiveExpression) -> Kratos.Vector:
-        result = Kratos.Vector(len(collective_list))
-
-        for i, collective_list_item in enumerate(collective_list):
-            result[i] = KratosOA.ExpressionUtils.InnerProduct(collective_list_item, other_collective)
-        return result
-
-    def __CollectiveListVectorProduct(self, collective_list: 'list[KratosOA.CollectiveExpression]', vector: Kratos.Vector) -> KratosOA.CollectiveExpression:
-        if len(collective_list) != vector.Size():
-            raise RuntimeError(f"Collective list size and vector size mismatch. [ Collective list size = {len(collective_list)}, vector size = {vector.Size()}]")
-        if len(collective_list) == 0:
-            raise RuntimeError("Collective lists cannot be empty.")
-
-        result = collective_list[0] * 0.0
-        for i, collective_list_item in enumerate(collective_list):
-            result += collective_list_item * vector[i]
-
-        return result
-
-    @time_decorator()
-    def ComputeControlUpdate(self, alpha: float) -> KratosOA.CollectiveExpression:
-        update = self.algorithm_data.GetBufferedData()["search_direction"] * alpha + self.algorithm_data.GetBufferedData()["correction"]
-        self.algorithm_data.GetBufferedData()["control_field_update"] = update.Clone()
-
-    @time_decorator()
-    def UpdateControl(self) -> KratosOA.CollectiveExpression:
-        update = self.algorithm_data.GetBufferedData()["control_field_update"]
-        self.__control_field += update
-        self.algorithm_data.GetBufferedData()["control_field"] = self.__control_field.Clone()
-
-    @time_decorator()
-    def GetCurrentObjValue(self) -> float:
-        return self.__obj_val
-
-    @time_decorator()
-    def GetCurrentControlField(self):
-        return self.__control_field
-
-    @time_decorator()
-    def Output(self) -> KratosOA.CollectiveExpression:
-        self.CallOnAllProcesses(["output_processes"], Kratos.OutputProcess.PrintOutput)
-
-    @time_decorator()
-    def Solve(self):
-        for_testing = []
-        while not self.converged:
-            with OptimizationAlgorithmTimeLogger("Gradient Projection",self._optimization_problem.GetStep()):
-                self.__obj_val = self.__objective.CalculateStandardizedValue(self.__control_field)
-                obj_info = self.__objective.GetInfo()
-                self.algorithm_data.GetBufferedData()["std_obj_value"] = obj_info["value"]
-                self.algorithm_data.GetBufferedData()["rel_change[%]"] = obj_info["rel_change [%]"]
-                if "abs_change [%]" in obj_info:
-                    self.algorithm_data.GetBufferedData()["abs_change[%]"] = obj_info["abs_change [%]"]
-                    for_testing.append([obj_info["value"], obj_info["rel_change [%]"], obj_info["abs_change [%]"]])
-
-                obj_grad = self.__objective.CalculateStandardizedGradient()
-
-                self.__constr_value = []
-                active_constr_grad = []
-                for constraint in self.__constraints_list:
-                    value = constraint.CalculateStandardizedValue(self.__control_field)
-                    self.__constr_value.append(value)
-                    constr_info = constraint.GetInfo()
-                    constr_name = constraint.GetResponseName()
-                    self.algorithm_data.GetBufferedData()[f"std_constr_{constr_name}_value"] = constr_info["value"]
-                    if value >= 0.0:
-                        active_constr_grad.append(constraint.CalculateStandardizedGradient())
-                    for_testing.append([constr_info["value"]])
-
-                self.ComputeSearchDirection(obj_grad, active_constr_grad)
-
-                alpha = self.__line_search_method.ComputeStep()
-
-                self.ComputeControlUpdate(alpha)
-
-                self.Output()
-
-                self.UpdateControl()
-
-                self.converged = self.__convergence_criteria.IsConverged()
-
-                self._optimization_problem.AdvanceStep()
-
-        return self.converged
-
-    def GetOptimizedObjectiveValue(self) -> float:
-        if self.converged:
-            return self.__obj_val
-        else:
-            raise RuntimeError("Optimization problem hasn't been solved.")
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.algorithms.standardized_objective import StandardizedObjective
+from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
+from KratosMultiphysics.OptimizationApplication.algorithms.algorithm import Algorithm
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.opt_convergence import CreateConvergenceCriteria
+from KratosMultiphysics.OptimizationApplication.utilities.opt_line_search import CreateLineSearch
+from KratosMultiphysics.OptimizationApplication.algorithms.standardized_constraint import StandardizedConstraint
+from KratosMultiphysics.LinearSolversApplication.dense_linear_solver_factory import ConstructSolver
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import OptimizationAlgorithmTimeLogger
+from KratosMultiphysics.OptimizationApplication.utilities.list_collective_expression_utilities import CollectiveListCollectiveProduct
+from KratosMultiphysics.OptimizationApplication.utilities.list_collective_expression_utilities import CollectiveListVectorProduct
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+    return AlgorithmGradientProjection(model, parameters, optimization_problem)
+
+class AlgorithmGradientProjection(Algorithm):
+    """
+        A classical steepest descent algorithm to solve unconstrainted optimization problems.
+    """
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        return Kratos.Parameters("""{
+            "module"            : "KratosMultiphysics.OptimizationApplication.algorithms",
+            "type"              : "PLEASE_PROVIDE_AN_ALGORITHM_CLASS_NAME",
+            "objective"         : {},
+            "constraints"       : [],
+            "controls"          : [],
+            "echo_level"        : 0,
+            "settings"          : {
+                "echo_level"      : 0,
+                "line_search"     : {},
+                "conv_settings"   : {},
+                "linear_solver_settings" : {},
+                "correction_size" : 0.0
+            }
+        }""")
+
+    def __init__(self, model:Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        self.model = model
+        self.parameters = parameters
+        self._optimization_problem = optimization_problem
+        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+
+        self.master_control = MasterControl() # Need to fill it with controls
+
+        for control_name in parameters["controls"].GetStringArray():
+            control = optimization_problem.GetControl(control_name)
+            self.master_control.AddControl(control)
+
+
+        settings = parameters["settings"]
+        settings.ValidateAndAssignDefaults(self.GetDefaultParameters()["settings"])
+
+        self.echo_level = settings["echo_level"].GetInt()
+
+        ComponentDataView("algorithm", self._optimization_problem).SetDataBuffer(self.GetMinimumBufferSize())
+
+        self.__convergence_criteria = CreateConvergenceCriteria(settings["conv_settings"], self._optimization_problem)
+        self.__line_search_method = CreateLineSearch(settings["line_search"], self._optimization_problem)
+
+        self.__objective = StandardizedObjective(parameters["objective"], self.master_control, self._optimization_problem)
+        self.__constraints_list: 'list[StandardizedConstraint]' = []
+        for constraint_param in parameters["constraints"].values():
+            constraint = StandardizedConstraint(constraint_param, self.master_control, self._optimization_problem)
+            self.__constraints_list.append(constraint)
+        self.__control_field = None
+        self.__obj_val = None
+
+        default_linear_solver_settings = Kratos.Parameters("""{
+            "solver_type": "LinearSolversApplication.dense_col_piv_householder_qr"
+        }""")
+        settings["linear_solver_settings"].ValidateAndAssignDefaults(default_linear_solver_settings)
+        self.linear_solver = ConstructSolver(settings["linear_solver_settings"])
+        self.correction_size = settings["correction_size"].GetDouble()
+
+    def GetMinimumBufferSize(self) -> int:
+        return 2
+
+    def Check(self):
+        self.master_control.Check()
+        self.__objective.Check()
+        CallOnAll(self.__constraints_list, StandardizedConstraint.Check)
+
+    @time_decorator()
+    def Initialize(self):
+        self.converged = False
+        self.__obj_val = None
+        self.master_control.Initialize()
+        self.__objective.Initialize()
+        CallOnAll(self.__constraints_list, StandardizedConstraint.Initialize)
+        self.__control_field = self.master_control.GetControlField()
+        self.algorithm_data = ComponentDataView("algorithm", self._optimization_problem)
+
+    @time_decorator()
+    def Finalize(self):
+        self.master_control.Finalize()
+        self.__objective.Finalize()
+        CallOnAll(self.__constraints_list, StandardizedConstraint.Finalize)
+
+    @time_decorator()
+    def ComputeSearchDirection(self, obj_grad: KratosOA.CollectiveExpression, constr_grad: 'list[KratosOA.CollectiveExpression]') -> KratosOA.CollectiveExpression:
+        active_constraints_list = [self.__constraints_list[i] for i in range(len(self.__constraints_list)) if self.__constr_value[i] >= 0.0]
+        number_of_active_constraints = len(active_constraints_list)
+        if not number_of_active_constraints:
+            search_direction = obj_grad * -1.0
+            correction = obj_grad * 0.0
+        else:
+            constraint_violations = Kratos.Vector(number_of_active_constraints)
+            for i, active_constraint in enumerate(active_constraints_list):
+                    constraint_violations[i] = active_constraint.GetScaledViolationValue()
+
+            # compute the projected search direction and correction
+            ntn = Kratos.Matrix(number_of_active_constraints, number_of_active_constraints)
+            for i in range(number_of_active_constraints):
+                for j in range(i, number_of_active_constraints):
+                    ntn[i, j] = KratosOA.ExpressionUtils.InnerProduct(constr_grad[i], constr_grad[j])
+                    ntn[j, i] = ntn[i, j]
+
+            # get the inverse of ntn
+            ntn_inverse = Kratos.Matrix(number_of_active_constraints, number_of_active_constraints)
+
+            # create the identity matrix
+            identity_matrix = Kratos.Matrix(number_of_active_constraints, number_of_active_constraints, 0.0)
+            for i in range(number_of_active_constraints):
+                identity_matrix[i, i] = 1.0
+
+            # solve for inverse of ntn
+            self.linear_solver.Solve(ntn, ntn_inverse, identity_matrix)
+
+            search_direction = - (obj_grad - CollectiveListVectorProduct(constr_grad, ntn_inverse * CollectiveListCollectiveProduct(constr_grad, obj_grad)))
+            correction = - CollectiveListVectorProduct(constr_grad, ntn_inverse * constraint_violations)
+        correction_norm = KratosOA.ExpressionUtils.NormInf(correction)
+        if correction_norm > self.correction_size:
+            correction *= self.correction_size / correction_norm
+        self.algorithm_data.GetBufferedData()["search_direction"] = search_direction.Clone()
+        self.algorithm_data.GetBufferedData()["correction"] = correction.Clone()
+
+    @time_decorator()
+    def ComputeControlUpdate(self, alpha: float) -> KratosOA.CollectiveExpression:
+        search_direction = self.algorithm_data.GetBufferedData()["search_direction"]
+        update = KratosOA.ExpressionUtils.Scale(search_direction, alpha) + self.algorithm_data.GetBufferedData()["correction"]
+        self.algorithm_data.GetBufferedData()["control_field_update"] = update.Clone()
+
+    @time_decorator()
+    def UpdateControl(self) -> KratosOA.CollectiveExpression:
+        update = self.algorithm_data.GetBufferedData()["control_field_update"]
+        self.__control_field += update
+
+    @time_decorator()
+    def GetCurrentObjValue(self) -> float:
+        return self.__obj_val
+
+    @time_decorator()
+    def GetCurrentControlField(self):
+        return self.__control_field
+
+    @time_decorator()
+    def Output(self) -> KratosOA.CollectiveExpression:
+        self.algorithm_data.GetBufferedData()["control_field"] = self.__control_field.Clone()
+        for process in self._optimization_problem.GetListOfProcesses("output_processes"):
+            if process.IsOutputStep():
+                process.PrintOutput()
+
+    @time_decorator()
+    def Solve(self):
+        while not self.converged:
+            with OptimizationAlgorithmTimeLogger("Gradient Projection",self._optimization_problem.GetStep()):
+                self._InitializeIteration()
+
+                self.__obj_val = self.__objective.CalculateStandardizedValue(self.__control_field)
+                obj_info = self.__objective.GetInfo()
+                self.algorithm_data.GetBufferedData()["std_obj_value"] = obj_info["std_value"]
+                self.algorithm_data.GetBufferedData()["rel_change[%]"] = obj_info["rel_change [%]"]
+                if "abs_change [%]" in obj_info:
+                    self.algorithm_data.GetBufferedData()["abs_change[%]"] = obj_info["abs_change [%]"]
+
+                obj_grad = self.__objective.CalculateStandardizedGradient()
+
+                self.__constr_value = []
+                active_constr_grad = []
+                for constraint in self.__constraints_list:
+                    value = constraint.CalculateStandardizedValue(self.__control_field)
+                    self.__constr_value.append(value)
+                    constr_name = constraint.GetResponseName()
+                    self.algorithm_data.GetBufferedData()[f"std_constr_{constr_name}_value"] = value
+                    if value >= 0.0:
+                        active_constr_grad.append(constraint.CalculateStandardizedGradient())
+
+                self.ComputeSearchDirection(obj_grad, active_constr_grad)
+
+                alpha = self.__line_search_method.ComputeStep()
+
+                self.ComputeControlUpdate(alpha)
+
+                self._FinalizeIteration()
+
+                self.Output()
+
+                self.UpdateControl()
+
+                self.converged = self.__convergence_criteria.IsConverged()
+
+                self._optimization_problem.AdvanceStep()
+
+        return self.converged
+
+    def GetOptimizedObjectiveValue(self) -> float:
+        if self.converged:
+            return self.__obj_val
+        else:
+            raise RuntimeError("Optimization problem hasn't been solved.")
```

## KratosMultiphysics/OptimizationApplication/algorithms/algorithm_steepest_descent.py

```diff
@@ -1,149 +1,152 @@
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.algorithms.standardized_objective import StandardizedObjective
-from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
-from KratosMultiphysics.OptimizationApplication.algorithms.algorithm import Algorithm
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.opt_convergence import CreateConvergenceCriteria
-from KratosMultiphysics.OptimizationApplication.utilities.opt_line_search import CreateLineSearch
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import OptimizationAlgorithmTimeLogger
-
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-    return AlgorithmSteepestDescent(model, parameters, optimization_problem)
-
-class AlgorithmSteepestDescent(Algorithm):
-    """
-        A classical steepest descent algorithm to solve unconstrainted optimization problems.
-    """
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        return Kratos.Parameters("""{
-            "module"            : "KratosMultiphysics.OptimizationApplication.algorithms",
-            "type"              : "PLEASE_PROVIDE_AN_ALGORITHM_CLASS_NAME",
-            "objective"         : {},
-            "controls"          : [],
-            "echo_level"        : 0,
-            "settings"          : {
-                "echo_level"      : 0,
-                "line_search"     : {},
-                "conv_settings"   : {}
-            }
-        }""")
-
-    def __init__(self, model:Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        self.model = model
-        self.parameters = parameters
-        self._optimization_problem = optimization_problem
-
-        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
-
-        self.master_control = MasterControl() # Need to fill it with controls
-
-        for control_name in parameters["controls"].GetStringArray():
-            control = optimization_problem.GetControl(control_name)
-            self.master_control.AddControl(control)
-
-
-        settings = parameters["settings"]
-        settings.ValidateAndAssignDefaults(self.GetDefaultParameters()["settings"])
-
-        self.echo_level = settings["echo_level"].GetInt()
-
-        ComponentDataView("algorithm", self._optimization_problem).SetDataBuffer(self.GetMinimumBufferSize())
-
-        self.__convergence_criteria = CreateConvergenceCriteria(settings["conv_settings"], self._optimization_problem)
-        self.__line_search_method = CreateLineSearch(settings["line_search"], self._optimization_problem)
-
-        self.__objective = StandardizedObjective(parameters["objective"], self.master_control, self._optimization_problem)
-        self.__control_field = None
-        self.__obj_val = None
-
-    def GetMinimumBufferSize(self) -> int:
-        return 2
-
-    def Check(self):
-        pass
-
-    @time_decorator()
-    def Initialize(self):
-        self.converged = False
-        self.__obj_val = None
-        self.__objective.Initialize()
-        self.__objective.Check()
-        self.master_control.Initialize()
-        self.__control_field = self.master_control.GetControlField()
-        self.algorithm_data = ComponentDataView("algorithm", self._optimization_problem)
-
-    def Finalize(self):
-        self.__objective.Finalize()
-        self.master_control.Finalize()
-
-    @time_decorator()
-    def ComputeSearchDirection(self, obj_grad) -> KratosOA.CollectiveExpression:
-        search_direction = obj_grad * -1.0
-        self.algorithm_data.GetBufferedData()["search_direction"] = search_direction.Clone()
-        return search_direction
-
-    @time_decorator()
-    def ComputeControlUpdate(self, alpha):
-        search_direction = self.algorithm_data.GetBufferedData()["search_direction"]
-        if isinstance(alpha, float):
-            update = search_direction * alpha
-        elif isinstance(alpha, KratosOA.CollectiveExpression):
-            update = search_direction.Scale(alpha)
-        self.algorithm_data.GetBufferedData()["control_field_update"] = update.Clone()
-
-    @time_decorator()
-    def UpdateControl(self) -> KratosOA.CollectiveExpression:
-        update = self.algorithm_data.GetBufferedData()["control_field_update"]
-        self.__control_field += update
-        self.algorithm_data.GetBufferedData()["control_field"] = self.__control_field.Clone()
-
-    @time_decorator()
-    def Output(self) -> KratosOA.CollectiveExpression:
-        self.CallOnAllProcesses(["output_processes"], Kratos.OutputProcess.PrintOutput)
-
-    def GetCurrentObjValue(self) -> float:
-        return self.__obj_val
-
-    def GetCurrentControlField(self):
-        return self.__control_field
-
-    @time_decorator()
-    def Solve(self):
-        while not self.converged:
-            with OptimizationAlgorithmTimeLogger("AlgorithmSteepestDescent",self._optimization_problem.GetStep()):
-                self.__obj_val = self.__objective.CalculateStandardizedValue(self.__control_field)
-                obj_info = self.__objective.GetInfo()
-                self.algorithm_data.GetBufferedData()["std_obj_value"] = obj_info["value"]
-                self.algorithm_data.GetBufferedData()["rel_obj[%]"] = obj_info["rel_change [%]"]
-                if "abs_change [%]" in obj_info:
-                    self.algorithm_data.GetBufferedData()["abs_obj[%]"] = obj_info["abs_change [%]"]
-
-                obj_grad = self.__objective.CalculateStandardizedGradient()
-
-                self.ComputeSearchDirection(obj_grad)
-
-                alpha = self.__line_search_method.ComputeStep()
-
-                self.ComputeControlUpdate(alpha)
-
-                self.Output()
-
-                self.UpdateControl()
-
-                self.converged = self.__convergence_criteria.IsConverged()
-
-                self._optimization_problem.AdvanceStep()
-
-        return self.converged
-
-    def GetOptimizedObjectiveValue(self) -> float:
-        if self.converged:
-            return self.__obj_val
-        else:
-            raise RuntimeError("Optimization problem hasn't been solved.")
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.algorithms.standardized_objective import StandardizedObjective
+from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
+from KratosMultiphysics.OptimizationApplication.algorithms.algorithm import Algorithm
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.opt_convergence import CreateConvergenceCriteria
+from KratosMultiphysics.OptimizationApplication.utilities.opt_line_search import CreateLineSearch
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import OptimizationAlgorithmTimeLogger
+
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+    return AlgorithmSteepestDescent(model, parameters, optimization_problem)
+
+class AlgorithmSteepestDescent(Algorithm):
+    """
+        A classical steepest descent algorithm to solve unconstrainted optimization problems.
+    """
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        return Kratos.Parameters("""{
+            "module"            : "KratosMultiphysics.OptimizationApplication.algorithms",
+            "type"              : "PLEASE_PROVIDE_AN_ALGORITHM_CLASS_NAME",
+            "objective"         : {},
+            "controls"          : [],
+            "echo_level"        : 0,
+            "settings"          : {
+                "echo_level"      : 0,
+                "line_search"     : {},
+                "conv_settings"   : {}
+            }
+        }""")
+
+    def __init__(self, model:Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        self.model = model
+        self.parameters = parameters
+        self._optimization_problem = optimization_problem
+
+        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+
+        self.master_control = MasterControl() # Need to fill it with controls
+
+        for control_name in parameters["controls"].GetStringArray():
+            control = optimization_problem.GetControl(control_name)
+            self.master_control.AddControl(control)
+
+
+        settings = parameters["settings"]
+        settings.ValidateAndAssignDefaults(self.GetDefaultParameters()["settings"])
+
+        self.echo_level = settings["echo_level"].GetInt()
+
+        ComponentDataView("algorithm", self._optimization_problem).SetDataBuffer(self.GetMinimumBufferSize())
+
+        self.__convergence_criteria = CreateConvergenceCriteria(settings["conv_settings"], self._optimization_problem)
+        self.__line_search_method = CreateLineSearch(settings["line_search"], self._optimization_problem)
+
+        self.__objective = StandardizedObjective(parameters["objective"], self.master_control, self._optimization_problem)
+        self.__control_field = None
+        self.__obj_val = None
+
+    def GetMinimumBufferSize(self) -> int:
+        return 2
+
+    def Check(self):
+        self.master_control.Check()
+        self.__objective.Check()
+
+    @time_decorator()
+    def Initialize(self):
+        self.converged = False
+        self.__obj_val = None
+        self.master_control.Initialize()
+        self.__objective.Initialize()
+        self.__control_field = self.master_control.GetControlField()
+        self.algorithm_data = ComponentDataView("algorithm", self._optimization_problem)
+
+    def Finalize(self):
+        self.master_control.Finalize()
+        self.__objective.Finalize()
+
+    @time_decorator()
+    def ComputeSearchDirection(self, obj_grad) -> KratosOA.CollectiveExpression:
+        search_direction = obj_grad * -1.0
+        self.algorithm_data.GetBufferedData()["search_direction"] = search_direction.Clone()
+        return search_direction
+
+    @time_decorator()
+    def ComputeControlUpdate(self, alpha):
+        search_direction = self.algorithm_data.GetBufferedData()["search_direction"]
+        update = KratosOA.ExpressionUtils.Scale(search_direction, alpha)
+        self.algorithm_data.GetBufferedData()["control_field_update"] = update.Clone()
+
+    @time_decorator()
+    def UpdateControl(self) -> KratosOA.CollectiveExpression:
+        update = self.algorithm_data.GetBufferedData()["control_field_update"]
+        self.__control_field += update
+
+    @time_decorator()
+    def Output(self) -> KratosOA.CollectiveExpression:
+        self.algorithm_data.GetBufferedData()["control_field"] = self.__control_field.Clone()
+        for process in self._optimization_problem.GetListOfProcesses("output_processes"):
+            if process.IsOutputStep():
+                process.PrintOutput()
+
+    def GetCurrentObjValue(self) -> float:
+        return self.__obj_val
+
+    def GetCurrentControlField(self):
+        return self.__control_field
+
+    @time_decorator()
+    def Solve(self):
+        while not self.converged:
+            with OptimizationAlgorithmTimeLogger("AlgorithmSteepestDescent",self._optimization_problem.GetStep()):
+                self._InitializeIteration()
+
+                self.__obj_val = self.__objective.CalculateStandardizedValue(self.__control_field)
+                obj_info = self.__objective.GetInfo()
+                self.algorithm_data.GetBufferedData()["std_obj_value"] = obj_info["std_value"]
+                self.algorithm_data.GetBufferedData()["rel_obj[%]"] = obj_info["rel_change [%]"]
+                if "abs_change [%]" in obj_info:
+                    self.algorithm_data.GetBufferedData()["abs_obj[%]"] = obj_info["abs_change [%]"]
+
+                obj_grad = self.__objective.CalculateStandardizedGradient()
+
+                self.ComputeSearchDirection(obj_grad)
+
+                alpha = self.__line_search_method.ComputeStep()
+
+                self.ComputeControlUpdate(alpha)
+
+                self._FinalizeIteration()
+
+                self.Output()
+
+                self.UpdateControl()
+
+                self.converged = self.__convergence_criteria.IsConverged()
+
+                self._optimization_problem.AdvanceStep()
+
+        return self.converged
+
+    def GetOptimizedObjectiveValue(self) -> float:
+        if self.converged:
+            return self.__obj_val
+        else:
+            raise RuntimeError("Optimization problem hasn't been solved.")
```

## KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_constraint.py

 * *Ordering differences only*

```diff
@@ -1,185 +1,185 @@
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.responses.response_routine import ResponseRoutine
-from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
-import numpy
-import sys
-
-class StandardizedNLOPTConstraint(ResponseRoutine):
-    """Standardized constraint response function
-
-    This class creates instances to standardize any response function for the specified type of the contraint.
-    Supported contraint types:
-        "=",
-        "<",
-        ">"
-
-    The reference value for the constraint either can be the "initial_value" or a specified value.
-
-    """
-    def __init__(self, parameters: Kratos.Parameters, master_control: MasterControl, optimization_problem: OptimizationProblem, required_buffer_size: int = 2):
-        default_parameters = Kratos.Parameters("""{
-            "response_name": "",
-            "type"                     : "",
-            "ref_value"             : "initial_value"
-        }""")
-
-        response_name = str(parameters["response_name"].GetString())
-        if not parameters.Has("ref_value"):
-            raise RuntimeError(f"Constraint for response {response_name} requires reference value specified in ref_value")
-
-        if parameters.Has("ref_value") and parameters["ref_value"].IsDouble():
-            default_parameters["ref_value"].SetDouble(0.0)
-
-        parameters.ValidateAndAssignDefaults(default_parameters)
-
-        response = optimization_problem.GetResponse(parameters["response_name"].GetString())
-
-        super().__init__(master_control, response)
-
-        if required_buffer_size < 2:
-            raise RuntimeError(f"Standardized constraint requires 2 as minimum buffer size. [ response name = {self.GetReponse().GetName()} ]")
-
-        component_data_view = ComponentDataView(response, optimization_problem)
-        component_data_view.SetDataBuffer(required_buffer_size)
-
-        self.__optimization_problem = optimization_problem
-        self.__buffered_data = component_data_view.GetBufferedData()
-        self.__unbuffered_data = component_data_view.GetUnBufferedData()
-
-        if parameters["ref_value"].IsDouble():
-            self.__reference_value = parameters["ref_value"].GetDouble()
-        elif parameters["ref_value"].IsString() and parameters["ref_value"].GetString() == "initial_value":
-            self.__reference_value = None
-        else:
-            raise RuntimeError("Provided \"reference_type\" is not supported for constraint response functions. Followings are supported options: \n\tinitial_value\n\tfloat value")
-
-        self.__constraint_type = parameters["type"].GetString()
-        if self.__constraint_type in ["=", "<"]:
-            self.__scaling = 1.0
-        elif self.__constraint_type in [">"]:
-            self.__scaling = -1.0
-            if not self.__reference_value is None: self.__reference_value *= -1
-        else:
-            raise RuntimeError(f"Provided \"type\" = {self.__constraint_type} is not supported in constraint response functions. Followings are supported options: \n\t=\n\t<\n\t>")
-
-        self.__zero_threshold = sys.float_info.epsilon
-
-    def IsEqualityType(self) -> str:
-        return self.__constraint_type == "="
-
-    def GetReferenceValue(self) -> float:
-        if self.__reference_value is not None:
-            return self.__reference_value
-        else:
-            if self.__unbuffered_data.HasValue("initial_value"):
-                self.__reference_value = self.__unbuffered_data["initial_value"]
-                return self.__reference_value
-            else:
-                raise RuntimeError(f"Response value for {self.GetReponse().GetName()} is not calculated yet.")
-
-    def CalculateStandardizedValueAndGradients(self, control_field: numpy.ndarray, gradient_field: numpy.ndarray, save_value: bool = True) -> float:
-
-        with TimeLogger(f"StandardizedNLOPTConstraint::Calculate {self.GetReponse().GetName()} value", None, "Finished"):
-
-            # first update the master control
-            self.UpdateMasterControl(control_field)
-
-            # compute the value
-            response_value = self.GetReponse().CalculateValue()
-
-            if not self.__unbuffered_data.HasValue("initial_value"):
-                self.__unbuffered_data["initial_value"] = response_value
-
-            if self.__buffered_data.HasValue("value"): del self.__buffered_data["value"]
-            self.__buffered_data["value"] = response_value
-
-            # log values
-            if save_value:
-                self.LogValues()
-
-            # print the info
-            DictLogger("Constraint info",self.GetInfo())
-
-            if gradient_field.size > 0:
-                gradient_collective_expression = self.CalculateGradient()
-                gradient_field[:] = gradient_collective_expression.Evaluate().reshape(-1) * self.GetStandardizationFactor()
-
-                if save_value:
-                    self.LogGradientFields(gradient_collective_expression)
-
-        return self.GetStandardizedValue()
-
-    def GetValue(self, step_index: int = 0) -> float:
-        return self.__buffered_data.GetValue("value", step_index)
-
-    def GetStandardizationFactor(self):
-        ref_value = self.GetReferenceValue()
-        standardization_factor = self.__scaling
-        if abs(ref_value) > self.__zero_threshold:
-            standardization_factor /= abs(ref_value)
-        return standardization_factor
-
-    def GetStandardizedValue(self, step_index: int = 0) -> float:
-        ref_value = self.GetReferenceValue()
-        standardized_response_value = self.GetValue(step_index) - ref_value
-        standardized_response_value *= self.GetStandardizationFactor()
-        return standardized_response_value
-
-    def GetAbsoluteViolation(self, step_index: int = 0) -> float:
-            ref_value = self.GetReferenceValue()
-            standardized_response_value = self.GetValue(step_index) - ref_value
-            standardization_factor = self.__scaling
-            if abs(ref_value) > self.__zero_threshold:
-                standardization_factor /= abs(ref_value)
-                standardization_factor *= 100
-            standardized_response_value *= standardization_factor
-            return standardized_response_value
-
-    def GetInfo(self) -> dict:
-        info = {
-            "name": self.GetReponse().GetName(),
-            "value": self.GetValue(),
-            "type": self.__constraint_type,
-            "ref_value": self.GetReferenceValue(),
-            "violation [%]": self.GetAbsoluteViolation()
-        }
-        return info
-
-    def LogValues(self) -> None:
-        if self.__buffered_data.HasValue("violation [%]"): del self.__buffered_data["violation [%]"]
-        self.__buffered_data["violation [%]"] = self.GetAbsoluteViolation()
-
-    def LogGradientFields(self,gradient_collective_expression) -> None:
-        # save the physical gradients for post processing in unbuffered data container.
-        for physical_var, physical_gradient in self.GetRequiredPhysicalGradients().items():
-            variable_name = f"d{self.GetReponse().GetName()}_d{physical_var.Name()}"
-            for physical_gradient_expression in physical_gradient.GetContainerExpressions():
-                if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
-                # cloning is a cheap operation, it only moves underlying pointers
-                # does not create additional memory.
-                self.__unbuffered_data[variable_name] = physical_gradient_expression.Clone()
-
-        # save the filtered gradients for post processing in unbuffered data container.
-        for gradient_container_expression, control in zip(gradient_collective_expression.GetContainerExpressions(), self.GetMasterControl().GetListOfControls()):
-            variable_name = f"d{self.GetReponse().GetName()}_d{control.GetName()}"
-            if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
-            # cloning is a cheap operation, it only moves underlying pointers
-            # does not create additional memory.
-            self.__unbuffered_data[variable_name] = gradient_container_expression.Clone()
-
-    def UpdateMasterControl(self, new_control_field: numpy.ndarray) -> None:
-        master_control = self.GetMasterControl()
-        new_control_field_exp = master_control.GetEmptyField()
-        number_of_entities = []
-        shapes = []
-        for control in master_control.GetListOfControls():
-            number_of_entities.append(len(control.GetControlField().GetContainer()))
-            shapes.append(control.GetControlField().GetItemShape())
-        KratosOA.CollectiveExpressionIO.Read(new_control_field_exp,new_control_field,shapes)
-        # now update the master control
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.responses.response_routine import ResponseRoutine
+from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
+import numpy
+import sys
+
+class StandardizedNLOPTConstraint(ResponseRoutine):
+    """Standardized constraint response function
+
+    This class creates instances to standardize any response function for the specified type of the contraint.
+    Supported contraint types:
+        "=",
+        "<",
+        ">"
+
+    The reference value for the constraint either can be the "initial_value" or a specified value.
+
+    """
+    def __init__(self, parameters: Kratos.Parameters, master_control: MasterControl, optimization_problem: OptimizationProblem, required_buffer_size: int = 2):
+        default_parameters = Kratos.Parameters("""{
+            "response_name": "",
+            "type"                     : "",
+            "ref_value"             : "initial_value"
+        }""")
+
+        response_name = str(parameters["response_name"].GetString())
+        if not parameters.Has("ref_value"):
+            raise RuntimeError(f"Constraint for response {response_name} requires reference value specified in ref_value")
+
+        if parameters.Has("ref_value") and parameters["ref_value"].IsDouble():
+            default_parameters["ref_value"].SetDouble(0.0)
+
+        parameters.ValidateAndAssignDefaults(default_parameters)
+
+        response = optimization_problem.GetResponse(parameters["response_name"].GetString())
+
+        super().__init__(master_control, response)
+
+        if required_buffer_size < 2:
+            raise RuntimeError(f"Standardized constraint requires 2 as minimum buffer size. [ response name = {self.GetReponse().GetName()} ]")
+
+        component_data_view = ComponentDataView(response, optimization_problem)
+        component_data_view.SetDataBuffer(required_buffer_size)
+
+        self.__optimization_problem = optimization_problem
+        self.__buffered_data = component_data_view.GetBufferedData()
+        self.__unbuffered_data = component_data_view.GetUnBufferedData()
+
+        if parameters["ref_value"].IsDouble():
+            self.__reference_value = parameters["ref_value"].GetDouble()
+        elif parameters["ref_value"].IsString() and parameters["ref_value"].GetString() == "initial_value":
+            self.__reference_value = None
+        else:
+            raise RuntimeError("Provided \"reference_type\" is not supported for constraint response functions. Followings are supported options: \n\tinitial_value\n\tfloat value")
+
+        self.__constraint_type = parameters["type"].GetString()
+        if self.__constraint_type in ["=", "<"]:
+            self.__scaling = 1.0
+        elif self.__constraint_type in [">"]:
+            self.__scaling = -1.0
+            if not self.__reference_value is None: self.__reference_value *= -1
+        else:
+            raise RuntimeError(f"Provided \"type\" = {self.__constraint_type} is not supported in constraint response functions. Followings are supported options: \n\t=\n\t<\n\t>")
+
+        self.__zero_threshold = sys.float_info.epsilon
+
+    def IsEqualityType(self) -> str:
+        return self.__constraint_type == "="
+
+    def GetReferenceValue(self) -> float:
+        if self.__reference_value is not None:
+            return self.__reference_value
+        else:
+            if self.__unbuffered_data.HasValue("initial_value"):
+                self.__reference_value = self.__unbuffered_data["initial_value"]
+                return self.__reference_value
+            else:
+                raise RuntimeError(f"Response value for {self.GetReponse().GetName()} is not calculated yet.")
+
+    def CalculateStandardizedValueAndGradients(self, control_field: numpy.ndarray, gradient_field: numpy.ndarray, save_value: bool = True) -> float:
+
+        with TimeLogger(f"StandardizedNLOPTConstraint::Calculate {self.GetReponse().GetName()} value", None, "Finished"):
+
+            # first update the master control
+            self.UpdateMasterControl(control_field)
+
+            # compute the value
+            response_value = self.GetReponse().CalculateValue()
+
+            if not self.__unbuffered_data.HasValue("initial_value"):
+                self.__unbuffered_data["initial_value"] = response_value
+
+            if self.__buffered_data.HasValue("value"): del self.__buffered_data["value"]
+            self.__buffered_data["value"] = response_value
+
+            # log values
+            if save_value:
+                self.LogValues()
+
+            # print the info
+            DictLogger("Constraint info",self.GetInfo())
+
+            if gradient_field.size > 0:
+                gradient_collective_expression = self.CalculateGradient()
+                gradient_field[:] = gradient_collective_expression.Evaluate().reshape(-1) * self.GetStandardizationFactor()
+
+                if save_value:
+                    self.LogGradientFields(gradient_collective_expression)
+
+        return self.GetStandardizedValue()
+
+    def GetValue(self, step_index: int = 0) -> float:
+        return self.__buffered_data.GetValue("value", step_index)
+
+    def GetStandardizationFactor(self):
+        ref_value = self.GetReferenceValue()
+        standardization_factor = self.__scaling
+        if abs(ref_value) > self.__zero_threshold:
+            standardization_factor /= abs(ref_value)
+        return standardization_factor
+
+    def GetStandardizedValue(self, step_index: int = 0) -> float:
+        ref_value = self.GetReferenceValue()
+        standardized_response_value = self.GetValue(step_index) - ref_value
+        standardized_response_value *= self.GetStandardizationFactor()
+        return standardized_response_value
+
+    def GetAbsoluteViolation(self, step_index: int = 0) -> float:
+            ref_value = self.GetReferenceValue()
+            standardized_response_value = self.GetValue(step_index) - ref_value
+            standardization_factor = self.__scaling
+            if abs(ref_value) > self.__zero_threshold:
+                standardization_factor /= abs(ref_value)
+                standardization_factor *= 100
+            standardized_response_value *= standardization_factor
+            return standardized_response_value
+
+    def GetInfo(self) -> dict:
+        info = {
+            "name": self.GetReponse().GetName(),
+            "value": self.GetValue(),
+            "type": self.__constraint_type,
+            "ref_value": self.GetReferenceValue(),
+            "violation [%]": self.GetAbsoluteViolation()
+        }
+        return info
+
+    def LogValues(self) -> None:
+        if self.__buffered_data.HasValue("violation [%]"): del self.__buffered_data["violation [%]"]
+        self.__buffered_data["violation [%]"] = self.GetAbsoluteViolation()
+
+    def LogGradientFields(self,gradient_collective_expression) -> None:
+        # save the physical gradients for post processing in unbuffered data container.
+        for physical_var, physical_gradient in self.GetRequiredPhysicalGradients().items():
+            variable_name = f"d{self.GetReponse().GetName()}_d{physical_var.Name()}"
+            for physical_gradient_expression in physical_gradient.GetContainerExpressions():
+                if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
+                # cloning is a cheap operation, it only moves underlying pointers
+                # does not create additional memory.
+                self.__unbuffered_data[variable_name] = physical_gradient_expression.Clone()
+
+        # save the filtered gradients for post processing in unbuffered data container.
+        for gradient_container_expression, control in zip(gradient_collective_expression.GetContainerExpressions(), self.GetMasterControl().GetListOfControls()):
+            variable_name = f"d{self.GetReponse().GetName()}_d{control.GetName()}"
+            if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
+            # cloning is a cheap operation, it only moves underlying pointers
+            # does not create additional memory.
+            self.__unbuffered_data[variable_name] = gradient_container_expression.Clone()
+
+    def UpdateMasterControl(self, new_control_field: numpy.ndarray) -> None:
+        master_control = self.GetMasterControl()
+        new_control_field_exp = master_control.GetEmptyField()
+        number_of_entities = []
+        shapes = []
+        for control in master_control.GetListOfControls():
+            number_of_entities.append(len(control.GetControlField().GetContainer()))
+            shapes.append(control.GetControlField().GetItemShape())
+        KratosOA.CollectiveExpressionIO.Read(new_control_field_exp,new_control_field,shapes)
+        # now update the master control
         master_control.Update(new_control_field_exp)
```

## KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_objective.py

 * *Ordering differences only*

```diff
@@ -1,181 +1,181 @@
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.responses.response_routine import ResponseRoutine
-from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
-import numpy
-import datetime
-
-class StandardizedNLOPTObjective(ResponseRoutine):
-    """Standardized objective response function
-
-    This class transformed a user-given optimization problem into the standard format.
-    Supported objective types:
-        "minimization",
-        "maximization"
-
-    """
-    def __init__(self, parameters: Kratos.Parameters, master_control: MasterControl, optimization_problem: OptimizationProblem, required_buffer_size: int = 2):
-        default_parameters = Kratos.Parameters("""{
-            "response_name": "",
-            "type"         : "",
-            "scaling"      : 1.0
-        }""")
-        parameters.ValidateAndAssignDefaults(default_parameters)
-
-        response = optimization_problem.GetResponse(parameters["response_name"].GetString())
-
-        super().__init__(master_control, response)
-
-        if required_buffer_size < 2:
-            raise RuntimeError(f"Standardized objective requires 2 as minimum buffer size. [ response name = {self.GetReponse().GetName()} ]")
-
-        component_data_view = ComponentDataView(response, optimization_problem)
-        component_data_view.SetDataBuffer(required_buffer_size)
-
-        self.__optimization_problem = optimization_problem
-        self.__buffered_data = component_data_view.GetBufferedData()
-        self.__unbuffered_data = component_data_view.GetUnBufferedData()
-
-        scaling = parameters["scaling"].GetDouble()
-        if scaling < 0.0:
-            raise RuntimeError(f"Scaling should be always positive [ given scale = {scaling}]")
-
-        self.__objective_type = parameters["type"].GetString()
-        if self.__objective_type == "minimization":
-            self.__scaling = scaling
-        elif self.__objective_type == "maximization":
-            self.__scaling = -scaling
-        else:
-            raise RuntimeError(f"Requesting unsupported type {self.__objective_type} for objective response function. Supported types are: \n\tminimization\n\tmaximization")
-
-    def GetInitialValue(self) -> float:
-        if self.__unbuffered_data.HasValue("initial_value"):
-            return self.__unbuffered_data["initial_value"] * self.__scaling
-        else:
-            raise RuntimeError(f"Response value for {self.GetReponse().GetName()} is not calculated yet.")
-
-    def CalculateStandardizedValueAndGradients(self, control_field: numpy.ndarray, gradient_field: numpy.ndarray, save_value: bool = True) -> float:
-        if self.UpdateMasterControlAndLogFields(control_field) or self.__optimization_problem.GetStep()==0:
-            with TimeLogger(f"CalculateStandardizedValueAndGradients {self.GetReponse().GetName()} value", None, "Finished"):
-
-                response_value = self.GetReponse().CalculateValue()
-
-                if not self.__unbuffered_data.HasValue("initial_value"):
-                    self.__unbuffered_data["initial_value"] = response_value
-
-                if self.__buffered_data.HasValue("value"): del self.__buffered_data["value"]
-                self.__buffered_data["value"] = response_value
-
-                # log values
-                if save_value:
-                    self.LogValues()
-
-                # print the info
-                DictLogger("Objective info",self.GetInfo())
-
-                # compute standardization factor
-                self.standardization_factor = self.__scaling
-                if abs(self.__unbuffered_data["initial_value"])>1e-15:
-                    self.standardization_factor /= abs(self.__unbuffered_data["initial_value"])
-                self.standardized_response_value = self.standardization_factor * response_value
-
-                # compute gradients
-                if gradient_field.size > 0:
-                    self.gradient_collective_expression = self.CalculateGradient()
-                    # save gradients
-                    if save_value:
-                        self.LogGradientFields()
-
-        if gradient_field.size > 0:
-            gradient_field[:] = self.standardization_factor * self.gradient_collective_expression.Evaluate().reshape(-1)
-
-        return self.standardized_response_value
-
-    def GetValue(self, step_index: int = 0) -> float:
-        return self.__buffered_data.GetValue("value", step_index)
-
-    def GetStandardizedValue(self, step_index: int = 0) -> float:
-        return self.GetValue(step_index) * self.__scaling
-
-    def GetRelativeChange(self) -> float:
-        if self.__optimization_problem.GetStep() > 0:
-            return self.GetStandardizedValue() / self.GetStandardizedValue(1) - 1.0 if abs(self.GetStandardizedValue(1)) > 1e-12 else self.GetStandardizedValue()
-        else:
-            return 0.0
-
-    def GetAbsoluteChange(self) -> float:
-        if self.__optimization_problem.GetStep() > 0:
-            return self.GetStandardizedValue() / self.GetInitialValue() - 1.0 if abs(self.GetInitialValue()) > 1e-12 else self.GetStandardizedValue()
-        else:
-            return 0.0
-
-    def GetInfo(self) -> dict:
-        info = {
-            "name": self.GetReponse().GetName(),
-            "type": self.__objective_type,
-            "value": self.GetValue(),
-            "abs_change [%]": self.GetAbsoluteChange() * 100.0,
-            "rel_change [%]": self.GetRelativeChange() * 100.0
-        }
-        return info
-
-    def LogValues(self) -> None:
-        values_info = self.GetInfo()
-        if self.__buffered_data.HasValue("rel_change [%]"): del self.__buffered_data["rel_change [%]"]
-        self.__buffered_data["rel_change [%]"] = values_info["rel_change [%]"]
-        if self.__buffered_data.HasValue("abs_change [%]"): del self.__buffered_data["abs_change [%]"]
-        self.__buffered_data["abs_change [%]"] = values_info["abs_change [%]"]
-
-    def LogGradientFields(self) -> None:
-        # save the physical gradients for post processing in unbuffered data container.
-        for physical_var, physical_gradient in self.GetRequiredPhysicalGradients().items():
-            variable_name = f"d{self.GetReponse().GetName()}_d{physical_var.Name()}"
-            for physical_gradient_expression in physical_gradient.GetContainerExpressions():
-                if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
-                # cloning is a cheap operation, it only moves underlying pointers
-                # does not create additional memory.
-                self.__unbuffered_data[variable_name] = physical_gradient_expression.Clone()
-
-        # save the filtered gradients for post processing in unbuffered data container.
-        for gradient_container_expression, control in zip(self.gradient_collective_expression.GetContainerExpressions(), self.GetMasterControl().GetListOfControls()):
-            variable_name = f"d{self.GetReponse().GetName()}_d{control.GetName()}"
-            if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
-            # cloning is a cheap operation, it only moves underlying pointers
-            # does not create additional memory.
-            self.__unbuffered_data[variable_name] = gradient_container_expression.Clone()
-
-    def LogOptimizationStep(self) -> None:
-        now = datetime.datetime.now()
-        now_str = now.strftime("%Y-%m-%d %H:%M:%S")
-        iteration_text = f" EoF Iteration {self.__optimization_problem.GetStep()}"
-        iteration_output = f"{'#'}  {iteration_text} [Time: {now_str}]  {'#'}"
-        divided_line = len(iteration_output) * '#'
-        to_print = f"{divided_line}\n{iteration_output}\n{divided_line}\n"
-        Kratos.Logger.PrintInfo(to_print)
-
-    def UpdateMasterControlAndLogFields(self, new_control_field: numpy.ndarray) -> bool:
-        master_control_updated = False
-        master_control = self.GetMasterControl()
-        control_change_norm = numpy.linalg.norm(master_control.GetControlField().Evaluate().reshape(-1)-new_control_field)
-        if control_change_norm > 1e-15:
-            # first out put the fields and update step
-            CallOnAll(self.__optimization_problem.GetListOfProcesses("output_processes"), Kratos.OutputProcess.PrintOutput)
-            self.LogOptimizationStep()
-            self.__optimization_problem.AdvanceStep()
-            # convert numpy arry to expression
-            new_control_field_exp = master_control.GetEmptyField()
-            number_of_entities = []
-            shapes = []
-            for control in master_control.GetListOfControls():
-                number_of_entities.append(len(control.GetControlField().GetContainer()))
-                shapes.append(control.GetControlField().GetItemShape())
-            KratosOA.CollectiveExpressionIO.Read(new_control_field_exp,new_control_field,shapes)
-            # now update the master control
-            master_control.Update(new_control_field_exp)
-            master_control_updated = True
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.responses.response_routine import ResponseRoutine
+from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
+import numpy
+import datetime
+
+class StandardizedNLOPTObjective(ResponseRoutine):
+    """Standardized objective response function
+
+    This class transformed a user-given optimization problem into the standard format.
+    Supported objective types:
+        "minimization",
+        "maximization"
+
+    """
+    def __init__(self, parameters: Kratos.Parameters, master_control: MasterControl, optimization_problem: OptimizationProblem, required_buffer_size: int = 2):
+        default_parameters = Kratos.Parameters("""{
+            "response_name": "",
+            "type"         : "",
+            "scaling"      : 1.0
+        }""")
+        parameters.ValidateAndAssignDefaults(default_parameters)
+
+        response = optimization_problem.GetResponse(parameters["response_name"].GetString())
+
+        super().__init__(master_control, response)
+
+        if required_buffer_size < 2:
+            raise RuntimeError(f"Standardized objective requires 2 as minimum buffer size. [ response name = {self.GetReponse().GetName()} ]")
+
+        component_data_view = ComponentDataView(response, optimization_problem)
+        component_data_view.SetDataBuffer(required_buffer_size)
+
+        self.__optimization_problem = optimization_problem
+        self.__buffered_data = component_data_view.GetBufferedData()
+        self.__unbuffered_data = component_data_view.GetUnBufferedData()
+
+        scaling = parameters["scaling"].GetDouble()
+        if scaling < 0.0:
+            raise RuntimeError(f"Scaling should be always positive [ given scale = {scaling}]")
+
+        self.__objective_type = parameters["type"].GetString()
+        if self.__objective_type == "minimization":
+            self.__scaling = scaling
+        elif self.__objective_type == "maximization":
+            self.__scaling = -scaling
+        else:
+            raise RuntimeError(f"Requesting unsupported type {self.__objective_type} for objective response function. Supported types are: \n\tminimization\n\tmaximization")
+
+    def GetInitialValue(self) -> float:
+        if self.__unbuffered_data.HasValue("initial_value"):
+            return self.__unbuffered_data["initial_value"] * self.__scaling
+        else:
+            raise RuntimeError(f"Response value for {self.GetReponse().GetName()} is not calculated yet.")
+
+    def CalculateStandardizedValueAndGradients(self, control_field: numpy.ndarray, gradient_field: numpy.ndarray, save_value: bool = True) -> float:
+        if self.UpdateMasterControlAndLogFields(control_field) or self.__optimization_problem.GetStep()==0:
+            with TimeLogger(f"CalculateStandardizedValueAndGradients {self.GetReponse().GetName()} value", None, "Finished"):
+
+                response_value = self.GetReponse().CalculateValue()
+
+                if not self.__unbuffered_data.HasValue("initial_value"):
+                    self.__unbuffered_data["initial_value"] = response_value
+
+                if self.__buffered_data.HasValue("value"): del self.__buffered_data["value"]
+                self.__buffered_data["value"] = response_value
+
+                # log values
+                if save_value:
+                    self.LogValues()
+
+                # print the info
+                DictLogger("Objective info",self.GetInfo())
+
+                # compute standardization factor
+                self.standardization_factor = self.__scaling
+                if abs(self.__unbuffered_data["initial_value"])>1e-15:
+                    self.standardization_factor /= abs(self.__unbuffered_data["initial_value"])
+                self.standardized_response_value = self.standardization_factor * response_value
+
+                # compute gradients
+                if gradient_field.size > 0:
+                    self.gradient_collective_expression = self.CalculateGradient()
+                    # save gradients
+                    if save_value:
+                        self.LogGradientFields()
+
+        if gradient_field.size > 0:
+            gradient_field[:] = self.standardization_factor * self.gradient_collective_expression.Evaluate().reshape(-1)
+
+        return self.standardized_response_value
+
+    def GetValue(self, step_index: int = 0) -> float:
+        return self.__buffered_data.GetValue("value", step_index)
+
+    def GetStandardizedValue(self, step_index: int = 0) -> float:
+        return self.GetValue(step_index) * self.__scaling
+
+    def GetRelativeChange(self) -> float:
+        if self.__optimization_problem.GetStep() > 0:
+            return self.GetStandardizedValue() / self.GetStandardizedValue(1) - 1.0 if abs(self.GetStandardizedValue(1)) > 1e-12 else self.GetStandardizedValue()
+        else:
+            return 0.0
+
+    def GetAbsoluteChange(self) -> float:
+        if self.__optimization_problem.GetStep() > 0:
+            return self.GetStandardizedValue() / self.GetInitialValue() - 1.0 if abs(self.GetInitialValue()) > 1e-12 else self.GetStandardizedValue()
+        else:
+            return 0.0
+
+    def GetInfo(self) -> dict:
+        info = {
+            "name": self.GetReponse().GetName(),
+            "type": self.__objective_type,
+            "value": self.GetValue(),
+            "abs_change [%]": self.GetAbsoluteChange() * 100.0,
+            "rel_change [%]": self.GetRelativeChange() * 100.0
+        }
+        return info
+
+    def LogValues(self) -> None:
+        values_info = self.GetInfo()
+        if self.__buffered_data.HasValue("rel_change [%]"): del self.__buffered_data["rel_change [%]"]
+        self.__buffered_data["rel_change [%]"] = values_info["rel_change [%]"]
+        if self.__buffered_data.HasValue("abs_change [%]"): del self.__buffered_data["abs_change [%]"]
+        self.__buffered_data["abs_change [%]"] = values_info["abs_change [%]"]
+
+    def LogGradientFields(self) -> None:
+        # save the physical gradients for post processing in unbuffered data container.
+        for physical_var, physical_gradient in self.GetRequiredPhysicalGradients().items():
+            variable_name = f"d{self.GetReponse().GetName()}_d{physical_var.Name()}"
+            for physical_gradient_expression in physical_gradient.GetContainerExpressions():
+                if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
+                # cloning is a cheap operation, it only moves underlying pointers
+                # does not create additional memory.
+                self.__unbuffered_data[variable_name] = physical_gradient_expression.Clone()
+
+        # save the filtered gradients for post processing in unbuffered data container.
+        for gradient_container_expression, control in zip(self.gradient_collective_expression.GetContainerExpressions(), self.GetMasterControl().GetListOfControls()):
+            variable_name = f"d{self.GetReponse().GetName()}_d{control.GetName()}"
+            if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
+            # cloning is a cheap operation, it only moves underlying pointers
+            # does not create additional memory.
+            self.__unbuffered_data[variable_name] = gradient_container_expression.Clone()
+
+    def LogOptimizationStep(self) -> None:
+        now = datetime.datetime.now()
+        now_str = now.strftime("%Y-%m-%d %H:%M:%S")
+        iteration_text = f" EoF Iteration {self.__optimization_problem.GetStep()}"
+        iteration_output = f"{'#'}  {iteration_text} [Time: {now_str}]  {'#'}"
+        divided_line = len(iteration_output) * '#'
+        to_print = f"{divided_line}\n{iteration_output}\n{divided_line}\n"
+        Kratos.Logger.PrintInfo(to_print)
+
+    def UpdateMasterControlAndLogFields(self, new_control_field: numpy.ndarray) -> bool:
+        master_control_updated = False
+        master_control = self.GetMasterControl()
+        control_change_norm = numpy.linalg.norm(master_control.GetControlField().Evaluate().reshape(-1)-new_control_field)
+        if control_change_norm > 1e-15:
+            # first out put the fields and update step
+            CallOnAll(self.__optimization_problem.GetListOfProcesses("output_processes"), Kratos.OutputProcess.PrintOutput)
+            self.LogOptimizationStep()
+            self.__optimization_problem.AdvanceStep()
+            # convert numpy arry to expression
+            new_control_field_exp = master_control.GetEmptyField()
+            number_of_entities = []
+            shapes = []
+            for control in master_control.GetListOfControls():
+                number_of_entities.append(len(control.GetControlField().GetContainer()))
+                shapes.append(control.GetControlField().GetItemShape())
+            KratosOA.CollectiveExpressionIO.Read(new_control_field_exp,new_control_field,shapes)
+            # now update the master control
+            master_control.Update(new_control_field_exp)
+            master_control_updated = True
         return master_control_updated
```

## KratosMultiphysics/OptimizationApplication/algorithms/standardized_constraint.py

 * *Ordering differences only*

```diff
@@ -1,167 +1,167 @@
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.responses.response_routine import ResponseRoutine
-from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
-
-class StandardizedConstraint(ResponseRoutine):
-    """Standardized constraint response function
-
-    This class creates instances to standardize any response function for the specified type of the contraint.
-    Supported contraint types:
-        "=",
-        "<",
-        "<=,
-        ">",
-        ">="
-
-    The reference value for the constraint either can be the "initial_value" or a specified value.
-
-    """
-    def __init__(self, parameters: Kratos.Parameters, master_control: MasterControl, optimization_problem: OptimizationProblem, required_buffer_size: int = 2):
-        default_parameters = Kratos.Parameters("""{
-            "response_name"       : "",
-            "type"                : "",
-            "scaling"             : 1.0,
-            "violation_scaling"   : 1.0,
-            "scaled_ref_value"    : "initial_value"
-        }""")
-
-        if parameters.Has("scaled_ref_value") and parameters["scaled_ref_value"].IsDouble():
-            default_parameters["scaled_ref_value"].SetDouble(0.0)
-
-        parameters.ValidateAndAssignDefaults(default_parameters)
-
-        response = optimization_problem.GetResponse(parameters["response_name"].GetString())
-
-        super().__init__(master_control, response)
-
-        if required_buffer_size < 2:
-            raise RuntimeError(f"Standardized objective requires 2 as minimum buffer size. [ response name = {self.GetResponseName()} ]")
-
-        component_data_view = ComponentDataView(response, optimization_problem)
-        component_data_view.SetDataBuffer(required_buffer_size)
-
-        self.__optimization_problem = optimization_problem
-        self.__buffered_data = component_data_view.GetBufferedData()
-        self.__unbuffered_data = component_data_view.GetUnBufferedData()
-
-        scaling = parameters["scaling"].GetDouble()
-        if scaling < 0.0:
-            raise RuntimeError(f"Scaling should be always positive [ given scale = {scaling}]")
-
-        if parameters["scaled_ref_value"].IsDouble():
-            self.__ref_type = "specified_value"
-            self.__reference_value = parameters["scaled_ref_value"].GetDouble()
-        elif parameters["scaled_ref_value"].IsString() and parameters["scaled_ref_value"].GetString() == "initial_value":
-            self.__ref_type = "initial_value"
-            self.__reference_value = None
-        else:
-            raise RuntimeError(f"Provided \"reference_type\" = {self.__ref_type} is not supported for constraint response functions. Followings are supported options: \n\tinitial_value\n\tfloat value")
-
-        self.__violation_scaling = parameters["violation_scaling"].GetDouble()
-        self.__constraint_type = parameters["type"].GetString()
-        if self.__constraint_type in ["<=", "="]:
-            self.__scaling = scaling
-        elif self.__constraint_type in [">="]:
-            self.__scaling = -scaling
-            if not self.__reference_value is None: self.__reference_value *= -1
-        else:
-            raise RuntimeError(f"Provided \"type\" = {self.__constraint_type} is not supported in constraint response functions. Followings are supported options: \n\t=\n\t<=\n\t<\n\t>=\n\t>")
-
-    def IsEqualityType(self) -> str:
-        return self.__constraint_type == "="
-
-    def GetStandardizedReferenceValue(self) -> float:
-        if self.__reference_value is not None:
-            return self.__reference_value
-        else:
-            if self.__unbuffered_data.HasValue("initial_value"):
-                return self.__unbuffered_data["initial_value"] * self.__scaling
-            else:
-                raise RuntimeError(f"Response value for {self.GetResponseName()} is not calculated yet.")
-
-    def CalculateStandardizedValue(self, control_field: KratosOA.CollectiveExpression, save_value: bool = True) -> float:
-        with TimeLogger(f"StandardizedConstraint::Calculate {self.GetResponseName()} value", None, "Finished"):
-            response_value = self.CalculateValue(control_field)
-            standardized_response_value = response_value * self.__scaling
-
-            if not self.__unbuffered_data.HasValue("initial_value"):
-                self.__unbuffered_data["initial_value"] = response_value
-
-            standardized_response_value -= self.GetStandardizedReferenceValue()
-
-            if save_value:
-                if self.__buffered_data.HasValue("value"): del self.__buffered_data["value"]
-                self.__buffered_data["value"] = response_value
-
-            DictLogger("Constraint info",self.GetInfo())
-
-        return standardized_response_value
-
-    def CalculateStandardizedGradient(self, save_field: bool = True) -> KratosOA.CollectiveExpression:
-
-        with TimeLogger(f"StandardizedConstraint::Calculate {self.GetResponseName()} gradients", None, "Finished"):
-            gradient_collective_expression = self.CalculateGradient()
-            if save_field:
-                # save the physical gradients for post processing in unbuffered data container.
-                for physical_var, physical_gradient in self.GetRequiredPhysicalGradients().items():
-                    variable_name = f"d{self.GetResponseName()}_d{physical_var.Name()}"
-                    for physical_gradient_expression in physical_gradient.GetContainerExpressions():
-                        if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
-                        # cloning is a cheap operation, it only moves underlying pointers
-                        # does not create additional memory.
-                        self.__unbuffered_data[variable_name] = physical_gradient_expression.Clone()
-
-                # save the filtered gradients for post processing in unbuffered data container.
-                for gradient_container_expression, control in zip(gradient_collective_expression.GetContainerExpressions(), self.GetMasterControl().GetListOfControls()):
-                    variable_name = f"d{self.GetResponseName()}_d{control.GetName()}"
-                    if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
-                    # cloning is a cheap operation, it only moves underlying pointers
-                    # does not create additional memory.
-                    self.__unbuffered_data[variable_name] = gradient_container_expression.Clone()
-
-        return gradient_collective_expression * self.__scaling
-
-    def GetValue(self, step_index: int = 0) -> float:
-        return self.__buffered_data.GetValue("value", step_index)
-
-    def GetStandardizedValue(self, step_index: int = 0) -> float:
-        return self.GetValue(step_index) * self.__scaling - self.GetStandardizedReferenceValue()
-
-    def GetScaledViolationValue(self, step_index: int = 0) -> float:
-        value = self.GetStandardizedValue(step_index)
-        return max(0.0, value * self.__violation_scaling)
-
-    def GetAbsoluteViolation(self, step_index: int = 0) -> float:
-        is_violated = self.IsEqualityType() or self.GetStandardizedValue(step_index) >= 0.0
-        return self.GetStandardizedValue(step_index) * is_violated
-
-    def GetRelativeViolation(self, step_index: int = 0) -> float:
-        return self.GetAbsoluteViolation(step_index) / self.GetStandardizedReferenceValue() if abs(self.GetStandardizedReferenceValue()) > 1e-12 else self.GetAbsoluteViolation(step_index)
-
-    def GetRelativeChange(self) -> float:
-        if self.__optimization_problem.GetStep() > 1:
-            return self.GetStandardizedValue() / self.GetStandardizedValue(1) - 1.0 if abs(self.GetStandardizedValue(1)) > 1e-12 else self.GetStandardizedValue()
-        else:
-            return 0.0
-
-    def GetAbsoluteChange(self) -> float:
-        return self.GetStandardizedValue() / self.GetStandardizedReferenceValue() - 1.0 if abs(self.GetStandardizedReferenceValue()) > 1e-12 else self.GetStandardizedValue()
-
-    def GetInfo(self) -> dict:
-        info = {
-            "name": self.GetResponseName(),
-            "value": self.GetValue(),
-            "scaled_value": self.GetValue() * abs(self.__scaling),
-            "type": self.__constraint_type,
-            "ref_value": self.GetStandardizedReferenceValue(),
-            "abs_change": self.GetAbsoluteChange(),
-            "rel_change [%]": self.GetRelativeChange() * 100.0,
-            "abs_violation [%]": self.GetAbsoluteViolation() * 100,
-            "rel_violation [%]": self.GetRelativeViolation() * 100.0
-        }
-        return info
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.responses.response_routine import ResponseRoutine
+from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
+
+class StandardizedConstraint(ResponseRoutine):
+    """Standardized constraint response function
+
+    This class creates instances to standardize any response function for the specified type of the contraint.
+    Supported contraint types:
+        "=",
+        "<",
+        "<=,
+        ">",
+        ">="
+
+    The reference value for the constraint either can be the "initial_value" or a specified value.
+
+    """
+    def __init__(self, parameters: Kratos.Parameters, master_control: MasterControl, optimization_problem: OptimizationProblem, required_buffer_size: int = 2):
+        default_parameters = Kratos.Parameters("""{
+            "response_name"       : "",
+            "type"                : "",
+            "scaling"             : 1.0,
+            "violation_scaling"   : 1.0,
+            "scaled_ref_value"    : "initial_value"
+        }""")
+
+        if parameters.Has("scaled_ref_value") and parameters["scaled_ref_value"].IsDouble():
+            default_parameters["scaled_ref_value"].SetDouble(0.0)
+
+        parameters.ValidateAndAssignDefaults(default_parameters)
+
+        response = optimization_problem.GetResponse(parameters["response_name"].GetString())
+
+        super().__init__(master_control, response)
+
+        if required_buffer_size < 2:
+            raise RuntimeError(f"Standardized objective requires 2 as minimum buffer size. [ response name = {self.GetResponseName()} ]")
+
+        component_data_view = ComponentDataView(response, optimization_problem)
+        component_data_view.SetDataBuffer(required_buffer_size)
+
+        self.__optimization_problem = optimization_problem
+        self.__buffered_data = component_data_view.GetBufferedData()
+        self.__unbuffered_data = component_data_view.GetUnBufferedData()
+
+        scaling = parameters["scaling"].GetDouble()
+        if scaling < 0.0:
+            raise RuntimeError(f"Scaling should be always positive [ given scale = {scaling}]")
+
+        if parameters["scaled_ref_value"].IsDouble():
+            self.__ref_type = "specified_value"
+            self.__reference_value = parameters["scaled_ref_value"].GetDouble()
+        elif parameters["scaled_ref_value"].IsString() and parameters["scaled_ref_value"].GetString() == "initial_value":
+            self.__ref_type = "initial_value"
+            self.__reference_value = None
+        else:
+            raise RuntimeError(f"Provided \"reference_type\" = {self.__ref_type} is not supported for constraint response functions. Followings are supported options: \n\tinitial_value\n\tfloat value")
+
+        self.__violation_scaling = parameters["violation_scaling"].GetDouble()
+        self.__constraint_type = parameters["type"].GetString()
+        if self.__constraint_type in ["<=", "="]:
+            self.__scaling = scaling
+        elif self.__constraint_type in [">="]:
+            self.__scaling = -scaling
+            if not self.__reference_value is None: self.__reference_value *= -1
+        else:
+            raise RuntimeError(f"Provided \"type\" = {self.__constraint_type} is not supported in constraint response functions. Followings are supported options: \n\t=\n\t<=\n\t<\n\t>=\n\t>")
+
+    def IsEqualityType(self) -> str:
+        return self.__constraint_type == "="
+
+    def GetStandardizedReferenceValue(self) -> float:
+        if self.__reference_value is not None:
+            return self.__reference_value
+        else:
+            if self.__unbuffered_data.HasValue("initial_value"):
+                return self.__unbuffered_data["initial_value"] * self.__scaling
+            else:
+                raise RuntimeError(f"Response value for {self.GetResponseName()} is not calculated yet.")
+
+    def CalculateStandardizedValue(self, control_field: KratosOA.CollectiveExpression, save_value: bool = True) -> float:
+        with TimeLogger(f"StandardizedConstraint::Calculate {self.GetResponseName()} value", None, "Finished"):
+            response_value = self.CalculateValue(control_field)
+            standardized_response_value = response_value * self.__scaling
+
+            if not self.__unbuffered_data.HasValue("initial_value"):
+                self.__unbuffered_data["initial_value"] = response_value
+
+            standardized_response_value -= self.GetStandardizedReferenceValue()
+
+            if save_value:
+                if self.__buffered_data.HasValue("value"): del self.__buffered_data["value"]
+                self.__buffered_data["value"] = response_value
+
+            DictLogger("Constraint info",self.GetInfo())
+
+        return standardized_response_value
+
+    def CalculateStandardizedGradient(self, save_field: bool = True) -> KratosOA.CollectiveExpression:
+
+        with TimeLogger(f"StandardizedConstraint::Calculate {self.GetResponseName()} gradients", None, "Finished"):
+            gradient_collective_expression = self.CalculateGradient()
+            if save_field:
+                # save the physical gradients for post processing in unbuffered data container.
+                for physical_var, physical_gradient in self.GetRequiredPhysicalGradients().items():
+                    variable_name = f"d{self.GetResponseName()}_d{physical_var.Name()}"
+                    for physical_gradient_expression in physical_gradient.GetContainerExpressions():
+                        if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
+                        # cloning is a cheap operation, it only moves underlying pointers
+                        # does not create additional memory.
+                        self.__unbuffered_data[variable_name] = physical_gradient_expression.Clone()
+
+                # save the filtered gradients for post processing in unbuffered data container.
+                for gradient_container_expression, control in zip(gradient_collective_expression.GetContainerExpressions(), self.GetMasterControl().GetListOfControls()):
+                    variable_name = f"d{self.GetResponseName()}_d{control.GetName()}"
+                    if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
+                    # cloning is a cheap operation, it only moves underlying pointers
+                    # does not create additional memory.
+                    self.__unbuffered_data[variable_name] = gradient_container_expression.Clone()
+
+        return gradient_collective_expression * self.__scaling
+
+    def GetValue(self, step_index: int = 0) -> float:
+        return self.__buffered_data.GetValue("value", step_index)
+
+    def GetStandardizedValue(self, step_index: int = 0) -> float:
+        return self.GetValue(step_index) * self.__scaling - self.GetStandardizedReferenceValue()
+
+    def GetScaledViolationValue(self, step_index: int = 0) -> float:
+        value = self.GetStandardizedValue(step_index)
+        return max(0.0, value * self.__violation_scaling)
+
+    def GetAbsoluteViolation(self, step_index: int = 0) -> float:
+        is_violated = self.IsEqualityType() or self.GetStandardizedValue(step_index) >= 0.0
+        return self.GetStandardizedValue(step_index) * is_violated
+
+    def GetRelativeViolation(self, step_index: int = 0) -> float:
+        return self.GetAbsoluteViolation(step_index) / self.GetStandardizedReferenceValue() if abs(self.GetStandardizedReferenceValue()) > 1e-12 else self.GetAbsoluteViolation(step_index)
+
+    def GetRelativeChange(self) -> float:
+        if self.__optimization_problem.GetStep() > 1:
+            return self.GetStandardizedValue() / self.GetStandardizedValue(1) - 1.0 if abs(self.GetStandardizedValue(1)) > 1e-12 else self.GetStandardizedValue()
+        else:
+            return 0.0
+
+    def GetAbsoluteChange(self) -> float:
+        return self.GetStandardizedValue() / self.GetStandardizedReferenceValue() - 1.0 if abs(self.GetStandardizedReferenceValue()) > 1e-12 else self.GetStandardizedValue()
+
+    def GetInfo(self) -> dict:
+        info = {
+            "name": self.GetResponseName(),
+            "value": self.GetValue(),
+            "scaled_value": self.GetValue() * abs(self.__scaling),
+            "type": self.__constraint_type,
+            "ref_value": self.GetStandardizedReferenceValue(),
+            "abs_change": self.GetAbsoluteChange(),
+            "rel_change [%]": self.GetRelativeChange() * 100.0,
+            "abs_violation [%]": self.GetAbsoluteViolation() * 100,
+            "rel_violation [%]": self.GetRelativeViolation() * 100.0
+        }
+        return info
```

## KratosMultiphysics/OptimizationApplication/algorithms/standardized_objective.py

```diff
@@ -1,126 +1,127 @@
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.responses.response_routine import ResponseRoutine
-from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
-
-class StandardizedObjective(ResponseRoutine):
-    """Standardized objective response function
-
-    This class transformed a user-given optimization problem into the standard format.
-    Supported objective types:
-        "minimization",
-        "maximization"
-
-    """
-    def __init__(self, parameters: Kratos.Parameters, master_control: MasterControl, optimization_problem: OptimizationProblem, required_buffer_size: int = 2):
-        default_parameters = Kratos.Parameters("""{
-            "response_name": "",
-            "type"         : "",
-            "scaling"      : 1.0
-        }""")
-        parameters.ValidateAndAssignDefaults(default_parameters)
-
-        response = optimization_problem.GetResponse(parameters["response_name"].GetString())
-
-        super().__init__(master_control, response)
-
-        if required_buffer_size < 2:
-            raise RuntimeError(f"Standardized objective requires 2 as minimum buffer size. [ response name = {self.GetResponseName()} ]")
-
-        component_data_view = ComponentDataView(response, optimization_problem)
-        component_data_view.SetDataBuffer(required_buffer_size)
-
-        self.__optimization_problem = optimization_problem
-        self.__buffered_data = component_data_view.GetBufferedData()
-        self.__unbuffered_data = component_data_view.GetUnBufferedData()
-
-        scaling = parameters["scaling"].GetDouble()
-        if scaling < 0.0:
-            raise RuntimeError(f"Scaling should be always positive [ given scale = {scaling}]")
-
-        self.__objective_type = parameters["type"].GetString()
-        if self.__objective_type == "minimization":
-            self.__scaling = scaling
-        elif self.__objective_type == "maximization":
-            self.__scaling = -scaling
-        else:
-            raise RuntimeError(f"Requesting unsupported type {self.__objective_type} for objective response function. Supported types are: \n\tminimization\n\tmaximization")
-
-    def GetInitialValue(self) -> float:
-        if self.__unbuffered_data.HasValue("initial_value"):
-            return self.__unbuffered_data["initial_value"] * self.__scaling
-        else:
-            raise RuntimeError(f"Response value for {self.GetResponseName()} is not calculated yet.")
-
-    def CalculateStandardizedValue(self, control_field: KratosOA.CollectiveExpression, save_value: bool = True) -> float:
-        with TimeLogger(f"StandardizedObjective::Calculate {self.GetResponseName()} value", None, "Finished"):
-            response_value = self.CalculateValue(control_field)
-            standardized_response_value = response_value * self.__scaling
-
-            if not self.__unbuffered_data.HasValue("initial_value"):
-                self.__unbuffered_data["initial_value"] = response_value
-
-            if save_value:
-                if self.__buffered_data.HasValue("value"): del self.__buffered_data["value"]
-                self.__buffered_data["value"] = response_value
-
-            DictLogger("Objective info",self.GetInfo())
-
-        return standardized_response_value
-
-    def GetValue(self, step_index: int = 0) -> float:
-        return self.__buffered_data.GetValue("value", step_index)
-
-    def GetStandardizedValue(self, step_index: int = 0) -> float:
-        return self.GetValue(step_index) * self.__scaling
-
-    def CalculateStandardizedGradient(self, save_field: bool = True) -> KratosOA.CollectiveExpression:
-
-        with TimeLogger(f"StandardizedObjective::Calculate {self.GetResponseName()} gradients", None, "Finished"):
-            gradient_collective_expression = self.CalculateGradient()
-            if save_field:
-                # save the physical gradients for post processing in unbuffered data container.
-                for physical_var, physical_gradient in self.GetRequiredPhysicalGradients().items():
-                    variable_name = f"d{self.GetResponseName()}_d{physical_var.Name()}"
-                    for physical_gradient_expression in physical_gradient.GetContainerExpressions():
-                        if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
-                        # cloning is a cheap operation, it only moves underlying pointers
-                        # does not create additional memory.
-                        self.__unbuffered_data[variable_name] = physical_gradient_expression.Clone()
-
-                # save the filtered gradients for post processing in unbuffered data container.
-                for gradient_container_expression, control in zip(gradient_collective_expression.GetContainerExpressions(), self.GetMasterControl().GetListOfControls()):
-                    variable_name = f"d{self.GetResponseName()}_d{control.GetName()}"
-                    if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
-                    # cloning is a cheap operation, it only moves underlying pointers
-                    # does not create additional memory.
-                    self.__unbuffered_data[variable_name] = gradient_container_expression.Clone()
-
-        return gradient_collective_expression * self.__scaling
-
-    def GetRelativeChange(self) -> float:
-        if self.__optimization_problem.GetStep() > 0:
-            return self.GetStandardizedValue() / self.GetStandardizedValue(1) - 1.0 if abs(self.GetStandardizedValue(1)) > 1e-12 else self.GetStandardizedValue()
-        else:
-            return 0.0
-
-    def GetAbsoluteChange(self) -> float:
-        return self.GetValue() - self.GetInitialValue()
-
-    def GetInfo(self) -> dict:
-        info = {
-            "name": self.GetResponseName(),
-            "type": self.__objective_type,
-            "value": self.GetValue(),
-            "abs_change": self.GetAbsoluteChange(),
-            "rel_change [%]": self.GetRelativeChange() * 100.0
-        }
-        init_value = self.GetInitialValue()
-        if init_value:
-            info["abs_change [%]"] = self.GetAbsoluteChange()/init_value * 100
-
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.responses.response_routine import ResponseRoutine
+from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
+
+class StandardizedObjective(ResponseRoutine):
+    """Standardized objective response function
+
+    This class transformed a user-given optimization problem into the standard format.
+    Supported objective types:
+        "minimization",
+        "maximization"
+
+    """
+    def __init__(self, parameters: Kratos.Parameters, master_control: MasterControl, optimization_problem: OptimizationProblem, required_buffer_size: int = 2):
+        default_parameters = Kratos.Parameters("""{
+            "response_name": "",
+            "type"         : "",
+            "scaling"      : 1.0
+        }""")
+        parameters.ValidateAndAssignDefaults(default_parameters)
+
+        response = optimization_problem.GetResponse(parameters["response_name"].GetString())
+
+        super().__init__(master_control, response)
+
+        if required_buffer_size < 2:
+            raise RuntimeError(f"Standardized objective requires 2 as minimum buffer size. [ response name = {self.GetResponseName()} ]")
+
+        component_data_view = ComponentDataView(response, optimization_problem)
+        component_data_view.SetDataBuffer(required_buffer_size)
+
+        self.__optimization_problem = optimization_problem
+        self.__buffered_data = component_data_view.GetBufferedData()
+        self.__unbuffered_data = component_data_view.GetUnBufferedData()
+
+        scaling = parameters["scaling"].GetDouble()
+        if scaling < 0.0:
+            raise RuntimeError(f"Scaling should be always positive [ given scale = {scaling}]")
+
+        self.__objective_type = parameters["type"].GetString()
+        if self.__objective_type == "minimization":
+            self.__scaling = scaling
+        elif self.__objective_type == "maximization":
+            self.__scaling = -scaling
+        else:
+            raise RuntimeError(f"Requesting unsupported type {self.__objective_type} for objective response function. Supported types are: \n\tminimization\n\tmaximization")
+
+    def GetInitialValue(self) -> float:
+        if self.__unbuffered_data.HasValue("initial_value"):
+            return self.__unbuffered_data["initial_value"] * self.__scaling
+        else:
+            raise RuntimeError(f"Response value for {self.GetResponseName()} is not calculated yet.")
+
+    def CalculateStandardizedValue(self, control_field: KratosOA.CollectiveExpression, save_value: bool = True) -> float:
+        with TimeLogger(f"StandardizedObjective::Calculate {self.GetResponseName()} value", None, "Finished"):
+            response_value = self.CalculateValue(control_field)
+            standardized_response_value = response_value * self.__scaling
+
+            if not self.__unbuffered_data.HasValue("initial_value"):
+                self.__unbuffered_data["initial_value"] = response_value
+
+            if save_value:
+                if self.__buffered_data.HasValue("value"): del self.__buffered_data["value"]
+                self.__buffered_data["value"] = response_value
+
+            DictLogger("Objective info",self.GetInfo())
+
+        return standardized_response_value
+
+    def GetValue(self, step_index: int = 0) -> float:
+        return self.__buffered_data.GetValue("value", step_index)
+
+    def GetStandardizedValue(self, step_index: int = 0) -> float:
+        return self.GetValue(step_index) * self.__scaling
+
+    def CalculateStandardizedGradient(self, save_field: bool = True) -> KratosOA.CollectiveExpression:
+
+        with TimeLogger(f"StandardizedObjective::Calculate {self.GetResponseName()} gradients", None, "Finished"):
+            gradient_collective_expression = self.CalculateGradient()
+            if save_field:
+                # save the physical gradients for post processing in unbuffered data container.
+                for physical_var, physical_gradient in self.GetRequiredPhysicalGradients().items():
+                    variable_name = f"d{self.GetResponseName()}_d{physical_var.Name()}"
+                    for physical_gradient_expression in physical_gradient.GetContainerExpressions():
+                        if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
+                        # cloning is a cheap operation, it only moves underlying pointers
+                        # does not create additional memory.
+                        self.__unbuffered_data[variable_name] = physical_gradient_expression.Clone()
+
+                # save the filtered gradients for post processing in unbuffered data container.
+                for gradient_container_expression, control in zip(gradient_collective_expression.GetContainerExpressions(), self.GetMasterControl().GetListOfControls()):
+                    variable_name = f"d{self.GetResponseName()}_d{control.GetName()}"
+                    if self.__unbuffered_data.HasValue(variable_name): del self.__unbuffered_data[variable_name]
+                    # cloning is a cheap operation, it only moves underlying pointers
+                    # does not create additional memory.
+                    self.__unbuffered_data[variable_name] = gradient_container_expression.Clone()
+
+        return gradient_collective_expression * self.__scaling
+
+    def GetRelativeChange(self) -> float:
+        if self.__optimization_problem.GetStep() > 0:
+            return self.GetStandardizedValue() / self.GetStandardizedValue(1) - 1.0 if abs(self.GetStandardizedValue(1)) > 1e-12 else self.GetStandardizedValue()
+        else:
+            return 0.0
+
+    def GetAbsoluteChange(self) -> float:
+        return self.GetValue() - self.GetInitialValue()
+
+    def GetInfo(self) -> dict:
+        info = {
+            "name": self.GetResponseName(),
+            "type": self.__objective_type,
+            "value": self.GetValue(),
+            "std_value": self.GetStandardizedValue(),
+            "abs_change": self.GetAbsoluteChange(),
+            "rel_change [%]": self.GetRelativeChange() * 100.0
+        }
+        init_value = self.GetInitialValue()
+        if init_value:
+            info["abs_change [%]"] = self.GetAbsoluteChange()/init_value * 100
+
         return info
```

## KratosMultiphysics/OptimizationApplication/controls/control.py

 * *Ordering differences only*

```diff
@@ -1,134 +1,134 @@
-from abc import ABC, abstractmethod
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
-
-class Control(ABC):
-    """Base abstract control class.
-
-    The base abstract control class has the following responsibilities.
-        1. Initalizes and finalizes the control.
-        2. Maps physical space gradients to control space gradients, if needed. Otherwise, it passes.
-        2. Updating the controlled parts of the model part with new given design.
-        3. Retrieve control field.
-        4. Retrieve physical space kratos variables (If more than one physical space kratos variables are controlled by the given control field.)
-
-    This control should only work on one model part and one kratos control variable. Hence, if multiple model parts required then,
-    a single model part should be created using Kratos.ModelPartOperationUtilities.
-
-    """
-    def __init__(self, control_name: str) -> None:
-        self.__name = control_name
-
-    def GetName(self) -> str:
-        return self.__name
-
-    @abstractmethod
-    def Initialize(self) -> None:
-        """Initializes the control.
-
-        This method initializes the control. This is only called once in the whole optimization process.
-
-        """
-        pass
-
-    @abstractmethod
-    def Check(self) -> None:
-        """Checks the control.
-
-        This method checks the control. This is only called once in the whole optimization process.
-
-        """
-        pass
-
-    @abstractmethod
-    def Finalize(self) -> None:
-        """Finalizes the control.
-
-        This method finalizes the control. This is only called once in the whole optimization process.
-
-        """
-        pass
-
-    @abstractmethod
-    def GetPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
-        """Returns list of physical control variables controlled by this control.
-
-        This method returns list of physical variable which are controlled by the control. In most of the cases, there is only one
-        control variable per control. But in some rare cases, there may be the requirement to control two physical variables. Anyhow,
-        the control space should only have one variable per control in the control space, but they can have multiple physical variables
-        in their design space.
-
-        Returns:
-            list[SupportedSensitivityFieldVariableTypes]: List of physical control variables.
-        """
-        pass
-
-    @abstractmethod
-    def GetEmptyField(self) -> ContainerExpressionTypes:
-        """Returns a new empty data field holder with correct dimensionality information.
-
-        This returns a new empty data field holder to give information about on which model part's container
-        this model part is acting on. This has O(1) complexity, hence has the least cost because it does not read
-        any data from respective model part's container.
-
-        Dimensionality information is provided by calling a ContainerExpression::SetData(value). This creates a single
-        memory allocation for whole container with the dimensions of the variable. This operation is cheap in memory and
-        consumes least time.
-
-        Eg:
-            1. If the control field is a scalar, then container_expression.SetData(0.0)
-            2. If the control field is a array3, then container_expression.SetData(Kratos.Array3(0.0))
-
-        Returns:
-            ContainerExpressionTypes: Returns a new empty ContainerExpression corresponding to control's model part's respective container.
-        """
-        pass
-
-    @abstractmethod
-    def GetControlField(self) -> ContainerExpressionTypes:
-        """Returns the current control field of the control.
-
-        This method returns the control field of the current design.
-
-        Returns:
-            ContainerExpressionTypes: Current designs control field.
-        """
-        pass
-
-    @abstractmethod
-    def MapGradient(self, physical_gradient_variable_container_expression_map: 'dict[SupportedSensitivityFieldVariableTypes, ContainerExpressionTypes]') -> ContainerExpressionTypes:
-        """Maps physical space gradients to the control space.
-
-        This method is used to map the given physical space gradients to the control space. The input should be as in the following example:
-            physical_gradient_variable_container_expression_map = {
-                Kratos.YOUNG_MODULUS: Kratos.ContainerExpressions.NodalNonHistoricalContainer,
-                Kratos.DENSITY      : Kratos.ContainerExpressions.ElementNonHistoricalContainer,
-                Kratos.SHAPE        : Kratos.ContainerExpressions.ElementNonHistoricalContainer
-            }
-
-        All the gradients w.r.t. @see GetPhysicalKratosVariables() variables will be given in @ref physical_gradient_variable_container_expression_map.
-        If the response does not depend on some of them or all, then container expressions with ContainerExpression::SetDataToZero() performed will be passed.
-        [ContainerExpression::SetDataToZero() will make the container expression to zero, but will only allocate one double value for the
-        whole container, hence it is cheap in memory and execution.]
-
-        Args:
-            physical_gradient_variable_container_expression_map (dict[SupportedSensitivityFieldVariableTypes, ContainerExpressionTypes]): Map of physical space variable and ContainerExpression with sensitivities.
-
-        Returns:
-            ContainerExpressionTypes: Gradients mapped in to control space.
-        """
-        pass
-
-    @abstractmethod
-    def Update(self, control_field: ContainerExpressionTypes) -> bool:
-        """Modifies the current control with the given control field.
-
-        Args:
-            control_field (ContainerExpressionTypes): The control field in control space.
-
-        Returns:
-            bool: True if the control field was applied to obtain a new design, otherwise False
-        """
-        pass
-
-
+from abc import ABC, abstractmethod
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
+
+class Control(ABC):
+    """Base abstract control class.
+
+    The base abstract control class has the following responsibilities.
+        1. Initalizes and finalizes the control.
+        2. Maps physical space gradients to control space gradients, if needed. Otherwise, it passes.
+        2. Updating the controlled parts of the model part with new given design.
+        3. Retrieve control field.
+        4. Retrieve physical space kratos variables (If more than one physical space kratos variables are controlled by the given control field.)
+
+    This control should only work on one model part and one kratos control variable. Hence, if multiple model parts required then,
+    a single model part should be created using Kratos.ModelPartOperationUtilities.
+
+    """
+    def __init__(self, control_name: str) -> None:
+        self.__name = control_name
+
+    def GetName(self) -> str:
+        return self.__name
+
+    @abstractmethod
+    def Initialize(self) -> None:
+        """Initializes the control.
+
+        This method initializes the control. This is only called once in the whole optimization process.
+
+        """
+        pass
+
+    @abstractmethod
+    def Check(self) -> None:
+        """Checks the control.
+
+        This method checks the control. This is only called once in the whole optimization process.
+
+        """
+        pass
+
+    @abstractmethod
+    def Finalize(self) -> None:
+        """Finalizes the control.
+
+        This method finalizes the control. This is only called once in the whole optimization process.
+
+        """
+        pass
+
+    @abstractmethod
+    def GetPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
+        """Returns list of physical control variables controlled by this control.
+
+        This method returns list of physical variable which are controlled by the control. In most of the cases, there is only one
+        control variable per control. But in some rare cases, there may be the requirement to control two physical variables. Anyhow,
+        the control space should only have one variable per control in the control space, but they can have multiple physical variables
+        in their design space.
+
+        Returns:
+            list[SupportedSensitivityFieldVariableTypes]: List of physical control variables.
+        """
+        pass
+
+    @abstractmethod
+    def GetEmptyField(self) -> ContainerExpressionTypes:
+        """Returns a new empty data field holder with correct dimensionality information.
+
+        This returns a new empty data field holder to give information about on which model part's container
+        this model part is acting on. This has O(1) complexity, hence has the least cost because it does not read
+        any data from respective model part's container.
+
+        Dimensionality information is provided by calling a ContainerExpression::SetData(value). This creates a single
+        memory allocation for whole container with the dimensions of the variable. This operation is cheap in memory and
+        consumes least time.
+
+        Eg:
+            1. If the control field is a scalar, then container_expression.SetData(0.0)
+            2. If the control field is a array3, then container_expression.SetData(Kratos.Array3(0.0))
+
+        Returns:
+            ContainerExpressionTypes: Returns a new empty ContainerExpression corresponding to control's model part's respective container.
+        """
+        pass
+
+    @abstractmethod
+    def GetControlField(self) -> ContainerExpressionTypes:
+        """Returns the current control field of the control.
+
+        This method returns the control field of the current design.
+
+        Returns:
+            ContainerExpressionTypes: Current designs control field.
+        """
+        pass
+
+    @abstractmethod
+    def MapGradient(self, physical_gradient_variable_container_expression_map: 'dict[SupportedSensitivityFieldVariableTypes, ContainerExpressionTypes]') -> ContainerExpressionTypes:
+        """Maps physical space gradients to the control space.
+
+        This method is used to map the given physical space gradients to the control space. The input should be as in the following example:
+            physical_gradient_variable_container_expression_map = {
+                Kratos.YOUNG_MODULUS: Kratos.ContainerExpressions.NodalNonHistoricalContainer,
+                Kratos.DENSITY      : Kratos.ContainerExpressions.ElementNonHistoricalContainer,
+                Kratos.SHAPE        : Kratos.ContainerExpressions.ElementNonHistoricalContainer
+            }
+
+        All the gradients w.r.t. @see GetPhysicalKratosVariables() variables will be given in @ref physical_gradient_variable_container_expression_map.
+        If the response does not depend on some of them or all, then container expressions with ContainerExpression::SetDataToZero() performed will be passed.
+        [ContainerExpression::SetDataToZero() will make the container expression to zero, but will only allocate one double value for the
+        whole container, hence it is cheap in memory and execution.]
+
+        Args:
+            physical_gradient_variable_container_expression_map (dict[SupportedSensitivityFieldVariableTypes, ContainerExpressionTypes]): Map of physical space variable and ContainerExpression with sensitivities.
+
+        Returns:
+            ContainerExpressionTypes: Gradients mapped in to control space.
+        """
+        pass
+
+    @abstractmethod
+    def Update(self, control_field: ContainerExpressionTypes) -> bool:
+        """Modifies the current control with the given control field.
+
+        Args:
+            control_field (ContainerExpressionTypes): The control field in control space.
+
+        Returns:
+            bool: True if the control field was applied to obtain a new design, otherwise False
+        """
+        pass
+
+
```

## KratosMultiphysics/OptimizationApplication/controls/master_control.py

```diff
@@ -1,190 +1,194 @@
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.controls.control import Control
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import IsSameContainerExpression
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import HasContainerExpression
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
-
-class MasterControl:
-    """Master control class.
-
-    This class is used to simplify working with many controls at once. Following responsibilities are assumed:
-        1. Maps physical gradients from different domains to one CollectiveExpression (using MapGradient).
-        2. Updates each respective domain from updates given by one CollectiveExpression (using Update).
-
-    There should be only one master control class per optimization problem.
-
-    """
-    def __init__(self) -> None:
-        self.__list_of_controls: 'list[Control]' = []
-
-    def AddControl(self, control: Control) -> None:
-        """Adds a given control to the master control.
-
-        Args:
-            control (Control): Control to be added
-        """
-        self.__list_of_controls.append(control)
-
-    def GetListOfControls(self) -> 'list[Control]':
-        """Returns the list of controls in the master control.
-
-        Returns:
-            list[Control]: List of controls.
-        """
-        return self.__list_of_controls
-
-    def GetPhysicalKratosVariableCollectiveExpressionsMap(self) -> 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]':
-        """Returns map of physical variables and collective expressions from each control.
-
-        This returns a map of physical control variables and a collective expressions. The collective expressions will contain
-        all the container expressions for respective control's control domains for each physical control variable. The repeated container
-        expressions for the same physical control variable is omitted to avoid double calculations.
-
-        Returns:
-            dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]: Physical control variable and collective expressions map.
-        """
-        physical_variable_collective_expressions: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]' = {}
-
-        for control in self.__list_of_controls:
-            for physical_variable in control.GetPhysicalKratosVariables():
-                # check whether the physical variable is already there.
-                if not physical_variable in physical_variable_collective_expressions.keys():
-                    physical_variable_collective_expressions[physical_variable] = KratosOA.CollectiveExpression()
-
-                current_variable_collective_expression = physical_variable_collective_expressions[physical_variable]
-
-                # check whether the container for that physical variable is already there.
-                control_container_expression = control.GetEmptyField()
-                if not HasContainerExpression(control_container_expression, current_variable_collective_expression.GetContainerExpressions()):
-                    current_variable_collective_expression.Add(control_container_expression)
-
-        return physical_variable_collective_expressions
-
-    def GetEmptyField(self) -> KratosOA.CollectiveExpression:
-        """Returns empty CollectiveExpression containing empty ContainerExpressions for each control.
-
-        Returns:
-            KratosOA.CollectiveExpression: Empty CollectiveExpression
-        """
-        empty_control_fields = KratosOA.CollectiveExpression()
-
-        for control in self.__list_of_controls:
-            empty_control_fields.Add(control.GetEmptyField())
-
-        return empty_control_fields
-
-    def GetControlField(self) -> KratosOA.CollectiveExpression:
-        """Returns CollectiveExpression containing control field ContainerExpressions for each control.
-
-        Returns:
-            KratosOA.CollectiveExpression: Control field CollectiveExpression
-        """
-        control_fields = KratosOA.CollectiveExpression()
-
-        for control in self.__list_of_controls:
-            control_fields.Add(control.GetControlField())
-
-        return control_fields
-
-    @time_decorator()
-    def MapGradient(self, physical_space_gradient_variable_and_collective_expressions_map: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]') -> KratosOA.CollectiveExpression:
-        """Maps physical space gradients to a collective expression.
-
-        This method maps sensitivities w.r.t. physical space variables to control space by using each control. It is done by converting input
-        map with CollectiveExpression to a map with ContainerExpressions. The following is a pseudo example:
-
-        input:
-
-        physical_space_gradient_variable_and_collective_expressions_map = {
-            "YOUND_MODULUS": [ControlDomain1, ControlDomain2],
-            "DENSITY"      : [ControlDomain1],
-            "VISCOSITY"    : [ControlDomain2],
-        }
-
-        control info:
-        control1: domain = ControlDomain1
-                  physical_vars = YOUND_MODULUS, DENSITY
-
-        control2: domain = ControlDomain2
-                  physical_vars = VISCOSITY, DENSITY
-
-
-        from above information, following two maps are created and passed to each control to obtain one ContainerExpression from each control.
-        control_specific_maps:
-        for control1: {YOUND_MODULUS: ControlDomain1, DENSITY: ControlDomain1}
-        for control2: {VISCOSITY: ControlDomain2, DENSITY: A zero valued ControlDomain}
-
-        then returned mapped gradients are added to one CollectiveExpression.
-
-        In here, the missing gradients for required physical variables will be assumed to be zero.
-
-        This converts given map of sensitivities w.r.t. different physical space variables to one sensitivities in control space and aggregated
-        to one CollectiveExpression.
-
-        Args:
-            physical_space_gradient_variable_and_collective_expressions_map (dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]): Map of physical space sensitivities.
-
-        Returns:
-            KratosOA.CollectiveExpression: Control space sensitivities.
-        """
-
-
-        mapped_gradients = KratosOA.CollectiveExpression()
-
-        for control in self.__list_of_controls:
-            # iterate through each control to create its own container expression map from the collective expressions map given as input
-            control_physical_sensitivities_container_expression_map = {}
-            for physical_control_variable in control.GetPhysicalKratosVariables():
-                # first assume the gradients for this physical_control_variable is zero, hence get the zero valued expression.
-                control_expression = control.GetEmptyField()
-
-                # get the required physical variables from control.
-                if physical_control_variable in physical_space_gradient_variable_and_collective_expressions_map.keys():
-                    # if the sensitivities for the given physical control variable exists, then try to find whether
-                    # for this specific control the physical control variable sensitivities exists.
-
-                    sensitivity_collective_expression = physical_space_gradient_variable_and_collective_expressions_map[physical_control_variable]
-                    for container_expression in sensitivity_collective_expression.GetContainerExpressions():
-                        if IsSameContainerExpression(control_expression, container_expression):
-                            # there exists for this control's physical variables sensitivities. then copy it to the expression
-                            # this copy moves the underlying vectors, hence cheap.
-                            control_expression.CopyFrom(container_expression)
-                            break
-
-                # now add it to the map. If it is found from input gradients, the control_expression will have those values,
-                # otherwise it will have representative zero control_expression.
-                control_physical_sensitivities_container_expression_map[physical_control_variable] = control_expression
-
-            # map the physical control variable sensitivities to one control space
-            mapped_gradients.Add(control.MapGradient(control_physical_sensitivities_container_expression_map))
-
-        return mapped_gradients
-
-    @time_decorator()
-    def Update(self, update_collective_expressions: KratosOA.CollectiveExpression) -> 'dict[Control, bool]':
-        """Update each control with given collective expression's respective container expression.
-
-        Args:
-            update_collective_expressions (KratosOA.CollectiveExpression): Update
-
-        Raises:
-            RuntimeError: If number of controls and number of container expressions mismatch.
-
-        Returns:
-            dict[Control, bool]: A map with control and a boolean whether the update changed anything in that control.
-        """
-        if len(self.__list_of_controls) != len(update_collective_expressions.GetContainerExpressions()):
-            raise RuntimeError(f"Controls size and update size mismatch [ number of controls: {len(self.__list_of_controls)}, number of container expressions: {len(update_collective_expressions.GetContainerExpressions())} ].")
-
-        update_map: 'dict[Control, bool]' = {}
-        for control, container_expression in zip(self.__list_of_controls, update_collective_expressions.GetContainerExpressions()):
-            update_map[control] = control.Update(container_expression)
-
-        return update_map
-
-    def Initialize(self):
-        pass
-
-    def Finalize(self):
-        pass
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.controls.control import Control
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import IsSameContainerExpression
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import HasContainerExpression
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
+
+class MasterControl:
+    """Master control class.
+
+    This class is used to simplify working with many controls at once. Following responsibilities are assumed:
+        1. Maps physical gradients from different domains to one CollectiveExpression (using MapGradient).
+        2. Updates each respective domain from updates given by one CollectiveExpression (using Update).
+
+    There should be only one master control class per optimization problem.
+
+    """
+    def __init__(self) -> None:
+        self.__list_of_controls: 'list[Control]' = []
+
+    def AddControl(self, control: Control) -> None:
+        """Adds a given control to the master control.
+
+        Args:
+            control (Control): Control to be added
+        """
+        self.__list_of_controls.append(control)
+
+    def GetListOfControls(self) -> 'list[Control]':
+        """Returns the list of controls in the master control.
+
+        Returns:
+            list[Control]: List of controls.
+        """
+        return self.__list_of_controls
+
+    def GetPhysicalKratosVariableCollectiveExpressionsMap(self) -> 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]':
+        """Returns map of physical variables and collective expressions from each control.
+
+        This returns a map of physical control variables and a collective expressions. The collective expressions will contain
+        all the container expressions for respective control's control domains for each physical control variable. The repeated container
+        expressions for the same physical control variable is omitted to avoid double calculations.
+
+        Returns:
+            dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]: Physical control variable and collective expressions map.
+        """
+        physical_variable_collective_expressions: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]' = {}
+
+        for control in self.__list_of_controls:
+            for physical_variable in control.GetPhysicalKratosVariables():
+                # check whether the physical variable is already there.
+                if not physical_variable in physical_variable_collective_expressions.keys():
+                    physical_variable_collective_expressions[physical_variable] = KratosOA.CollectiveExpression()
+
+                current_variable_collective_expression = physical_variable_collective_expressions[physical_variable]
+
+                # check whether the container for that physical variable is already there.
+                control_container_expression = control.GetEmptyField()
+                if not HasContainerExpression(control_container_expression, current_variable_collective_expression.GetContainerExpressions()):
+                    current_variable_collective_expression.Add(control_container_expression)
+
+        return physical_variable_collective_expressions
+
+    def GetEmptyField(self) -> KratosOA.CollectiveExpression:
+        """Returns empty CollectiveExpression containing empty ContainerExpressions for each control.
+
+        Returns:
+            KratosOA.CollectiveExpression: Empty CollectiveExpression
+        """
+        empty_control_fields = KratosOA.CollectiveExpression()
+
+        for control in self.__list_of_controls:
+            empty_control_fields.Add(control.GetEmptyField())
+
+        return empty_control_fields
+
+    def GetControlField(self) -> KratosOA.CollectiveExpression:
+        """Returns CollectiveExpression containing control field ContainerExpressions for each control.
+
+        Returns:
+            KratosOA.CollectiveExpression: Control field CollectiveExpression
+        """
+        control_fields = KratosOA.CollectiveExpression()
+
+        for control in self.__list_of_controls:
+            control_fields.Add(control.GetControlField())
+
+        return control_fields
+
+    @time_decorator()
+    def MapGradient(self, physical_space_gradient_variable_and_collective_expressions_map: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]') -> KratosOA.CollectiveExpression:
+        """Maps physical space gradients to a collective expression.
+
+        This method maps sensitivities w.r.t. physical space variables to control space by using each control. It is done by converting input
+        map with CollectiveExpression to a map with ContainerExpressions. The following is a pseudo example:
+
+        input:
+
+        physical_space_gradient_variable_and_collective_expressions_map = {
+            "YOUND_MODULUS": [ControlDomain1, ControlDomain2],
+            "DENSITY"      : [ControlDomain1],
+            "VISCOSITY"    : [ControlDomain2],
+        }
+
+        control info:
+        control1: domain = ControlDomain1
+                  physical_vars = YOUND_MODULUS, DENSITY
+
+        control2: domain = ControlDomain2
+                  physical_vars = VISCOSITY, DENSITY
+
+
+        from above information, following two maps are created and passed to each control to obtain one ContainerExpression from each control.
+        control_specific_maps:
+        for control1: {YOUND_MODULUS: ControlDomain1, DENSITY: ControlDomain1}
+        for control2: {VISCOSITY: ControlDomain2, DENSITY: A zero valued ControlDomain}
+
+        then returned mapped gradients are added to one CollectiveExpression.
+
+        In here, the missing gradients for required physical variables will be assumed to be zero.
+
+        This converts given map of sensitivities w.r.t. different physical space variables to one sensitivities in control space and aggregated
+        to one CollectiveExpression.
+
+        Args:
+            physical_space_gradient_variable_and_collective_expressions_map (dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]): Map of physical space sensitivities.
+
+        Returns:
+            KratosOA.CollectiveExpression: Control space sensitivities.
+        """
+
+
+        mapped_gradients = KratosOA.CollectiveExpression()
+
+        for control in self.__list_of_controls:
+            # iterate through each control to create its own container expression map from the collective expressions map given as input
+            control_physical_sensitivities_container_expression_map = {}
+            for physical_control_variable in control.GetPhysicalKratosVariables():
+                # first assume the gradients for this physical_control_variable is zero, hence get the zero valued expression.
+                control_expression = control.GetEmptyField()
+
+                # get the required physical variables from control.
+                if physical_control_variable in physical_space_gradient_variable_and_collective_expressions_map.keys():
+                    # if the sensitivities for the given physical control variable exists, then try to find whether
+                    # for this specific control the physical control variable sensitivities exists.
+
+                    sensitivity_collective_expression = physical_space_gradient_variable_and_collective_expressions_map[physical_control_variable]
+                    for container_expression in sensitivity_collective_expression.GetContainerExpressions():
+                        if IsSameContainerExpression(control_expression, container_expression):
+                            # there exists for this control's physical variables sensitivities. then copy it to the expression
+                            # this copy moves the underlying vectors, hence cheap.
+                            control_expression.CopyFrom(container_expression)
+                            break
+
+                # now add it to the map. If it is found from input gradients, the control_expression will have those values,
+                # otherwise it will have representative zero control_expression.
+                control_physical_sensitivities_container_expression_map[physical_control_variable] = control_expression
+
+            # map the physical control variable sensitivities to one control space
+            mapped_gradients.Add(control.MapGradient(control_physical_sensitivities_container_expression_map))
+
+        return mapped_gradients
+
+    @time_decorator()
+    def Update(self, update_collective_expressions: KratosOA.CollectiveExpression) -> 'dict[Control, bool]':
+        """Update each control with given collective expression's respective container expression.
+
+        Args:
+            update_collective_expressions (KratosOA.CollectiveExpression): Update
+
+        Raises:
+            RuntimeError: If number of controls and number of container expressions mismatch.
+
+        Returns:
+            dict[Control, bool]: A map with control and a boolean whether the update changed anything in that control.
+        """
+        if len(self.__list_of_controls) != len(update_collective_expressions.GetContainerExpressions()):
+            raise RuntimeError(f"Controls size and update size mismatch [ number of controls: {len(self.__list_of_controls)}, number of container expressions: {len(update_collective_expressions.GetContainerExpressions())} ].")
+
+        update_map: 'dict[Control, bool]' = {}
+        for control, container_expression in zip(self.__list_of_controls, update_collective_expressions.GetContainerExpressions()):
+            update_map[control] = control.Update(container_expression)
+
+        return update_map
+
+    def Check(self) -> None:
+        CallOnAll(self.__list_of_controls, Control.Check)
+
+    def Initialize(self) -> None:
+        CallOnAll(self.__list_of_controls, Control.Initialize)
+
+    def Finalize(self) -> None:
+        CallOnAll(self.__list_of_controls, Control.Finalize)
```

## KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_material.py

 * *Ordering differences only*

```diff
@@ -1,93 +1,93 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ==============================================================================
-
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-import KratosMultiphysics.OptimizationApplication as KOA
-from KratosMultiphysics.OptimizationApplication.controls.material.material_control import MaterialControl
-
-class HelmholtzMaterial(MaterialControl):
-
-    def __init__(self, name, model, settings):
-        super().__init__(name,model,settings)
-        self.technique_settings = self.settings["technique_settings"]
-        self.default_technique_settings = KM.Parameters("""{
-                    "automatic_filter_size" : true,
-                    "filter_radius" : 0.000000000001,
-                    "beta_settings": {
-                        "initial_value" : 25,
-                        "max_value" : 25,
-                        "adaptive" : false,
-                        "increase_fac" : 1.5,
-                        "update_period" : 20
-                    },
-                    "SIMP_power_fac": 3,
-                    "initial_density":0.000001,
-                    "youngs_modules": [], 
-                    "physical_densities": [],
-                    "fixed_model_parts": [],
-                    "fixed_model_parts_densities": [],    
-                    "linear_solver_settings" : {
-                        "solver_type" : "amgcl",
-                        "smoother_type":"ilu0",
-                        "krylov_type": "gmres",
-                        "coarsening_type": "aggregation",
-                        "max_iteration": 200,
-                        "provide_coordinates": false,
-                        "gmres_krylov_space_dimension": 100,
-                        "verbosity" : 0,
-                        "tolerance": 1e-7,
-                        "scaling": false,
-                        "block_size": 1,
-                        "use_block_matrices_if_possible" : true,
-                        "coarse_enough" : 5000
-                    }
-                }""")
-
-        self.technique_settings.RecursivelyValidateAndAssignDefaults(self.default_technique_settings)
-
-
-        # add vars
-        for model_part_name in self.controlling_objects:
-            root_model = model_part_name.split(".")[0]
-            self.model.GetModelPart(root_model).AddNodalSolutionStepVariable(KOA.HELMHOLTZ_VAR_DENSITY)
-            self.model.GetModelPart(root_model).AddNodalSolutionStepVariable(KOA.HELMHOLTZ_SOURCE_DENSITY)
-
-        ## Construct the linear solver
-        import KratosMultiphysics.python_linear_solver_factory as python_linear_solver_factory
-        self.linear_solvers = []
-        root_model_parts = []
-        for model_part_name in self.controlling_objects:
-            extracted_root_model_part_name = model_part_name.split(".")[0]
-            if not extracted_root_model_part_name in root_model_parts:
-                root_model_parts.append(extracted_root_model_part_name)
-                self.linear_solvers.append(python_linear_solver_factory.ConstructSolver(self.technique_settings["linear_solver_settings"]))
-
-        self.helmholtz_material_control = KOA.HelmholtzMaterial(self.name,self.model,self.linear_solvers,self.settings)
-
-    def Initialize(self):
-        super().Initialize()
-        self.helmholtz_material_control.Initialize()
-    
-    def MapFirstDerivative(self,derivative_variable_name,mapped_derivative_variable_name):
-        self.helmholtz_material_control.MapFirstDerivative(derivative_variable_name,mapped_derivative_variable_name)
-
-    def Compute(self):
-        pass
-
-    def Update(self):
-        self.helmholtz_material_control.Update() 
-
-    def GetControllingObjects(self):
-        return self.controlling_objects
-            
-            
-
-
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ==============================================================================
+
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+import KratosMultiphysics.OptimizationApplication as KOA
+from KratosMultiphysics.OptimizationApplication.controls.material.material_control import MaterialControl
+
+class HelmholtzMaterial(MaterialControl):
+
+    def __init__(self, name, model, settings):
+        super().__init__(name,model,settings)
+        self.technique_settings = self.settings["technique_settings"]
+        self.default_technique_settings = KM.Parameters("""{
+                    "automatic_filter_size" : true,
+                    "filter_radius" : 0.000000000001,
+                    "beta_settings": {
+                        "initial_value" : 25,
+                        "max_value" : 25,
+                        "adaptive" : false,
+                        "increase_fac" : 1.5,
+                        "update_period" : 20
+                    },
+                    "SIMP_power_fac": 3,
+                    "initial_density":0.000001,
+                    "youngs_modules": [], 
+                    "physical_densities": [],
+                    "fixed_model_parts": [],
+                    "fixed_model_parts_densities": [],    
+                    "linear_solver_settings" : {
+                        "solver_type" : "amgcl",
+                        "smoother_type":"ilu0",
+                        "krylov_type": "gmres",
+                        "coarsening_type": "aggregation",
+                        "max_iteration": 200,
+                        "provide_coordinates": false,
+                        "gmres_krylov_space_dimension": 100,
+                        "verbosity" : 0,
+                        "tolerance": 1e-7,
+                        "scaling": false,
+                        "block_size": 1,
+                        "use_block_matrices_if_possible" : true,
+                        "coarse_enough" : 5000
+                    }
+                }""")
+
+        self.technique_settings.RecursivelyValidateAndAssignDefaults(self.default_technique_settings)
+
+
+        # add vars
+        for model_part_name in self.controlling_objects:
+            root_model = model_part_name.split(".")[0]
+            self.model.GetModelPart(root_model).AddNodalSolutionStepVariable(KOA.HELMHOLTZ_VAR_DENSITY)
+            self.model.GetModelPart(root_model).AddNodalSolutionStepVariable(KOA.HELMHOLTZ_SOURCE_DENSITY)
+
+        ## Construct the linear solver
+        import KratosMultiphysics.python_linear_solver_factory as python_linear_solver_factory
+        self.linear_solvers = []
+        root_model_parts = []
+        for model_part_name in self.controlling_objects:
+            extracted_root_model_part_name = model_part_name.split(".")[0]
+            if not extracted_root_model_part_name in root_model_parts:
+                root_model_parts.append(extracted_root_model_part_name)
+                self.linear_solvers.append(python_linear_solver_factory.ConstructSolver(self.technique_settings["linear_solver_settings"]))
+
+        self.helmholtz_material_control = KOA.HelmholtzMaterial(self.name,self.model,self.linear_solvers,self.settings)
+
+    def Initialize(self):
+        super().Initialize()
+        self.helmholtz_material_control.Initialize()
+    
+    def MapFirstDerivative(self,derivative_variable_name,mapped_derivative_variable_name):
+        self.helmholtz_material_control.MapFirstDerivative(derivative_variable_name,mapped_derivative_variable_name)
+
+    def Compute(self):
+        pass
+
+    def Update(self):
+        self.helmholtz_material_control.Update() 
+
+    def GetControllingObjects(self):
+        return self.controlling_objects
+            
+            
+
+
```

## KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_partition.py

 * *Ordering differences only*

```diff
@@ -1,81 +1,81 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ==============================================================================
-
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-import KratosMultiphysics.OptimizationApplication as KOA
-from KratosMultiphysics.OptimizationApplication.controls.material.material_control import MaterialControl
-
-class HelmholtzPartition(MaterialControl):
-
-    def __init__(self, name, model, settings):
-        super().__init__(name,model,settings)
-        self.technique_settings = self.settings["technique_settings"]
-        self.default_technique_settings = KM.Parameters("""{
-                    "filter_radius" : 0.000000000001,
-                    "beta":25,
-                    "initial_density":0.000001,  
-                    "linear_solver_settings" : {
-                        "solver_type" : "amgcl",
-                        "smoother_type":"ilu0",
-                        "krylov_type": "gmres",
-                        "coarsening_type": "aggregation",
-                        "max_iteration": 200,
-                        "provide_coordinates": false,
-                        "gmres_krylov_space_dimension": 100,
-                        "verbosity" : 0,
-                        "tolerance": 1e-7,
-                        "scaling": false,
-                        "block_size": 1,
-                        "use_block_matrices_if_possible" : true,
-                        "coarse_enough" : 5000
-                    }
-                }""")
-
-        self.technique_settings.RecursivelyValidateAndAssignDefaults(self.default_technique_settings)
-
-
-        # add vars
-        for model_part_name in self.controlling_objects:
-            root_model = model_part_name.split(".")[0]
-            self.model.GetModelPart(root_model).AddNodalSolutionStepVariable(KOA.HELMHOLTZ_VAR_DENSITY)
-            self.model.GetModelPart(root_model).AddNodalSolutionStepVariable(KOA.HELMHOLTZ_SOURCE_DENSITY)
-
-        ## Construct the linear solver
-        import KratosMultiphysics.python_linear_solver_factory as python_linear_solver_factory
-        self.linear_solvers = []
-        root_model_parts = []
-        for model_part_name in self.controlling_objects:
-            extracted_root_model_part_name = model_part_name.split(".")[0]
-            if not extracted_root_model_part_name in root_model_parts:
-                root_model_parts.append(extracted_root_model_part_name)
-                self.linear_solvers.append(python_linear_solver_factory.ConstructSolver(self.technique_settings["linear_solver_settings"]))
-
-        self.helmholtz_material_control = KOA.HelmholtzPartition(self.name,self.model,self.linear_solvers,self.settings)
-
-    def Initialize(self):
-        super().Initialize()
-        self.helmholtz_material_control.Initialize()
-    
-    def MapFirstDerivative(self,derivative_variable_name,mapped_derivative_variable_name):
-        self.helmholtz_material_control.MapFirstDerivative(derivative_variable_name,mapped_derivative_variable_name)
-
-    def Compute(self):
-        pass
-
-    def Update(self):
-        self.helmholtz_material_control.Update() 
-
-    def GetControllingObjects(self):
-        return self.controlling_objects
-            
-            
-
-
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ==============================================================================
+
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+import KratosMultiphysics.OptimizationApplication as KOA
+from KratosMultiphysics.OptimizationApplication.controls.material.material_control import MaterialControl
+
+class HelmholtzPartition(MaterialControl):
+
+    def __init__(self, name, model, settings):
+        super().__init__(name,model,settings)
+        self.technique_settings = self.settings["technique_settings"]
+        self.default_technique_settings = KM.Parameters("""{
+                    "filter_radius" : 0.000000000001,
+                    "beta":25,
+                    "initial_density":0.000001,  
+                    "linear_solver_settings" : {
+                        "solver_type" : "amgcl",
+                        "smoother_type":"ilu0",
+                        "krylov_type": "gmres",
+                        "coarsening_type": "aggregation",
+                        "max_iteration": 200,
+                        "provide_coordinates": false,
+                        "gmres_krylov_space_dimension": 100,
+                        "verbosity" : 0,
+                        "tolerance": 1e-7,
+                        "scaling": false,
+                        "block_size": 1,
+                        "use_block_matrices_if_possible" : true,
+                        "coarse_enough" : 5000
+                    }
+                }""")
+
+        self.technique_settings.RecursivelyValidateAndAssignDefaults(self.default_technique_settings)
+
+
+        # add vars
+        for model_part_name in self.controlling_objects:
+            root_model = model_part_name.split(".")[0]
+            self.model.GetModelPart(root_model).AddNodalSolutionStepVariable(KOA.HELMHOLTZ_VAR_DENSITY)
+            self.model.GetModelPart(root_model).AddNodalSolutionStepVariable(KOA.HELMHOLTZ_SOURCE_DENSITY)
+
+        ## Construct the linear solver
+        import KratosMultiphysics.python_linear_solver_factory as python_linear_solver_factory
+        self.linear_solvers = []
+        root_model_parts = []
+        for model_part_name in self.controlling_objects:
+            extracted_root_model_part_name = model_part_name.split(".")[0]
+            if not extracted_root_model_part_name in root_model_parts:
+                root_model_parts.append(extracted_root_model_part_name)
+                self.linear_solvers.append(python_linear_solver_factory.ConstructSolver(self.technique_settings["linear_solver_settings"]))
+
+        self.helmholtz_material_control = KOA.HelmholtzPartition(self.name,self.model,self.linear_solvers,self.settings)
+
+    def Initialize(self):
+        super().Initialize()
+        self.helmholtz_material_control.Initialize()
+    
+    def MapFirstDerivative(self,derivative_variable_name,mapped_derivative_variable_name):
+        self.helmholtz_material_control.MapFirstDerivative(derivative_variable_name,mapped_derivative_variable_name)
+
+    def Compute(self):
+        pass
+
+    def Update(self):
+        self.helmholtz_material_control.Update() 
+
+    def GetControllingObjects(self):
+        return self.controlling_objects
+            
+            
+
+
```

## KratosMultiphysics/OptimizationApplication/controls/material/material_control.py

 * *Ordering differences only*

```diff
@@ -1,71 +1,71 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ==============================================================================
-
-import KratosMultiphysics as KM
-import KratosMultiphysics.OptimizationApplication as KOA
-
-class MaterialControl():
-    def __init__(self, name, model, settings):
-        
-        self.name = name
-        self.type = "material"
-        self.model = model
-        self.settings = settings
-        self.controlling_objects = self.settings["controlling_objects"].GetStringArray() 
-
-        self.control_variable_name = "CD"
-        self.control_update_name = "D_CD"
-        self.scalar_fields = ["CD","FD","PD","PE","D_CD","D_PD_D_FD","D_PE_D_FD"]
-        self.vector_fields = []
-        self.output_names = self.scalar_fields + self.vector_fields
-
-        # add vars
-        for model_part_name in self.controlling_objects:
-            root_model = model_part_name.split(".")[0]
-            for field_name in self.output_names:
-                self.model.GetModelPart(root_model).AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(field_name))
-
-
-    def Initialize(self):
-        # initialize zero the fields
-        for model_part_name in self.controlling_objects:
-            model_part = self.model.GetModelPart(model_part_name)         
-            for node in model_part.Nodes:
-                for vec_field in self.vector_fields:
-                    node.SetSolutionStepValue(KM.KratosGlobals.GetVariable(vec_field), [0.0, 0.0, 0.0])
-                for scala_field in self.scalar_fields:
-                    node.SetSolutionStepValue(KM.KratosGlobals.GetVariable(scala_field), 0)
- 
-    def MapFirstDerivative(self,derivative_variable_name,mapped_derivative_variable_name):
-        raise RuntimeError("MaterialControl:MapFirstDerivative: calling base class function") 
-
-    def Compute(self):
-        raise RuntimeError("MaterialControl:Compute: calling base class function")
-
-    def Update(self):
-        raise RuntimeError("MaterialControl:Update: calling base class function") 
-
-    def GetControllingObjects(self):
-        raise RuntimeError("MaterialControl:GetControllingObjects: calling base class function") 
-
-    def GetVariableName(self):
-        return self.control_variable_name       
-
-    def GetUpdateName(self):
-        return self.control_update_name   
-
-    def GetOutputNames(self):
-        return self.output_names 
-
-    def GetType(self):
-        return self.type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
-            
-
-
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ==============================================================================
+
+import KratosMultiphysics as KM
+import KratosMultiphysics.OptimizationApplication as KOA
+
+class MaterialControl():
+    def __init__(self, name, model, settings):
+        
+        self.name = name
+        self.type = "material"
+        self.model = model
+        self.settings = settings
+        self.controlling_objects = self.settings["controlling_objects"].GetStringArray() 
+
+        self.control_variable_name = "CD"
+        self.control_update_name = "D_CD"
+        self.scalar_fields = ["CD","FD","PD","PE","D_CD","D_PD_D_FD","D_PE_D_FD"]
+        self.vector_fields = []
+        self.output_names = self.scalar_fields + self.vector_fields
+
+        # add vars
+        for model_part_name in self.controlling_objects:
+            root_model = model_part_name.split(".")[0]
+            for field_name in self.output_names:
+                self.model.GetModelPart(root_model).AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(field_name))
+
+
+    def Initialize(self):
+        # initialize zero the fields
+        for model_part_name in self.controlling_objects:
+            model_part = self.model.GetModelPart(model_part_name)         
+            for node in model_part.Nodes:
+                for vec_field in self.vector_fields:
+                    node.SetSolutionStepValue(KM.KratosGlobals.GetVariable(vec_field), [0.0, 0.0, 0.0])
+                for scala_field in self.scalar_fields:
+                    node.SetSolutionStepValue(KM.KratosGlobals.GetVariable(scala_field), 0)
+ 
+    def MapFirstDerivative(self,derivative_variable_name,mapped_derivative_variable_name):
+        raise RuntimeError("MaterialControl:MapFirstDerivative: calling base class function") 
+
+    def Compute(self):
+        raise RuntimeError("MaterialControl:Compute: calling base class function")
+
+    def Update(self):
+        raise RuntimeError("MaterialControl:Update: calling base class function") 
+
+    def GetControllingObjects(self):
+        raise RuntimeError("MaterialControl:GetControllingObjects: calling base class function") 
+
+    def GetVariableName(self):
+        return self.control_variable_name       
+
+    def GetUpdateName(self):
+        return self.control_update_name   
+
+    def GetOutputNames(self):
+        return self.output_names 
+
+    def GetType(self):
+        return self.type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
+            
+
+
```

## KratosMultiphysics/OptimizationApplication/controls/material/material_properties_control.py

```diff
@@ -1,110 +1,110 @@
-from typing import Optional
-
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.controls.control import Control
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import IsSameContainerExpression
-from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> Control:
-    if not parameters.Has("name"):
-        raise RuntimeError(f"MaterialPropertiesControl instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"MaterialPropertiesControl instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-
-    return MaterialPropertiesControl(parameters["name"].GetString(), model, parameters["settings"])
-
-class MaterialPropertiesControl(Control):
-    """Material properties control
-
-    This is a generic material properties control which creates a control
-    for the specified control variable. This does not do any filtering.
-
-    TODO: Extend with filtering techniques when they are implemented.
-
-    """
-    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters):
-        super().__init__(name)
-
-        default_settings = Kratos.Parameters("""{
-            "model_part_names"     : [""],
-            "control_variable_name": ""
-        }""")
-        parameters.ValidateAndAssignDefaults(default_settings)
-
-        self.model = model
-
-        control_variable_name = parameters["control_variable_name"].GetString()
-        control_variable_type = Kratos.KratosGlobals.GetVariableType(control_variable_name)
-        if control_variable_type != "Double":
-            raise RuntimeError(f"{control_variable_name} with {control_variable_type} type is not supported. Only supports double variables")
-        self.controlled_physical_variable = Kratos.KratosGlobals.GetVariable(control_variable_name)
-
-        controlled_model_part_names = parameters["model_part_names"].GetStringArray()
-        if len(controlled_model_part_names) == 0:
-            raise RuntimeError(f"No model parts were provided for MaterialPropertiesControl. [ control name = \"{self.GetName()}\"]")
-
-        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"control_{self.GetName()}", controlled_model_part_names, False)
-        self.model_part: Optional[Kratos.ModelPart] = None
-
-    def Initialize(self) -> None:
-        self.model_part = self.model_part_operation.GetModelPart()
-
-        if not KratosOA.ModelPartUtils.CheckModelPartStatus(self.model_part, "element_specific_properties_created"):
-            KratosOA.OptimizationUtils.CreateEntitySpecificPropertiesForContainer(self.model_part, self.model_part.Elements)
-            KratosOA.ModelPartUtils.LogModelPartStatus(self.model_part, "element_specific_properties_created")
-
-    def Check(self) -> None:
-        pass
-
-    def Finalize(self) -> None:
-        pass
-
-    def GetPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
-        return [self.controlled_physical_variable]
-
-    def GetEmptyField(self) -> ContainerExpressionTypes:
-        field = Kratos.Expression.ElementExpression(self.model_part)
-        Kratos.Expression.LiteralExpressionIO.SetData(field, 0.0)
-        return field
-
-    def GetControlField(self) -> ContainerExpressionTypes:
-        field = self.GetEmptyField()
-        KratosOA.PropertiesVariableExpressionIO.Read(field, self.controlled_physical_variable)
-        return field
-
-    def MapGradient(self, physical_gradient_variable_container_expression_map: 'dict[SupportedSensitivityFieldVariableTypes, ContainerExpressionTypes]') -> ContainerExpressionTypes:
-        keys = physical_gradient_variable_container_expression_map.keys()
-        if len(keys) != 1:
-            raise RuntimeError(f"Provided more than required gradient fields for control \"{self.GetName()}\". Following are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
-        if self.controlled_physical_variable not in keys:
-            raise RuntimeError(f"The required gradient for control \"{self.GetName()}\" w.r.t. {self.controlled_physical_variable.Name()} not found. Followings are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
-
-        physical_gradient = physical_gradient_variable_container_expression_map[self.controlled_physical_variable]
-        if not IsSameContainerExpression(physical_gradient, self.GetEmptyField()):
-            raise RuntimeError(f"Gradients for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.model_part.FullName()}, given model part name: {physical_gradient.GetModelPart().FullName()} ]")
-
-        # TODO: Implement filtering mechanisms here
-        return physical_gradient_variable_container_expression_map[self.controlled_physical_variable].Clone()
-
-    def Update(self, control_field: ContainerExpressionTypes) -> bool:
-        if not IsSameContainerExpression(control_field, self.GetEmptyField()):
-            raise RuntimeError(f"Updates for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.model_part.FullName()}, given model part name: {control_field.GetModelPart().FullName()} ]")
-
-        # TODO: Implement inverse filtering mechanisms here
-        # since no filtering is implemented yet, we are checking the unfiltered updates with the filtered updates. This needs to be changed once the
-        # filtering mechanisms are implemented.
-
-        # get the current unfiltered control field
-        unfiltered_control_field = self.GetControlField()
-
-        if KratosOA.ExpressionUtils.NormL2(unfiltered_control_field - control_field) > 1e-9:
-            KratosOA.PropertiesVariableExpressionIO.Write(control_field, self.controlled_physical_variable)
-            return True
-
-        return False
-
-    def __str__(self) -> str:
-        return f"Control [type = {self.__class__.__name__}, name = {self.GetName()}, model part name = {self.model_part.FullName()}, control variable = {self.controlled_physical_variable.Name()}"
+from typing import Optional
+
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.controls.control import Control
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import IsSameContainerExpression
+from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> Control:
+    if not parameters.Has("name"):
+        raise RuntimeError(f"MaterialPropertiesControl instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"MaterialPropertiesControl instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+
+    return MaterialPropertiesControl(parameters["name"].GetString(), model, parameters["settings"])
+
+class MaterialPropertiesControl(Control):
+    """Material properties control
+
+    This is a generic material properties control which creates a control
+    for the specified control variable. This does not do any filtering.
+
+    TODO: Extend with filtering techniques when they are implemented.
+
+    """
+    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters):
+        super().__init__(name)
+
+        default_settings = Kratos.Parameters("""{
+            "model_part_names"     : [""],
+            "control_variable_name": ""
+        }""")
+        parameters.ValidateAndAssignDefaults(default_settings)
+
+        self.model = model
+
+        control_variable_name = parameters["control_variable_name"].GetString()
+        control_variable_type = Kratos.KratosGlobals.GetVariableType(control_variable_name)
+        if control_variable_type != "Double":
+            raise RuntimeError(f"{control_variable_name} with {control_variable_type} type is not supported. Only supports double variables")
+        self.controlled_physical_variable = Kratos.KratosGlobals.GetVariable(control_variable_name)
+
+        controlled_model_part_names = parameters["model_part_names"].GetStringArray()
+        if len(controlled_model_part_names) == 0:
+            raise RuntimeError(f"No model parts were provided for MaterialPropertiesControl. [ control name = \"{self.GetName()}\"]")
+
+        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"control_{self.GetName()}", controlled_model_part_names, False)
+        self.model_part: Optional[Kratos.ModelPart] = None
+
+    def Initialize(self) -> None:
+        self.model_part = self.model_part_operation.GetModelPart()
+
+        if not KratosOA.OptAppModelPartUtils.CheckModelPartStatus(self.model_part, "element_specific_properties_created"):
+            KratosOA.OptimizationUtils.CreateEntitySpecificPropertiesForContainer(self.model_part, self.model_part.Elements)
+            KratosOA.OptAppModelPartUtils.LogModelPartStatus(self.model_part, "element_specific_properties_created")
+
+    def Check(self) -> None:
+        pass
+
+    def Finalize(self) -> None:
+        pass
+
+    def GetPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
+        return [self.controlled_physical_variable]
+
+    def GetEmptyField(self) -> ContainerExpressionTypes:
+        field = Kratos.Expression.ElementExpression(self.model_part)
+        Kratos.Expression.LiteralExpressionIO.SetData(field, 0.0)
+        return field
+
+    def GetControlField(self) -> ContainerExpressionTypes:
+        field = self.GetEmptyField()
+        KratosOA.PropertiesVariableExpressionIO.Read(field, self.controlled_physical_variable)
+        return field
+
+    def MapGradient(self, physical_gradient_variable_container_expression_map: 'dict[SupportedSensitivityFieldVariableTypes, ContainerExpressionTypes]') -> ContainerExpressionTypes:
+        keys = physical_gradient_variable_container_expression_map.keys()
+        if len(keys) != 1:
+            raise RuntimeError(f"Provided more than required gradient fields for control \"{self.GetName()}\". Following are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
+        if self.controlled_physical_variable not in keys:
+            raise RuntimeError(f"The required gradient for control \"{self.GetName()}\" w.r.t. {self.controlled_physical_variable.Name()} not found. Followings are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
+
+        physical_gradient = physical_gradient_variable_container_expression_map[self.controlled_physical_variable]
+        if not IsSameContainerExpression(physical_gradient, self.GetEmptyField()):
+            raise RuntimeError(f"Gradients for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.model_part.FullName()}, given model part name: {physical_gradient.GetModelPart().FullName()} ]")
+
+        # TODO: Implement filtering mechanisms here
+        return physical_gradient_variable_container_expression_map[self.controlled_physical_variable].Clone()
+
+    def Update(self, control_field: ContainerExpressionTypes) -> bool:
+        if not IsSameContainerExpression(control_field, self.GetEmptyField()):
+            raise RuntimeError(f"Updates for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.model_part.FullName()}, given model part name: {control_field.GetModelPart().FullName()} ]")
+
+        # TODO: Implement inverse filtering mechanisms here
+        # since no filtering is implemented yet, we are checking the unfiltered updates with the filtered updates. This needs to be changed once the
+        # filtering mechanisms are implemented.
+
+        # get the current unfiltered control field
+        unfiltered_control_field = self.GetControlField()
+
+        if Kratos.Expression.Utils.NormL2(unfiltered_control_field - control_field) > 1e-9:
+            KratosOA.PropertiesVariableExpressionIO.Write(control_field, self.controlled_physical_variable)
+            return True
+
+        return False
+
+    def __str__(self) -> str:
+        return f"Control [type = {self.__class__.__name__}, name = {self.GetName()}, model part name = {self.model_part.FullName()}, control variable = {self.controlled_physical_variable.Name()}"
```

## KratosMultiphysics/OptimizationApplication/controls/shape/vertex_morphing_shape_control.py

```diff
@@ -1,369 +1,257 @@
-from typing import Optional
-
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.controls.control import Control
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import IsSameContainerExpression
-from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.filtering.helmholtz_analysis import HelmholtzAnalysis
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
-
-try:
-    from KratosMultiphysics.MeshMovingApplication.mesh_moving_analysis import MeshMovingAnalysis
-    mesh_motion_solver_available = True
-except ImportError:
-    mesh_motion_solver_available = False
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> Control:
-    if not parameters.Has("name"):
-        raise RuntimeError(f"VertexMorphingShapeControl instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"VertexMorphingShapeControl instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-
-    return VertexMorphingShapeControl(parameters["name"].GetString(), model, parameters["settings"], optimization_problem)
-
-def GetImplicitFilterParameters(filter_model_part_name: str, parameters: Kratos.Parameters):
-    filter_radius = parameters["filter_settings"]["radius"].GetDouble()
-    filter_type = parameters["filter_settings"]["type"].GetString()
-    linear_solver_settings = parameters["filter_settings"]["linear_solver_settings"]
-    implicit_vector_filter_parameters = Kratos.Parameters("""
-     {
-        "solver_settings" : {
-             "domain_size"          : 3,
-             "echo_level"           : 0,
-             "filter_type"          : "general_vector",
-             "model_import_settings": {
-                 "input_type"     : "use_input_model_part"
-             }
-         },
-        "problem_data": {
-             "echo_level"    : 0,
-             "start_time"    : 0.0,
-             "end_time"      : 1.0,
-             "parallel_type" : "OpenMP"
-         },
-        "processes" : {
-                "boundary_conditions_process_list" : []
-            }
-     }""")
-
-    if filter_type == "bulk_surface_implicit":
-        implicit_vector_filter_parameters["solver_settings"]["filter_type"].SetString("bulk_surface_shape")
-
-    implicit_vector_filter_parameters["solver_settings"].AddDouble("filter_radius",filter_radius)
-    implicit_vector_filter_parameters["solver_settings"].AddString("model_part_name",filter_model_part_name)
-    if linear_solver_settings.Has("solver_type"):
-        implicit_vector_filter_parameters["solver_settings"].AddValue("linear_solver_settings", linear_solver_settings)
-
-    for model_part_name, direction_params in parameters["fixed_model_parts"].items():
-        auto_process_settings = Kratos.Parameters(
-            """
-            {
-                "python_module" : "fix_vector_variable_process",
-                "kratos_module" : "KratosMultiphysics",
-                "help"          : "This process fixes the selected components of a given vector variable without modifying the value of the variable.",
-                "process_name"  : "FixVectorVariableProcess",
-                "Parameters"    : {
-                    "model_part_name" : \""""+model_part_name+"""\",
-                    "variable_name"   : "HELMHOLTZ_VECTOR",
-                    "constrained"          : [false,false,false]
-                }
-            }
-            """)
-        auto_process_settings["Parameters"]["constrained"] = direction_params
-        implicit_vector_filter_parameters["processes"]["boundary_conditions_process_list"].Append(auto_process_settings)
-
-    return implicit_vector_filter_parameters
-
-def GetMeshMotionParameters(parameters: Kratos.Parameters, main_model_part_name, moving_sub_model_part_name):
-    default_mesh_motion_settings = Kratos.Parameters("""
-    {
-        "apply_mesh_solver" : true,
-        "solver_settings" : {
-            "domain_size"     : 3,
-            "echo_level"      : 0,
-            "solver_type"     : "structural_similarity",
-            "model_part_name" : "NONE",
-            "model_import_settings"              : {
-                "input_type"     : "use_input_model_part"
-            },
-            "time_stepping" : {
-                "time_step"       : 1.0
-            },
-            "compute_reactions"                : false,
-            "calculate_mesh_velocity"          : false
-        },
-        "processes" : {
-            "boundary_conditions_process_list" : []
-        }
-    }""")
-
-    parameters.ValidateAndAssignDefaults(default_mesh_motion_settings)
-
-    parameters["solver_settings"].AddString("model_part_name",main_model_part_name)
-
-    auto_process_settings = Kratos.Parameters(
-    """
-    {
-        "python_module" : "fix_vector_variable_process",
-        "kratos_module" : "KratosMultiphysics",
-        "help"          : "This process fixes the selected components of a given vector variable without modifying the value of the variable.",
-        "process_name"  : "FixVectorVariableProcess",
-        "Parameters"    : {
-            "model_part_name"      : \""""+str(moving_sub_model_part_name)+"""\",
-            "variable_name"        : "MESH_DISPLACEMENT",
-            "constrained"          : [true,true,true]
-        }
-    }
-    """)
-
-    parameters["processes"]["boundary_conditions_process_list"].Append(auto_process_settings)
-
-    problem_data = Kratos.Parameters("""{
-        "echo_level"    : 0,
-        "start_time"    : 0.0,
-        "end_time"      : 1.0,
-        "parallel_type" : "OpenMP"
-    }""")
-
-    parameters.AddValue("problem_data", problem_data)
-
-    return parameters
-
-class VertexMorphingShapeControl(Control):
-    """Node-based shape control using implicit and explicit Vertex Morphing techniques
-
-    This is filtering-based discrete shape control which parametrizes and controls
-    discrete shell and solid geometeries.
-
-    """
-    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        super().__init__(name)
-
-        self.parameters = parameters
-        self.model = model
-        self.optimization_problem = optimization_problem
-
-        default_settings = Kratos.Parameters("""{
-            "controlled_model_part_names": [],
-            "filter_settings": {
-                "type" : "surface_explicit",
-                "filter_function_type" : "linear",
-                "damping_function_type" : "sigmoidal",
-                "radius": 0.000000000001,
-                "max_nodes_in_filter_radius": 1000,
-                "linear_solver_settings" : {}
-            },
-            "mesh_motion_settings" : {},
-            "output_all_fields": false,
-            "fixed_model_parts": {},
-            "utilities": []
-        }""")
-
-        self.parameters.ValidateAndAssignDefaults(default_settings)
-        self.parameters["filter_settings"].ValidateAndAssignDefaults(default_settings["filter_settings"])
-
-        self.output_all_fields = self.parameters["output_all_fields"].GetBool()
-        self.filter_type = self.parameters["filter_settings"]["type"].GetString()
-
-        self.supported_filter_types = ["surface_implicit","surface_implicit_with_mesh_motion","bulk_surface_implicit","surface_explicit","surface_explicit_with_mesh_motion"]
-        if not self.filter_type in self.supported_filter_types:
-            raise RuntimeError(f"The specified filter type \"{self.filter_type}\" is not supported. Followings are the variables:\n\t" + "\n\t".join([k for k in self.supported_filter_types]))
-
-        controlled_model_names_parts = parameters["controlled_model_part_names"].GetStringArray()
-        if len(controlled_model_names_parts) == 0:
-            raise RuntimeError(f"No model parts are provided for VertexMorphingShapeControl. [ control name = \"{self.GetName()}\"]")
-
-        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"control_{self.GetName()}", controlled_model_names_parts, False)
-        self.model_part: 'Optional[Kratos.ModelPart]' = None
-
-        self.filter = None
-        self.is_filter_implicit = False
-        if "implicit" in self.filter_type:
-            self.is_filter_implicit = True
-            helmholtz_settings = GetImplicitFilterParameters(self.model_part_operation.GetModelPartFullName(), self.parameters)
-            self.filter = HelmholtzAnalysis(self.model, helmholtz_settings)
-
-        # now setup mesh motion
-        self.SetupMeshMotion()
-
-        self.is_initialized = False
-
-    @time_decorator(methodName="GetName")
-    def Initialize(self) -> None:
-
-        if self.filter_type == "bulk_surface_implicit":
-            self.filter_model_part = self.model_part_operation.GetModelPart().GetRootModelPart()
-        else:
-            self.filter_model_part = self.model_part_operation.GetModelPart()
-
-        # initialize filters
-        if not self.is_filter_implicit:
-            # make sure that explicit filter model part only has conditions
-            if len(self.filter_model_part.Elements) > 0:
-                raise RuntimeError("VertexMorphingShapeControl with explicit filtering only allows model parts with conditions")
-            # now damping and creating the filter
-            fixed_model_parts_names = list(self.parameters["fixed_model_parts"].keys())
-            if len(fixed_model_parts_names)>0:
-                self.fixed_model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"control_{self.GetName()}", fixed_model_parts_names, False)
-                self.fixed_model_part = self.fixed_model_part_operation.GetModelPart()
-                self.filter = KratosOA.NodalExplicitFilter(self.filter_model_part, self.fixed_model_part, self.parameters["filter_settings"]["filter_function_type"].GetString(),
-                                                           self.parameters["filter_settings"]["damping_function_type"].GetString(),
-                                                           self.parameters["filter_settings"]["max_nodes_in_filter_radius"].GetInt())
-            else:
-                self.filter = KratosOA.NodalExplicitFilter(self.filter_model_part, self.parameters["filter_settings"]["filter_function_type"].GetString(),
-                                                           self.parameters["filter_settings"]["max_nodes_in_filter_radius"].GetInt())
-
-            filter_radius_field = Kratos.Expression.NodalExpression(self.filter_model_part)
-            Kratos.Expression.LiteralExpressionIO.SetData(filter_radius_field, self.parameters["filter_settings"]["radius"].GetDouble())
-            self.filter.SetFilterRadius(filter_radius_field)
-            self.control_field = Kratos.Expression.NodalExpression(self.filter_model_part)
-            Kratos.Expression.LiteralExpressionIO.SetData(self.control_field,[0,0,0])
-        else:
-            self.filter.Initialize()
-            self._SetFixedModelPartValues(False)
-            self.control_field = self.filter.UnFilterField(self.GetPhysicalField())
-            self._SetFixedModelPartValues(True)
-
-        # initialize_mesh_motion
-        if self.has_mesh_motion:
-            self._mesh_moving_analysis.Initialize()
-
-        # now update
-        self._UpdateAndOutputFields(self.GetEmptyField())
-        self.is_initialized = True
-
-    def SetupMeshMotion(self):
-        if "mesh_motion" in self.filter_type:
-            self.has_mesh_motion = True
-            self.mesh_motion_params = GetMeshMotionParameters(self.parameters["mesh_motion_settings"],self.model_part_operation.GetRootModelPart().Name,self.model_part_operation.GetModelPartFullName())
-            self._mesh_moving_analysis = MeshMovingAnalysis(self.model, self.mesh_motion_params)
-        else:
-            self.has_mesh_motion = False
-
-    def Check(self) -> None:
-        if self.is_filter_implicit:
-            return self.filter.Check()
-
-    def Finalize(self) -> None:
-        if self.is_filter_implicit:
-            self.filter.Finalize()
-        if self.has_mesh_motion:
-            self._mesh_moving_analysis.Finalize()
-
-    def GetPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
-        return [KratosOA.SHAPE]
-
-    def GetEmptyField(self) -> ContainerExpressionTypes:
-        field = Kratos.Expression.NodalExpression(self.filter_model_part)
-        Kratos.Expression.LiteralExpressionIO.SetData(field, [0,0,0])
-        return field
-
-    def GetControlField(self) -> ContainerExpressionTypes:
-        return self.control_field
-
-    def GetPhysicalField(self) -> ContainerExpressionTypes:
-        physical_shape_field = Kratos.Expression.NodalExpression(self.filter_model_part)
-        Kratos.Expression.NodalPositionExpressionIO.Read(physical_shape_field, Kratos.Configuration.Initial)
-        return physical_shape_field
-
-    @time_decorator(methodName="GetName")
-    def MapGradient(self, physical_gradient_variable_container_expression_map: 'dict[SupportedSensitivityFieldVariableTypes, ContainerExpressionTypes]') -> ContainerExpressionTypes:
-        keys = physical_gradient_variable_container_expression_map.keys()
-        if len(keys) != 1:
-            raise RuntimeError(f"Provided more than required gradient fields for control \"{self.GetName()}\". Following are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
-        if KratosOA.SHAPE not in keys:
-            raise RuntimeError(f"The required gradient for control \"{self.GetName()}\" w.r.t. {KratosOA.SHAPE.Name()} not found. Followings are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
-
-        physical_gradient = physical_gradient_variable_container_expression_map[KratosOA.SHAPE]
-        if not IsSameContainerExpression(physical_gradient, self.GetEmptyField()):
-            raise RuntimeError(f"Gradients for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.filter_model_part.FullName()}, given model part name: {physical_gradient.GetModelPart().FullName()} ]")
-
-        # now filter the field
-        filtered_gradient = self.filter.FilterIntegratedField(physical_gradient)
-
-        return filtered_gradient
-
-    @time_decorator(methodName="GetName")
-    def Update(self, new_control_field: ContainerExpressionTypes) -> bool:
-        if not IsSameContainerExpression(new_control_field, self.GetEmptyField()):
-            raise RuntimeError(f"Updates for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.filter_model_part.FullName()}, given model part name: {new_control_field.GetModelPart().FullName()} ]")
-        if KratosOA.ExpressionUtils.NormL2(self.control_field - new_control_field) > 1e-15:
-            # update the control SHAPE field
-            control_update = new_control_field - self.control_field
-            self.control_field = new_control_field
-            # now update the physical field
-            self._UpdateAndOutputFields(control_update)
-            # update explicit filter
-            if not self.is_filter_implicit:
-                self.filter.Update()
-            return True
-        return False
-
-    def _UpdateMesh(self, shape_update) -> None:
-        if self.has_mesh_motion:
-            mm_computing_model_part = self._mesh_moving_analysis._GetSolver().GetComputingModelPart()
-            time_before_update = mm_computing_model_part.ProcessInfo.GetValue(Kratos.TIME)
-            step_before_update = mm_computing_model_part.ProcessInfo.GetValue(Kratos.STEP)
-            delta_time_before_update = mm_computing_model_part.ProcessInfo.GetValue(Kratos.DELTA_TIME)
-
-            # Reset step/time iterators such that they match the current iteration after calling RunSolutionLoop (which internally calls CloneTimeStep)
-            mm_computing_model_part.ProcessInfo.SetValue(Kratos.STEP, step_before_update-1)
-            mm_computing_model_part.ProcessInfo.SetValue(Kratos.TIME, time_before_update-1)
-            mm_computing_model_part.ProcessInfo.SetValue(Kratos.DELTA_TIME, 0)
-
-            # assign the boundary_displacements
-            Kratos.Expression.VariableExpressionIO.Write(shape_update, Kratos.MESH_DISPLACEMENT, True)
-
-            # solve for the volume mesh displacements
-            if not self._mesh_moving_analysis.time < self._mesh_moving_analysis.end_time:
-                self._mesh_moving_analysis.end_time += 1
-            self._mesh_moving_analysis.RunSolutionLoop()
-
-            # update the coords
-            mesh_disp_field = Kratos.Expression.NodalExpression(mm_computing_model_part)
-            Kratos.Expression.LiteralExpressionIO.SetData(mesh_disp_field, [0,0,0])
-            Kratos.Expression.VariableExpressionIO.Read(mesh_disp_field, Kratos.MESH_DISPLACEMENT, True)
-            physical_shape_field = Kratos.Expression.NodalExpression(mm_computing_model_part)
-            Kratos.Expression.NodalPositionExpressionIO.Read(physical_shape_field, Kratos.Configuration.Initial)
-            Kratos.Expression.NodalPositionExpressionIO.Write(mesh_disp_field + physical_shape_field, Kratos.Configuration.Initial)
-            Kratos.Expression.NodalPositionExpressionIO.Write(mesh_disp_field + physical_shape_field, Kratos.Configuration.Current)
-
-            mm_computing_model_part.ProcessInfo.SetValue(Kratos.STEP, step_before_update)
-            mm_computing_model_part.ProcessInfo.SetValue(Kratos.TIME, time_before_update)
-            mm_computing_model_part.ProcessInfo.SetValue(Kratos.DELTA_TIME, delta_time_before_update)
-        else:
-            Kratos.Expression.NodalPositionExpressionIO.Write(shape_update + self.GetPhysicalField(), Kratos.Configuration.Initial)
-            Kratos.Expression.NodalPositionExpressionIO.Write(shape_update + self.GetPhysicalField(), Kratos.Configuration.Current)
-
-    def _UpdateAndOutputFields(self, control_update) -> None:
-        # compute the shape update
-        shape_update = self.filter.FilterField(control_update)
-
-        # now update the shape
-        self._UpdateMesh(shape_update)
-
-        # now output the fields
-        un_buffered_data = ComponentDataView(self, self.optimization_problem).GetUnBufferedData()
-        un_buffered_data.SetValue("shape_update", shape_update.Clone(),overwrite=self.is_initialized)
-        if self.output_all_fields:
-            un_buffered_data.SetValue("shape_control", self.control_field.Clone(),overwrite=self.is_initialized)
-            un_buffered_data.SetValue("shape_control_update", control_update.Clone(),overwrite=self.is_initialized)
-
-    def _SetFixedModelPartValues(self, is_backward = False) -> None:
-        for model_part_name in self.parameters["fixed_model_parts"].keys():
-            field =  Kratos.Expression.NodalExpression(self.model[model_part_name])
-            Kratos.Expression.LiteralExpressionIO.SetData(field,[0,0,0])
-            if is_backward:
-                Kratos.Expression.LiteralExpressionIO.SetData(field,[0,0,0])
-            else:
-                Kratos.Expression.NodalPositionExpressionIO.Read(field, Kratos.Configuration.Initial)
-
-            Kratos.Expression.VariableExpressionIO.Write(field, KratosOA.HELMHOLTZ_VECTOR,True)
-
-    def __str__(self) -> str:
-        return f"Control [type = {self.__class__.__name__}, name = {self.GetName()}, model part name = {self.filter_model_part.FullName()}, control variable = {KratosOA.SHAPE.Name()}"
+from typing import Optional
+
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.controls.control import Control
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import IsSameContainerExpression
+from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
+from KratosMultiphysics.OptimizationApplication.filtering.filter import Factory as FilterFactory
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> Control:
+    if not parameters.Has("name"):
+        raise RuntimeError(f"VertexMorphingShapeControl instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"VertexMorphingShapeControl instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+
+    return VertexMorphingShapeControl(parameters["name"].GetString(), model, parameters["settings"], optimization_problem)
+
+class VertexMorphingShapeControl(Control):
+    """Node-based shape control using implicit and explicit Vertex Morphing techniques
+
+    This is filtering-based discrete shape control which parametrizes and controls
+    discrete shell and solid geometries.
+
+    """
+    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        super().__init__(name)
+
+        self.parameters = parameters
+        self.model = model
+        self.optimization_problem = optimization_problem
+
+        default_settings = Kratos.Parameters("""{
+            "controlled_model_part_names": [],
+            "filter_settings"            : {},
+            "mesh_motion_solver_type"    : "none",
+            "skin_model_part_names"      : [],
+            "mesh_motion_solver_settings": {},
+            "output_all_fields"          : false
+        }""")
+
+        self.parameters.ValidateAndAssignDefaults(default_settings)
+
+        self.output_all_fields = self.parameters["output_all_fields"].GetBool()
+
+        controlled_model_names_parts = parameters["controlled_model_part_names"].GetStringArray()
+        if len(controlled_model_names_parts) == 0:
+            raise RuntimeError(f"No model parts are provided for VertexMorphingShapeControl. [ control name = \"{self.GetName()}\"]")
+
+        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"control_{self.GetName()}", controlled_model_names_parts, False)
+        self.model_part: 'Optional[Kratos.ModelPart]' = None
+
+        self.filter = FilterFactory(self.model, self.model_part_operation.GetModelPartFullName(), KratosOA.SHAPE, Kratos.Globals.DataLocation.NodeHistorical, self.parameters["filter_settings"])
+
+        # now setup mesh motion
+        self.__mesh_moving_analysis: 'Optional[MeshMovingAnalysis]' = None
+        self.__boundary_model_part: 'Optional[Kratos.ModelPart]' = None
+
+        self.mesh_motion_solver_type = self.parameters["mesh_motion_solver_type"].GetString()
+        supported_mesh_motion_solver_types = ["mesh_moving_analysis", "filter_based", "none"]
+        if self.mesh_motion_solver_type not in supported_mesh_motion_solver_types:
+            raise RuntimeError(f"Unsupported mesh_motion_solver_type = \"{self.mesh_motion_solver_type}\" requested. Supported types are:\n\t" + "\n\t".join(supported_mesh_motion_solver_types))
+
+        if self.mesh_motion_solver_type == "mesh_moving_analysis":
+            # import is done here, so that, if it is not required to use mesh_motion,
+            # then it is not loaded, hence not even required to have MeshMovingApplication
+            # compiled.
+            from KratosMultiphysics.MeshMovingApplication.mesh_moving_analysis import MeshMovingAnalysis
+            self.__mesh_moving_analysis = MeshMovingAnalysis(self.model, self.parameters["mesh_motion_solver_settings"])
+
+    @time_decorator(methodName="GetName")
+    def Initialize(self) -> None:
+        self.model_part = self.model_part_operation.GetModelPart()
+
+        # initialize filters
+        self.filter.SetComponentDataView(ComponentDataView(self, self.optimization_problem))
+        self.filter.Initialize()
+
+        self.control_field = self.filter.UnfilterField(self.GetPhysicalField())
+
+        # initialize_mesh_motion if defined.
+        if not self.__mesh_moving_analysis is None:
+            self.__mesh_moving_analysis.Initialize()
+
+            def recursively_increase_usage(model_part: Kratos.ModelPart) -> None:
+                if not model_part.Has(KratosOA.NUMBER_OF_SOLVERS_USING_NODES):
+                    model_part[KratosOA.NUMBER_OF_SOLVERS_USING_NODES] = 0
+                model_part[KratosOA.NUMBER_OF_SOLVERS_USING_NODES] += 1
+
+                for sub_model_part in model_part.SubModelParts:
+                    recursively_increase_usage(sub_model_part)
+
+            # we increase the usage of all the sub-model parts because, mesh moving works with
+            # root model parts, and all the sub model parts are suing the root model parts. Hence
+            # mesh moving will affect all the shared sub-model parts
+            recursively_increase_usage(self.__mesh_moving_analysis._GetSolver().GetComputingModelPart())
+
+        # now update
+        self._UpdateAndOutputFields(self.GetEmptyField())
+
+    def Check(self) -> None:
+        self.filter.Check()
+
+    def Finalize(self) -> None:
+        self.filter.Finalize()
+        if not self.__mesh_moving_analysis is None:
+            self.__mesh_moving_analysis.Finalize()
+            del self.__mesh_moving_analysis
+
+    def GetPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
+        return [KratosOA.SHAPE]
+
+    def GetEmptyField(self) -> ContainerExpressionTypes:
+        field = Kratos.Expression.NodalExpression(self.__GetPhysicalModelPart())
+        Kratos.Expression.LiteralExpressionIO.SetData(field, [0,0,0])
+        return field
+
+    def GetControlField(self) -> ContainerExpressionTypes:
+        return self.control_field
+
+    def GetPhysicalField(self) -> ContainerExpressionTypes:
+        physical_shape_field = Kratos.Expression.NodalExpression(self.__GetPhysicalModelPart())
+        Kratos.Expression.NodalPositionExpressionIO.Read(physical_shape_field, Kratos.Configuration.Initial)
+        return physical_shape_field
+
+    @time_decorator(methodName="GetName")
+    def MapGradient(self, physical_gradient_variable_container_expression_map: 'dict[SupportedSensitivityFieldVariableTypes, ContainerExpressionTypes]') -> ContainerExpressionTypes:
+        keys = physical_gradient_variable_container_expression_map.keys()
+        if len(keys) != 1:
+            raise RuntimeError(f"Provided more than required gradient fields for control \"{self.GetName()}\". Following are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
+        if KratosOA.SHAPE not in keys:
+            raise RuntimeError(f"The required gradient for control \"{self.GetName()}\" w.r.t. {KratosOA.SHAPE.Name()} not found. Followings are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
+
+        physical_gradient = physical_gradient_variable_container_expression_map[KratosOA.SHAPE]
+        if not IsSameContainerExpression(physical_gradient, self.GetEmptyField()):
+            raise RuntimeError(f"Gradients for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.model_part.FullName()}, given model part name: {physical_gradient.GetModelPart().FullName()} ]")
+
+        filtered_gradient = self.filter.BackwardFilterIntegratedField(KratosOA.ExpressionUtils.ExtractData(physical_gradient, self.model_part))
+
+        return KratosOA.ExpressionUtils.ExtractData(filtered_gradient, self.__GetPhysicalModelPart())
+
+    @time_decorator(methodName="GetName")
+    def Update(self, new_control_field: ContainerExpressionTypes) -> bool:
+        if not IsSameContainerExpression(new_control_field, self.GetEmptyField()):
+            raise RuntimeError(f"Updates for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.model_part.FullName()}, given model part name: {new_control_field.GetModelPart().FullName()} ]")
+        if Kratos.Expression.Utils.NormL2(self.control_field - new_control_field) > 1e-15:
+            # update the control SHAPE field
+            control_update = new_control_field - self.control_field
+            self.control_field = new_control_field
+            # now update the physical field
+            self._UpdateAndOutputFields(control_update)
+
+            self.filter.Update()
+            return True
+        return False
+
+    def _UpdateAndOutputFields(self, control_update: ContainerExpressionTypes) -> None:
+        # compute the shape update
+        if self.mesh_motion_solver_type == "filter_based":
+            shape_update = self.filter.ForwardFilterField(control_update)
+        else:
+            shape_update = self.filter.ForwardFilterField(KratosOA.ExpressionUtils.ExtractData(control_update, self.model_part))
+
+        # now update the shape
+        self._UpdateMesh(shape_update)
+
+        # now output the fields
+        un_buffered_data = ComponentDataView(self, self.optimization_problem).GetUnBufferedData()
+        un_buffered_data.SetValue("shape_update", shape_update.Clone(),overwrite=True)
+        if self.output_all_fields:
+            un_buffered_data.SetValue("shape_control", self.control_field.Clone(),overwrite=True)
+            un_buffered_data.SetValue("shape_control_update", control_update.Clone(),overwrite=True)
+
+    def _UpdateMesh(self, shape_update: ContainerExpressionTypes) -> None:
+        if self.mesh_motion_solver_type != "none":
+            mesh_displacement_field = Kratos.Expression.NodalExpression(self.model_part_operation.GetRootModelPart())
+
+            if not self.__mesh_moving_analysis is None:
+                mm_computing_model_part: Kratos.ModelPart = self.__mesh_moving_analysis._GetSolver().GetComputingModelPart()
+                time_before_update = mm_computing_model_part.ProcessInfo.GetValue(Kratos.TIME)
+                step_before_update = mm_computing_model_part.ProcessInfo.GetValue(Kratos.STEP)
+                delta_time_before_update = mm_computing_model_part.ProcessInfo.GetValue(Kratos.DELTA_TIME)
+
+                # Reset step/time iterators such that they match the current iteration after calling RunSolutionLoop (which internally calls CloneTimeStep)
+                mm_computing_model_part.ProcessInfo.SetValue(Kratos.STEP, step_before_update-1)
+                mm_computing_model_part.ProcessInfo.SetValue(Kratos.TIME, time_before_update-1)
+                mm_computing_model_part.ProcessInfo.SetValue(Kratos.DELTA_TIME, 0)
+
+                # first reset the MESH_DISPLACEMENTS
+                Kratos.VariableUtils().SetHistoricalVariableToZero(Kratos.MESH_DISPLACEMENT, mm_computing_model_part.Nodes)
+
+                # assign the design surface MESH_DISPLACEMENTS
+                Kratos.Expression.VariableExpressionIO.Write(shape_update, Kratos.MESH_DISPLACEMENT, True)
+
+                # since we know that the nodes in the shape_update model part needs to be fixed to correctly
+                # compute the MESH_DISPLACEMENT. We Only do that in here by first freeing all the MESH_DISPLACEMENT
+                # dofs, then followed by fixing the shape_update model part nodes' MESH_DISPLACEMENTs. If further
+                # boundaries needs fixing, then they need to be specified in the mesh_motion_solver settings
+                # using fix_vector_variable_process.
+                mesh_displacement_comps = [Kratos.MESH_DISPLACEMENT_X, Kratos.MESH_DISPLACEMENT_Y, Kratos.MESH_DISPLACEMENT_Z]
+                for i_comp, mesh_displacement_var in enumerate(mesh_displacement_comps):
+                    # first free the mesh displacement component
+                    Kratos.VariableUtils().ApplyFixity(mesh_displacement_var, False, mm_computing_model_part.Nodes)
+                    # now fix the design surface component
+                    Kratos.VariableUtils().ApplyFixity(mesh_displacement_var, True, shape_update.GetModelPart().Nodes)
+                    # now fix boundary condition components
+                    for model_part in self.filter.GetBoundaryConditions()[i_comp]:
+                        Kratos.VariableUtils().ApplyFixity(mesh_displacement_var, True, model_part.Nodes)
+
+                # solve for the volume mesh displacements
+                if not self.__mesh_moving_analysis.time < self.__mesh_moving_analysis.end_time:
+                    self.__mesh_moving_analysis.end_time += 1
+                self.__mesh_moving_analysis.RunSolutionLoop()
+
+                Kratos.Expression.VariableExpressionIO.Read(mesh_displacement_field, Kratos.MESH_DISPLACEMENT, True)
+
+                mm_computing_model_part.ProcessInfo.SetValue(Kratos.STEP, step_before_update)
+                mm_computing_model_part.ProcessInfo.SetValue(Kratos.TIME, time_before_update)
+                mm_computing_model_part.ProcessInfo.SetValue(Kratos.DELTA_TIME, delta_time_before_update)
+            else:
+                # filter based mesh motion is used. Hence read the value from the filter. then the shape update is the mesh displacement
+                mesh_displacement_field = shape_update.Clone()
+
+            # a mesh motion is solved (either by mesh motion solver or the filter), and MESH_DISPLACEMENT variable is filled
+            # Hence, update the coords
+            physical_field = Kratos.Expression.NodalExpression(self.model_part_operation.GetRootModelPart())
+
+            Kratos.Expression.NodalPositionExpressionIO.Read(physical_field, Kratos.Configuration.Initial)
+
+            Kratos.Expression.NodalPositionExpressionIO.Write(mesh_displacement_field + physical_field, Kratos.Configuration.Initial)
+            Kratos.Expression.NodalPositionExpressionIO.Write(mesh_displacement_field + physical_field, Kratos.Configuration.Current)
+            Kratos.Logger.PrintInfo(self.__class__.__name__, "Applied MESH_DISPLACEMENT to the mesh.")
+        else:
+            # no mesh motion is preferred, hence only updating the design field
+            physical_field = self.GetPhysicalField()
+            Kratos.Expression.NodalPositionExpressionIO.Write(shape_update + physical_field, Kratos.Configuration.Initial)
+            Kratos.Expression.NodalPositionExpressionIO.Write(shape_update + physical_field, Kratos.Configuration.Current)
+
+    def __GetPhysicalModelPart(self) -> Kratos.ModelPart:
+        if self.mesh_motion_solver_type == "none":
+            # this control does not require mesh_motion, hence this does not
+            # have any influence on the volume domain. So the physical model part
+            # is the controlled model part
+            return self.model_part
+        else:
+            # this is the case where mesh motion is required, that means this control will control the
+            # whole domain by moving its internal nodes because, the controlled model part represents
+            # a surface of the volume domain. hence the physical field should be the whole
+            # model part
+            return self.model_part.GetRootModelPart()
+
+    def __str__(self) -> str:
+        return f"Control [type = {self.__class__.__name__}, name = {self.GetName()}, model part name = {self.model_part.FullName()}, control variable = SHAPE ]"
```

## KratosMultiphysics/OptimizationApplication/controls/thickness/shell_thickness_control.py

```diff
@@ -1,257 +1,210 @@
-from typing import Optional
-
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.controls.control import Control
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import IsSameContainerExpression
-from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.filtering.helmholtz_analysis import HelmholtzAnalysis
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> Control:
-    if not parameters.Has("name"):
-        raise RuntimeError(f"ShellThicknessControl instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"ShellThicknessControl instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-
-    return ShellThicknessControl(parameters["name"].GetString(), model, parameters["settings"], optimization_problem)
-
-def GetImplicitFilterParameters(model_part_name: str, parameters: Kratos.Parameters) -> Kratos.Parameters:
-    filter_radius = parameters["filter_settings"]["radius"].GetDouble()
-    linear_solver_settings = parameters["filter_settings"]["linear_solver_settings"]
-    shell_scalar_filter_parameters = Kratos.Parameters("""
-     {
-        "solver_settings" : {
-             "domain_size"          : 3,
-             "echo_level"           : 0,
-             "filter_type"          : "general_scalar",
-             "model_import_settings": {
-                 "input_type"     : "use_input_model_part"
-             }
-         },
-        "problem_data": {
-             "echo_level"    : 0,
-             "start_time"    : 0.0,
-             "end_time"      : 1.0,
-             "parallel_type" : "OpenMP"
-         },
-        "processes" : {
-                "boundary_conditions_process_list" : []
-            }
-     }""")
-
-    shell_scalar_filter_parameters["solver_settings"].AddDouble("filter_radius",filter_radius)
-    shell_scalar_filter_parameters["solver_settings"].AddString("model_part_name",model_part_name)
-    shell_scalar_filter_parameters["solver_settings"].AddValue("linear_solver_settings", linear_solver_settings)
-
-    fixed_model_parts = parameters["fixed_model_parts_and_thicknesses"].keys()
-
-    for fixed_model_part in fixed_model_parts:
-        auto_process_settings = Kratos.Parameters(
-            """
-            {
-                "python_module" : "fix_scalar_variable_process",
-                "kratos_module" : "KratosMultiphysics",
-                "process_name"  : "FixScalarVariableProcess",
-                "Parameters"    : {
-                    "model_part_name" : \""""+fixed_model_part+"""\",
-                    "variable_name"   : "HELMHOLTZ_SCALAR",
-                    "constrained"     : true
-                }
-            }
-            """)
-        shell_scalar_filter_parameters["processes"]["boundary_conditions_process_list"].Append(auto_process_settings)
-
-    return shell_scalar_filter_parameters
-
-class ShellThicknessControl(Control):
-    """Shell thickness control
-
-    This is filtering-based discrete thickness control which parametrizes and controls
-    shell elements thickness.
-
-    """
-    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        super().__init__(name)
-
-        self.parameters = parameters
-        self.model = model
-        self.optimization_problem = optimization_problem
-
-        default_settings = Kratos.Parameters("""{
-            "controlled_model_part_names": [],
-            "filter_settings": {
-                "type" : "implicit",
-                "radius": 0.000000000001,
-                "linear_solver_settings" : {}
-            },
-            "beta_value": 25.0,
-            "penalty_power": 1,
-            "output_all_fields": false,
-            "initial_physical_thickness":0.000001,
-            "physical_thicknesses": [],
-            "fixed_model_parts_and_thicknesses": {},
-            "utilities": []
-        }""")
-
-        self.parameters.ValidateAndAssignDefaults(default_settings)
-        self.parameters["filter_settings"].ValidateAndAssignDefaults(default_settings["filter_settings"])
-
-        self.penalty_power = self.parameters["penalty_power"].GetInt()
-        self.beta = self.parameters["beta_value"].GetDouble()
-        self.output_all_fields = self.parameters["output_all_fields"].GetBool()
-        self.physical_thicknesses = self.parameters["physical_thicknesses"].GetVector()
-        num_phys_thick = len(self.physical_thicknesses)
-        if num_phys_thick == 0:
-            raise RuntimeError("The physical_thicknesses can not be empty, at least min and max should be provided.")
-        self.filtered_thicknesses = [i for i, _ in enumerate(self.physical_thicknesses)]
-
-        self.filter_type = self.parameters["filter_settings"]["type"].GetString()
-        self.supported_filter_types = ["implicit"]
-
-        if not self.filter_type in self.supported_filter_types:
-            raise RuntimeError(f"The specified filter type \"{self.filter_type}\" is not supported. Followings are the variables:\n\t" + "\n\t".join([k for k in self.supported_filter_types]))
-
-        controlled_model_names_parts = parameters["controlled_model_part_names"].GetStringArray()
-        if len(controlled_model_names_parts) == 0:
-            raise RuntimeError(f"No model parts were provided for ShellThicknessControl. [ control name = \"{self.GetName()}\"]")
-
-        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"control_{self.GetName()}", controlled_model_names_parts, False)
-        self.model_part: 'Optional[Kratos.ModelPart]' = None
-
-        self.fixed_model_parts_and_thicknesses: 'dict[str, float]' = {}
-        for model_part_name, thickness_params in self.parameters["fixed_model_parts_and_thicknesses"].items():
-            self.fixed_model_parts_and_thicknesses[model_part_name] = thickness_params.GetDouble()
-
-        if not all(entry.GetDouble() in self.physical_thicknesses for entry in self.fixed_model_parts_and_thicknesses.values()):
-            raise RuntimeError("fixed_model_parts_thicknesses should exist in physical_thicknesses !")
-
-        helmholtz_settings = GetImplicitFilterParameters(self.model_part_operation.GetModelPartFullName(), self.parameters)
-
-        # create implicit filter using Helmholtz analysis
-        self.filter = HelmholtzAnalysis(self.model, helmholtz_settings)
-
-        self.is_initialized = False
-
-    def Initialize(self) -> None:
-        self.model_part = self.model_part_operation.GetModelPart()
-
-        if not KratosOA.ModelPartUtils.CheckModelPartStatus(self.model_part, "element_specific_properties_created"):
-            KratosOA.OptimizationUtils.CreateEntitySpecificPropertiesForContainer(self.model_part, self.model_part.Elements)
-            KratosOA.ModelPartUtils.LogModelPartStatus(self.model_part, "element_specific_properties_created")
-
-        # initiliaze the filter
-        self.filter.Initialize()
-        # compute control thickness field from the initial physical control field
-        physical_thickness_field = Kratos.Expression.ElementExpression(self.model_part)
-        Kratos.Expression.LiteralExpressionIO.SetData(physical_thickness_field, self.parameters["initial_physical_thickness"].GetDouble())
-        # project backward the uniform physical control field and assign it to the control field
-        self.control_field = KratosOA.ControlUtils.SigmoidalProjectionUtils.ProjectBackward(
-                                                physical_thickness_field,
-                                                self.filtered_thicknesses,
-                                                self.physical_thicknesses,
-                                                self.beta,
-                                                self.penalty_power)
-        # now update the physical thickness field
-        self._UpdateAndOutputFields()
-        self.is_initialized = True
-
-    def Check(self) -> None:
-        return self.filter.Check()
-
-    def Finalize(self) -> None:
-        return self.filter.Finalize()
-
-    def GetPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
-        return [Kratos.THICKNESS]
-
-    def GetEmptyField(self) -> ContainerExpressionTypes:
-        field = Kratos.Expression.ElementExpression(self.model_part)
-        Kratos.Expression.LiteralExpressionIO.SetData(field, 0.0)
-        return field
-
-    def GetControlField(self) -> ContainerExpressionTypes:
-        return self.control_field
-
-    def GetPhysicalField(self) -> ContainerExpressionTypes:
-        physical_thickness_field = Kratos.Expression.ElementExpression(self.model_part)
-        KratosOA.PropertiesVariableExpressionIO.Read(physical_thickness_field, Kratos.THICKNESS)
-        return physical_thickness_field
-
-    def MapGradient(self, physical_gradient_variable_container_expression_map: 'dict[SupportedSensitivityFieldVariableTypes, ContainerExpressionTypes]') -> ContainerExpressionTypes:
-        with TimeLogger("ShellThicknessControl::MapGradient", None, "Finished",False):
-            keys = physical_gradient_variable_container_expression_map.keys()
-            if len(keys) != 1:
-                raise RuntimeError(f"Provided more than required gradient fields for control \"{self.GetName()}\". Following are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
-            if Kratos.THICKNESS not in keys:
-                raise RuntimeError(f"The required gradient for control \"{self.GetName()}\" w.r.t. {Kratos.THICKNESS.Name()} not found. Followings are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
-
-            physical_gradient = physical_gradient_variable_container_expression_map[Kratos.THICKNESS]
-            if not IsSameContainerExpression(physical_gradient, self.GetEmptyField()):
-                raise RuntimeError(f"Gradients for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.model_part.FullName()}, given model part name: {physical_gradient.GetModelPart().FullName()} ]")
-
-            # multiply the physical sensitivity field with projection derivatives
-            projected_gradient = physical_gradient * self.projection_derivative_field
-            # now filter the field
-            filtered_gradient = self.filter.FilterIntegratedField(projected_gradient)
-
-            return filtered_gradient
-
-    def Update(self, new_control_field: ContainerExpressionTypes) -> bool:
-        if not IsSameContainerExpression(new_control_field, self.GetEmptyField()):
-            raise RuntimeError(f"Updates for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.model_part.FullName()}, given model part name: {new_control_field.GetModelPart().FullName()} ]")
-
-        if KratosOA.ExpressionUtils.NormL2(self.control_field - new_control_field) > 1e-15:
-            with TimeLogger(self.__class__.__name__, f"Updating {self.GetName()}...", f"Finished updating of {self.GetName()}.",False):
-                # update the control thickness field
-                self.control_field = new_control_field
-                # now update the physical field
-                self._UpdateAndOutputFields()
-                return True
-        return False
-
-    def _UpdateAndOutputFields(self) -> None:
-        # apply boundary conditions for the forward filtering
-        self._SetFixedModelPartValues()
-        # filter the control field
-        filtered_thickness_field = self.filter.FilterField(self.control_field)
-        # project forward the filtered thickness field
-        projected_filtered_thickness_field = KratosOA.ControlUtils.SigmoidalProjectionUtils.ProjectForward(
-                                                filtered_thickness_field,
-                                                self.filtered_thicknesses,
-                                                self.physical_thicknesses,
-                                                self.beta,
-                                                self.penalty_power)
-        # now update physical field
-        KratosOA.PropertiesVariableExpressionIO.Write(projected_filtered_thickness_field, Kratos.THICKNESS)
-        # compute and strore projection derivatives for consistent filtering of the sensitivities
-        self.projection_derivative_field = KratosOA.ControlUtils.SigmoidalProjectionUtils.CalculateForwardProjectionGradient(
-                                                filtered_thickness_field,
-                                                self.filtered_thicknesses,
-                                                self.physical_thicknesses,
-                                                self.beta,
-                                                self.penalty_power)
-        # apply boundary conditions for the filtering of the sensitivites
-        self._SetFixedModelPartValues(True)
-        # now output the fields
-        un_buffered_data = ComponentDataView(self, self.optimization_problem).GetUnBufferedData()
-        un_buffered_data.SetValue("physical_thickness", projected_filtered_thickness_field.Clone(),overwrite=self.is_initialized)
-        if self.output_all_fields:
-            un_buffered_data.SetValue("filtered_thickness", filtered_thickness_field.Clone(),overwrite=self.is_initialized)
-            un_buffered_data.SetValue("control_thickness", self.control_field.Clone(),overwrite=self.is_initialized)
-            un_buffered_data.SetValue("projection_derivative", self.projection_derivative_field.Clone(),overwrite=self.is_initialized)
-
-    def _SetFixedModelPartValues(self, is_backward = False) -> None:
-        for model_parts_name, model_parts_thickness in self.fixed_model_parts_and_thicknesses.items():
-            if is_backward:
-                model_parts_thickness = 0.0
-            field =  Kratos.Expression.NodalExpression(self.model[model_parts_name])
-            Kratos.Expression.LiteralExpressionIO.SetData(field, model_parts_thickness)
-            Kratos.Expression.VariableExpressionIO.Write(field, KratosOA.HELMHOLTZ_SCALAR, True)
-
-    def __str__(self) -> str:
-        return f"Control [type = {self.__class__.__name__}, name = {self.GetName()}, model part name = {self.model_part.FullName()}, control variable = {Kratos.THICKNESS.Name()}"
+from typing import Optional
+
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.controls.control import Control
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import IsSameContainerExpression
+from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.filtering.filter import Factory as FilterFactory
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> Control:
+    if not parameters.Has("name"):
+        raise RuntimeError(f"ShellThicknessControl instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"ShellThicknessControl instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+
+    return ShellThicknessControl(parameters["name"].GetString(), model, parameters["settings"], optimization_problem)
+
+class ShellThicknessControl(Control):
+    """Shell thickness control
+
+    This is filtering-based discrete thickness control which parametrizes and controls
+    shell elements thickness.
+
+    """
+    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        super().__init__(name)
+
+        self.parameters = parameters
+        self.model = model
+        self.optimization_problem = optimization_problem
+
+        default_settings = Kratos.Parameters("""{
+            "controlled_model_part_names": [],
+            "filter_settings"            : {},
+            "penalty_power"              : 1,
+            "output_all_fields"          : false,
+            "physical_thicknesses"       : [],
+            "beta_settings": {
+                "initial_value": 5,
+                "max_value"    : 30,
+                "adaptive"     : true,
+                "increase_fac" : 1.05,
+                "update_period": 50
+            }
+        }""")
+
+        self.parameters.ValidateAndAssignDefaults(default_settings)
+
+        controlled_model_names_parts = parameters["controlled_model_part_names"].GetStringArray()
+        if len(controlled_model_names_parts) == 0:
+            raise RuntimeError(f"No model parts were provided for ShellThicknessControl. [ control name = \"{self.GetName()}\"]")
+
+        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"control_{self.GetName()}", self.parameters["controlled_model_part_names"].GetStringArray(), False)
+        self.model_part: 'Optional[Kratos.ModelPart]' = None
+
+        self.filter = FilterFactory(self.model, self.model_part_operation.GetModelPartFullName(), Kratos.THICKNESS, Kratos.Globals.DataLocation.Element, self.parameters["filter_settings"])
+
+        self.penalty_power = self.parameters["penalty_power"].GetInt()
+        self.output_all_fields = self.parameters["output_all_fields"].GetBool()
+        self.physical_thicknesses = self.parameters["physical_thicknesses"].GetVector()
+
+        # beta settings
+        beta_settings = parameters["beta_settings"]
+        beta_settings.ValidateAndAssignDefaults(default_settings["beta_settings"])
+        self.beta = beta_settings["initial_value"].GetDouble()
+        self.beta_max = beta_settings["max_value"].GetDouble()
+        self.beta_adaptive = beta_settings["adaptive"].GetBool()
+        self.beta_increase_frac = beta_settings["increase_fac"].GetDouble()
+        self.beta_update_period = beta_settings["update_period"].GetInt()
+        self.beta_computed_step = 1
+
+        num_phys_thick = len(self.physical_thicknesses)
+        if num_phys_thick == 0:
+            raise RuntimeError("The physical_thicknesses can not be empty, at least min and max should be provided.")
+        self.filtered_thicknesses = [i for i, _ in enumerate(self.physical_thicknesses)]
+
+    def Initialize(self) -> None:
+        self.model_part = self.model_part_operation.GetModelPart()
+
+        if not KratosOA.OptAppModelPartUtils.CheckModelPartStatus(self.model_part, "element_specific_properties_created"):
+            KratosOA.OptimizationUtils.CreateEntitySpecificPropertiesForContainer(self.model_part, self.model_part.Elements)
+            KratosOA.OptAppModelPartUtils.LogModelPartStatus(self.model_part, "element_specific_properties_created")
+
+        # initialize the filter
+        self.filter.SetComponentDataView(ComponentDataView(self, self.optimization_problem))
+        self.filter.Initialize()
+
+        physical_thickness_field = Kratos.Expression.ElementExpression(self.model_part)
+        KratosOA.PropertiesVariableExpressionIO.Read(physical_thickness_field, Kratos.THICKNESS)
+
+        # project backward the uniform physical control field and assign it to the control field
+        self.physical_phi_field = KratosOA.ControlUtils.SigmoidalProjectionUtils.ProjectBackward(
+                                                physical_thickness_field,
+                                                self.filtered_thicknesses,
+                                                self.physical_thicknesses,
+                                                self.beta,
+                                                self.penalty_power)
+
+        # take the physical and control field the same
+        self.control_phi_field = self.filter.UnfilterField(self.physical_phi_field)
+
+        # now update the physical thickness field
+        self._UpdateAndOutputFields(self.GetEmptyField())
+
+    def Check(self) -> None:
+        self.filter.Check()
+
+    def Finalize(self) -> None:
+        self.filter.Finalize()
+
+    def GetPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
+        return [Kratos.THICKNESS]
+
+    def GetEmptyField(self) -> ContainerExpressionTypes:
+        field = Kratos.Expression.ElementExpression(self.model_part)
+        Kratos.Expression.LiteralExpressionIO.SetData(field, 0.0)
+        return field
+
+    def GetControlField(self) -> ContainerExpressionTypes:
+        return self.control_phi_field
+
+    def GetPhysicalField(self) -> ContainerExpressionTypes:
+        physical_thickness_field = Kratos.Expression.ElementExpression(self.model_part)
+        KratosOA.PropertiesVariableExpressionIO.Read(physical_thickness_field, Kratos.THICKNESS)
+        return physical_thickness_field
+
+    def MapGradient(self, physical_gradient_variable_container_expression_map: 'dict[SupportedSensitivityFieldVariableTypes, ContainerExpressionTypes]') -> ContainerExpressionTypes:
+        with TimeLogger("ShellThicknessControl::MapGradient", None, "Finished",False):
+            keys = physical_gradient_variable_container_expression_map.keys()
+            if len(keys) != 1:
+                raise RuntimeError(f"Provided more than required gradient fields for control \"{self.GetName()}\". Following are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
+            if Kratos.THICKNESS not in keys:
+                raise RuntimeError(f"The required gradient for control \"{self.GetName()}\" w.r.t. {Kratos.THICKNESS.Name()} not found. Followings are the variables:\n\t" + "\n\t".join([k.Name() for k in keys]))
+
+            physical_gradient = physical_gradient_variable_container_expression_map[Kratos.THICKNESS]
+            if not IsSameContainerExpression(physical_gradient, self.GetEmptyField()):
+                raise RuntimeError(f"Gradients for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.model_part.FullName()}, given model part name: {physical_gradient.GetModelPart().FullName()} ]")
+
+            # multiply the physical sensitivity field with projection derivatives
+            projected_gradient = physical_gradient * self.projection_derivative_field
+            # now filter the field
+            filtered_gradient = self.filter.BackwardFilterIntegratedField(projected_gradient)
+
+            return filtered_gradient
+
+    def Update(self, new_control_field: ContainerExpressionTypes) -> bool:
+        if not IsSameContainerExpression(new_control_field, self.GetEmptyField()):
+            raise RuntimeError(f"Updates for the required element container not found for control \"{self.GetName()}\". [ required model part name: {self.model_part.FullName()}, given model part name: {new_control_field.GetModelPart().FullName()} ]")
+
+        update = new_control_field - self.control_phi_field
+        if Kratos.Expression.Utils.NormL2(update) > 1e-15:
+            with TimeLogger(self.__class__.__name__, f"Updating {self.GetName()}...", f"Finished updating of {self.GetName()}.",False):
+                # update the control thickness field
+                self.control_phi_field = new_control_field
+                # now update the physical field
+                self._UpdateAndOutputFields(update)
+
+                self.filter.Update()
+
+                self.__UpdateBeta()
+                return True
+        return False
+
+    def __UpdateBeta(self) -> None:
+        if self.beta_adaptive:
+            step = self.optimization_problem.GetStep()
+            if step % self.beta_update_period == 0 and self.beta_computed_step != step:
+                self.beta_computed_step = step
+                self.beta = min(self.beta * self.beta_increase_frac, self.beta_max)
+                Kratos.Logger.PrintInfo(f"::{self.GetName()}::", f"Increased beta to {self.beta}.")
+
+    def _UpdateAndOutputFields(self, update: ContainerExpressionTypes) -> None:
+        # filter the control field
+        filtered_thickness_field_update = self.filter.ForwardFilterField(update)
+        self.physical_phi_field = Kratos.Expression.Utils.Collapse(self.physical_phi_field + filtered_thickness_field_update)
+
+        # project forward the filtered thickness field
+        projected_filtered_thickness_field = KratosOA.ControlUtils.SigmoidalProjectionUtils.ProjectForward(
+                                                self.physical_phi_field,
+                                                self.filtered_thicknesses,
+                                                self.physical_thicknesses,
+                                                self.beta,
+                                                self.penalty_power)
+        # now update physical field
+        KratosOA.PropertiesVariableExpressionIO.Write(projected_filtered_thickness_field, Kratos.THICKNESS)
+
+        # compute and stroe projection derivatives for consistent filtering of the sensitivities
+        self.projection_derivative_field = KratosOA.ControlUtils.SigmoidalProjectionUtils.CalculateForwardProjectionGradient(
+                                                self.physical_phi_field,
+                                                self.filtered_thicknesses,
+                                                self.physical_thicknesses,
+                                                self.beta,
+                                                self.penalty_power)
+
+        # now output the fields
+        un_buffered_data = ComponentDataView(self, self.optimization_problem).GetUnBufferedData()
+        un_buffered_data.SetValue("physical_thickness", projected_filtered_thickness_field.Clone(),overwrite=True)
+        if self.output_all_fields:
+            un_buffered_data.SetValue("filtered_thickness_update", filtered_thickness_field_update.Clone(), overwrite=True)
+            un_buffered_data.SetValue("control_thickness_phi", self.control_phi_field.Clone(), overwrite=True)
+            un_buffered_data.SetValue("physical_thickness_phi", self.physical_phi_field.Clone(), overwrite=True)
+            un_buffered_data.SetValue("projection_derivative", self.projection_derivative_field.Clone(), overwrite=True)
+
+    def __str__(self) -> str:
+        return f"Control [type = {self.__class__.__name__}, name = {self.GetName()}, model part name = {self.model_part.FullName()}, control variable = {Kratos.THICKNESS.Name()}"
```

## KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy.py

```diff
@@ -1,29 +1,46 @@
-from abc import ABC, abstractmethod
-import KratosMultiphysics as Kratos
-
-class ExecutionPolicy(ABC):
-    def __init__(self, execution_policy_name: str) -> None:
-        self.__name = execution_policy_name
-
-    def GetName(self) -> str:
-        return self.__name
-
-    @abstractmethod
-    def Initialize(self) -> None:
-        pass
-
-    @abstractmethod
-    def Check(self) -> None:
-        pass
-
-    @abstractmethod
-    def Finalize(self) -> None:
-        pass
-
-    @abstractmethod
-    def GetAnalysisModelPart(self) -> Kratos.ModelPart:
-        pass
-
-    @abstractmethod
-    def Execute(self) -> None:
+from abc import ABC, abstractmethod
+import KratosMultiphysics as Kratos
+
+class ExecutionPolicy(ABC):
+    """Base class for execution policy
+
+    This represents the base class for the execution policy which
+    can be used to execute primal analysis to obtain response function
+    values and their gradients.
+
+    """
+    def __init__(self, execution_policy_name: str) -> None:
+        self.__name = execution_policy_name
+
+    def GetName(self) -> str:
+        return self.__name
+
+    @abstractmethod
+    def Initialize(self) -> None:
+        pass
+
+    @abstractmethod
+    def Check(self) -> None:
+        pass
+
+    @abstractmethod
+    def Finalize(self) -> None:
+        pass
+
+    @abstractmethod
+    def GetAnalysisModelPart(self) -> Kratos.ModelPart:
+        """Returns the analysis model part.
+
+        Each execution policy will be using a domain to compute the primal model part.
+        This method should return that domain as a Kratos::ModelPart.
+
+        Returns:
+            Kratos.ModelPart: Domain used to compute the primal solution.
+        """
+        pass
+
+    @abstractmethod
+    def Execute(self) -> None:
+        """Solves the associated primal problem.
+        """
         pass
```

## KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy_decorator.py

 * *Ordering differences only*

```diff
@@ -1,67 +1,67 @@
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.model_parameters_factory import KratosModelParametersFactory
-from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import FileLogger
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import OptimizationComponentFactory
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
-
-class ExecutionPolicyDecorator(ExecutionPolicy):
-    def __init__(self, model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        default_parameters = Kratos.Parameters("""{
-            "name"           : "",
-            "type"           : "please_provide_python_module_name",
-            "module"         : "KratosMultiphysics.OptimizationApplication.execution_policies",
-            "pre_operations" : [],
-            "post_operations": [],
-            "log_in_file"    : false,
-            "log_file_name"  : "",
-            "settings"       : {}
-        }""")
-        parameters.ValidateAndAssignDefaults(default_parameters)
-
-        super().__init__(parameters["name"].GetString())
-
-        self.__log_file_name = parameters["log_file_name"].GetString()
-        self.__log_in_file = parameters["log_in_file"].GetBool()
-
-        if self.__log_in_file and self.__log_file_name == "":
-            raise RuntimeError("Logger file name is empty for execution policy. Please provide \"log_file_name\" or make \"log_in_file\" to false.")
-
-        factory = KratosModelParametersFactory(model)
-
-        # create operations
-        self.__list_of_pre_operations: 'list[Kratos.Operation]' = factory.ConstructListOfItems(parameters["pre_operations"])
-        self.__list_of_post_operations: 'list[Kratos.Operation]' = factory.ConstructListOfItems(parameters["post_operations"])
-
-        # create execution policy
-        self.__execution_policy: ExecutionPolicy = OptimizationComponentFactory(model, parameters, optimization_problem)
-
-    def GetExecutionPolicy(self):
-        return self.__execution_policy
-
-    def GetAnalysisModelPart(self) -> Kratos.ModelPart:
-        return self.__execution_policy.GetAnalysisModelPart()
-
-    def Initialize(self):
-        self.__execution_policy.Initialize()
-
-    def Check(self):
-        self.__execution_policy.Check()
-
-    def Finalize(self):
-        self.__execution_policy.Finalize()
-
-    def Execute(self):
-        with TimeLogger(f"ExecutionPolicyDecorator::Executing {self.GetName()}", None, "Finished"):
-            if self.__log_in_file:
-                with FileLogger(self.__log_file_name):
-                    self.__ExecuteWithoutFileLogger()
-            else:
-                self.__ExecuteWithoutFileLogger()
-
-    def __ExecuteWithoutFileLogger(self):
-        CallOnAll(self.__list_of_pre_operations, Kratos.Operation.Execute)
-        self.__execution_policy.Execute()
-        CallOnAll(self.__list_of_post_operations, Kratos.Operation.Execute)
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.model_parameters_factory import KratosModelParametersFactory
+from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import FileLogger
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import OptimizationComponentFactory
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import CallOnAll
+
+class ExecutionPolicyDecorator(ExecutionPolicy):
+    def __init__(self, model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        default_parameters = Kratos.Parameters("""{
+            "name"           : "",
+            "type"           : "please_provide_python_module_name",
+            "module"         : "KratosMultiphysics.OptimizationApplication.execution_policies",
+            "pre_operations" : [],
+            "post_operations": [],
+            "log_in_file"    : false,
+            "log_file_name"  : "",
+            "settings"       : {}
+        }""")
+        parameters.ValidateAndAssignDefaults(default_parameters)
+
+        super().__init__(parameters["name"].GetString())
+
+        self.__log_file_name = parameters["log_file_name"].GetString()
+        self.__log_in_file = parameters["log_in_file"].GetBool()
+
+        if self.__log_in_file and self.__log_file_name == "":
+            raise RuntimeError("Logger file name is empty for execution policy. Please provide \"log_file_name\" or make \"log_in_file\" to false.")
+
+        factory = KratosModelParametersFactory(model)
+
+        # create operations
+        self.__list_of_pre_operations: 'list[Kratos.Operation]' = factory.ConstructListOfItems(parameters["pre_operations"])
+        self.__list_of_post_operations: 'list[Kratos.Operation]' = factory.ConstructListOfItems(parameters["post_operations"])
+
+        # create execution policy
+        self.__execution_policy: ExecutionPolicy = OptimizationComponentFactory(model, parameters, optimization_problem)
+
+    def GetExecutionPolicy(self):
+        return self.__execution_policy
+
+    def GetAnalysisModelPart(self) -> Kratos.ModelPart:
+        return self.__execution_policy.GetAnalysisModelPart()
+
+    def Initialize(self):
+        self.__execution_policy.Initialize()
+
+    def Check(self):
+        self.__execution_policy.Check()
+
+    def Finalize(self):
+        self.__execution_policy.Finalize()
+
+    def Execute(self):
+        with TimeLogger(f"ExecutionPolicyDecorator::Executing {self.GetName()}", None, "Finished"):
+            if self.__log_in_file:
+                with FileLogger(self.__log_file_name):
+                    self.__ExecuteWithoutFileLogger()
+            else:
+                self.__ExecuteWithoutFileLogger()
+
+    def __ExecuteWithoutFileLogger(self):
+        CallOnAll(self.__list_of_pre_operations, Kratos.Operation.Execute)
+        self.__execution_policy.Execute()
+        CallOnAll(self.__list_of_post_operations, Kratos.Operation.Execute)
```

## KratosMultiphysics/OptimizationApplication/execution_policies/independent_analysis_execution_policy.py

 * *Ordering differences only*

```diff
@@ -1,78 +1,78 @@
-from typing import Union
-from importlib import import_module
-
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.analysis_stage import AnalysisStage
-from KratosMultiphysics.project import Project
-from KratosMultiphysics.orchestrators.orchestrator import Orchestrator
-from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetClassModuleFromKratos
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> ExecutionPolicy:
-    if not parameters.Has("name"):
-        raise RuntimeError(f"IndependentAnalysisExecutionPolicy instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"IndependentAnalysisExecutionPolicy instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-
-    return IndependentAnalysisExecutionPolicy(parameters["name"].GetString(), model, parameters["settings"])
-
-class IndependentAnalysisExecutionPolicy(ExecutionPolicy):
-    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters):
-        super().__init__(name)
-
-        self.model = model
-
-        default_settings = Kratos.Parameters("""{
-            "analysis_module"         : "KratosMultiphysics",
-            "analysis_type"           : "",
-            "analysis_model_part_name": "",
-            "analysis_settings"       : {}
-        }""")
-
-        parameters.ValidateAndAssignDefaults(default_settings)
-
-        self.analysis_module = parameters["analysis_module"].GetString()
-        self.analysis_type = parameters["analysis_type"].GetString()
-        self.analysis_settings = parameters["analysis_settings"]
-        self.analysis_model_part_name = parameters["analysis_model_part_name"].GetString()
-
-        if self.analysis_module == "KratosMultiphysics":
-            self.analysis_full_module, self.analysis_type = GetClassModuleFromKratos(self.analysis_type)
-        else:
-            self.analysis_full_module = f"{self.analysis_module}.{Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(self.analysis_type)}"
-
-
-    def Initialize(self) -> None:
-        pass
-
-    def Check(self) -> None:
-        pass
-
-    def Finalize(self) -> None:
-        pass
-
-    def Execute(self):
-        analysis_type = getattr(import_module(self.analysis_full_module), self.analysis_type)
-        if AnalysisStage in analysis_type.mro():
-            # the analysis type is derrived from AnalysisStage
-            self.current_analysis: AnalysisStage = getattr(import_module(self.analysis_full_module), self.analysis_type)(self.model, self.analysis_settings.Clone())
-        elif Orchestrator in analysis_type.mro():
-            # the analysis type is derrive from the Orchestrator
-            project = Project(self.analysis_settings.Clone())
-            self.current_analysis: Orchestrator = getattr(import_module(self.analysis_full_module), self.analysis_type)(project)
-
-        self.current_analysis.Run()
-
-    def GetAnalysisModelPart(self):
-        if self.current_analysis is not None:
-            if isinstance(self.current_analysis, AnalysisStage):
-                if self.analysis_model_part_name == "" or self.analysis_model_part_name == self.current_analysis._GetSolver().GetComputingModelPart().FullName():
-                    return self.current_analysis._GetSolver().GetComputingModelPart()
-                else:
-                    raise RuntimeError(f"The specified analysis model part name mismatch [ specified analysis model part name = {self.analysis_model_part_name}, used analysis model part name = {self.current_analysis._GetSolver().GetComputingModelPart().FullName()} ].")
-            elif isinstance(self.current_analysis, Orchestrator):
-                return self.current_analysis.GetProject().GetModel()[self.analysis_model_part_name]
-            else:
-                raise RuntimeError(f"Unsupported analysis type = {self.current_analysis}.")
-        else:
-            raise RuntimeError("The analysis is not run yet.")
+from typing import Union
+from importlib import import_module
+
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.analysis_stage import AnalysisStage
+from KratosMultiphysics.project import Project
+from KratosMultiphysics.orchestrators.orchestrator import Orchestrator
+from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetClassModuleFromKratos
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> ExecutionPolicy:
+    if not parameters.Has("name"):
+        raise RuntimeError(f"IndependentAnalysisExecutionPolicy instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"IndependentAnalysisExecutionPolicy instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+
+    return IndependentAnalysisExecutionPolicy(parameters["name"].GetString(), model, parameters["settings"])
+
+class IndependentAnalysisExecutionPolicy(ExecutionPolicy):
+    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters):
+        super().__init__(name)
+
+        self.model = model
+
+        default_settings = Kratos.Parameters("""{
+            "analysis_module"         : "KratosMultiphysics",
+            "analysis_type"           : "",
+            "analysis_model_part_name": "",
+            "analysis_settings"       : {}
+        }""")
+
+        parameters.ValidateAndAssignDefaults(default_settings)
+
+        self.analysis_module = parameters["analysis_module"].GetString()
+        self.analysis_type = parameters["analysis_type"].GetString()
+        self.analysis_settings = parameters["analysis_settings"]
+        self.analysis_model_part_name = parameters["analysis_model_part_name"].GetString()
+
+        if self.analysis_module == "KratosMultiphysics":
+            self.analysis_full_module, self.analysis_type = GetClassModuleFromKratos(self.analysis_type)
+        else:
+            self.analysis_full_module = f"{self.analysis_module}.{Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(self.analysis_type)}"
+
+
+    def Initialize(self) -> None:
+        pass
+
+    def Check(self) -> None:
+        pass
+
+    def Finalize(self) -> None:
+        pass
+
+    def Execute(self):
+        analysis_type = getattr(import_module(self.analysis_full_module), self.analysis_type)
+        if AnalysisStage in analysis_type.mro():
+            # the analysis type is derrived from AnalysisStage
+            self.current_analysis: AnalysisStage = getattr(import_module(self.analysis_full_module), self.analysis_type)(self.model, self.analysis_settings.Clone())
+        elif Orchestrator in analysis_type.mro():
+            # the analysis type is derrive from the Orchestrator
+            project = Project(self.analysis_settings.Clone())
+            self.current_analysis: Orchestrator = getattr(import_module(self.analysis_full_module), self.analysis_type)(project)
+
+        self.current_analysis.Run()
+
+    def GetAnalysisModelPart(self):
+        if self.current_analysis is not None:
+            if isinstance(self.current_analysis, AnalysisStage):
+                if self.analysis_model_part_name == "" or self.analysis_model_part_name == self.current_analysis._GetSolver().GetComputingModelPart().FullName():
+                    return self.current_analysis._GetSolver().GetComputingModelPart()
+                else:
+                    raise RuntimeError(f"The specified analysis model part name mismatch [ specified analysis model part name = {self.analysis_model_part_name}, used analysis model part name = {self.current_analysis._GetSolver().GetComputingModelPart().FullName()} ].")
+            elif isinstance(self.current_analysis, Orchestrator):
+                return self.current_analysis.GetProject().GetModel()[self.analysis_model_part_name]
+            else:
+                raise RuntimeError(f"Unsupported analysis type = {self.current_analysis}.")
+        else:
+            raise RuntimeError("The analysis is not run yet.")
```

## KratosMultiphysics/OptimizationApplication/execution_policies/kratos_analysis_execution_policy.py

 * *Ordering differences only*

```diff
@@ -1,110 +1,110 @@
-from importlib import import_module
-from typing import Any
-
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.analysis_stage import AnalysisStage
-from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetClassModuleFromKratos
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> ExecutionPolicy:
-    if not parameters.Has("name"):
-        raise RuntimeError(f"KratosAnalysisExecutionPolicy instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"KratosAnalysisExecutionPolicy instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-
-    return KratosAnalysisExecutionPolicy(parameters["name"].GetString(), model, parameters["settings"], optimization_problem)
-
-class KratosAnalysisExecutionPolicy(ExecutionPolicy):
-    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        super().__init__(name)
-
-        default_settings = Kratos.Parameters("""{
-            "model_part_names" : [],
-            "analysis_module"  : "KratosMultiphysics",
-            "analysis_type"    : "",
-            "analysis_settings": {},
-            "analysis_output_settings": {
-                     "nodal_solution_step_data_variables": [],
-                     "nodal_data_value_variables"        : [],
-                     "element_data_value_variables"      : [],
-                     "condition_data_value_variables"    : []
-            }
-        }""")
-        self.model = model
-        self.parameters = parameters
-        self.optimization_problem = optimization_problem
-        self.parameters.ValidateAndAssignDefaults(default_settings)
-        self.parameters["analysis_output_settings"].ValidateAndAssignDefaults(default_settings["analysis_output_settings"])
-
-        analysis_module = parameters["analysis_module"].GetString()
-        analysis_type = parameters["analysis_type"].GetString()
-        analysis_settings = parameters["analysis_settings"]
-
-        if analysis_module == "KratosMultiphysics":
-            analysis_full_module, analysis_type = GetClassModuleFromKratos(analysis_type)
-        else:
-            analysis_full_module = f"{analysis_module}.{Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(analysis_type)}"
-
-        self.model_parts: 'list[Kratos.ModelPart]' = []
-        self.analysis: AnalysisStage = getattr(import_module(analysis_full_module), analysis_type)(self.model, analysis_settings.Clone())
-
-        analysis_output_settings = self.parameters["analysis_output_settings"]
-        analysis_output_settings.ValidateAndAssignDefaults(default_settings["analysis_output_settings"])
-        self.nodal_solution_step_data_variables = KratosAnalysisExecutionPolicy.__GetVariablesList(analysis_output_settings["nodal_solution_step_data_variables"].GetStringArray())
-        self.nodal_data_value_variables = KratosAnalysisExecutionPolicy.__GetVariablesList(analysis_output_settings["nodal_data_value_variables"].GetStringArray())
-        self.element_data_value_variables = KratosAnalysisExecutionPolicy.__GetVariablesList(analysis_output_settings["element_data_value_variables"].GetStringArray())
-        self.condition_data_value_variables = KratosAnalysisExecutionPolicy.__GetVariablesList(analysis_output_settings["condition_data_value_variables"].GetStringArray())
-
-    def GetAnalysisModelPart(self):
-        return self.analysis._GetSolver().GetComputingModelPart()
-
-    def Initialize(self):
-        self.analysis.Initialize()
-
-        # initialize model parts
-        self.model_parts = [self.model[model_part_name] for model_part_name in self.parameters["model_part_names"].GetStringArray()]
-
-    def Check(self) -> None:
-        pass
-
-    def Finalize(self) -> None:
-        self.analysis.Finalize()
-
-    def Execute(self):
-        self.analysis.time = self.analysis.project_parameters["problem_data"]["start_time"].GetDouble()
-        for model_part in self.model_parts:
-            model_part.ProcessInfo.SetValue(Kratos.STEP, 0)
-            model_part.ProcessInfo.SetValue(Kratos.TIME, 0)
-            model_part.ProcessInfo.SetValue(Kratos.DELTA_TIME, 0)
-        self.analysis.RunSolutionLoop()
-
-        self._OutputAnalysisData()
-
-    def _OutputAnalysisData(self):
-        unbuffered_data = ComponentDataView(self, self.optimization_problem).GetUnBufferedData()
-        for model_part in self.model_parts:
-            for variable in self.nodal_solution_step_data_variables:
-                nodal_field = Kratos.Expression.NodalExpression(model_part)
-                Kratos.Expression.VariableExpressionIO.Read(nodal_field, variable, True)
-                unbuffered_data.SetValue(variable.Name(), nodal_field.Clone(), overwrite=True)
-            for variable in self.nodal_data_value_variables:
-                nodal_field = Kratos.Expression.NodalExpression(model_part)
-                Kratos.Expression.VariableExpressionIO.Read(nodal_field, variable, False)
-                unbuffered_data.SetValue(variable.Name(), nodal_field.Clone(), overwrite=True)
-            for variable in self.element_data_value_variables:
-                elem_field = Kratos.Expression.ElementExpression(model_part)
-                Kratos.Expression.VariableExpressionIO.Read(elem_field, variable)
-                unbuffered_data.SetValue(variable.Name(), elem_field.Clone(), overwrite=True)
-            for variable in self.condition_data_value_variables:
-                cond_field = Kratos.Expression.ConditionExpression(model_part)
-                Kratos.Expression.VariableExpressionIO.Read(cond_field, variable)
-                unbuffered_data.SetValue(variable.Name(), cond_field.Clone(), overwrite=True)
-
-    @staticmethod
-    def __GetVariablesList(variable_names_list: 'list[str]') -> 'list[Any]':
-        return [Kratos.KratosGlobals.GetVariable(variable_name) for variable_name in variable_names_list]
-
-
-
+from importlib import import_module
+from typing import Any
+
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.analysis_stage import AnalysisStage
+from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetClassModuleFromKratos
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> ExecutionPolicy:
+    if not parameters.Has("name"):
+        raise RuntimeError(f"KratosAnalysisExecutionPolicy instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"KratosAnalysisExecutionPolicy instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+
+    return KratosAnalysisExecutionPolicy(parameters["name"].GetString(), model, parameters["settings"], optimization_problem)
+
+class KratosAnalysisExecutionPolicy(ExecutionPolicy):
+    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        super().__init__(name)
+
+        default_settings = Kratos.Parameters("""{
+            "model_part_names" : [],
+            "analysis_module"  : "KratosMultiphysics",
+            "analysis_type"    : "",
+            "analysis_settings": {},
+            "analysis_output_settings": {
+                     "nodal_solution_step_data_variables": [],
+                     "nodal_data_value_variables"        : [],
+                     "element_data_value_variables"      : [],
+                     "condition_data_value_variables"    : []
+            }
+        }""")
+        self.model = model
+        self.parameters = parameters
+        self.optimization_problem = optimization_problem
+        self.parameters.ValidateAndAssignDefaults(default_settings)
+        self.parameters["analysis_output_settings"].ValidateAndAssignDefaults(default_settings["analysis_output_settings"])
+
+        analysis_module = parameters["analysis_module"].GetString()
+        analysis_type = parameters["analysis_type"].GetString()
+        analysis_settings = parameters["analysis_settings"]
+
+        if analysis_module == "KratosMultiphysics":
+            analysis_full_module, analysis_type = GetClassModuleFromKratos(analysis_type)
+        else:
+            analysis_full_module = f"{analysis_module}.{Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(analysis_type)}"
+
+        self.model_parts: 'list[Kratos.ModelPart]' = []
+        self.analysis: AnalysisStage = getattr(import_module(analysis_full_module), analysis_type)(self.model, analysis_settings.Clone())
+
+        analysis_output_settings = self.parameters["analysis_output_settings"]
+        analysis_output_settings.ValidateAndAssignDefaults(default_settings["analysis_output_settings"])
+        self.nodal_solution_step_data_variables = KratosAnalysisExecutionPolicy.__GetVariablesList(analysis_output_settings["nodal_solution_step_data_variables"].GetStringArray())
+        self.nodal_data_value_variables = KratosAnalysisExecutionPolicy.__GetVariablesList(analysis_output_settings["nodal_data_value_variables"].GetStringArray())
+        self.element_data_value_variables = KratosAnalysisExecutionPolicy.__GetVariablesList(analysis_output_settings["element_data_value_variables"].GetStringArray())
+        self.condition_data_value_variables = KratosAnalysisExecutionPolicy.__GetVariablesList(analysis_output_settings["condition_data_value_variables"].GetStringArray())
+
+    def GetAnalysisModelPart(self):
+        return self.analysis._GetSolver().GetComputingModelPart()
+
+    def Initialize(self):
+        self.analysis.Initialize()
+
+        # initialize model parts
+        self.model_parts = [self.model[model_part_name] for model_part_name in self.parameters["model_part_names"].GetStringArray()]
+
+    def Check(self) -> None:
+        pass
+
+    def Finalize(self) -> None:
+        self.analysis.Finalize()
+
+    def Execute(self):
+        self.analysis.time = self.analysis.project_parameters["problem_data"]["start_time"].GetDouble()
+        for model_part in self.model_parts:
+            model_part.ProcessInfo.SetValue(Kratos.STEP, 0)
+            model_part.ProcessInfo.SetValue(Kratos.TIME, 0)
+            model_part.ProcessInfo.SetValue(Kratos.DELTA_TIME, 0)
+        self.analysis.RunSolutionLoop()
+
+        self._OutputAnalysisData()
+
+    def _OutputAnalysisData(self):
+        unbuffered_data = ComponentDataView(self, self.optimization_problem).GetUnBufferedData()
+        for model_part in self.model_parts:
+            for variable in self.nodal_solution_step_data_variables:
+                nodal_field = Kratos.Expression.NodalExpression(model_part)
+                Kratos.Expression.VariableExpressionIO.Read(nodal_field, variable, True)
+                unbuffered_data.SetValue(variable.Name(), nodal_field.Clone(), overwrite=True)
+            for variable in self.nodal_data_value_variables:
+                nodal_field = Kratos.Expression.NodalExpression(model_part)
+                Kratos.Expression.VariableExpressionIO.Read(nodal_field, variable, False)
+                unbuffered_data.SetValue(variable.Name(), nodal_field.Clone(), overwrite=True)
+            for variable in self.element_data_value_variables:
+                elem_field = Kratos.Expression.ElementExpression(model_part)
+                Kratos.Expression.VariableExpressionIO.Read(elem_field, variable)
+                unbuffered_data.SetValue(variable.Name(), elem_field.Clone(), overwrite=True)
+            for variable in self.condition_data_value_variables:
+                cond_field = Kratos.Expression.ConditionExpression(model_part)
+                Kratos.Expression.VariableExpressionIO.Read(cond_field, variable)
+                unbuffered_data.SetValue(variable.Name(), cond_field.Clone(), overwrite=True)
+
+    @staticmethod
+    def __GetVariablesList(variable_names_list: 'list[str]') -> 'list[Any]':
+        return [Kratos.KratosGlobals.GetVariable(variable_name) for variable_name in variable_names_list]
+
+
+
```

## KratosMultiphysics/OptimizationApplication/execution_policies/stepping_analysis_execution_policy.py

 * *Ordering differences only*

```diff
@@ -1,88 +1,88 @@
-from importlib import import_module
-
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.analysis_stage import AnalysisStage
-from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetClassModuleFromKratos
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> ExecutionPolicy:
-    if not parameters.Has("name"):
-        raise RuntimeError(f"SteppingAnalysisExecutionPolicy instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"SteppingAnalysisExecutionPolicy instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-
-    return SteppingAnalysisExecutionPolicy(parameters["name"].GetString(), model, parameters["settings"])
-
-class SteppingAnalysisExecutionPolicy(ExecutionPolicy):
-    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters):
-        super().__init__(name)
-
-        default_settings = Kratos.Parameters("""{
-            "model_part_names" : [],
-            "analysis_module"  : "KratosMultiphysics",
-            "analysis_type"    : "",
-            "analysis_settings": {}
-        }""")
-        self.model = model
-        self.parameters = parameters
-        self.parameters.ValidateAndAssignDefaults(default_settings)
-
-        analysis_module = parameters["analysis_module"].GetString()
-        analysis_type = parameters["analysis_type"].GetString()
-        analysis_settings = parameters["analysis_settings"]
-
-        if analysis_module == "KratosMultiphysics":
-            analysis_full_module, analysis_type = GetClassModuleFromKratos(analysis_type)
-        else:
-            analysis_full_module = f"{analysis_module}.{Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(analysis_type)}"
-
-        self.model_parts = []
-        self.analysis: AnalysisStage = getattr(import_module(analysis_full_module), analysis_type)(self.model, analysis_settings.Clone())
-
-    def GetAnalysisModelPart(self):
-        return self.analysis._GetSolver().GetComputingModelPart()
-
-    def Initialize(self):
-        self.analysis.Initialize()
-
-        # initialize model parts
-        self.model_parts = [self.model[model_part_name] for model_part_name in self.parameters["model_part_names"].GetStringArray()]
-
-    def Check(self) -> None:
-        pass
-
-    def Finalize(self) -> None:
-        pass
-
-    def Execute(self):
-        time_before_analysis = []
-        step_before_analysis = []
-        delta_time_before_analysis = []
-
-        for model_part in self.model_parts:
-            time_before_analysis.append(model_part.ProcessInfo[Kratos.TIME])
-            step_before_analysis.append(model_part.ProcessInfo[Kratos.STEP])
-            delta_time_before_analysis.append(model_part.ProcessInfo[Kratos.DELTA_TIME])
-
-        # Reset step/time iterators such that they match the optimization iteration after calling CalculateValue (which internally calls CloneTimeStep)
-        for index, model_part in enumerate(self.model_parts):
-            model_part.ProcessInfo.SetValue(Kratos.STEP, step_before_analysis[index] - 1)
-            model_part.ProcessInfo.SetValue(Kratos.TIME, time_before_analysis[index] - 1)
-            model_part.ProcessInfo.SetValue(Kratos.DELTA_TIME, 0)
-
-        self.analysis.time = self.analysis._GetSolver().AdvanceInTime(self.analysis.time)
-        self.analysis.InitializeSolutionStep()
-        self.analysis._GetSolver().Predict()
-        self.analysis._GetSolver().SolveSolutionStep()
-
-        self.analysis.FinalizeSolutionStep()
-        self.analysis.OutputSolutionStep()
-
-        # Clear results or modifications on model parts
-        for index, model_part in enumerate(self.model_parts):
-            model_part.ProcessInfo.SetValue(Kratos.STEP, step_before_analysis[index])
-            model_part.ProcessInfo.SetValue(Kratos.TIME, time_before_analysis[index])
-            model_part.ProcessInfo.SetValue(Kratos.DELTA_TIME, delta_time_before_analysis[index])
-
-
-
+from importlib import import_module
+
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.analysis_stage import AnalysisStage
+from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetClassModuleFromKratos
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> ExecutionPolicy:
+    if not parameters.Has("name"):
+        raise RuntimeError(f"SteppingAnalysisExecutionPolicy instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"SteppingAnalysisExecutionPolicy instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+
+    return SteppingAnalysisExecutionPolicy(parameters["name"].GetString(), model, parameters["settings"])
+
+class SteppingAnalysisExecutionPolicy(ExecutionPolicy):
+    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters):
+        super().__init__(name)
+
+        default_settings = Kratos.Parameters("""{
+            "model_part_names" : [],
+            "analysis_module"  : "KratosMultiphysics",
+            "analysis_type"    : "",
+            "analysis_settings": {}
+        }""")
+        self.model = model
+        self.parameters = parameters
+        self.parameters.ValidateAndAssignDefaults(default_settings)
+
+        analysis_module = parameters["analysis_module"].GetString()
+        analysis_type = parameters["analysis_type"].GetString()
+        analysis_settings = parameters["analysis_settings"]
+
+        if analysis_module == "KratosMultiphysics":
+            analysis_full_module, analysis_type = GetClassModuleFromKratos(analysis_type)
+        else:
+            analysis_full_module = f"{analysis_module}.{Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(analysis_type)}"
+
+        self.model_parts = []
+        self.analysis: AnalysisStage = getattr(import_module(analysis_full_module), analysis_type)(self.model, analysis_settings.Clone())
+
+    def GetAnalysisModelPart(self):
+        return self.analysis._GetSolver().GetComputingModelPart()
+
+    def Initialize(self):
+        self.analysis.Initialize()
+
+        # initialize model parts
+        self.model_parts = [self.model[model_part_name] for model_part_name in self.parameters["model_part_names"].GetStringArray()]
+
+    def Check(self) -> None:
+        pass
+
+    def Finalize(self) -> None:
+        pass
+
+    def Execute(self):
+        time_before_analysis = []
+        step_before_analysis = []
+        delta_time_before_analysis = []
+
+        for model_part in self.model_parts:
+            time_before_analysis.append(model_part.ProcessInfo[Kratos.TIME])
+            step_before_analysis.append(model_part.ProcessInfo[Kratos.STEP])
+            delta_time_before_analysis.append(model_part.ProcessInfo[Kratos.DELTA_TIME])
+
+        # Reset step/time iterators such that they match the optimization iteration after calling CalculateValue (which internally calls CloneTimeStep)
+        for index, model_part in enumerate(self.model_parts):
+            model_part.ProcessInfo.SetValue(Kratos.STEP, step_before_analysis[index] - 1)
+            model_part.ProcessInfo.SetValue(Kratos.TIME, time_before_analysis[index] - 1)
+            model_part.ProcessInfo.SetValue(Kratos.DELTA_TIME, 0)
+
+        self.analysis.time = self.analysis._GetSolver().AdvanceInTime(self.analysis.time)
+        self.analysis.InitializeSolutionStep()
+        self.analysis._GetSolver().Predict()
+        self.analysis._GetSolver().SolveSolutionStep()
+
+        self.analysis.FinalizeSolutionStep()
+        self.analysis.OutputSolutionStep()
+
+        # Clear results or modifications on model parts
+        for index, model_part in enumerate(self.model_parts):
+            model_part.ProcessInfo.SetValue(Kratos.STEP, step_before_analysis[index])
+            model_part.ProcessInfo.SetValue(Kratos.TIME, time_before_analysis[index])
+            model_part.ProcessInfo.SetValue(Kratos.DELTA_TIME, delta_time_before_analysis[index])
+
+
+
```

## KratosMultiphysics/OptimizationApplication/filtering/helmholtz_analysis.py

```diff
@@ -1,140 +1,137 @@
-from typing import Any
-
-# Importing Kratos
-import KratosMultiphysics as KM
-import KratosMultiphysics.OptimizationApplication as KOA
-import KratosMultiphysics.OptimizationApplication.filtering.python_solvers_wrapper_implicit_filters as implicit_filter_solvers
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
-
-# Importing the base class
-from KratosMultiphysics.analysis_stage import AnalysisStage
-
-class HelmholtzAnalysis(AnalysisStage):
-    """
-    This class is the main-script of the implicit filtering analysis
-    It can be imported and used as "black-box"
-    """
-    def __init__(self, model: KM.Model, project_parameters: KM.Parameters):
-        super().__init__(model, project_parameters)
-        self.__source_data: ContainerExpressionTypes = None
-        self.__neighbour_entities: 'dict[Any, KM.Expression.NodalExpression]' = {}
-
-    #### Internal functions ####
-    def _CreateSolver(self):
-        """ Create the Solver (and create and import the ModelPart if it is not alread in the model) """
-        return implicit_filter_solvers.CreateSolver(self.model, self.project_parameters)
-
-    def _GetSimulationName(self):
-        return "::[Helmholtz/Sobolev Analysis]:: "
-
-    def _GetComputingModelPart(self):
-        return self._GetSolver().GetComputingModelPart()
-
-    def _SetSolverMode(self, invers_mode:bool = False):
-        self._GetComputingModelPart().ProcessInfo.SetValue(KOA.COMPUTE_HELMHOLTZ_INVERSE, invers_mode)
-
-    def _SetHelmHoltzSourceMode(self, integrated_field=False):
-        self._GetComputingModelPart().ProcessInfo.SetValue(KOA.HELMHOLTZ_INTEGRATED_FIELD, integrated_field)
-
-    #### Public user interface functions ####
-    def Initialize(self):
-        super().Initialize()
-        self._SetSolverMode()
-        self.SetFilterRadius(self._GetSolver().GetFilterRadius())
-        self.SetBulkFilterRadius()
-        self._SetHelmHoltzSourceMode()
-
-    def SetFilterRadius(self, filter_radius: float):
-        self._GetComputingModelPart().ProcessInfo.SetValue(KOA.HELMHOLTZ_RADIUS, filter_radius)
-
-    def SetBulkFilterRadius(self):
-        if self._GetSolver().GetFilterType() == "bulk_surface_shape":
-            KOA.ImplicitFilterUtils.SetBulkRadiusForShapeFiltering(self._GetComputingModelPart())
-
-    def RunSolver(self):
-        self.InitializeSolutionStep()
-        self._GetSolver().Predict()
-        self._GetSolver().SolveSolutionStep()
-        self.FinalizeSolutionStep()
-
-    def FilterField(self, unfiltered_field: ContainerExpressionTypes) -> ContainerExpressionTypes:
-
-        self.__AssignDataExpressionToNodalSource(unfiltered_field)
-        self._SetSolverMode(False)
-        self._SetHelmHoltzSourceMode(False)
-        self.RunSolver()
-        return self.__AssignNodalSolutionToDataExpression()
-
-    def FilterIntegratedField(self, unfiltered_field: ContainerExpressionTypes) -> ContainerExpressionTypes:
-
-        self.__AssignDataExpressionToNodalSource(unfiltered_field)
-        self._SetSolverMode(False)
-        self._SetHelmHoltzSourceMode(True)
-        self.RunSolver()
-        return self.__AssignNodalSolutionToDataExpression()
-
-    def UnFilterField(self, filtered_field: ContainerExpressionTypes) -> ContainerExpressionTypes:
-
-        self.__AssignDataExpressionToNodalSource(filtered_field)
-        self._SetSolverMode(True)
-        self._SetHelmHoltzSourceMode(False)
-        self.RunSolver()
-        return self.__AssignNodalSolutionToDataExpression()
-
-    def __AssignDataExpressionToNodalSource(self, data_exp: ContainerExpressionTypes):
-        self.__source_data = data_exp
-
-        # it is better to work on the model part of the data_exp rather than the internal
-        # model part created with ConnectivityPreserveModelPart because, then all the outputs will
-        # be written to one vtu file automatically, otherwise, there will be outputs distributed among
-        # the helmholtz model part and the original model part. This is safer because the helmholtz modelpart
-        # is created using the ConnectivityPreserveModeller which preserves the same nodes and condition/element
-        # data containers.
-        mapped_values = KM.Expression.NodalExpression(data_exp.GetModelPart())
-        if isinstance(data_exp, KM.Expression.NodalExpression):
-            mapped_values = data_exp
-        else:
-            # following makes the number of neighbours computation to be executed once
-            # per given contaienr, hence if the mesh element/connectivity changes
-            # this computation needs to be redone. Especially in the case if MMG is
-            # used for re-meshing.
-            key = data_exp.GetContainer()
-            if key not in  self.__neighbour_entities.keys():
-                self.__neighbour_entities[key] = KM.Expression.NodalExpression(data_exp.GetModelPart())
-                if isinstance(data_exp, KM.Expression.ElementExpression):
-                    KOA.ExpressionUtils.ComputeNumberOfNeighbourElements(self.__neighbour_entities[key])
-                else:
-                    KOA.ExpressionUtils.ComputeNumberOfNeighbourConditions(self.__neighbour_entities[key])
-
-            KOA.ExpressionUtils.MapContainerVariableToNodalVariable(mapped_values, data_exp, self.__neighbour_entities[key])
-
-        filter_type = self._GetSolver().GetFilterType()
-        if filter_type == "bulk_surface_shape" or filter_type == "general_vector":
-            KM.Expression.VariableExpressionIO.Write(mapped_values, KOA.HELMHOLTZ_VECTOR_SOURCE, False)
-        else:
-            KM.Expression.VariableExpressionIO.Write(mapped_values, KOA.HELMHOLTZ_SCALAR_SOURCE, False)
-
-    def __AssignNodalSolutionToDataExpression(self) -> ContainerExpressionTypes:
-        if self.__source_data is None:
-            raise RuntimeError("The __AssignDataExpressionToNodalSource shoud be called first.")
-
-        # it is better to work on the model part of the data_exp rather than the internal
-        # model part created with ConnectivityPreserveModelPart because, then all the outputs will
-        # be written to one vtu file automatically, otherwise, there will be outputs distributed among
-        # the helmholtz model part and the original model part. This is safer because the helmholtz modelpart
-        # is created using the ConnectivityPreserveModeller which preserves the same nodes and condition/element
-        # data containers.
-        nodal_solution_field = KM.Expression.NodalExpression(self.__source_data.GetModelPart())
-
-        filter_type = self._GetSolver().GetFilterType()
-        if filter_type == "bulk_surface_shape" or filter_type == "general_vector":
-            KM.Expression.VariableExpressionIO.Read(nodal_solution_field, KOA.HELMHOLTZ_VECTOR, True)
-        else:
-            KM.Expression.VariableExpressionIO.Read(nodal_solution_field, KOA.HELMHOLTZ_SCALAR, True)
-
-        if isinstance(self.__source_data, KM.Expression.NodalExpression):
-            return nodal_solution_field.Clone()
-        else:
-            mapped_entity_solution_field = self.__source_data.Clone()
-            KOA.ExpressionUtils.MapNodalVariableToContainerVariable(mapped_entity_solution_field, nodal_solution_field)
-            return mapped_entity_solution_field
+from typing import Any
+
+# Importing Kratos
+import KratosMultiphysics as KM
+import KratosMultiphysics.OptimizationApplication as KOA
+import KratosMultiphysics.OptimizationApplication.filtering.python_solvers_wrapper_implicit_filters as implicit_filter_solvers
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
+
+# Importing the base class
+from KratosMultiphysics.analysis_stage import AnalysisStage
+
+class HelmholtzAnalysis(AnalysisStage):
+    """
+    This class is the main-script of the implicit filtering analysis
+    It can be imported and used as "black-box"
+    """
+    def __init__(self, model: KM.Model, project_parameters: KM.Parameters):
+        super().__init__(model, project_parameters)
+        self.__source_data: ContainerExpressionTypes = None
+        self.__neighbour_entities: 'dict[Any, KM.Expression.NodalExpression]' = {}
+
+    #### Internal functions ####
+    def _CreateSolver(self):
+        """ Create the Solver (and create and import the ModelPart if it is not alread in the model) """
+        return implicit_filter_solvers.CreateSolver(self.model, self.project_parameters)
+
+    def _GetSimulationName(self):
+        return "::[Helmholtz/Sobolev Analysis]:: "
+
+    def _GetComputingModelPart(self):
+        return self._GetSolver().GetComputingModelPart()
+
+    def _SetSolverMode(self, invers_mode:bool = False):
+        self._GetComputingModelPart().ProcessInfo.SetValue(KOA.COMPUTE_HELMHOLTZ_INVERSE, invers_mode)
+
+    def _SetHelmHoltzSourceMode(self, integrated_field=False):
+        self._GetComputingModelPart().ProcessInfo.SetValue(KOA.HELMHOLTZ_INTEGRATED_FIELD, integrated_field)
+
+    #### Public user interface functions ####
+    def Initialize(self):
+        super().Initialize()
+        self.InitializeFilterModelPart()
+
+    def InitializeFilterModelPart(self):
+        self._SetSolverMode()
+        self._GetSolver().SetFilterRadius(self._GetSolver().GetFilterRadius())
+        self._SetHelmHoltzSourceMode()
+
+    def RunSolver(self):
+        self.InitializeSolutionStep()
+        self._GetSolver().Predict()
+        self._GetSolver().SolveSolutionStep()
+        self.FinalizeSolutionStep()
+
+    def FilterField(self, unfiltered_field: ContainerExpressionTypes) -> ContainerExpressionTypes:
+
+        self.__AssignDataExpressionToNodalSource(unfiltered_field)
+        self._SetSolverMode(False)
+        self._SetHelmHoltzSourceMode(False)
+        self.RunSolver()
+        return self.__AssignNodalSolutionToDataExpression()
+
+    def FilterIntegratedField(self, unfiltered_field: ContainerExpressionTypes) -> ContainerExpressionTypes:
+
+        self.__AssignDataExpressionToNodalSource(unfiltered_field)
+        self._SetSolverMode(False)
+        self._SetHelmHoltzSourceMode(True)
+        self.RunSolver()
+        return self.__AssignNodalSolutionToDataExpression()
+
+    def UnFilterField(self, filtered_field: ContainerExpressionTypes) -> ContainerExpressionTypes:
+
+        self.__AssignDataExpressionToNodalSource(filtered_field)
+        self._SetSolverMode(True)
+        self._SetHelmHoltzSourceMode(False)
+        self.RunSolver()
+        return self.__AssignNodalSolutionToDataExpression()
+
+    def AssignExpressionDataToNodalSolution(self, data_exp: ContainerExpressionTypes) -> None:
+        mapped_values = KM.Expression.NodalExpression(data_exp.GetModelPart())
+        if isinstance(data_exp, KM.Expression.NodalExpression):
+            mapped_values = data_exp
+        else:
+            KOA.ExpressionUtils.MapContainerVariableToNodalVariable(mapped_values, data_exp, self.__GetNeighbourEntities(data_exp))
+        KM.Expression.VariableExpressionIO.Write(mapped_values, self._GetSolver().GetSolvingVariable(), True)
+
+    def __AssignDataExpressionToNodalSource(self, data_exp: ContainerExpressionTypes):
+        self.__source_data = data_exp
+
+        # it is better to work on the model part of the data_exp rather than the internal
+        # model part created with ConnectivityPreserveModelPart because, then all the outputs will
+        # be written to one vtu file automatically, otherwise, there will be outputs distributed among
+        # the helmholtz model part and the original model part. This is safer because the helmholtz modelpart
+        # is created using the ConnectivityPreserveModeller which preserves the same nodes and condition/element
+        # data containers.
+        mapped_values = KM.Expression.NodalExpression(data_exp.GetModelPart())
+        if isinstance(data_exp, KM.Expression.NodalExpression):
+            mapped_values = data_exp
+        else:
+            KOA.ExpressionUtils.MapContainerVariableToNodalVariable(mapped_values, data_exp, self.__GetNeighbourEntities(data_exp))
+
+        KM.Expression.VariableExpressionIO.Write(mapped_values, self._GetSolver().GetSourceVariable(), False)
+
+    def __AssignNodalSolutionToDataExpression(self) -> ContainerExpressionTypes:
+        if self.__source_data is None:
+            raise RuntimeError("The __AssignDataExpressionToNodalSource shoud be called first.")
+
+        # it is better to work on the model part of the data_exp rather than the internal
+        # model part created with ConnectivityPreserveModelPart because, then all the outputs will
+        # be written to one vtu file automatically, otherwise, there will be outputs distributed among
+        # the helmholtz model part and the original model part. This is safer because the helmholtz modelpart
+        # is created using the ConnectivityPreserveModeller which preserves the same nodes and condition/element
+        # data containers.
+        nodal_solution_field = KM.Expression.NodalExpression(self.__source_data.GetModelPart())
+
+        KM.Expression.VariableExpressionIO.Read(nodal_solution_field, self._GetSolver().GetSolvingVariable(), True)
+
+        if isinstance(self.__source_data, KM.Expression.NodalExpression):
+            return nodal_solution_field.Clone()
+        else:
+            mapped_entity_solution_field = self.__source_data.Clone()
+            KOA.ExpressionUtils.MapNodalVariableToContainerVariable(mapped_entity_solution_field, nodal_solution_field)
+            return mapped_entity_solution_field
+
+    def __GetNeighbourEntities(self, data_exp: ContainerExpressionTypes) -> ContainerExpressionTypes:
+        # following makes the number of neighbours computation to be executed once
+        # per given contaienr, hence if the mesh element/connectivity changes
+        # this computation needs to be redone. Especially in the case if MMG is
+        # used for re-meshing.
+        key = data_exp.GetContainer()
+        if key not in  self.__neighbour_entities.keys():
+            self.__neighbour_entities[key] = KM.Expression.NodalExpression(data_exp.GetModelPart())
+            if isinstance(data_exp, KM.Expression.ElementExpression):
+                KOA.ExpressionUtils.ComputeNumberOfNeighbourElements(self.__neighbour_entities[key])
+            else:
+                KOA.ExpressionUtils.ComputeNumberOfNeighbourConditions(self.__neighbour_entities[key])
+        return self.__neighbour_entities[key]
```

## KratosMultiphysics/OptimizationApplication/filtering/helmholtz_scalar_solver.py

```diff
@@ -1,52 +1,39 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Import applications
-import KratosMultiphysics.OptimizationApplication as KOA
-
-# Import baseclass
-from KratosMultiphysics.OptimizationApplication.filtering.helmholtz_solver_base import HelmholtzSolverBase
-
-def CreateSolver(model: KM.Model, custom_settings: KM.Parameters):
-    return HelmholtzScalarSolver(model, custom_settings)
-
-class HelmholtzScalarSolver(HelmholtzSolverBase):
-
-    def AddVariables(self) -> None:
-        # Add variables required for the helmholtz filtering
-        self.GetOriginRootModelPart().AddNodalSolutionStepVariable(KOA.HELMHOLTZ_SCALAR)
-        KM.Logger.PrintInfo("::[HelmholtzScalarSolver]:: Variables ADDED.")
-
-    def AddDofs(self) -> None:
-        KM.VariableUtils().AddDof(KOA.HELMHOLTZ_SCALAR, self.GetOriginRootModelPart())
-        KM.Logger.PrintInfo("::[HelmholtzScalarSolver]:: DOFs ADDED.")
-
-    def PrepareModelPart(self) -> None:
-
-        if len(self.GetOriginModelPart().Conditions)>0 and len(self.GetOriginModelPart().Elements)>0:
-            KM.Logger.PrintWarning("::[HelmholtzScalarSolver]:: filter model part ", self.GetOriginModelPart().Name, " has both elements and conditions. Giving precedence to conditions ")
-
-        if len(self.GetOriginModelPart().Conditions)>0:
-           filter_container = self.GetOriginModelPart().Conditions
-        elif len(self.GetOriginModelPart().Elements)>0:
-           filter_container = self.GetOriginModelPart().Elements
-
-        is_surface_filter = self._IsSurfaceContainer(filter_container)
-        num_nodes = self._GetContainerTypeNumNodes(filter_container)
-
-        if is_surface_filter:
-            element_name = f"HelmholtzSurfaceElement3D{num_nodes}N"
-        else:
-            element_name = f"HelmholtzSolidElement3D{num_nodes}N"
-
-        filter_properties = self.helmholtz_model_part.GetRootModelPart().CreateNewProperties(self.helmholtz_model_part.GetRootModelPart().NumberOfProperties()+1)
-        for node in self.GetOriginModelPart().Nodes:
-            self.helmholtz_model_part.AddNode(node)
-
-        elem_index = len(self.helmholtz_model_part.GetRootModelPart().Elements) + 1
-        for cond in filter_container:
-            element_nodes_ids = []
-            for node in cond.GetNodes():
-                element_nodes_ids.append(node.Id)
-            self.helmholtz_model_part.CreateNewElement(element_name, elem_index, element_nodes_ids, filter_properties)
-            elem_index += 1
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Import applications
+import KratosMultiphysics.OptimizationApplication as KOA
+
+# Import baseclass
+from KratosMultiphysics.OptimizationApplication.filtering.helmholtz_solver_base import HelmholtzSolverBase
+
+def CreateSolver(model: KM.Model, custom_settings: KM.Parameters):
+    return HelmholtzScalarSolver(model, custom_settings)
+
+class HelmholtzScalarSolver(HelmholtzSolverBase):
+    def GetSolvingVariable(self) -> KM.DoubleVariable:
+        return KOA.HELMHOLTZ_SCALAR
+
+    def _GetComputingModelPartName(self) -> str:
+        return self.GetOriginModelPart().FullName().replace(".", "_") + "_helmholtz_scalar"
+
+    def SetFilterRadius(self, filter_radius: float) -> None:
+        self.GetComputingModelPart().ProcessInfo.SetValue(KOA.HELMHOLTZ_RADIUS, filter_radius)
+
+    def _FillComputingModelPart(self) -> None:
+        if self.GetOriginModelPart().NumberOfElements() > 0:
+            # here we have to replace the elements, while keeping the
+            # geometries the same. Hence using the ConnectivityPreserveModeller
+            container = self.GetOriginModelPart().Elements
+            num_nodes = self._GetContainerTypeNumNodes(container)
+            if self._IsSurfaceContainer(container):
+                KM.ConnectivityPreserveModeler().GenerateModelPart(self.GetOriginModelPart(), self.GetComputingModelPart(), f"HelmholtzSurfaceElement3D{num_nodes}N")
+            else:
+                KM.ConnectivityPreserveModeler().GenerateModelPart(self.GetOriginModelPart(), self.GetComputingModelPart(), f"HelmholtzSolidElement3D{num_nodes}N")
+        elif self.GetOriginModelPart().NumberOfConditions() > 0:
+            # here we have conditions in the origin model part. Now we have to create elements using
+            # the geometries of the conditions. There cannot be volume conditions in Kratos, therefore,
+            # there can be only surface conditions, hence only required to create surface elements.
+            KOA.OptAppModelPartUtils.GenerateModelPart(self.GetOriginModelPart().Conditions, self.GetComputingModelPart(), f"HelmholtzSurfaceElement3D{self._GetContainerTypeNumNodes(self.GetOriginModelPart().Conditions)}N")
+        else:
+            raise RuntimeError(f"No elements or conditions found in {self.GetOriginModelPart()}.")
```

## KratosMultiphysics/OptimizationApplication/filtering/helmholtz_solver_base.py

```diff
@@ -1,204 +1,272 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-import KratosMultiphysics.OptimizationApplication as KOA
-
-# Other imports
-from KratosMultiphysics.python_solver import PythonSolver
-
-class HelmholtzSolverBase(PythonSolver):
-    """The base class for Helmholtz-based solvers.
-
-    This class defines the user interface to Helmholtz solvers.
-
-    """
-    def __init__(self, model: KratosMultiphysics.Model, custom_settings: KratosMultiphysics.Parameters):
-        self._validate_settings_in_baseclass=True # To be removed eventually
-        super().__init__(model, custom_settings)
-
-        # Either retrieve the model part from the model or create a new one
-        self.filtering_model_part_name = self.settings["model_part_name"].GetString()
-
-        if self.filtering_model_part_name == "":
-            raise Exception('Please provide the model part name as the "model_part_name" (string) parameter!')
-
-        # the filtering_model_part_name can be a sub model part. Hence we need the main model part
-        # for variable and dof addition.
-        root_model_part_name = self.filtering_model_part_name.split(".")[0]
-        if self.model.HasModelPart(root_model_part_name):
-            self.origin_root_model_part = self.model.GetModelPart(root_model_part_name)
-        else:
-            self.origin_root_model_part = model.CreateModelPart(root_model_part_name)
-
-        domain_size = self.settings["domain_size"].GetInt()
-        if domain_size == -1:
-            raise Exception('Please provide the domain size as the "domain_size" (int) parameter!')
-        self.origin_root_model_part.ProcessInfo.SetValue(KratosMultiphysics.DOMAIN_SIZE, domain_size)
-
-        # Create Helmholtz model part
-        # replacing "." with "_" if the filtering model part is a sub model part since model part names
-        # cannot have ".", and helmholtz_model_part needs to be a root model part
-        helmholtz_model_part_name = self.filtering_model_part_name.replace(".", "_") + "_helmholtz_filter_mdp"
-        self.helmholtz_model_part = self.model.CreateModelPart(helmholtz_model_part_name)
-
-        # Get the filter radius
-        self.filter_radius = self.settings["filter_radius"].GetDouble()
-        self.filter_type = self.settings["filter_type"].GetString()
-
-        KratosMultiphysics.Logger.PrintInfo("::[HelmholtzSolverBase]:: Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls) -> KratosMultiphysics.Parameters:
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "solver_type"           : "helmholtz_solver_base",
-            "domain_size"           : -1,
-            "filter_type"     : "",
-            "filter_radius"     : 0.0,
-            "model_part_name"       : "",
-            "time_stepping" : {
-                "time_step"       : 1.0
-            },
-            "model_import_settings" : {
-                "input_type"     : "mdpa",
-                "input_filename" : "unknown_name"
-            },
-            "linear_solver_settings" : {
-                "solver_type" : "amgcl",
-                "smoother_type":"ilu0",
-                "krylov_type": "gmres",
-                "coarsening_type": "aggregation",
-                "max_iteration": 200,
-                "provide_coordinates": false,
-                "gmres_krylov_space_dimension": 100,
-                "verbosity" : 0,
-                "tolerance": 1e-7,
-                "scaling": false,
-                "block_size": 1,
-                "use_block_matrices_if_possible" : true,
-                "coarse_enough" : 5000
-            },
-            "material_properties": {}
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    #### Public user interface functions ####
-
-    def AdvanceInTime(self, current_time: float) -> float:
-        dt = self.settings["time_stepping"]["time_step"].GetDouble()
-        new_time = current_time + dt
-        self.helmholtz_model_part.ProcessInfo[KratosMultiphysics.STEP] += 1
-        self.helmholtz_model_part.CloneTimeStep(new_time)
-
-        return new_time
-
-    def Initialize(self) -> None:
-        self._GetSolutionStrategy().Initialize()
-        KOA.ImplicitFilterUtils.CalculateNodeNeighbourCount(self.helmholtz_model_part)
-        KratosMultiphysics.Logger.PrintInfo("::[HelmholtzSolverBase]:: Finished initialization.")
-
-    def InitializeSolutionStep(self) -> None:
-        self._GetSolutionStrategy().InitializeSolutionStep()
-
-    def FinalizeSolutionStep(self) -> None:
-        self._GetSolutionStrategy().FinalizeSolutionStep()
-
-    def Predict(self) -> None:
-        self._GetSolutionStrategy().Predict()
-
-    def SolveSolutionStep(self) -> None:
-        is_converged = bool(self._GetSolutionStrategy().Solve())
-        return is_converged
-
-    def SetEchoLevel(self, level: int) -> None:
-        self._GetSolutionStrategy().SetEchoLevel(level)
-
-    def GetEchoLevel(self) -> int:
-        self._GetSolutionStrategy().GetEchoLevel()
-
-    def Clear(self) -> None:
-        self._GetSolutionStrategy().Clear()
-
-    def ImportModelPart(self) -> None:
-        self._ImportModelPart(self.origin_root_model_part, self.settings["model_import_settings"])
-
-    def GetComputingModelPart(self) -> KratosMultiphysics.ModelPart:
-        return self.helmholtz_model_part
-
-    def GetOriginRootModelPart(self) -> KratosMultiphysics.ModelPart:
-        return self.origin_root_model_part
-
-    def GetOriginModelPart(self) -> KratosMultiphysics.ModelPart:
-        return self.model[self.filtering_model_part_name]
-
-    def GetFilterType(self) -> str:
-        return self.filter_type
-
-    def GetFilterRadius(self) -> str:
-        return self.filter_radius
-
-    #### Protected functions ####
-
-    #### Specific internal functions ####
-
-    def _GetScheme(self):
-        if not hasattr(self, '_solution_scheme'):
-            self._solution_scheme = self._CreateScheme()
-        return self._solution_scheme
-
-    def _GetLinearSolver(self):
-        if not hasattr(self, '_linear_solver'):
-            self._linear_solver = self._CreateLinearSolver()
-        return self._linear_solver
-
-    def _GetBuilderAndSolver(self):
-        if not hasattr(self, '_builder_and_solver'):
-            self._builder_and_solver = self._CreateBuilderAndSolver()
-        return self._builder_and_solver
-
-    def _GetSolutionStrategy(self):
-        if not hasattr(self, '_solution_strategy'):
-            self._solution_strategy = self._CreateSolutionStrategy()
-        return self._solution_strategy
-
-    def _CreateBuilderAndSolver(self):
-        linear_solver = self._GetLinearSolver()
-        return KratosMultiphysics.ResidualBasedBlockBuilderAndSolver(linear_solver)
-
-    def _CreateLinearSolver(self):
-        from KratosMultiphysics.python_linear_solver_factory import ConstructSolver
-        return ConstructSolver(self.settings["linear_solver_settings"])
-
-    def _CreateScheme(self):
-        return KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
-
-    def _CreateSolutionStrategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        scheme = self._GetScheme()
-        builder_and_solver = self._GetBuilderAndSolver()
-        return KratosMultiphysics.ResidualBasedLinearStrategy(computing_model_part,
-                                                              scheme,
-                                                              builder_and_solver,
-                                                              False,
-                                                              False,
-                                                              False,
-                                                              False)
-
-    def _AssignProperties(self, parameters: KratosMultiphysics.Parameters):
-        KOA.ImplicitFilterUtils.AssignProperties(self.GetComputingModelPart(), parameters)
-
-    def _GetContainerTypeNumNodes(self, container) -> int:
-        num_nodes = None
-        for cont_type in container:
-            num_nodes = len(cont_type.GetNodes())
-            break
-        return num_nodes
-
-    def _IsSurfaceContainer(self, container) -> bool:
-        is_surface = False
-        for cont_type in container:
-            geom = cont_type.GetGeometry()
-            if geom.WorkingSpaceDimension() != geom.LocalSpaceDimension():
-                is_surface = True
-            break
-        return is_surface
-
+import abc
+import typing
+
+# Importing the Kratos Library
+import KratosMultiphysics
+import KratosMultiphysics.OptimizationApplication as KOA
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
+
+# Other imports
+from KratosMultiphysics.python_solver import PythonSolver
+from KratosMultiphysics.python_linear_solver_factory import ConstructSolver
+
+class HelmholtzSolverBase(PythonSolver):
+    """The base class for Helmholtz-based solvers.
+
+    This class defines the user interface to Helmholtz solvers.
+
+    """
+    def __init__(self, model: KratosMultiphysics.Model, custom_settings: KratosMultiphysics.Parameters):
+        self._validate_settings_in_baseclass=True # To be removed eventually
+        super().__init__(model, custom_settings)
+
+        # Either retrieve the model part from the model or create a new one
+        self.filtering_model_part_name = self.settings["model_part_name"].GetString()
+
+        if self.filtering_model_part_name == "":
+            raise Exception('Please provide the model part name as the "model_part_name" (string) parameter!')
+
+        # the filtering_model_part_name can be a sub model part. Hence we need the main model part
+        # for variable and dof addition.
+        root_model_part_name = self.filtering_model_part_name.split(".")[0]
+        if self.model.HasModelPart(root_model_part_name):
+            self.origin_root_model_part = self.model.GetModelPart(root_model_part_name)
+        else:
+            self.origin_root_model_part = model.CreateModelPart(root_model_part_name)
+
+        domain_size = self.settings["domain_size"].GetInt()
+        if domain_size == -1:
+            raise Exception('Please provide the domain size as the "domain_size" (int) parameter!')
+        self.origin_root_model_part.ProcessInfo.SetValue(KratosMultiphysics.DOMAIN_SIZE, domain_size)
+
+        # we don't create the helmholtz model part here, because
+        # we need to have unique model parts for different filtering variable types
+        # hence, it cannot be determined at this point.
+        self.helmholtz_model_part: 'typing.Optional[KratosMultiphysics.ModelPart]' = None
+
+        # Get the filter radius
+        self.filter_radius = self.settings["filter_radius"].GetDouble()
+
+        KratosMultiphysics.Logger.PrintInfo("::[HelmholtzSolverBase]:: Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls) -> KratosMultiphysics.Parameters:
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "solver_type"           : "helmholtz_solver_base",
+            "domain_size"           : -1,
+            "filter_type"     : "",
+            "filter_radius"     : 0.0,
+            "model_part_name"       : "",
+            "time_stepping" : {
+                "time_step"       : 1.0
+            },
+            "model_import_settings" : {
+                "input_type"     : "mdpa",
+                "input_filename" : "unknown_name"
+            },
+            "linear_solver_settings" : {
+                "solver_type" : "amgcl",
+                "smoother_type":"ilu0",
+                "krylov_type": "gmres",
+                "coarsening_type": "aggregation",
+                "max_iteration": 200,
+                "provide_coordinates": false,
+                "gmres_krylov_space_dimension": 100,
+                "verbosity" : 0,
+                "tolerance": 1e-7,
+                "scaling": false,
+                "block_size": 1,
+                "use_block_matrices_if_possible" : true,
+                "coarse_enough" : 5000
+            },
+            "material_properties": {}
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    #### Public user interface functions ####
+
+    @abc.abstractmethod
+    def _GetComputingModelPartName(self) -> str:
+        pass
+
+    @abc.abstractmethod
+    def _FillComputingModelPart(self) -> None:
+        pass
+
+    @abc.abstractmethod
+    def GetSolvingVariable(self) -> SupportedSensitivityFieldVariableTypes:
+        pass
+
+    @abc.abstractmethod
+    def SetFilterRadius(self, filter_radius: float) -> None:
+        pass
+
+    def AddVariables(self) -> None:
+        self.GetOriginRootModelPart().AddNodalSolutionStepVariable(self.GetSolvingVariable())
+        KratosMultiphysics.Logger.PrintInfo("::[HelmholtzSolverBase]:: Variables ADDED.")
+
+    def AddDofs(self) -> None:
+        if isinstance(self.GetSolvingVariable(), KratosMultiphysics.DoubleVariable):
+            KratosMultiphysics.VariableUtils().AddDof(self.GetSolvingVariable(), self.GetOriginRootModelPart())
+        elif isinstance(self.GetSolvingVariable(), KratosMultiphysics.Array1DVariable3):
+            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.KratosGlobals.GetVariable(f"{self.GetSolvingVariable().Name()}_X"), self.GetOriginRootModelPart())
+            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.KratosGlobals.GetVariable(f"{self.GetSolvingVariable().Name()}_Y"), self.GetOriginRootModelPart())
+            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.KratosGlobals.GetVariable(f"{self.GetSolvingVariable().Name()}_Z"), self.GetOriginRootModelPart())
+        else:
+            raise RuntimeError("Unsupported solving variable type.")
+        KratosMultiphysics.Logger.PrintInfo("::[HelmholtzSolverBase]:: DOFs ADDED.")
+
+    def AdvanceInTime(self, current_time: float) -> float:
+        dt = self.settings["time_stepping"]["time_step"].GetDouble()
+        new_time = current_time + dt
+        self.helmholtz_model_part.ProcessInfo[KratosMultiphysics.STEP] += 1
+        self.helmholtz_model_part.CloneTimeStep(new_time)
+
+        return new_time
+
+    def Initialize(self) -> None:
+        self._GetSolutionStrategy().Initialize()
+        neighbours_exp = KratosMultiphysics.Expression.NodalExpression(self.helmholtz_model_part)
+        KOA.ExpressionUtils.ComputeNumberOfNeighbourElements(neighbours_exp)
+        KratosMultiphysics.Expression.VariableExpressionIO.Write(neighbours_exp, KratosMultiphysics.NUMBER_OF_NEIGHBOUR_ELEMENTS, False)
+        KratosMultiphysics.Logger.PrintInfo("::[HelmholtzSolverBase]:: Finished initialization.")
+
+    def InitializeSolutionStep(self) -> None:
+        self._GetSolutionStrategy().InitializeSolutionStep()
+
+    def FinalizeSolutionStep(self) -> None:
+        self._GetSolutionStrategy().FinalizeSolutionStep()
+
+    def Predict(self) -> None:
+        self._GetSolutionStrategy().Predict()
+
+    def SolveSolutionStep(self) -> None:
+        is_converged = bool(self._GetSolutionStrategy().Solve())
+        return is_converged
+
+    def SetEchoLevel(self, level: int) -> None:
+        self._GetSolutionStrategy().SetEchoLevel(level)
+
+    def GetEchoLevel(self) -> int:
+        self._GetSolutionStrategy().GetEchoLevel()
+
+    def Clear(self) -> None:
+        self._GetSolutionStrategy().Clear()
+
+    def ImportModelPart(self) -> None:
+        self._ImportModelPart(self.origin_root_model_part, self.settings["model_import_settings"])
+
+    def GetComputingModelPart(self) -> KratosMultiphysics.ModelPart:
+        return self.helmholtz_model_part
+
+    def GetOriginRootModelPart(self) -> KratosMultiphysics.ModelPart:
+        return self.origin_root_model_part
+
+    def GetOriginModelPart(self) -> KratosMultiphysics.ModelPart:
+        return self.model[self.filtering_model_part_name]
+
+    def GetFilterRadius(self) -> str:
+        return self.filter_radius
+
+    #### Protected functions ####
+
+    #### Specific internal functions ####
+
+    def _GetScheme(self):
+        if not hasattr(self, '_solution_scheme'):
+            self._solution_scheme = self._CreateScheme()
+        return self._solution_scheme
+
+    def _GetLinearSolver(self):
+        if not hasattr(self, '_linear_solver'):
+            self._linear_solver = self._CreateLinearSolver()
+        return self._linear_solver
+
+    def _GetBuilderAndSolver(self):
+        if not hasattr(self, '_builder_and_solver'):
+            self._builder_and_solver = self._CreateBuilderAndSolver()
+        return self._builder_and_solver
+
+    def _GetSolutionStrategy(self):
+        if not hasattr(self, '_solution_strategy'):
+            self._solution_strategy = self._CreateSolutionStrategy()
+        return self._solution_strategy
+
+    def _CreateBuilderAndSolver(self):
+        linear_solver = self._GetLinearSolver()
+        return KratosMultiphysics.ResidualBasedBlockBuilderAndSolver(linear_solver)
+
+    def _CreateLinearSolver(self):
+        return ConstructSolver(self.settings["linear_solver_settings"])
+
+    def _CreateScheme(self):
+        return KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
+
+    def _CreateSolutionStrategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        scheme = self._GetScheme()
+        builder_and_solver = self._GetBuilderAndSolver()
+        return KratosMultiphysics.ResidualBasedLinearStrategy(computing_model_part,
+                                                              scheme,
+                                                              builder_and_solver,
+                                                              False,
+                                                              False,
+                                                              False,
+                                                              False)
+
+    def _GetContainerTypeNumNodes(self, container: 'typing.Union[KratosMultiphysics.ConditionsArray, KratosMultiphysics.ElementsArray]') -> int:
+        num_nodes = None
+        for cont_type in container:
+            return len(cont_type.GetNodes())
+        return num_nodes
+
+    def _IsSurfaceContainer(self, container: 'typing.Union[KratosMultiphysics.ConditionsArray, KratosMultiphysics.ElementsArray]') -> bool:
+        return any(map(lambda x: x.GetGeometry().WorkingSpaceDimension() != x.GetGeometry().LocalSpaceDimension(), container))
+
+    def GetSourceVariable(self) -> SupportedSensitivityFieldVariableTypes:
+        if isinstance(self.GetSolvingVariable(), KratosMultiphysics.DoubleVariable):
+            return KOA.HELMHOLTZ_SCALAR_SOURCE
+        elif isinstance(self.GetSolvingVariable(), KratosMultiphysics.Array1DVariable3):
+            return KOA.HELMHOLTZ_VECTOR_SOURCE
+        else:
+            raise RuntimeError("Unsupported solving variable.")
+
+    def PrepareModelPart(self) -> str:
+        computing_model_part_name = self._GetComputingModelPartName()
+
+        if self.model.HasModelPart(computing_model_part_name):
+            # a same model part with same entities were already created by some other filter
+            # hence reusing it
+            self.helmholtz_model_part = self.model[computing_model_part_name]
+        else:
+            # the model part needs to be created.
+            self.helmholtz_model_part = self.model.CreateModelPart(computing_model_part_name)
+            KOA.OptimizationUtils.CopySolutionStepVariablesList(self.helmholtz_model_part, self.GetOriginRootModelPart())
+
+            # now fill with the appropriate elements and conditions
+            self._FillComputingModelPart()
+
+        self.__IncrementModelPartUsageCounter()
+
+    def __IncrementModelPartUsageCounter(self) -> None:
+        # we increase the usage number of filters using the model part.
+        # this is required to know whether we need to apply boundary conditions
+        # every time filter is used so that we don't mix-up different BCs from
+        # different filters and mesh motion solvers
+
+        # in here, the origin model part and its parents are updated. This is because,
+        # the computing model part shares nodes with the origin model part.
+        def increase_counter(model_part: KratosMultiphysics.ModelPart) -> None:
+            if not model_part.Has(KOA.NUMBER_OF_SOLVERS_USING_NODES):
+                model_part[KOA.NUMBER_OF_SOLVERS_USING_NODES] = 0
+            model_part[KOA.NUMBER_OF_SOLVERS_USING_NODES] += 1
+
+        current_model_part = self.GetOriginModelPart()
+        increase_counter(current_model_part)
+
+        # now increase the usage counter in all parent model parts.
+        while current_model_part != current_model_part.GetParentModelPart():
+            current_model_part = current_model_part.GetParentModelPart()
+            increase_counter(current_model_part)
+
```

## KratosMultiphysics/OptimizationApplication/filtering/helmholtz_vector_solver.py

```diff
@@ -1,120 +1,39 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Import applications
-import KratosMultiphysics.OptimizationApplication as KOA
-
-# Import baseclass
-from KratosMultiphysics.OptimizationApplication.filtering.helmholtz_solver_base import HelmholtzSolverBase
-
-def CreateSolver(model, custom_settings):
-    return HelmholtzVectorSolver(model, custom_settings)
-
-class HelmholtzVectorSolver(HelmholtzSolverBase):
-    def __init__(self, model: KM.Model, custom_settings: KM.Parameters) -> None:
-        super().__init__(model, custom_settings)
-        if self.settings["filter_type"].GetString() == "bulk_surface_shape":
-            self.bulk_surface_shape_filter = True
-        else:
-            self.bulk_surface_shape_filter = False
-        KM.Logger.PrintInfo("::[HelmholtzVectorSolver]:: Construction finished")
-
-    def AddVariables(self) -> None:
-        # Add variables required for the helmholtz filtering
-        self.GetOriginRootModelPart().AddNodalSolutionStepVariable(KOA.HELMHOLTZ_VECTOR)
-        KM.Logger.PrintInfo("::[HelmholtzVectorSolver]:: Variables ADDED.")
-
-    def AddDofs(self) -> None:
-        KM.VariableUtils().AddDof(KOA.HELMHOLTZ_VECTOR_X, self.GetOriginRootModelPart())
-        KM.VariableUtils().AddDof(KOA.HELMHOLTZ_VECTOR_Y, self.GetOriginRootModelPart())
-        KM.VariableUtils().AddDof(KOA.HELMHOLTZ_VECTOR_Z, self.GetOriginRootModelPart())
-        KM.Logger.PrintInfo("::[HelmholtzVectorSolver]:: DOFs ADDED.")
-
-    def PrepareModelPart(self) -> None:
-
-        if self.bulk_surface_shape_filter:
-
-            num_root_elems_nodes = self._GetContainerTypeNumNodes(self.GetOriginModelPart().GetRootModelPart().Elements)
-            is_root_surface = self._IsSurfaceContainer(self.GetOriginModelPart().GetRootModelPart().Elements)
-            num_cond_nodes = self._GetContainerTypeNumNodes(self.GetOriginModelPart().Conditions)
-            is_surface_condition = self._IsSurfaceContainer(self.GetOriginModelPart().Conditions)
-
-            if num_root_elems_nodes != 4:
-                raise Exception('::[HelmholtzVectorSolver]:: given model part must have only tetrahedral elemenst')
-            if num_cond_nodes != 3:
-                raise Exception('::[HelmholtzVectorSolver]:: given model part must have only triangular conditions')
-            if not is_surface_condition or is_root_surface:
-                raise Exception('::[HelmholtzVectorSolver]:: bulk surface should have solid tetrahedral elemenst and triangular conditions')
-
-            # add nodes
-            for node in self.GetOriginModelPart().GetRootModelPart().Nodes:
-                self.helmholtz_model_part.AddNode(node)
-
-            # add elems
-            elem_properties = self.helmholtz_model_part.CreateNewProperties(self.helmholtz_model_part.NumberOfProperties()+1)
-            elem_index = len(self.helmholtz_model_part.Elements) + 1
-            for elem in self.GetOriginModelPart().GetRootModelPart().Elements:
-                element_nodes_ids = []
-                for node in elem.GetNodes():
-                    element_nodes_ids.append(node.Id)
-                self.helmholtz_model_part.CreateNewElement("HelmholtzSolidShapeElement3D4N", elem_index, element_nodes_ids, elem_properties)
-                elem_index += 1
-
-            # add conds
-            cond_properties = self.helmholtz_model_part.CreateNewProperties(self.helmholtz_model_part.NumberOfProperties()+1)
-            cond_index = len(self.helmholtz_model_part.GetRootModelPart().Conditions) + 1
-            for cond in self.GetOriginModelPart().Conditions:
-                cond_nodes_ids = []
-                for node in cond.GetNodes():
-                    cond_nodes_ids.append(node.Id)
-                self.helmholtz_model_part.CreateNewCondition("HelmholtzSurfaceShapeCondition3D3N", cond_index, cond_nodes_ids, cond_properties)
-                cond_index += 1
-
-            material_properties = self.settings["material_properties"]
-            defaults = KM.Parameters("""{
-                "properties_id": 10000000000000000,
-                "Material": {
-                    "constitutive_law": {
-                        "name": "HelmholtzJacobianStiffened3D"
-                    },
-                    "Variables": {
-                        "POISSON_RATIO": 0.3
-                    }
-                }
-            }""")
-            material_properties.RecursivelyAddMissingParameters(defaults)
-            self._AssignProperties(material_properties)
-
-            tmoc = KM.TetrahedralMeshOrientationCheck
-            flags = (tmoc.COMPUTE_NODAL_NORMALS).AsFalse() | (tmoc.COMPUTE_CONDITION_NORMALS).AsFalse() | tmoc.ASSIGN_NEIGHBOUR_ELEMENTS_TO_CONDITIONS
-            KM.TetrahedralMeshOrientationCheck(self.helmholtz_model_part, False, flags).Execute()
-
-        else:
-
-            if len(self.GetOriginModelPart().Conditions)>0 and len(self.GetOriginModelPart().Elements)>0:
-                KM.Logger.PrintWarning("::[HelmholtzVectorSolver]:: filter model part ", self.GetOriginModelPart().Name, " has both elements and conditions. Giving precedence to conditions ")
-
-            if len(self.GetOriginModelPart().Conditions)>0:
-               filter_container = self.GetOriginModelPart().Conditions
-            elif len(self.GetOriginModelPart().Elements)>0:
-               filter_container = self.GetOriginModelPart().Elements
-
-            is_surface_filter = self._IsSurfaceContainer(filter_container)
-            num_nodes = self._GetContainerTypeNumNodes(filter_container)
-
-            if is_surface_filter:
-                element_name = f"HelmholtzVectorSurfaceElement3D{num_nodes}N"
-            else:
-                element_name = f"HelmholtzVectorSolidElement3D{num_nodes}N"
-
-            filter_properties = self.helmholtz_model_part.GetRootModelPart().CreateNewProperties(self.helmholtz_model_part.GetRootModelPart().NumberOfProperties()+1)
-            for node in self.GetOriginModelPart().Nodes:
-                self.helmholtz_model_part.AddNode(node)
-
-            elem_index = len(self.helmholtz_model_part.GetRootModelPart().Elements) + 1
-            for cond in filter_container:
-                element_nodes_ids = []
-                for node in cond.GetNodes():
-                    element_nodes_ids.append(node.Id)
-                self.helmholtz_model_part.CreateNewElement(element_name, elem_index, element_nodes_ids, filter_properties)
-                elem_index += 1
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Import applications
+import KratosMultiphysics.OptimizationApplication as KOA
+
+# Import baseclass
+from KratosMultiphysics.OptimizationApplication.filtering.helmholtz_solver_base import HelmholtzSolverBase
+
+def CreateSolver(model: KM.Model, custom_settings: KM.Parameters):
+    return HelmholtzVectorSolver(model, custom_settings)
+
+class HelmholtzVectorSolver(HelmholtzSolverBase):
+    def GetSolvingVariable(self) -> KM.Array1DVariable3:
+        return KOA.HELMHOLTZ_VECTOR
+
+    def _GetComputingModelPartName(self) -> str:
+        return self.GetOriginModelPart().FullName().replace(".", "_") + "_helmholtz_vector"
+
+    def SetFilterRadius(self, filter_radius: float) -> None:
+        self.GetComputingModelPart().ProcessInfo.SetValue(KOA.HELMHOLTZ_RADIUS, filter_radius)
+
+    def _FillComputingModelPart(self) -> None:
+        if self.GetOriginModelPart().NumberOfElements() > 0:
+            # here we have to replace the elements, while keeping the
+            # geometries the same. Hence using the ConnectivityPreserveModeller
+            container = self.GetOriginModelPart().Elements
+            num_nodes = self._GetContainerTypeNumNodes(container)
+            if self._IsSurfaceContainer(container):
+                KM.ConnectivityPreserveModeler().GenerateModelPart(self.GetOriginModelPart(), self.GetComputingModelPart(), f"HelmholtzVectorSurfaceElement3D{num_nodes}N")
+            else:
+                KM.ConnectivityPreserveModeler().GenerateModelPart(self.GetOriginModelPart(), self.GetComputingModelPart(), f"HelmholtzVectorSolidElement3D{num_nodes}N")
+        elif self.GetOriginModelPart().NumberOfConditions() > 0:
+            # here we have conditions in the origin model part. Now we have to create elements using
+            # the geometries of the conditions. There cannot be volume conditions in Kratos, therefore,
+            # there can be only surface conditions, hence only required to create surface elements.
+            KOA.OptAppModelPartUtils.GenerateModelPart(self.GetOriginModelPart().Conditions, self.GetComputingModelPart(), f"HelmholtzVectorSurfaceElement3D{self._GetContainerTypeNumNodes(self.GetOriginModelPart().Conditions)}N")
+        else:
+            raise RuntimeError(f"No elements or conditions found in {self.GetOriginModelPart()}.")
```

## KratosMultiphysics/OptimizationApplication/filtering/python_solvers_wrapper_implicit_filters.py

```diff
@@ -1,56 +1,56 @@
-import KratosMultiphysics
-from importlib import import_module
-
-def CreateSolverByParameters(model: KratosMultiphysics.Model, solver_settings: KratosMultiphysics.Parameters, parallelism: str):
-
-    filter_type = solver_settings["filter_type"].GetString()
-
-    # Solvers for OpenMP parallelism
-    if (parallelism == "OpenMP"):
-
-        if (filter_type == "general_scalar" ):
-            solver_module_name = "helmholtz_scalar_solver"
-
-        elif (filter_type == "bulk_surface_shape" or filter_type == "general_vector"):
-            solver_module_name = "helmholtz_vector_solver"
-        else:
-            err_msg =  'The requested solver type "' + filter_type + '" is not in the python solvers wrapper\n'
-            err_msg += 'Available options are: "general_scalar", "general_vector", "bulk_surface_shape"'
-            raise Exception(err_msg)
-
-    # Solvers for MPI parallelism
-    elif (parallelism == "MPI"):
-
-        if (filter_type == filter_type == "bulk_surface_shape" or filter_type == "general_vector"):
-            solver_module_name = "trilinos_general_vector_filter_solver"
-
-        elif (filter_type == "general_scalar" ):
-            solver_module_name = "trilinos_general_scalar_filter_solver"
-
-        else:
-            err_msg =  'The requested solver type "' + filter_type + '" is not in the python solvers wrapper\n'
-            err_msg += 'Available options are: "trilinos_general_vector_filter_solver", "trilinos_general_scalar_filter_solver", "trilinos_shape_filter_solver"'
-            raise Exception(err_msg)
-
-    else:
-        err_msg =  'The requested parallel type "' + parallelism + '" is not available!\n'
-        err_msg += 'Available options are: "OpenMP", "MPI"'
-        raise Exception(err_msg)
-
-    module_full = 'KratosMultiphysics.OptimizationApplication.filtering.' + solver_module_name
-    solver = import_module(module_full).CreateSolver(model, solver_settings)
-
-    return solver
-
-def CreateSolver(model: KratosMultiphysics.Model, custom_settings: KratosMultiphysics.Parameters):
-
-    if not isinstance(model, KratosMultiphysics.Model):
-        raise Exception("input is expected to be provided as a Kratos Model object")#
-
-    if not isinstance(custom_settings, KratosMultiphysics.Parameters):
-        raise Exception("input is expected to be provided as a Kratos Parameters object")
-
-    solver_settings = custom_settings["solver_settings"]
-    parallelism = custom_settings["problem_data"]["parallel_type"].GetString()
-
-    return CreateSolverByParameters(model, solver_settings, parallelism)
+import KratosMultiphysics
+from importlib import import_module
+from KratosMultiphysics.OptimizationApplication.filtering.helmholtz_solver_base import HelmholtzSolverBase
+
+def CreateSolverByParameters(model: KratosMultiphysics.Model, solver_settings: KratosMultiphysics.Parameters, parallelism: str) -> HelmholtzSolverBase:
+
+    filter_type = solver_settings["filter_type"].GetString()
+
+    # Solvers for OpenMP parallelism
+    if parallelism == "OpenMP":
+
+        if filter_type == "general_scalar":
+            solver_module_name = "helmholtz_scalar_solver"
+        elif filter_type == "general_vector":
+            solver_module_name = "helmholtz_vector_solver"
+        elif (filter_type == "bulk_surface_shape" or filter_type == "shape"):
+            solver_module_name = "helmholtz_shape_solver"
+        else:
+            err_msg =  'The requested solver type "' + filter_type + '" is not in the python solvers wrapper\n'
+            err_msg += 'Available options are: "general_scalar", "general_vector", "shape"'
+            raise Exception(err_msg)
+
+    # Solvers for MPI parallelism
+    elif parallelism == "MPI":
+        if filter_type == "general_scalar":
+            solver_module_name = "trilinos_helmholtz_general_scalar_solver"
+        elif filter_type == "general_vector":
+            solver_module_name = "trilinos_helmholtz_general_vector_solver"
+        elif (filter_type == "bulk_surface_shape" or filter_type == "shape"):
+            solver_module_name = "trilinos_helmholtz_shape_solver"
+        else:
+            err_msg =  'The requested solver type "' + filter_type + '" is not in the python solvers wrapper\n'
+            err_msg += 'Available options are: "general_scalar", "general_vector", "bulk_surface_shape", "shape"'
+            raise Exception(err_msg)
+    else:
+        err_msg =  'The requested parallel type "' + parallelism + '" is not available!\n'
+        err_msg += 'Available options are: "OpenMP", "MPI"'
+        raise Exception(err_msg)
+
+    module_full = 'KratosMultiphysics.OptimizationApplication.filtering.' + solver_module_name
+    solver = import_module(module_full).CreateSolver(model, solver_settings)
+
+    return solver
+
+def CreateSolver(model: KratosMultiphysics.Model, custom_settings: KratosMultiphysics.Parameters) -> HelmholtzSolverBase:
+
+    if not isinstance(model, KratosMultiphysics.Model):
+        raise Exception("input is expected to be provided as a Kratos Model object")#
+
+    if not isinstance(custom_settings, KratosMultiphysics.Parameters):
+        raise Exception("input is expected to be provided as a Kratos Parameters object")
+
+    solver_settings = custom_settings["solver_settings"]
+    parallelism = custom_settings["problem_data"]["parallel_type"].GetString()
+
+    return CreateSolverByParameters(model, solver_settings, parallelism)
```

## KratosMultiphysics/OptimizationApplication/model_part_controllers/mdpa_model_part_controller.py

 * *Ordering differences only*

```diff
@@ -1,44 +1,44 @@
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.OptimizationApplication.model_part_controllers.model_part_controller import ModelPartController
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> ModelPartController:
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"MdpaModelPartController instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-    return MdpaModelPartController(model, parameters["settings"])
-
-class MdpaModelPartController(ModelPartController):
-    def __init__(self, model: Kratos.Model, parameters: Kratos.Parameters):
-        default_settings = Kratos.Parameters("""{
-            "model_part_name": "",
-            "input_filename" : "",
-            "domain_size"    : -1,
-            "read_data"      : false
-        }""")
-
-        parameters.ValidateAndAssignDefaults(default_settings)
-
-        model_part_name = parameters["model_part_name"].GetString()
-        if model_part_name == "":
-            raise RuntimeError("Empty \"model_part_name\" is not allowed which is given with following parameters:\n" + str(parameters))
-
-        self.input_filename = parameters["input_filename"].GetString()
-        if self.input_filename == "":
-            raise RuntimeError("Empty \"input_filename\" is not allowed which is given with following parameters:\n" + str(parameters))
-
-        self.domain_size = parameters["domain_size"].GetInt()
-        if self.domain_size not in [1, 2, 3]:
-            raise RuntimeError("\"domain_size\"  should be either 1, 2 or 3." + str(parameters))
-
-        self.model_part = model.CreateModelPart(model_part_name)
-        self.read_data = parameters["read_data"].GetBool()
-
-    def ImportModelPart(self) -> None:
-        if self.read_data:
-            Kratos.ModelPartIO(self.input_filename, Kratos.ModelPartIO.READ).ReadModelPart(self.model_part)
-        else:
-            Kratos.ModelPartIO(self.input_filename, Kratos.ModelPartIO.READ | Kratos.ModelPartIO.MESH_ONLY).ReadModelPart(self.model_part)
-
-        self.model_part.ProcessInfo[Kratos.DOMAIN_SIZE] = self.domain_size
-
-    def GetModelPart(self) -> Kratos.ModelPart:
-        return self.model_part
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.OptimizationApplication.model_part_controllers.model_part_controller import ModelPartController
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> ModelPartController:
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"MdpaModelPartController instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+    return MdpaModelPartController(model, parameters["settings"])
+
+class MdpaModelPartController(ModelPartController):
+    def __init__(self, model: Kratos.Model, parameters: Kratos.Parameters):
+        default_settings = Kratos.Parameters("""{
+            "model_part_name": "",
+            "input_filename" : "",
+            "domain_size"    : -1,
+            "read_data"      : false
+        }""")
+
+        parameters.ValidateAndAssignDefaults(default_settings)
+
+        model_part_name = parameters["model_part_name"].GetString()
+        if model_part_name == "":
+            raise RuntimeError("Empty \"model_part_name\" is not allowed which is given with following parameters:\n" + str(parameters))
+
+        self.input_filename = parameters["input_filename"].GetString()
+        if self.input_filename == "":
+            raise RuntimeError("Empty \"input_filename\" is not allowed which is given with following parameters:\n" + str(parameters))
+
+        self.domain_size = parameters["domain_size"].GetInt()
+        if self.domain_size not in [1, 2, 3]:
+            raise RuntimeError("\"domain_size\"  should be either 1, 2 or 3." + str(parameters))
+
+        self.model_part = model.CreateModelPart(model_part_name)
+        self.read_data = parameters["read_data"].GetBool()
+
+    def ImportModelPart(self) -> None:
+        if self.read_data:
+            Kratos.ModelPartIO(self.input_filename, Kratos.ModelPartIO.READ).ReadModelPart(self.model_part)
+        else:
+            Kratos.ModelPartIO(self.input_filename, Kratos.ModelPartIO.READ | Kratos.ModelPartIO.MESH_ONLY).ReadModelPart(self.model_part)
+
+        self.model_part.ProcessInfo[Kratos.DOMAIN_SIZE] = self.domain_size
+
+    def GetModelPart(self) -> Kratos.ModelPart:
+        return self.model_part
```

## KratosMultiphysics/OptimizationApplication/model_part_controllers/model_part_controller.py

 * *Ordering differences only*

```diff
@@ -1,19 +1,19 @@
-from abc import ABC, abstractmethod
-import KratosMultiphysics as Kratos
-
-class ModelPartController(ABC):
-    def Initialize(self) -> None:
-        pass
-
-    def Finalize(self) -> None:
-        pass
-
-    @abstractmethod
-    def ImportModelPart(self) -> None:
-        pass
-
-    @abstractmethod
-    def GetModelPart(self) -> Kratos.ModelPart:
-        pass
-
-
+from abc import ABC, abstractmethod
+import KratosMultiphysics as Kratos
+
+class ModelPartController(ABC):
+    def Initialize(self) -> None:
+        pass
+
+    def Finalize(self) -> None:
+        pass
+
+    @abstractmethod
+    def ImportModelPart(self) -> None:
+        pass
+
+    @abstractmethod
+    def GetModelPart(self) -> Kratos.ModelPart:
+        pass
+
+
```

## KratosMultiphysics/OptimizationApplication/processes/optimization_problem_ascii_output_process.py

 * *Ordering differences only*

```diff
@@ -1,208 +1,208 @@
-from datetime import datetime
-from typing import Union, Any
-
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
-from KratosMultiphysics.OptimizationApplication.controls.control import Control
-from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetAllComponentFullNamesWithData
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetComponentHavingDataByFullName
-
-def Factory(_: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> ExecutionPolicy:
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"OptimizationProblemAsciiOutputProcess instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-    return OptimizationProblemAsciiOutputProcess(parameters["settings"], optimization_problem)
-
-class Header:
-    def __init__(self, header_name: str, value: Any, format_info: dict):
-        header_name = header_name.strip()
-        header_length = len(header_name)
-
-        if isinstance(value, bool):
-            value_length = max(len(format_info[type(value)][0]), len(format_info[type(value)][1]))
-            value_format_post_fix = "s"
-            self.__value_converter = lambda x: format_info[type(value)][1] if x else format_info[type(value)][0]
-        elif isinstance(value, int):
-            value_length = len(("{:" + str(format_info[type(value)]) + "d}").format(value))
-            value_format_post_fix = "d"
-            self.__value_converter = lambda x: int(x)
-        elif isinstance(value, float):
-            value_length = len(("{:0." + str(format_info[type(value)]) + "e}").format(value))
-            value_format_post_fix = f".{format_info[type(value)]}e"
-            self.__value_converter = lambda x: float(x)
-        else:
-            value_length = format_info[str]
-            value_format_post_fix = "s"
-            self.__value_converter = lambda x: str(x)
-
-        if header_length > value_length:
-            self.__header_name = header_name
-            self.__value_format = "{:>" + str(header_length) + value_format_post_fix + "}"
-        else:
-            self.__header_name = ("{:>" + str(value_length) + "s}").format(header_name)
-            self.__value_format = "{:>" + str(value_length) + value_format_post_fix + "}"
-
-    def GetHeaderName(self) -> str:
-        return self.__header_name
-
-    def GetValueStr(self, value: Any) -> str:
-        return self.__value_format.format(self.__value_converter(value))
-
-class OptimizationProblemAsciiOutputProcess(Kratos.OutputProcess):
-    def GetDefaultParameters(self):
-        return Kratos.Parameters(
-            """
-            {
-                "output_file_name"         : "SPECIFY_OUTPUT_FILE_NAME",
-                "write_kratos_version"     : true,
-                "write_time_stamp"         : true,
-                "write_initial_values"     : true,
-                "list_of_output_components": ["all"],
-                "format_info": {
-                    "int_length"     : 7,
-                    "float_precision": 9,
-                    "bool_values"    : ["no", "yes"],
-                    "string_length"  : 10
-                }
-            }
-            """
-        )
-
-    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        Kratos.OutputProcess.__init__(self)
-
-        self.optimization_problem = optimization_problem
-        parameters.RecursivelyValidateAndAssignDefaults(self.GetDefaultParameters())
-
-        self.output_file_name = parameters["output_file_name"].GetString()
-        if not self.output_file_name.endswith(".csv"):
-            self.output_file_name += ".csv"
-
-        self.write_kratos_version = parameters["write_kratos_version"].GetBool()
-        self.write_time_stamp = parameters["write_time_stamp"].GetBool()
-        self.write_initial_values = parameters["write_initial_values"].GetBool()
-
-        self.format_info = {
-            int  : parameters["format_info"]["int_length"].GetInt(),
-            float: parameters["format_info"]["float_precision"].GetInt(),
-            bool : parameters["format_info"]["bool_values"].GetStringArray(),
-            str  : parameters["format_info"]["string_length"].GetInt(),
-        }
-
-        if len(self.format_info[bool]) != 2:
-            raise RuntimeError("The \"bool_values\" should have only two strings corresponding to False and True values in the mentioned order.")
-
-        self.list_of_components: 'list[Union[str, ResponseFunction, Control, ExecutionPolicy]]' = []
-        list_of_component_names = parameters["list_of_output_components"].GetStringArray()
-        if len(list_of_component_names) == 1 and list_of_component_names[0] == "all":
-            list_of_component_names = GetAllComponentFullNamesWithData(optimization_problem)
-
-        for component_name in list_of_component_names:
-            self.list_of_components.append(GetComponentHavingDataByFullName(component_name, optimization_problem))
-
-        self.list_of_headers: 'list[tuple[Any, dict[str, Header]]]' = []
-        self.initialized_headers = False
-
-    def IsOutputStep(self) -> bool:
-        return True
-
-    def PrintOutput(self) -> None:
-        if not self.initialized_headers:
-            # now get the buffered data headers
-            self.list_of_headers = self._GetHeaders(lambda x: x.GetBufferedData())
-            # write the ehader information
-            self._WriteHeaders()
-            self.initialized_headers = True
-
-        if self._IsWritingProcess():
-            # now write step data
-            with open(self.output_file_name, "a") as file_output:
-                # write the step
-                file_output.write("{:>7d}".format(self.optimization_problem.GetStep()))
-
-                # wrtie the values
-                for component, header_info_dict in self.list_of_headers:
-                    componend_data_view = ComponentDataView(component, self.optimization_problem)
-                    buffered_dict = componend_data_view.GetBufferedData()
-                    for k, header in header_info_dict.items():
-                        file_output.write(", " + header.GetValueStr(buffered_dict[k]))
-
-                file_output.write("\n")
-
-    def ExecuteFinalize(self):
-        if self._IsWritingProcess():
-            with open(self.output_file_name, "a") as file_output:
-                file_output.write("# End of file")
-
-    def _IsWritingProcess(self):
-        if Kratos.IsDistributedRun():
-            data_communicator: Kratos.DataCommunicator = Kratos.ParallelEnvironment.GetDefaultDataCommunicator()
-            return data_communicator.Rank() == 0
-        else:
-            return True
-
-    def _WriteHeaders(self):
-        if (self._IsWritingProcess()):
-            kratos_version = "not_given"
-            if (self.write_kratos_version):
-                kratos_version = str(Kratos.KratosGlobals.Kernel.Version())
-
-            time_stamp = "not_specified"
-            if (self.write_time_stamp):
-                time_stamp = str(datetime.now())
-
-            msg_header = ""
-            msg_header = f"{msg_header}# Optimization problem ascii output\n"
-            msg_header = f"{msg_header}# Kratos version: {kratos_version}\n"
-            msg_header = f"{msg_header}# Timestamp     : {time_stamp}\n"
-            msg_header = f"{msg_header}# -----------------------------------------------\n"
-
-            if self.write_initial_values:
-                msg_header = f"{msg_header}# --------------- Initial values ----------------\n"
-
-                initial_headers = self._GetHeaders(lambda x: x.GetUnBufferedData())
-                # now write the initial value container data
-                for component, header_info_dict in initial_headers:
-                    componend_data_view = ComponentDataView(component, self.optimization_problem)
-                    buffered_dict = componend_data_view.GetUnBufferedData()
-                    component_name = componend_data_view.GetComponentName()
-                    msg_header = f"{msg_header}# \t" + component_name + ":\n"
-                    for k, header in header_info_dict.items():
-                        component_name_header = header.GetHeaderName().strip()[len(component_name)+1:]
-                        msg_header = f"{msg_header}# \t\t" + component_name_header + ": " + header.GetValueStr(buffered_dict[k]).strip() + "\n"
-
-                msg_header = f"{msg_header}# ------------ End of initial values ------------\n"
-                msg_header = f"{msg_header}# -----------------------------------------------\n"
-
-            msg_header = f"{msg_header}# ------------ Start of step values -------------\n"
-            msg_header = f"{msg_header}# Headers:\n"
-
-            msg_header = f"{msg_header}#  STEP"
-
-            for _, header_info_dict in self.list_of_headers:
-                for header in header_info_dict.values():
-                    msg_header = f"{msg_header}, " + header.GetHeaderName()
-
-            msg_header = f"{msg_header}\n"
-
-            # write the header
-            with open(self.output_file_name, "w") as file_output:
-                file_output.write(msg_header)
-
-    def _GetHeaders(self, dict_getter_method) ->  'list[tuple[Any, dict[str, Header]]]':
-        list_of_headers: 'list[tuple[Any, dict[str, Header]]]' = []
-        for component in self.list_of_components:
-            componend_data_view = ComponentDataView(component, self.optimization_problem)
-            values_map = dict_getter_method(componend_data_view).GetMap()
-            header_info_dict: 'dict[str, Header]' = {}
-            component_name = componend_data_view.GetComponentName()
-            for k, v in values_map.items():
-                if isinstance(v, (bool, int, float, str)):
-                    header_name = component_name + ":" + k[k.rfind("/") + 1:]
-                    if header_name in [header.GetHeaderName().strip() for header in header_info_dict.values()]:
-                        Kratos.Logger.PrintWarning(self.__class__.__name__, "Second value with same header name = \"" + header_name + "\" found.")
-                    header_info_dict[k] = Header(header_name, v, self.format_info)
-            list_of_headers.append([component, header_info_dict])
+from datetime import datetime
+from typing import Union, Any
+
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
+from KratosMultiphysics.OptimizationApplication.controls.control import Control
+from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetAllComponentFullNamesWithData
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetComponentHavingDataByFullName
+
+def Factory(_: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> ExecutionPolicy:
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"OptimizationProblemAsciiOutputProcess instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+    return OptimizationProblemAsciiOutputProcess(parameters["settings"], optimization_problem)
+
+class Header:
+    def __init__(self, header_name: str, value: Any, format_info: dict):
+        header_name = header_name.strip()
+        header_length = len(header_name)
+
+        if isinstance(value, bool):
+            value_length = max(len(format_info[type(value)][0]), len(format_info[type(value)][1]))
+            value_format_post_fix = "s"
+            self.__value_converter = lambda x: format_info[type(value)][1] if x else format_info[type(value)][0]
+        elif isinstance(value, int):
+            value_length = len(("{:" + str(format_info[type(value)]) + "d}").format(value))
+            value_format_post_fix = "d"
+            self.__value_converter = lambda x: int(x)
+        elif isinstance(value, float):
+            value_length = len(("{:0." + str(format_info[type(value)]) + "e}").format(value))
+            value_format_post_fix = f".{format_info[type(value)]}e"
+            self.__value_converter = lambda x: float(x)
+        else:
+            value_length = format_info[str]
+            value_format_post_fix = "s"
+            self.__value_converter = lambda x: str(x)
+
+        if header_length > value_length:
+            self.__header_name = header_name
+            self.__value_format = "{:>" + str(header_length) + value_format_post_fix + "}"
+        else:
+            self.__header_name = ("{:>" + str(value_length) + "s}").format(header_name)
+            self.__value_format = "{:>" + str(value_length) + value_format_post_fix + "}"
+
+    def GetHeaderName(self) -> str:
+        return self.__header_name
+
+    def GetValueStr(self, value: Any) -> str:
+        return self.__value_format.format(self.__value_converter(value))
+
+class OptimizationProblemAsciiOutputProcess(Kratos.OutputProcess):
+    def GetDefaultParameters(self):
+        return Kratos.Parameters(
+            """
+            {
+                "output_file_name"         : "SPECIFY_OUTPUT_FILE_NAME",
+                "write_kratos_version"     : true,
+                "write_time_stamp"         : true,
+                "write_initial_values"     : true,
+                "list_of_output_components": ["all"],
+                "format_info": {
+                    "int_length"     : 7,
+                    "float_precision": 9,
+                    "bool_values"    : ["no", "yes"],
+                    "string_length"  : 10
+                }
+            }
+            """
+        )
+
+    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        Kratos.OutputProcess.__init__(self)
+
+        self.optimization_problem = optimization_problem
+        parameters.RecursivelyValidateAndAssignDefaults(self.GetDefaultParameters())
+
+        self.output_file_name = parameters["output_file_name"].GetString()
+        if not self.output_file_name.endswith(".csv"):
+            self.output_file_name += ".csv"
+
+        self.write_kratos_version = parameters["write_kratos_version"].GetBool()
+        self.write_time_stamp = parameters["write_time_stamp"].GetBool()
+        self.write_initial_values = parameters["write_initial_values"].GetBool()
+
+        self.format_info = {
+            int  : parameters["format_info"]["int_length"].GetInt(),
+            float: parameters["format_info"]["float_precision"].GetInt(),
+            bool : parameters["format_info"]["bool_values"].GetStringArray(),
+            str  : parameters["format_info"]["string_length"].GetInt(),
+        }
+
+        if len(self.format_info[bool]) != 2:
+            raise RuntimeError("The \"bool_values\" should have only two strings corresponding to False and True values in the mentioned order.")
+
+        self.list_of_components: 'list[Union[str, ResponseFunction, Control, ExecutionPolicy]]' = []
+        list_of_component_names = parameters["list_of_output_components"].GetStringArray()
+        if len(list_of_component_names) == 1 and list_of_component_names[0] == "all":
+            list_of_component_names = GetAllComponentFullNamesWithData(optimization_problem)
+
+        for component_name in list_of_component_names:
+            self.list_of_components.append(GetComponentHavingDataByFullName(component_name, optimization_problem))
+
+        self.list_of_headers: 'list[tuple[Any, dict[str, Header]]]' = []
+        self.initialized_headers = False
+
+    def IsOutputStep(self) -> bool:
+        return True
+
+    def PrintOutput(self) -> None:
+        if not self.initialized_headers:
+            # now get the buffered data headers
+            self.list_of_headers = self._GetHeaders(lambda x: x.GetBufferedData())
+            # write the ehader information
+            self._WriteHeaders()
+            self.initialized_headers = True
+
+        if self._IsWritingProcess():
+            # now write step data
+            with open(self.output_file_name, "a") as file_output:
+                # write the step
+                file_output.write("{:>7d}".format(self.optimization_problem.GetStep()))
+
+                # wrtie the values
+                for component, header_info_dict in self.list_of_headers:
+                    componend_data_view = ComponentDataView(component, self.optimization_problem)
+                    buffered_dict = componend_data_view.GetBufferedData()
+                    for k, header in header_info_dict.items():
+                        file_output.write(", " + header.GetValueStr(buffered_dict[k]))
+
+                file_output.write("\n")
+
+    def ExecuteFinalize(self):
+        if self._IsWritingProcess():
+            with open(self.output_file_name, "a") as file_output:
+                file_output.write("# End of file")
+
+    def _IsWritingProcess(self):
+        if Kratos.IsDistributedRun():
+            data_communicator: Kratos.DataCommunicator = Kratos.ParallelEnvironment.GetDefaultDataCommunicator()
+            return data_communicator.Rank() == 0
+        else:
+            return True
+
+    def _WriteHeaders(self):
+        if (self._IsWritingProcess()):
+            kratos_version = "not_given"
+            if (self.write_kratos_version):
+                kratos_version = str(Kratos.KratosGlobals.Kernel.Version())
+
+            time_stamp = "not_specified"
+            if (self.write_time_stamp):
+                time_stamp = str(datetime.now())
+
+            msg_header = ""
+            msg_header = f"{msg_header}# Optimization problem ascii output\n"
+            msg_header = f"{msg_header}# Kratos version: {kratos_version}\n"
+            msg_header = f"{msg_header}# Timestamp     : {time_stamp}\n"
+            msg_header = f"{msg_header}# -----------------------------------------------\n"
+
+            if self.write_initial_values:
+                msg_header = f"{msg_header}# --------------- Initial values ----------------\n"
+
+                initial_headers = self._GetHeaders(lambda x: x.GetUnBufferedData())
+                # now write the initial value container data
+                for component, header_info_dict in initial_headers:
+                    componend_data_view = ComponentDataView(component, self.optimization_problem)
+                    buffered_dict = componend_data_view.GetUnBufferedData()
+                    component_name = componend_data_view.GetComponentName()
+                    msg_header = f"{msg_header}# \t" + component_name + ":\n"
+                    for k, header in header_info_dict.items():
+                        component_name_header = header.GetHeaderName().strip()[len(component_name)+1:]
+                        msg_header = f"{msg_header}# \t\t" + component_name_header + ": " + header.GetValueStr(buffered_dict[k]).strip() + "\n"
+
+                msg_header = f"{msg_header}# ------------ End of initial values ------------\n"
+                msg_header = f"{msg_header}# -----------------------------------------------\n"
+
+            msg_header = f"{msg_header}# ------------ Start of step values -------------\n"
+            msg_header = f"{msg_header}# Headers:\n"
+
+            msg_header = f"{msg_header}#  STEP"
+
+            for _, header_info_dict in self.list_of_headers:
+                for header in header_info_dict.values():
+                    msg_header = f"{msg_header}, " + header.GetHeaderName()
+
+            msg_header = f"{msg_header}\n"
+
+            # write the header
+            with open(self.output_file_name, "w") as file_output:
+                file_output.write(msg_header)
+
+    def _GetHeaders(self, dict_getter_method) ->  'list[tuple[Any, dict[str, Header]]]':
+        list_of_headers: 'list[tuple[Any, dict[str, Header]]]' = []
+        for component in self.list_of_components:
+            componend_data_view = ComponentDataView(component, self.optimization_problem)
+            values_map = dict_getter_method(componend_data_view).GetMap()
+            header_info_dict: 'dict[str, Header]' = {}
+            component_name = componend_data_view.GetComponentName()
+            for k, v in values_map.items():
+                if isinstance(v, (bool, int, float, str)):
+                    header_name = component_name + ":" + k[k.rfind("/") + 1:]
+                    if header_name in [header.GetHeaderName().strip() for header in header_info_dict.values()]:
+                        Kratos.Logger.PrintWarning(self.__class__.__name__, "Second value with same header name = \"" + header_name + "\" found.")
+                    header_info_dict[k] = Header(header_name, v, self.format_info)
+            list_of_headers.append([component, header_info_dict])
         return list_of_headers
```

## KratosMultiphysics/OptimizationApplication/processes/optimization_problem_vtu_output_process.py

 * *Ordering differences only*

```diff
@@ -1,231 +1,231 @@
-from typing import Any, Union
-from abc import ABC, abstractmethod
-from pathlib import Path
-
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.kratos_utilities as kratos_utils
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
-from KratosMultiphysics.OptimizationApplication.controls.control import Control
-from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetAllComponentFullNamesWithData
-from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetComponentHavingDataByFullName
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
-
-def Factory(_: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> Any:
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"OptimizationProblemVtuOutputProcess instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-    return OptimizationProblemVtuOutputProcess(parameters["settings"], optimization_problem)
-
-class ExpressionData(ABC):
-    def __init__(self, expression_path: str, container_expression: ContainerExpressionTypes) -> None:
-        self.expression_path = expression_path
-        self.container_expression_type = type(container_expression)
-        self.model_part = container_expression.GetModelPart()
-
-    def GetContainerExpressionType(self) -> Any:
-        return self.container_expression_type
-
-    def GetContainerExpressionName(self) -> str:
-        return self.expression_path[self.expression_path.rfind("/")+1:]
-
-    def GetExpressionPath(self) -> str:
-        return self.expression_path
-
-    def GetModelPart(self) -> Kratos.ModelPart:
-        return self.model_part
-
-    def _IsValidContainerExpression(self, container_expression: ContainerExpressionTypes) -> bool:
-        return isinstance(container_expression, self.container_expression_type) and self.model_part == container_expression.GetModelPart()
-
-    @abstractmethod
-    def GetContainerExpression(self, optiization_problem: OptimizationProblem) -> ContainerExpressionTypes:
-        pass
-
-class ContainerExpressionData(ExpressionData):
-    def __inif__(self, expression_path: str, container_expression: ContainerExpressionTypes):
-        super().__init__(expression_path, container_expression)
-
-    def GetContainerExpression(self, optiization_problem: OptimizationProblem) -> ContainerExpressionTypes:
-        data = optiization_problem.GetProblemDataContainer()[self.expression_path]
-        if not self._IsValidContainerExpression(data):
-            raise RuntimeError(f"The data at \"{self.expression_path}\" is not valid. The original data found at this location is of type {self.container_expression_type.__name__} with {self.model_part.FullName()}. Found data = {data}")
-        return data
-
-class CollectiveExpressionData(ExpressionData):
-    def __init__(self, collective_expression_path: str, collective_expression: KratosOA.CollectiveExpression, container_expression_index: int):
-        super().__init__(collective_expression_path, collective_expression.GetContainerExpressions()[container_expression_index])
-        self.container_expression_index = container_expression_index
-
-    def GetContainerExpression(self, optiization_problem: OptimizationProblem) -> ContainerExpressionTypes:
-        data = optiization_problem.GetProblemDataContainer()[self.expression_path]
-        if not isinstance(data, KratosOA.CollectiveExpression):
-            raise RuntimeError(f"The data type at \"{self.expression_path}\" changed from {KratosOA.CollectiveExpression.__name__} to {type(data).__class__.__name__}.")
-        data = data.GetContainerExpressions()[self.container_expression_index]
-        if not self._IsValidContainerExpression(data):
-            raise RuntimeError(f"The data at \"{self.expression_path}\" is not valid. The original data found at this location is of type {self.container_expression_type.__name__} with {self.model_part.FullName()}. Found data = {data}")
-        return data
-
-class ExpressionVtuOutput:
-    def __init__(self, parameters: 'dict[str, Any]', model_part: Kratos.ModelPart, optimization_problem: OptimizationProblem):
-        self.model_part = model_part
-        self.optimization_problem = optimization_problem
-        self.output_file_name_prefix = parameters["output_file_name_prefix"]
-
-        if parameters["save_output_files_in_folder"]:
-            self.output_path = Path(parameters["output_path"])
-            if not self.model_part.ProcessInfo[Kratos.IS_RESTARTED]:
-                kratos_utils.DeleteDirectoryIfExisting(str(self.output_path))
-            self.model_part.GetCommunicator().GetDataCommunicator().Barrier()
-            # now create the output path
-            Kratos.FilesystemExtensions.MPISafeCreateDirectories(str(self.output_path))
-        else:
-            self.output_path = Path(".")
-
-        self.vtu_output: Kratos.VtuOutput = Kratos.VtuOutput(model_part, parameters["is_initial_configuration"], parameters["writer_format"], parameters["precision"])
-        self.dict_of_expression_data: 'dict[Any, dict[str, ExpressionData]]' = {}
-
-        # vtu output gives priority to elements over conditions if both are present.
-        # nodal container expression is allowed in any case. hence that is added first
-        self.dict_of_expression_data[Kratos.Expression.NodalExpression]  = {}
-
-        # now check for elements
-        communicator: Kratos.Communicator = self.model_part.GetCommunicator()
-        if communicator.GlobalNumberOfElements() > 0:
-            self.dict_of_expression_data[Kratos.Expression.ElementExpression] = {}
-        elif communicator.GlobalNumberOfConditions() > 0:
-            self.dict_of_expression_data[Kratos.Expression.ConditionExpression] = {}
-
-    def AddExpressionData(self, expression_data: ExpressionData) -> bool:
-        if expression_data.GetModelPart() == self.vtu_output.GetModelPart():
-            current_expression_type = expression_data.GetContainerExpressionType()
-            if current_expression_type not in self.dict_of_expression_data.keys():
-                raise RuntimeError(f"The {current_expression_type.__name__} is not supported to be written in vtu format for {self.model_part.FullName()}")
-
-            dict_of_current_expression_type = self.dict_of_expression_data[current_expression_type]
-
-            current_expression_name = expression_data.GetContainerExpressionName()
-            if current_expression_name not in dict_of_current_expression_type.keys():
-                dict_of_current_expression_type[current_expression_name] = expression_data
-            else:
-                raise RuntimeError(f"Trying to add a duplicate expression with the name = \"{current_expression_name}\" [ The original data path = \"{dict_of_current_expression_type[current_expression_name].GetExpressionPath()}\", current data path = \"{expression_data.GetExpressionPath()}\"].")
-
-            return True
-
-        return False
-
-    def WriteOutput(self):
-        for current_expression_name_data_pair in self.dict_of_expression_data.values():
-            for expression_data in current_expression_name_data_pair.values():
-                self.vtu_output.AddContainerExpression(expression_data.GetContainerExpressionName(), expression_data.GetContainerExpression(self.optimization_problem))
-
-        output_file_name = self.output_file_name_prefix
-        output_file_name = output_file_name.replace("<model_part_full_name>", self.model_part.FullName())
-        output_file_name = output_file_name.replace("<model_part_name>", self.model_part.Name)
-        output_file_name = output_file_name.replace("<step>", str(self.optimization_problem.GetStep()))
-        self.vtu_output.PrintOutput(str(self.output_path /output_file_name))
-
-class OptimizationProblemVtuOutputProcess(Kratos.OutputProcess):
-    def GetDefaultParameters(self):
-        return Kratos.Parameters(
-            """
-            {
-                "file_name"                   : "<model_part_full_name>_<step>",
-                "file_format"                 : "binary",
-                "output_path"                 : "Optimization_Results",
-                "save_output_files_in_folder" : true,
-                "write_deformed_configuration": false,
-                "list_of_output_components"   : ["all"],
-                "output_precision"            : 7,
-                "output_interval"             : 1,
-                "echo_level"                  : 0
-            }
-            """
-        )
-
-    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> None:
-        super().__init__()
-
-        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
-
-        self.optimization_problem = optimization_problem
-
-        self.echo_level = parameters["echo_level"].GetInt()
-        self.file_name = parameters["file_name"].GetString()
-        self.output_path = parameters["output_path"].GetString()
-        self.save_output_files_in_folder = parameters["save_output_files_in_folder"].GetBool()
-        self.write_deformed_configuration = parameters["write_deformed_configuration"].GetBool()
-        self.output_precision = parameters["output_precision"].GetInt()
-        file_format = parameters["file_format"].GetString()
-        if file_format == "ascii":
-            self.writer_format = Kratos.VtuOutput.ASCII
-        elif file_format == "binary":
-            self.writer_format = Kratos.VtuOutput.BINARY
-        else:
-            raise RuntimeError(f"Only supports \"ascii\" and \"binary\" file_format. [ provided file_format = \"{file_format}\" ].")
-
-        self.list_of_component_names = parameters["list_of_output_components"].GetStringArray()
-        self.list_of_expresson_vtu_outputs: 'list[ExpressionVtuOutput]' = []
-        self.initialized_vtu_outputs = False
-
-    def PrintOutput(self) -> None:
-        if not self.initialized_vtu_outputs:
-            self.InitializeVtuOutputIO()
-            self.initialized_vtu_outputs = True
-
-        for expression_vtu_output in self.list_of_expresson_vtu_outputs:
-            expression_vtu_output.WriteOutput()
-
-    def InitializeVtuOutputIO(self) -> None:
-        # get all the component names at the first writing point
-        if len(self.list_of_component_names) == 1 and self.list_of_component_names[0] == "all":
-            self.list_of_component_names = GetAllComponentFullNamesWithData(self.optimization_problem)
-
-        list_of_components: 'list[Union[str, ResponseFunction, Control, ExecutionPolicy]]' = []
-        for component_name in self.list_of_component_names:
-            list_of_components.append(GetComponentHavingDataByFullName(component_name, self.optimization_problem))
-
-        global_values_map = self.optimization_problem.GetProblemDataContainer().GetMap()
-        for global_k, global_v in global_values_map.items():
-             # first check whether this is part of requested list of components
-            found_valid_component = False
-            for component in list_of_components:
-                component_data = ComponentDataView(component, self.optimization_problem)
-                if global_k.startswith(component_data.GetDataPath()):
-                     found_valid_component = True
-                     break
-
-            # if a valid component is found, add the expression
-            if found_valid_component:
-                if isinstance(global_v, Kratos.Expression.NodalExpression) or \
-                   isinstance(global_v, Kratos.Expression.ConditionExpression) or \
-                   isinstance(global_v, Kratos.Expression.ElementExpression):
-                    self._AddContainerExpression(ContainerExpressionData(global_k, global_v))
-                elif isinstance(global_v, KratosOA.CollectiveExpression):
-                    for i, _ in enumerate(global_v.GetContainerExpressions()):
-                        self._AddContainerExpression(CollectiveExpressionData(global_k, global_v, i))
-
-    def _AddContainerExpression(self, expression_data: ExpressionData):
-        found_vtu_output = False
-        for expression_vtu_output in self.list_of_expresson_vtu_outputs:
-            if expression_vtu_output.AddExpressionData(expression_data):
-                found_vtu_output = True
-                break
-
-        if not found_vtu_output:
-            vtu_parameters = {
-                "output_file_name_prefix": self.file_name,
-                "is_initial_configuration": not self.write_deformed_configuration,
-                "writer_format": self.writer_format,
-                "precision": self.output_precision,
-                "save_output_files_in_folder": self.save_output_files_in_folder,
-                "output_path": self.output_path
-            }
-
-            expression_vtu_output = ExpressionVtuOutput(vtu_parameters, expression_data.GetModelPart(), self.optimization_problem)
-            expression_vtu_output.AddExpressionData(expression_data)
-            self.list_of_expresson_vtu_outputs.append(expression_vtu_output)
-            if self.echo_level > 0:
+from typing import Any, Union
+from abc import ABC, abstractmethod
+from pathlib import Path
+
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.kratos_utilities as kratos_utils
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
+from KratosMultiphysics.OptimizationApplication.controls.control import Control
+from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetAllComponentFullNamesWithData
+from KratosMultiphysics.OptimizationApplication.utilities.helper_utilities import GetComponentHavingDataByFullName
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
+
+def Factory(_: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> Any:
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"OptimizationProblemVtuOutputProcess instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+    return OptimizationProblemVtuOutputProcess(parameters["settings"], optimization_problem)
+
+class ExpressionData(ABC):
+    def __init__(self, expression_path: str, container_expression: ContainerExpressionTypes) -> None:
+        self.expression_path = expression_path
+        self.container_expression_type = type(container_expression)
+        self.model_part = container_expression.GetModelPart()
+
+    def GetContainerExpressionType(self) -> Any:
+        return self.container_expression_type
+
+    def GetContainerExpressionName(self) -> str:
+        return self.expression_path[self.expression_path.rfind("/")+1:]
+
+    def GetExpressionPath(self) -> str:
+        return self.expression_path
+
+    def GetModelPart(self) -> Kratos.ModelPart:
+        return self.model_part
+
+    def _IsValidContainerExpression(self, container_expression: ContainerExpressionTypes) -> bool:
+        return isinstance(container_expression, self.container_expression_type) and self.model_part == container_expression.GetModelPart()
+
+    @abstractmethod
+    def GetContainerExpression(self, optiization_problem: OptimizationProblem) -> ContainerExpressionTypes:
+        pass
+
+class ContainerExpressionData(ExpressionData):
+    def __inif__(self, expression_path: str, container_expression: ContainerExpressionTypes):
+        super().__init__(expression_path, container_expression)
+
+    def GetContainerExpression(self, optiization_problem: OptimizationProblem) -> ContainerExpressionTypes:
+        data = optiization_problem.GetProblemDataContainer()[self.expression_path]
+        if not self._IsValidContainerExpression(data):
+            raise RuntimeError(f"The data at \"{self.expression_path}\" is not valid. The original data found at this location is of type {self.container_expression_type.__name__} with {self.model_part.FullName()}. Found data = {data}")
+        return data
+
+class CollectiveExpressionData(ExpressionData):
+    def __init__(self, collective_expression_path: str, collective_expression: KratosOA.CollectiveExpression, container_expression_index: int):
+        super().__init__(collective_expression_path, collective_expression.GetContainerExpressions()[container_expression_index])
+        self.container_expression_index = container_expression_index
+
+    def GetContainerExpression(self, optiization_problem: OptimizationProblem) -> ContainerExpressionTypes:
+        data = optiization_problem.GetProblemDataContainer()[self.expression_path]
+        if not isinstance(data, KratosOA.CollectiveExpression):
+            raise RuntimeError(f"The data type at \"{self.expression_path}\" changed from {KratosOA.CollectiveExpression.__name__} to {type(data).__class__.__name__}.")
+        data = data.GetContainerExpressions()[self.container_expression_index]
+        if not self._IsValidContainerExpression(data):
+            raise RuntimeError(f"The data at \"{self.expression_path}\" is not valid. The original data found at this location is of type {self.container_expression_type.__name__} with {self.model_part.FullName()}. Found data = {data}")
+        return data
+
+class ExpressionVtuOutput:
+    def __init__(self, parameters: 'dict[str, Any]', model_part: Kratos.ModelPart, optimization_problem: OptimizationProblem):
+        self.model_part = model_part
+        self.optimization_problem = optimization_problem
+        self.output_file_name_prefix = parameters["output_file_name_prefix"]
+
+        if parameters["save_output_files_in_folder"]:
+            self.output_path = Path(parameters["output_path"])
+            if not self.model_part.ProcessInfo[Kratos.IS_RESTARTED]:
+                kratos_utils.DeleteDirectoryIfExisting(str(self.output_path))
+            self.model_part.GetCommunicator().GetDataCommunicator().Barrier()
+            # now create the output path
+            Kratos.FilesystemExtensions.MPISafeCreateDirectories(str(self.output_path))
+        else:
+            self.output_path = Path(".")
+
+        self.vtu_output: Kratos.VtuOutput = Kratos.VtuOutput(model_part, parameters["is_initial_configuration"], parameters["writer_format"], parameters["precision"])
+        self.dict_of_expression_data: 'dict[Any, dict[str, ExpressionData]]' = {}
+
+        # vtu output gives priority to elements over conditions if both are present.
+        # nodal container expression is allowed in any case. hence that is added first
+        self.dict_of_expression_data[Kratos.Expression.NodalExpression]  = {}
+
+        # now check for elements
+        communicator: Kratos.Communicator = self.model_part.GetCommunicator()
+        if communicator.GlobalNumberOfElements() > 0:
+            self.dict_of_expression_data[Kratos.Expression.ElementExpression] = {}
+        elif communicator.GlobalNumberOfConditions() > 0:
+            self.dict_of_expression_data[Kratos.Expression.ConditionExpression] = {}
+
+    def AddExpressionData(self, expression_data: ExpressionData) -> bool:
+        if expression_data.GetModelPart() == self.vtu_output.GetModelPart():
+            current_expression_type = expression_data.GetContainerExpressionType()
+            if current_expression_type not in self.dict_of_expression_data.keys():
+                raise RuntimeError(f"The {current_expression_type.__name__} is not supported to be written in vtu format for {self.model_part.FullName()}")
+
+            dict_of_current_expression_type = self.dict_of_expression_data[current_expression_type]
+
+            current_expression_name = expression_data.GetContainerExpressionName()
+            if current_expression_name not in dict_of_current_expression_type.keys():
+                dict_of_current_expression_type[current_expression_name] = expression_data
+            else:
+                raise RuntimeError(f"Trying to add a duplicate expression with the name = \"{current_expression_name}\" [ The original data path = \"{dict_of_current_expression_type[current_expression_name].GetExpressionPath()}\", current data path = \"{expression_data.GetExpressionPath()}\"].")
+
+            return True
+
+        return False
+
+    def WriteOutput(self):
+        for current_expression_name_data_pair in self.dict_of_expression_data.values():
+            for expression_data in current_expression_name_data_pair.values():
+                self.vtu_output.AddContainerExpression(expression_data.GetContainerExpressionName(), expression_data.GetContainerExpression(self.optimization_problem))
+
+        output_file_name = self.output_file_name_prefix
+        output_file_name = output_file_name.replace("<model_part_full_name>", self.model_part.FullName())
+        output_file_name = output_file_name.replace("<model_part_name>", self.model_part.Name)
+        output_file_name = output_file_name.replace("<step>", str(self.optimization_problem.GetStep()))
+        self.vtu_output.PrintOutput(str(self.output_path /output_file_name))
+
+class OptimizationProblemVtuOutputProcess(Kratos.OutputProcess):
+    def GetDefaultParameters(self):
+        return Kratos.Parameters(
+            """
+            {
+                "file_name"                   : "<model_part_full_name>_<step>",
+                "file_format"                 : "binary",
+                "output_path"                 : "Optimization_Results",
+                "save_output_files_in_folder" : true,
+                "write_deformed_configuration": false,
+                "list_of_output_components"   : ["all"],
+                "output_precision"            : 7,
+                "output_interval"             : 1,
+                "echo_level"                  : 0
+            }
+            """
+        )
+
+    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> None:
+        super().__init__()
+
+        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+
+        self.optimization_problem = optimization_problem
+
+        self.echo_level = parameters["echo_level"].GetInt()
+        self.file_name = parameters["file_name"].GetString()
+        self.output_path = parameters["output_path"].GetString()
+        self.save_output_files_in_folder = parameters["save_output_files_in_folder"].GetBool()
+        self.write_deformed_configuration = parameters["write_deformed_configuration"].GetBool()
+        self.output_precision = parameters["output_precision"].GetInt()
+        file_format = parameters["file_format"].GetString()
+        if file_format == "ascii":
+            self.writer_format = Kratos.VtuOutput.ASCII
+        elif file_format == "binary":
+            self.writer_format = Kratos.VtuOutput.BINARY
+        else:
+            raise RuntimeError(f"Only supports \"ascii\" and \"binary\" file_format. [ provided file_format = \"{file_format}\" ].")
+
+        self.list_of_component_names = parameters["list_of_output_components"].GetStringArray()
+        self.list_of_expresson_vtu_outputs: 'list[ExpressionVtuOutput]' = []
+        self.initialized_vtu_outputs = False
+
+    def PrintOutput(self) -> None:
+        if not self.initialized_vtu_outputs:
+            self.InitializeVtuOutputIO()
+            self.initialized_vtu_outputs = True
+
+        for expression_vtu_output in self.list_of_expresson_vtu_outputs:
+            expression_vtu_output.WriteOutput()
+
+    def InitializeVtuOutputIO(self) -> None:
+        # get all the component names at the first writing point
+        if len(self.list_of_component_names) == 1 and self.list_of_component_names[0] == "all":
+            self.list_of_component_names = GetAllComponentFullNamesWithData(self.optimization_problem)
+
+        list_of_components: 'list[Union[str, ResponseFunction, Control, ExecutionPolicy]]' = []
+        for component_name in self.list_of_component_names:
+            list_of_components.append(GetComponentHavingDataByFullName(component_name, self.optimization_problem))
+
+        global_values_map = self.optimization_problem.GetProblemDataContainer().GetMap()
+        for global_k, global_v in global_values_map.items():
+             # first check whether this is part of requested list of components
+            found_valid_component = False
+            for component in list_of_components:
+                component_data = ComponentDataView(component, self.optimization_problem)
+                if global_k.startswith(component_data.GetDataPath()):
+                     found_valid_component = True
+                     break
+
+            # if a valid component is found, add the expression
+            if found_valid_component:
+                if isinstance(global_v, Kratos.Expression.NodalExpression) or \
+                   isinstance(global_v, Kratos.Expression.ConditionExpression) or \
+                   isinstance(global_v, Kratos.Expression.ElementExpression):
+                    self._AddContainerExpression(ContainerExpressionData(global_k, global_v))
+                elif isinstance(global_v, KratosOA.CollectiveExpression):
+                    for i, _ in enumerate(global_v.GetContainerExpressions()):
+                        self._AddContainerExpression(CollectiveExpressionData(global_k, global_v, i))
+
+    def _AddContainerExpression(self, expression_data: ExpressionData):
+        found_vtu_output = False
+        for expression_vtu_output in self.list_of_expresson_vtu_outputs:
+            if expression_vtu_output.AddExpressionData(expression_data):
+                found_vtu_output = True
+                break
+
+        if not found_vtu_output:
+            vtu_parameters = {
+                "output_file_name_prefix": self.file_name,
+                "is_initial_configuration": not self.write_deformed_configuration,
+                "writer_format": self.writer_format,
+                "precision": self.output_precision,
+                "save_output_files_in_folder": self.save_output_files_in_folder,
+                "output_path": self.output_path
+            }
+
+            expression_vtu_output = ExpressionVtuOutput(vtu_parameters, expression_data.GetModelPart(), self.optimization_problem)
+            expression_vtu_output.AddExpressionData(expression_data)
+            self.list_of_expresson_vtu_outputs.append(expression_vtu_output)
+            if self.echo_level > 0:
                 Kratos.Logger.PrintInfo(self.__class__.__name__, f"Created expression vtu output for {expression_data.GetModelPart().FullName()}.")
```

## KratosMultiphysics/OptimizationApplication/responses/additive_manufacturing_responses.py

 * *Ordering differences only*

```diff
@@ -1,410 +1,410 @@
-import KratosMultiphysics as KM
-from KratosMultiphysics import Parameters, Logger
-import KratosMultiphysics.OptimizationApplication as KOA
-from KratosMultiphysics.OptimizationApplication.responses.base_response import BaseResponseFunction
-
-import time as timer
-import numpy as np
-
-class InterfaceResponseFunction(BaseResponseFunction):
-
-    def __init__(self,response_name, response_settings,model):
-
-        self.type = "interface"
-        self.variable = "INTERFACE"
-        super().__init__(response_name, response_settings, model)
-
-        self.supported_control_types = ["material"]
-        self.gradients_variables = {"material":"D_INTERFACE_D_FD"}
-
-        if len(self.evaluated_model_parts) != 1:
-            raise RuntimeError("InterfaceResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name))
-
-        for control_type in self.control_types:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("InterfaceResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
-
-
-        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
-        for evaluated_model_part in self.evaluated_model_parts:
-            if evaluated_model_part.split(".")[0] != root_model_part_name:
-                raise RuntimeError("InterfaceResponseFunction: evaluated_model_parts of mass response must have the same root model part !")
-
-        self.root_model_part = self.model.GetModelPart(root_model_part_name)
-
-        # add vars and response
-        self.response_function = KOA.InterfaceOptResponse(response_name,model,self.response_settings)
-        for control_type in self.control_types:
-            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-
-    def GetVariableName(self):
-        return  self.variable
-
-    def GetGradientsVariablesName(self):
-        return self.gradients_variables
-
-    def GetGradientVariableNameForType(self,control_type, raise_error=True):
-        if raise_error:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("InterfaceResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
-
-        return self.gradients_variables[control_type]
-
-    def Initialize(self):
-        super().Initialize()
-        self.response_function.Initialize()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("InterfaceResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
-        startTime = timer.time()
-        self.value = self.response_function.CalculateValue()
-        Logger.PrintInfo("InterfaceResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")
-        return self.value
-
-    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
-
-        if raise_error:
-            for itr in range(len(controlled_objects)):
-                controlled_object = controlled_objects[itr]
-                control_type = control_types[itr]
-                found = False
-                for itr_2 in range(len(self.controlled_model_parts)):
-                    controlled_model_part = self.controlled_model_parts[itr_2]
-                    controlled_type = self.control_types[itr_2]
-                    if controlled_type==control_type and controlled_model_part==controlled_object:
-                        found = True
-                        break
-                if not found:
-                    raise RuntimeError("InterfaceResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
-
-        Logger.PrintInfo("InterfaceResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
-        startTime = timer.time()
-        self.response_function.CalculateGradient()
-        Logger.PrintInfo("InterfaceResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
-
-class PartitionMassResponseFunction(BaseResponseFunction):
-
-    def __init__(self,response_name, response_settings,model):
-
-        self.type = "partition_mass"
-        self.variable = "PARTITION_MASS"
-        super().__init__(response_name, response_settings, model)
-
-        self.supported_control_types = ["material"]
-        self.gradients_variables = {"material":"D_PARTITION_MASS_D_FD"}
-
-        if len(self.evaluated_model_parts) != 1:
-            raise RuntimeError("PartitionMassResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name))
-
-        for control_type in self.control_types:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("PartitionMassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
-
-
-        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
-        for evaluated_model_part in self.evaluated_model_parts:
-            if evaluated_model_part.split(".")[0] != root_model_part_name:
-                raise RuntimeError("PartitionMassResponseFunction: evaluated_model_parts of mass response must have the same root model part !")
-
-        self.root_model_part = self.model.GetModelPart(root_model_part_name)
-
-        # add vars and response
-        self.response_function = KOA.PartitionMassOptResponse(response_name,model,self.response_settings)
-        for control_type in self.control_types:
-            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-
-    def GetVariableName(self):
-        return  self.variable
-
-    def GetGradientsVariablesName(self):
-        return self.gradients_variables
-
-    def GetGradientVariableNameForType(self,control_type, raise_error=True):
-        if raise_error:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("PartitionMassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
-
-        return self.gradients_variables[control_type]
-
-    def Initialize(self):
-        super().Initialize()
-        self.response_function.Initialize()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("PartitionMassResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
-        startTime = timer.time()
-        self.value = self.response_function.CalculateValue()
-        Logger.PrintInfo("PartitionMassResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")
-        return self.value
-
-    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
-
-        if raise_error:
-            for itr in range(len(controlled_objects)):
-                controlled_object = controlled_objects[itr]
-                control_type = control_types[itr]
-                found = False
-                for itr_2 in range(len(self.controlled_model_parts)):
-                    controlled_model_part = self.controlled_model_parts[itr_2]
-                    controlled_type = self.control_types[itr_2]
-                    if controlled_type==control_type and controlled_model_part==controlled_object:
-                        found = True
-                        break
-                if not found:
-                    raise RuntimeError("PartitionMassResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
-
-        Logger.PrintInfo("PartitionMassResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
-        startTime = timer.time()
-        self.response_function.CalculateGradient()
-        Logger.PrintInfo("PartitionMassResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
-
-class PartitionMassResponseFunction(BaseResponseFunction):
-
-    def __init__(self,response_name, response_settings,model):
-
-        self.type = "partition_mass"
-        self.variable = "PARTITION_MASS"
-        super().__init__(response_name, response_settings, model)
-
-        self.supported_control_types = ["material"]
-        self.gradients_variables = {"material":"D_PARTITION_MASS_D_FD"}
-
-        if len(self.evaluated_model_parts) != 1:
-            raise RuntimeError("PartitionMassResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name))
-
-        for control_type in self.control_types:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("PartitionMassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
-
-
-        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
-        for evaluated_model_part in self.evaluated_model_parts:
-            if evaluated_model_part.split(".")[0] != root_model_part_name:
-                raise RuntimeError("PartitionMassResponseFunction: evaluated_model_parts of mass response must have the same root model part !")
-
-        self.root_model_part = self.model.GetModelPart(root_model_part_name)
-
-        # add vars and response
-        self.response_function = KOA.PartitionMassOptResponse(response_name,model,self.response_settings)
-        for control_type in self.control_types:
-            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-
-    def GetVariableName(self):
-        return  self.variable
-
-    def GetGradientsVariablesName(self):
-        return self.gradients_variables
-
-    def GetGradientVariableNameForType(self,control_type, raise_error=True):
-        if raise_error:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("PartitionMassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
-
-        return self.gradients_variables[control_type]
-
-    def Initialize(self):
-        super().Initialize()
-        self.response_function.Initialize()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("PartitionMassResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
-        startTime = timer.time()
-        self.value = self.response_function.CalculateValue()
-        Logger.PrintInfo("PartitionMassResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")
-        return self.value
-
-    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
-
-        if raise_error:
-            for itr in range(len(controlled_objects)):
-                controlled_object = controlled_objects[itr]
-                control_type = control_types[itr]
-                found = False
-                for itr_2 in range(len(self.controlled_model_parts)):
-                    controlled_model_part = self.controlled_model_parts[itr_2]
-                    controlled_type = self.control_types[itr_2]
-                    if controlled_type==control_type and controlled_model_part==controlled_object:
-                        found = True
-                        break
-                if not found:
-                    raise RuntimeError("PartitionMassResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
-
-        Logger.PrintInfo("PartitionMassResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
-        startTime = timer.time()
-        self.response_function.CalculateGradient()
-        Logger.PrintInfo("PartitionMassResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
-
-class PartitionInterfaceStressResponseFunction(BaseResponseFunction):
-
-    def __init__(self,response_name, response_settings,model):
-
-        self.type = "partition_interface_stress"
-        self.variable = "STRESS"
-        super().__init__(response_name, response_settings, model)
-
-        self.supported_control_types = ["material"]
-        self.gradients_variables = {"material":"D_STRESS_D_FD"}
-
-        if len(self.evaluated_model_parts) != 1:
-            raise RuntimeError("PartitionInterfaceStressResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name))
-
-        for control_type in self.control_types:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("PartitionInterfaceStressResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
-
-
-        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
-        for evaluated_model_part in self.evaluated_model_parts:
-            if evaluated_model_part.split(".")[0] != root_model_part_name:
-                raise RuntimeError("PartitionInterfaceStressResponseFunction: evaluated_model_parts of mass response must have the same root model part !")
-
-        self.root_model_part = self.model.GetModelPart(root_model_part_name)
-
-        # add vars and response
-        self.response_function = KOA.PartitionInterfaceStressOptResponse(response_name,model,self.response_settings)
-        for control_type in self.control_types:
-            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-
-    def GetVariableName(self):
-        return  self.variable
-
-    def GetGradientsVariablesName(self):
-        return self.gradients_variables
-
-    def GetGradientVariableNameForType(self,control_type, raise_error=True):
-        if raise_error:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("PartitionInterfaceStressResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
-
-        return self.gradients_variables[control_type]
-
-    def Initialize(self):
-        super().Initialize()
-        self.response_function.Initialize()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("PartitionInterfaceStressResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
-        startTime = timer.time()
-        self.value = self.response_function.CalculateValue()
-        Logger.PrintInfo("PartitionInterfaceStressResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")
-        return self.value
-
-    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
-
-        if raise_error:
-            for itr in range(len(controlled_objects)):
-                controlled_object = controlled_objects[itr]
-                control_type = control_types[itr]
-                found = False
-                for itr_2 in range(len(self.controlled_model_parts)):
-                    controlled_model_part = self.controlled_model_parts[itr_2]
-                    controlled_type = self.control_types[itr_2]
-                    if controlled_type==control_type and controlled_model_part==controlled_object:
-                        found = True
-                        break
-                if not found:
-                    raise RuntimeError("PartitionInterfaceStressResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
-
-        Logger.PrintInfo("PartitionInterfaceStressResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
-        startTime = timer.time()
-        self.response_function.CalculateGradient()
-        Logger.PrintInfo("PartitionInterfaceStressResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
-
-class MaxOverhangAngleResponseFunction(BaseResponseFunction):
-
-    def __init__(self,response_name, response_settings,model):
-
-        self.default_response_settings = KM.Parameters("""{
-                    "evaluated_objects": [],
-                    "control_types": [],
-                    "controlled_objects": [],
-                    "print_direction": [],
-                    "max_angle": -30.0,
-                    "heaviside_beta": 25.0,
-                    "penalty_factor": 2.0,
-                    "gradient_settings":{
-                        "step_size" : 1e-6,
-                        "gradient_mode": "finite_differencing"
-                    }
-                }""")
-
-        response_settings.RecursivelyValidateAndAssignDefaults(self.default_response_settings)
-
-        self.type = "max_overhang_angle"
-        self.variable = "MAX_OVERHANG_ANGLE"
-        super().__init__(response_name, response_settings, model)
-
-        self.supported_control_types = ["shape"]
-        self.gradients_variables = {"shape":"D_MAX_OVERHANG_ANGLE_D_X"}
-
-        if len(self.evaluated_model_parts) != 1:
-            raise RuntimeError("MaxOverhangAngleResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name))
-
-        for control_type in self.control_types:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("MaxOverhangAngleResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
-
-        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
-        for evaluated_model_part in self.evaluated_model_parts:
-            if evaluated_model_part.split(".")[0] != root_model_part_name:
-                raise RuntimeError("MaxOverhangAngleResponseFunction: evaluated_model_parts of max_overhang_angle response must have the same root model part !")
-
-        self.root_model_part = self.model.GetModelPart(root_model_part_name)
-
-        # add vars and response
-        for control_type in self.control_types:
-            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-
-
-    def GetVariableName(self):
-        return  self.variable
-
-    def GetGradientsVariablesName(self):
-        return self.gradients_variables
-
-    def GetGradientVariableNameForType(self,control_type, raise_error=True):
-        if raise_error:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("MaxOverhangAngleResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
-
-        return self.gradients_variables[control_type]
-
-    def Initialize(self):
-        super().Initialize()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("MaxOverhangAngleResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
-        startTime = timer.time()
-
-        r_evaluated_model_parts: 'list[KM.ModelPart]' = []
-        for model_part_name in self.evaluated_model_parts:
-            r_evaluated_model_parts.append(self.model[model_part_name])
-
-        self.value =  KOA.ResponseUtils.MaxOverhangAngleResponseUtils.CalculateValue(r_evaluated_model_parts,self.response_settings)
-
-        Logger.PrintInfo("MaxOverhangAngleResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")
-        return self.value
-
-    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
-
-        r_evaluated_model_parts: 'list[KM.ModelPart]' = []
-        for model_part_name in self.evaluated_model_parts:
-            r_evaluated_model_parts.append(self.model[model_part_name])
-
-        r_controlled_model_parts: 'list[KM.ModelPart]' = []
-        for model_part_name in controlled_objects:
-            r_controlled_model_parts.append(self.model[model_part_name])
-
-        Logger.PrintInfo("MaxOverhangAngleResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
-        startTime = timer.time()
-        KOA.ResponseUtils.MaxOverhangAngleResponseUtils.CalculateSensitivity(r_evaluated_model_parts,{KM.SHAPE_SENSITIVITY: r_controlled_model_parts},self.response_settings)
-
-        #TODO: After restructuring this copying data should be removed
-        for model_part in r_controlled_model_parts:
-            for node in model_part.Nodes:
-                shape_sens = node.GetValue(KM.SHAPE_SENSITIVITY)
-                node.SetSolutionStepValue(KM.KratosGlobals.GetVariable("D_MAX_OVERHANG_ANGLE_D_X"), shape_sens)
-
-        Logger.PrintInfo("MaxOverhangAngleResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
-
+import KratosMultiphysics as KM
+from KratosMultiphysics import Parameters, Logger
+import KratosMultiphysics.OptimizationApplication as KOA
+from KratosMultiphysics.OptimizationApplication.responses.base_response import BaseResponseFunction
+
+import time as timer
+import numpy as np
+
+class InterfaceResponseFunction(BaseResponseFunction):
+
+    def __init__(self,response_name, response_settings,model):
+
+        self.type = "interface"
+        self.variable = "INTERFACE"
+        super().__init__(response_name, response_settings, model)
+
+        self.supported_control_types = ["material"]
+        self.gradients_variables = {"material":"D_INTERFACE_D_FD"}
+
+        if len(self.evaluated_model_parts) != 1:
+            raise RuntimeError("InterfaceResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name))
+
+        for control_type in self.control_types:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("InterfaceResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
+
+
+        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
+        for evaluated_model_part in self.evaluated_model_parts:
+            if evaluated_model_part.split(".")[0] != root_model_part_name:
+                raise RuntimeError("InterfaceResponseFunction: evaluated_model_parts of mass response must have the same root model part !")
+
+        self.root_model_part = self.model.GetModelPart(root_model_part_name)
+
+        # add vars and response
+        self.response_function = KOA.InterfaceOptResponse(response_name,model,self.response_settings)
+        for control_type in self.control_types:
+            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+
+    def GetVariableName(self):
+        return  self.variable
+
+    def GetGradientsVariablesName(self):
+        return self.gradients_variables
+
+    def GetGradientVariableNameForType(self,control_type, raise_error=True):
+        if raise_error:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("InterfaceResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
+
+        return self.gradients_variables[control_type]
+
+    def Initialize(self):
+        super().Initialize()
+        self.response_function.Initialize()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("InterfaceResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
+        startTime = timer.time()
+        self.value = self.response_function.CalculateValue()
+        Logger.PrintInfo("InterfaceResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")
+        return self.value
+
+    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
+
+        if raise_error:
+            for itr in range(len(controlled_objects)):
+                controlled_object = controlled_objects[itr]
+                control_type = control_types[itr]
+                found = False
+                for itr_2 in range(len(self.controlled_model_parts)):
+                    controlled_model_part = self.controlled_model_parts[itr_2]
+                    controlled_type = self.control_types[itr_2]
+                    if controlled_type==control_type and controlled_model_part==controlled_object:
+                        found = True
+                        break
+                if not found:
+                    raise RuntimeError("InterfaceResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
+
+        Logger.PrintInfo("InterfaceResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
+        startTime = timer.time()
+        self.response_function.CalculateGradient()
+        Logger.PrintInfo("InterfaceResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
+
+class PartitionMassResponseFunction(BaseResponseFunction):
+
+    def __init__(self,response_name, response_settings,model):
+
+        self.type = "partition_mass"
+        self.variable = "PARTITION_MASS"
+        super().__init__(response_name, response_settings, model)
+
+        self.supported_control_types = ["material"]
+        self.gradients_variables = {"material":"D_PARTITION_MASS_D_FD"}
+
+        if len(self.evaluated_model_parts) != 1:
+            raise RuntimeError("PartitionMassResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name))
+
+        for control_type in self.control_types:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("PartitionMassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
+
+
+        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
+        for evaluated_model_part in self.evaluated_model_parts:
+            if evaluated_model_part.split(".")[0] != root_model_part_name:
+                raise RuntimeError("PartitionMassResponseFunction: evaluated_model_parts of mass response must have the same root model part !")
+
+        self.root_model_part = self.model.GetModelPart(root_model_part_name)
+
+        # add vars and response
+        self.response_function = KOA.PartitionMassOptResponse(response_name,model,self.response_settings)
+        for control_type in self.control_types:
+            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+
+    def GetVariableName(self):
+        return  self.variable
+
+    def GetGradientsVariablesName(self):
+        return self.gradients_variables
+
+    def GetGradientVariableNameForType(self,control_type, raise_error=True):
+        if raise_error:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("PartitionMassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
+
+        return self.gradients_variables[control_type]
+
+    def Initialize(self):
+        super().Initialize()
+        self.response_function.Initialize()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("PartitionMassResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
+        startTime = timer.time()
+        self.value = self.response_function.CalculateValue()
+        Logger.PrintInfo("PartitionMassResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")
+        return self.value
+
+    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
+
+        if raise_error:
+            for itr in range(len(controlled_objects)):
+                controlled_object = controlled_objects[itr]
+                control_type = control_types[itr]
+                found = False
+                for itr_2 in range(len(self.controlled_model_parts)):
+                    controlled_model_part = self.controlled_model_parts[itr_2]
+                    controlled_type = self.control_types[itr_2]
+                    if controlled_type==control_type and controlled_model_part==controlled_object:
+                        found = True
+                        break
+                if not found:
+                    raise RuntimeError("PartitionMassResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
+
+        Logger.PrintInfo("PartitionMassResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
+        startTime = timer.time()
+        self.response_function.CalculateGradient()
+        Logger.PrintInfo("PartitionMassResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
+
+class PartitionMassResponseFunction(BaseResponseFunction):
+
+    def __init__(self,response_name, response_settings,model):
+
+        self.type = "partition_mass"
+        self.variable = "PARTITION_MASS"
+        super().__init__(response_name, response_settings, model)
+
+        self.supported_control_types = ["material"]
+        self.gradients_variables = {"material":"D_PARTITION_MASS_D_FD"}
+
+        if len(self.evaluated_model_parts) != 1:
+            raise RuntimeError("PartitionMassResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name))
+
+        for control_type in self.control_types:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("PartitionMassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
+
+
+        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
+        for evaluated_model_part in self.evaluated_model_parts:
+            if evaluated_model_part.split(".")[0] != root_model_part_name:
+                raise RuntimeError("PartitionMassResponseFunction: evaluated_model_parts of mass response must have the same root model part !")
+
+        self.root_model_part = self.model.GetModelPart(root_model_part_name)
+
+        # add vars and response
+        self.response_function = KOA.PartitionMassOptResponse(response_name,model,self.response_settings)
+        for control_type in self.control_types:
+            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+
+    def GetVariableName(self):
+        return  self.variable
+
+    def GetGradientsVariablesName(self):
+        return self.gradients_variables
+
+    def GetGradientVariableNameForType(self,control_type, raise_error=True):
+        if raise_error:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("PartitionMassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
+
+        return self.gradients_variables[control_type]
+
+    def Initialize(self):
+        super().Initialize()
+        self.response_function.Initialize()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("PartitionMassResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
+        startTime = timer.time()
+        self.value = self.response_function.CalculateValue()
+        Logger.PrintInfo("PartitionMassResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")
+        return self.value
+
+    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
+
+        if raise_error:
+            for itr in range(len(controlled_objects)):
+                controlled_object = controlled_objects[itr]
+                control_type = control_types[itr]
+                found = False
+                for itr_2 in range(len(self.controlled_model_parts)):
+                    controlled_model_part = self.controlled_model_parts[itr_2]
+                    controlled_type = self.control_types[itr_2]
+                    if controlled_type==control_type and controlled_model_part==controlled_object:
+                        found = True
+                        break
+                if not found:
+                    raise RuntimeError("PartitionMassResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
+
+        Logger.PrintInfo("PartitionMassResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
+        startTime = timer.time()
+        self.response_function.CalculateGradient()
+        Logger.PrintInfo("PartitionMassResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
+
+class PartitionInterfaceStressResponseFunction(BaseResponseFunction):
+
+    def __init__(self,response_name, response_settings,model):
+
+        self.type = "partition_interface_stress"
+        self.variable = "STRESS"
+        super().__init__(response_name, response_settings, model)
+
+        self.supported_control_types = ["material"]
+        self.gradients_variables = {"material":"D_STRESS_D_FD"}
+
+        if len(self.evaluated_model_parts) != 1:
+            raise RuntimeError("PartitionInterfaceStressResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name))
+
+        for control_type in self.control_types:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("PartitionInterfaceStressResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
+
+
+        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
+        for evaluated_model_part in self.evaluated_model_parts:
+            if evaluated_model_part.split(".")[0] != root_model_part_name:
+                raise RuntimeError("PartitionInterfaceStressResponseFunction: evaluated_model_parts of mass response must have the same root model part !")
+
+        self.root_model_part = self.model.GetModelPart(root_model_part_name)
+
+        # add vars and response
+        self.response_function = KOA.PartitionInterfaceStressOptResponse(response_name,model,self.response_settings)
+        for control_type in self.control_types:
+            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+
+    def GetVariableName(self):
+        return  self.variable
+
+    def GetGradientsVariablesName(self):
+        return self.gradients_variables
+
+    def GetGradientVariableNameForType(self,control_type, raise_error=True):
+        if raise_error:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("PartitionInterfaceStressResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
+
+        return self.gradients_variables[control_type]
+
+    def Initialize(self):
+        super().Initialize()
+        self.response_function.Initialize()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("PartitionInterfaceStressResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
+        startTime = timer.time()
+        self.value = self.response_function.CalculateValue()
+        Logger.PrintInfo("PartitionInterfaceStressResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")
+        return self.value
+
+    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
+
+        if raise_error:
+            for itr in range(len(controlled_objects)):
+                controlled_object = controlled_objects[itr]
+                control_type = control_types[itr]
+                found = False
+                for itr_2 in range(len(self.controlled_model_parts)):
+                    controlled_model_part = self.controlled_model_parts[itr_2]
+                    controlled_type = self.control_types[itr_2]
+                    if controlled_type==control_type and controlled_model_part==controlled_object:
+                        found = True
+                        break
+                if not found:
+                    raise RuntimeError("PartitionInterfaceStressResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
+
+        Logger.PrintInfo("PartitionInterfaceStressResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
+        startTime = timer.time()
+        self.response_function.CalculateGradient()
+        Logger.PrintInfo("PartitionInterfaceStressResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
+
+class MaxOverhangAngleResponseFunction(BaseResponseFunction):
+
+    def __init__(self,response_name, response_settings,model):
+
+        self.default_response_settings = KM.Parameters("""{
+                    "evaluated_objects": [],
+                    "control_types": [],
+                    "controlled_objects": [],
+                    "print_direction": [],
+                    "max_angle": -30.0,
+                    "heaviside_beta": 25.0,
+                    "penalty_factor": 2.0,
+                    "gradient_settings":{
+                        "step_size" : 1e-6,
+                        "gradient_mode": "finite_differencing"
+                    }
+                }""")
+
+        response_settings.RecursivelyValidateAndAssignDefaults(self.default_response_settings)
+
+        self.type = "max_overhang_angle"
+        self.variable = "MAX_OVERHANG_ANGLE"
+        super().__init__(response_name, response_settings, model)
+
+        self.supported_control_types = ["shape"]
+        self.gradients_variables = {"shape":"D_MAX_OVERHANG_ANGLE_D_X"}
+
+        if len(self.evaluated_model_parts) != 1:
+            raise RuntimeError("MaxOverhangAngleResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name))
+
+        for control_type in self.control_types:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("MaxOverhangAngleResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
+
+        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
+        for evaluated_model_part in self.evaluated_model_parts:
+            if evaluated_model_part.split(".")[0] != root_model_part_name:
+                raise RuntimeError("MaxOverhangAngleResponseFunction: evaluated_model_parts of max_overhang_angle response must have the same root model part !")
+
+        self.root_model_part = self.model.GetModelPart(root_model_part_name)
+
+        # add vars and response
+        for control_type in self.control_types:
+            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+
+
+    def GetVariableName(self):
+        return  self.variable
+
+    def GetGradientsVariablesName(self):
+        return self.gradients_variables
+
+    def GetGradientVariableNameForType(self,control_type, raise_error=True):
+        if raise_error:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("MaxOverhangAngleResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types))
+
+        return self.gradients_variables[control_type]
+
+    def Initialize(self):
+        super().Initialize()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("MaxOverhangAngleResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
+        startTime = timer.time()
+
+        r_evaluated_model_parts: 'list[KM.ModelPart]' = []
+        for model_part_name in self.evaluated_model_parts:
+            r_evaluated_model_parts.append(self.model[model_part_name])
+
+        self.value =  KOA.ResponseUtils.MaxOverhangAngleResponseUtils.CalculateValue(r_evaluated_model_parts,self.response_settings)
+
+        Logger.PrintInfo("MaxOverhangAngleResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")
+        return self.value
+
+    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
+
+        r_evaluated_model_parts: 'list[KM.ModelPart]' = []
+        for model_part_name in self.evaluated_model_parts:
+            r_evaluated_model_parts.append(self.model[model_part_name])
+
+        r_controlled_model_parts: 'list[KM.ModelPart]' = []
+        for model_part_name in controlled_objects:
+            r_controlled_model_parts.append(self.model[model_part_name])
+
+        Logger.PrintInfo("MaxOverhangAngleResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
+        startTime = timer.time()
+        KOA.ResponseUtils.MaxOverhangAngleResponseUtils.CalculateSensitivity(r_evaluated_model_parts,{KM.SHAPE_SENSITIVITY: r_controlled_model_parts},self.response_settings)
+
+        #TODO: After restructuring this copying data should be removed
+        for model_part in r_controlled_model_parts:
+            for node in model_part.Nodes:
+                shape_sens = node.GetValue(KM.SHAPE_SENSITIVITY)
+                node.SetSolutionStepValue(KM.KratosGlobals.GetVariable("D_MAX_OVERHANG_ANGLE_D_X"), shape_sens)
+
+        Logger.PrintInfo("MaxOverhangAngleResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
+
```

## KratosMultiphysics/OptimizationApplication/responses/analysis_based_response_function_factory.py

 * *Ordering differences only*

```diff
@@ -1,14 +1,14 @@
-# importing the Kratos Library
-from . import structural_responses
-from . import additive_manufacturing_responses
-
-def CreateResponseFunction(response_name,response_type,response_settings, response_analysis,model):
-
-    if response_type == "strain_energy": 
-        return structural_responses.StrainEnergyResponseFunction(response_name,response_settings,response_analysis,model)
-
-    elif response_type == "stress":
-        return structural_responses.StressResponseFunction(response_name,response_settings,response_analysis,model)
-
-    elif response_type == "partition_interface_stress":
-        return additive_manufacturing_responses.PartitionInterfaceStressResponseFunction(response_name,response_settings,model)        
+# importing the Kratos Library
+from . import structural_responses
+from . import additive_manufacturing_responses
+
+def CreateResponseFunction(response_name,response_type,response_settings, response_analysis,model):
+
+    if response_type == "strain_energy": 
+        return structural_responses.StrainEnergyResponseFunction(response_name,response_settings,response_analysis,model)
+
+    elif response_type == "stress":
+        return structural_responses.StressResponseFunction(response_name,response_settings,response_analysis,model)
+
+    elif response_type == "partition_interface_stress":
+        return additive_manufacturing_responses.PartitionInterfaceStressResponseFunction(response_name,response_settings,model)
```

## KratosMultiphysics/OptimizationApplication/responses/analysis_free_response_function_factory.py

 * *Ordering differences only*

```diff
@@ -1,14 +1,14 @@
-# importing the Kratos Library
-from . import structural_responses
-from . import additive_manufacturing_responses
-
-def CreateResponseFunction(response_name,response_type,response_settings,model):
-
-    if response_type == "mass":
-        return structural_responses.MassResponseFunction(response_name,response_settings,model)
-    elif response_type == "interface":
-        return additive_manufacturing_responses.InterfaceResponseFunction(response_name,response_settings,model)
-    elif response_type == "partition_mass":
-        return additive_manufacturing_responses.PartitionMassResponseFunction(response_name,response_settings,model)
-    elif response_type == "am_max_overhang_angle":
+# importing the Kratos Library
+from . import structural_responses
+from . import additive_manufacturing_responses
+
+def CreateResponseFunction(response_name,response_type,response_settings,model):
+
+    if response_type == "mass":
+        return structural_responses.MassResponseFunction(response_name,response_settings,model)
+    elif response_type == "interface":
+        return additive_manufacturing_responses.InterfaceResponseFunction(response_name,response_settings,model)
+    elif response_type == "partition_mass":
+        return additive_manufacturing_responses.PartitionMassResponseFunction(response_name,response_settings,model)
+    elif response_type == "am_max_overhang_angle":
         return additive_manufacturing_responses.MaxOverhangAngleResponseFunction(response_name,response_settings,model)
```

## KratosMultiphysics/OptimizationApplication/responses/base_response.py

 * *Ordering differences only*

```diff
@@ -1,66 +1,66 @@
-# importing the Kratos Library
-from numpy import gradient
-import KratosMultiphysics as KM
-from KratosMultiphysics import Parameters, Logger
-import KratosMultiphysics.OptimizationApplication as KOA
-
-import time as timer
-import numpy as np
-
-# ==============================================================================
-class BaseResponseFunction:
-
-    def __init__(self,response_name, response_settings, model, response_analysis=None):
-       
-        self.name = response_name
-        self.response_settings = response_settings
-        self.model = model
-        self.analysis = response_analysis
-        self.analysis_model_part = None
-        if not response_analysis == None:
-            self.analysis_model_part = self.analysis._GetSolver().GetComputingModelPart()
-
-        self.evaluated_model_parts = response_settings["evaluated_objects"].GetStringArray()
-        self.controlled_model_parts = response_settings["controlled_objects"].GetStringArray()
-        self.control_types = response_settings["control_types"].GetStringArray()  
-
-    def Initialize(self):
-
-        for evaluated_model_part in self.evaluated_model_parts:
-            if not self.analysis == None:
-                evaluated_model_part_splitted = evaluated_model_part.split(".")
-                if not evaluated_model_part_splitted[0] == self.analysis_model_part.Name:
-                    raise RuntimeError("BaseResponseFunction:Initialize: root evaluated_model_part {} of response '{}' is not the analysis model!".format(evaluated_model_part_splitted[0],self.name))
-            if not self.model.HasModelPart(evaluated_model_part): 
-                raise RuntimeError("BaseResponseFunction:Initialize: evaluated_model_part {} of response '{}' does not exist!".format(evaluated_model_part,self.name))
-
-        for controlled_model_part in self.controlled_model_parts:
-            if not self.model.HasModelPart(controlled_model_part): 
-                raise RuntimeError("BaseResponseFunction:Initialize: controlled_model_part {} of response '{}' does not exist!".format(controlled_model_part,self.name))
-
-    def CalculateValue(self):
-        raise RuntimeError("BaseResponseFunction:CalculateValue: Not implemeted ! ")
-
-    def GetValue(self):
-        raise RuntimeError("BaseResponseFunction:GetValue: Not implemeted ! ")
-
-    def CalculateGradients(self):
-        raise RuntimeError("BaseResponseFunction:CalculateGradients: Not implemeted ! ")
-
-    def CalculateGradientsForTypeAndObjects(self,control_type,controlled_objects,raise_error=True):
-        raise RuntimeError("BaseResponseFunction:CalculateGradientsForTypeAndObjects: Not implemeted ! ") 
-
-    def GetGradients(self):
-        raise RuntimeError("BaseResponseFunction:GetGradients: Not implemeted ! ")
-
-    def GetType(self):
-        raise RuntimeError("BaseResponseFunction:GetValue: Not implemeted ! ")        
-
-    def GetVariableName(self):
-        raise RuntimeError("BaseResponseFunction:GetVariableName: Not implemeted ! ") 
-
-    def GetGradientsVariablesName(self):
-        raise RuntimeError("BaseResponseFunction:GetGradientsVariablesName: Not implemeted ! ")
-
-    def GetGradientVariableNameForType(self,control_type):
+# importing the Kratos Library
+from numpy import gradient
+import KratosMultiphysics as KM
+from KratosMultiphysics import Parameters, Logger
+import KratosMultiphysics.OptimizationApplication as KOA
+
+import time as timer
+import numpy as np
+
+# ==============================================================================
+class BaseResponseFunction:
+
+    def __init__(self,response_name, response_settings, model, response_analysis=None):
+       
+        self.name = response_name
+        self.response_settings = response_settings
+        self.model = model
+        self.analysis = response_analysis
+        self.analysis_model_part = None
+        if not response_analysis == None:
+            self.analysis_model_part = self.analysis._GetSolver().GetComputingModelPart()
+
+        self.evaluated_model_parts = response_settings["evaluated_objects"].GetStringArray()
+        self.controlled_model_parts = response_settings["controlled_objects"].GetStringArray()
+        self.control_types = response_settings["control_types"].GetStringArray()  
+
+    def Initialize(self):
+
+        for evaluated_model_part in self.evaluated_model_parts:
+            if not self.analysis == None:
+                evaluated_model_part_splitted = evaluated_model_part.split(".")
+                if not evaluated_model_part_splitted[0] == self.analysis_model_part.Name:
+                    raise RuntimeError("BaseResponseFunction:Initialize: root evaluated_model_part {} of response '{}' is not the analysis model!".format(evaluated_model_part_splitted[0],self.name))
+            if not self.model.HasModelPart(evaluated_model_part): 
+                raise RuntimeError("BaseResponseFunction:Initialize: evaluated_model_part {} of response '{}' does not exist!".format(evaluated_model_part,self.name))
+
+        for controlled_model_part in self.controlled_model_parts:
+            if not self.model.HasModelPart(controlled_model_part): 
+                raise RuntimeError("BaseResponseFunction:Initialize: controlled_model_part {} of response '{}' does not exist!".format(controlled_model_part,self.name))
+
+    def CalculateValue(self):
+        raise RuntimeError("BaseResponseFunction:CalculateValue: Not implemeted ! ")
+
+    def GetValue(self):
+        raise RuntimeError("BaseResponseFunction:GetValue: Not implemeted ! ")
+
+    def CalculateGradients(self):
+        raise RuntimeError("BaseResponseFunction:CalculateGradients: Not implemeted ! ")
+
+    def CalculateGradientsForTypeAndObjects(self,control_type,controlled_objects,raise_error=True):
+        raise RuntimeError("BaseResponseFunction:CalculateGradientsForTypeAndObjects: Not implemeted ! ") 
+
+    def GetGradients(self):
+        raise RuntimeError("BaseResponseFunction:GetGradients: Not implemeted ! ")
+
+    def GetType(self):
+        raise RuntimeError("BaseResponseFunction:GetValue: Not implemeted ! ")        
+
+    def GetVariableName(self):
+        raise RuntimeError("BaseResponseFunction:GetVariableName: Not implemeted ! ") 
+
+    def GetGradientsVariablesName(self):
+        raise RuntimeError("BaseResponseFunction:GetGradientsVariablesName: Not implemeted ! ")
+
+    def GetGradientVariableNameForType(self,control_type):
         raise RuntimeError("BaseResponseFunction:GetGradientVariableNameForType: Not implemeted ! ")
```

## KratosMultiphysics/OptimizationApplication/responses/geometric_centroid_deviation_response_function.py

 * *Ordering differences only*

```diff
@@ -1,105 +1,105 @@
-from typing import Optional
-
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
-from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
-from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartUtilities
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> ResponseFunction:
-    if not parameters.Has("name"):
-        raise RuntimeError(f"GeometricCentroidDeviationResponseFunction instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"GeometricCentroidDeviationResponseFunction instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-
-    return GeometricCentroidDeviationResponseFunction(parameters["name"].GetString(), model, parameters["settings"])
-
-class GeometricCentroidDeviationResponseFunction(ResponseFunction):
-    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters):
-        super().__init__(name)
-
-        default_settings = Kratos.Parameters("""{
-            "evaluated_model_part_names"     : [
-                "PLEASE_PROVIDE_A_MODEL_PART_NAME"
-            ]
-        }""")
-        parameters.ValidateAndAssignDefaults(default_settings)
-
-        self.model = model
-
-        evaluated_model_part_names = parameters["evaluated_model_part_names"].GetStringArray()
-        if len(evaluated_model_part_names) == 0:
-            raise RuntimeError(f"No model parts were provided for GeometricCentroidDeviationResponseFunction. [ response name = \"{self.GetName()}\"]")
-
-        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"response_{self.GetName()}", evaluated_model_part_names, False)
-        self.model_part: Optional[Kratos.ModelPart] = None
-
-    def GetImplementedPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
-        return [KratosOA.SHAPE]
-
-    def GetEvaluatedModelPart(self) -> Kratos.ModelPart:
-        if self.model_part is None:
-            raise RuntimeError("Please call GeometricCentroidDeviationResponseFunction::Initialize first.")
-        return self.model_part
-
-    def GetAnalysisModelPart(self) -> None:
-        return None
-
-    def Initialize(self) -> None:
-        self.model_part = self.model_part_operation.GetModelPart()
-
-        self.model_part_center = Kratos.Array3(0.0)
-        number_of_nodes = self.model_part.GetCommunicator().GlobalNumberOfNodes()
-
-        if number_of_nodes == 0:
-            raise RuntimeError(f"The provided model part {self.model_part.FullName()} does not contain any nodes.")
-
-        for node in self.model_part.Nodes:
-            self.model_part_center[0] += node.X
-            self.model_part_center[1] += node.Y
-            self.model_part_center[2] += node.Z
-
-        self.model_part_center = self.model_part.GetCommunicator().GetDataCommunicator().SumAll(self.model_part_center)
-        self.model_part_center /= number_of_nodes
-
-    def Check(self) -> None:
-        pass
-
-    def Finalize(self) -> None:
-        pass
-
-    def CalculateValue(self) -> float:
-        average_location = Kratos.Array3(0.0)
-        for node in self.model_part.Nodes:
-            average_location[0] += node.X
-            average_location[1] += node.Y
-            average_location[2] += node.Z
-
-        average_location = self.model_part.GetCommunicator().GetDataCommunicator().SumAll(average_location)
-
-        number_of_nodes = self.model_part.GetCommunicator().GlobalNumberOfNodes()
-        self.value_array = (average_location / number_of_nodes  - self.model_part_center)
-        return self.value_array[0] ** 2 + self.value_array[1] ** 2 + self.value_array[2] ** 2
-
-    def CalculateGradient(self, physical_variable_collective_expressions: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]') -> None:
-        # first merge all the model parts
-        merged_model_part_map = ModelPartUtilities.GetMergedMap(physical_variable_collective_expressions, False)
-
-        # now get the intersected model parts
-        intersected_model_part_map = ModelPartUtilities.GetIntersectedMap(self.model_part, merged_model_part_map, False)
-
-        number_of_nodes = self.model_part.GetCommunicator().GlobalNumberOfNodes()
-
-        # calculate the gradients
-        for physical_variable, merged_model_part in merged_model_part_map.items():
-            if physical_variable == KratosOA.SHAPE:
-                Kratos.VariableUtils().SetNonHistoricalVariableToZero(Kratos.SHAPE_SENSITIVITY, merged_model_part.Nodes)
-                Kratos.VariableUtils().SetNonHistoricalVariable(Kratos.SHAPE_SENSITIVITY, 2.0 * self.value_array / number_of_nodes, intersected_model_part_map[physical_variable].Nodes)
-                for container_expression in physical_variable_collective_expressions[physical_variable].GetContainerExpressions():
-                    if isinstance(container_expression, Kratos.Expression.NodalExpression):
-                        Kratos.Expression.VariableExpressionIO.Read(container_expression, Kratos.SHAPE_SENSITIVITY, False)
-                    else:
-                        raise RuntimeError(f"Requesting sensitivity w.r.t. SHAPE for a Container expression which is not a NodalExpression. [ Requested container expression = {container_expression} ].")
-            else:
-                raise RuntimeError(f"Unsupported sensitivity w.r.t. {physical_variable.Name()} requested. Followings are supported sensitivity variables:\n\tSHAPE")
+from typing import Optional
+
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
+from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
+from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartUtilities
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> ResponseFunction:
+    if not parameters.Has("name"):
+        raise RuntimeError(f"GeometricCentroidDeviationResponseFunction instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"GeometricCentroidDeviationResponseFunction instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+
+    return GeometricCentroidDeviationResponseFunction(parameters["name"].GetString(), model, parameters["settings"])
+
+class GeometricCentroidDeviationResponseFunction(ResponseFunction):
+    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters):
+        super().__init__(name)
+
+        default_settings = Kratos.Parameters("""{
+            "evaluated_model_part_names"     : [
+                "PLEASE_PROVIDE_A_MODEL_PART_NAME"
+            ]
+        }""")
+        parameters.ValidateAndAssignDefaults(default_settings)
+
+        self.model = model
+
+        evaluated_model_part_names = parameters["evaluated_model_part_names"].GetStringArray()
+        if len(evaluated_model_part_names) == 0:
+            raise RuntimeError(f"No model parts were provided for GeometricCentroidDeviationResponseFunction. [ response name = \"{self.GetName()}\"]")
+
+        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"response_{self.GetName()}", evaluated_model_part_names, False)
+        self.model_part: Optional[Kratos.ModelPart] = None
+
+    def GetImplementedPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
+        return [KratosOA.SHAPE]
+
+    def GetEvaluatedModelPart(self) -> Kratos.ModelPart:
+        if self.model_part is None:
+            raise RuntimeError("Please call GeometricCentroidDeviationResponseFunction::Initialize first.")
+        return self.model_part
+
+    def GetAnalysisModelPart(self) -> None:
+        return None
+
+    def Initialize(self) -> None:
+        self.model_part = self.model_part_operation.GetModelPart()
+
+        self.model_part_center = Kratos.Array3(0.0)
+        number_of_nodes = self.model_part.GetCommunicator().GlobalNumberOfNodes()
+
+        if number_of_nodes == 0:
+            raise RuntimeError(f"The provided model part {self.model_part.FullName()} does not contain any nodes.")
+
+        for node in self.model_part.Nodes:
+            self.model_part_center[0] += node.X
+            self.model_part_center[1] += node.Y
+            self.model_part_center[2] += node.Z
+
+        self.model_part_center = self.model_part.GetCommunicator().GetDataCommunicator().SumAll(self.model_part_center)
+        self.model_part_center /= number_of_nodes
+
+    def Check(self) -> None:
+        pass
+
+    def Finalize(self) -> None:
+        pass
+
+    def CalculateValue(self) -> float:
+        average_location = Kratos.Array3(0.0)
+        for node in self.model_part.Nodes:
+            average_location[0] += node.X
+            average_location[1] += node.Y
+            average_location[2] += node.Z
+
+        average_location = self.model_part.GetCommunicator().GetDataCommunicator().SumAll(average_location)
+
+        number_of_nodes = self.model_part.GetCommunicator().GlobalNumberOfNodes()
+        self.value_array = (average_location / number_of_nodes  - self.model_part_center)
+        return self.value_array[0] ** 2 + self.value_array[1] ** 2 + self.value_array[2] ** 2
+
+    def CalculateGradient(self, physical_variable_collective_expressions: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]') -> None:
+        # first merge all the model parts
+        merged_model_part_map = ModelPartUtilities.GetMergedMap(physical_variable_collective_expressions, False)
+
+        # now get the intersected model parts
+        intersected_model_part_map = ModelPartUtilities.GetIntersectedMap(self.model_part, merged_model_part_map, False)
+
+        number_of_nodes = self.model_part.GetCommunicator().GlobalNumberOfNodes()
+
+        # calculate the gradients
+        for physical_variable, merged_model_part in merged_model_part_map.items():
+            if physical_variable == KratosOA.SHAPE:
+                Kratos.VariableUtils().SetNonHistoricalVariableToZero(Kratos.SHAPE_SENSITIVITY, merged_model_part.Nodes)
+                Kratos.VariableUtils().SetNonHistoricalVariable(Kratos.SHAPE_SENSITIVITY, 2.0 * self.value_array / number_of_nodes, intersected_model_part_map[physical_variable].Nodes)
+                for container_expression in physical_variable_collective_expressions[physical_variable].GetContainerExpressions():
+                    if isinstance(container_expression, Kratos.Expression.NodalExpression):
+                        Kratos.Expression.VariableExpressionIO.Read(container_expression, Kratos.SHAPE_SENSITIVITY, False)
+                    else:
+                        raise RuntimeError(f"Requesting sensitivity w.r.t. SHAPE for a Container expression which is not a NodalExpression. [ Requested container expression = {container_expression} ].")
+            else:
+                raise RuntimeError(f"Unsupported sensitivity w.r.t. {physical_variable.Name()} requested. Followings are supported sensitivity variables:\n\tSHAPE")
```

## KratosMultiphysics/OptimizationApplication/responses/linear_strain_energy_response_function.py

 * *Ordering differences only*

```diff
@@ -1,85 +1,85 @@
-from typing import Optional
-
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy_decorator import ExecutionPolicyDecorator
-from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
-from KratosMultiphysics.OptimizationApplication.responses.response_function import SupportedSensitivityFieldVariableTypes
-from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
-from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartUtilities
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> ResponseFunction:
-    if not parameters.Has("name"):
-        raise RuntimeError(f"LinearStrainEnergyResponseFunction instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"LinearStrainEnergyResponseFunction instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-
-    return LinearStrainEnergyResponseFunction(parameters["name"].GetString(), model, parameters["settings"], optimization_problem)
-
-class LinearStrainEnergyResponseFunction(ResponseFunction):
-    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        super().__init__(name)
-
-        default_settings = Kratos.Parameters("""{
-            "primal_analysis_name"           : "",
-            "perturbation_size"              : 1e-8,
-            "evaluated_model_part_names"     : [
-                "PLEASE_PROVIDE_A_MODEL_PART_NAME"
-            ]
-        }""")
-        parameters.ValidateAndAssignDefaults(default_settings)
-
-        self.perturbation_size = parameters["perturbation_size"].GetDouble()
-        self.model = model
-        self.primal_analysis_execution_policy_decorator: ExecutionPolicyDecorator = optimization_problem.GetExecutionPolicy(parameters["primal_analysis_name"].GetString())
-
-        evaluated_model_part_names = parameters["evaluated_model_part_names"].GetStringArray()
-        if len(evaluated_model_part_names) == 0:
-            raise RuntimeError(f"No model parts were provided for LinearStrainEnergyResponseFunction. [ response name = \"{self.GetName()}\"]")
-
-        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"response_{self.GetName()}", evaluated_model_part_names, False)
-        self.model_part: Optional[Kratos.ModelPart] = None
-
-    def GetImplementedPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
-        return [KratosOA.SHAPE, Kratos.YOUNG_MODULUS, Kratos.THICKNESS, Kratos.POISSON_RATIO]
-
-    def Initialize(self) -> None:
-        self.model_part = self.model_part_operation.GetModelPart()
-
-    def Check(self) -> None:
-        pass
-
-    def Finalize(self) -> None:
-        pass
-
-    def GetEvaluatedModelPart(self) -> Kratos.ModelPart:
-        if self.model_part is None:
-            raise RuntimeError("Please call LinearStrainEnergyResponseFunction::Initialize first.")
-        return self.model_part
-
-    def GetAnalysisModelPart(self) -> Kratos.ModelPart:
-        return self.primal_analysis_execution_policy_decorator.GetAnalysisModelPart()
-
-    def CalculateValue(self) -> float:
-        self.primal_analysis_execution_policy_decorator.Execute()
-        return KratosOA.ResponseUtils.LinearStrainEnergyResponseUtils.CalculateValue(self.model_part)
-
-    def CalculateGradient(self, physical_variable_collective_expressions: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]') -> None:
-        # first merge all the model parts
-        merged_model_part_map = ModelPartUtilities.GetMergedMap(physical_variable_collective_expressions, False)
-
-        # now get the intersected model parts
-        intersected_model_part_map = ModelPartUtilities.GetIntersectedMap(self.model_part, merged_model_part_map, True)
-
-        # calculate the gradients
-        for physical_variable, merged_model_part in merged_model_part_map.items():
-            KratosOA.ResponseUtils.LinearStrainEnergyResponseUtils.CalculateGradient(
-                physical_variable,
-                merged_model_part,
-                intersected_model_part_map[physical_variable],
-                physical_variable_collective_expressions[physical_variable].GetContainerExpressions(),
-                self.perturbation_size)
-
-    def __str__(self) -> str:
+from typing import Optional
+
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy_decorator import ExecutionPolicyDecorator
+from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
+from KratosMultiphysics.OptimizationApplication.responses.response_function import SupportedSensitivityFieldVariableTypes
+from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
+from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartUtilities
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem) -> ResponseFunction:
+    if not parameters.Has("name"):
+        raise RuntimeError(f"LinearStrainEnergyResponseFunction instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"LinearStrainEnergyResponseFunction instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+
+    return LinearStrainEnergyResponseFunction(parameters["name"].GetString(), model, parameters["settings"], optimization_problem)
+
+class LinearStrainEnergyResponseFunction(ResponseFunction):
+    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        super().__init__(name)
+
+        default_settings = Kratos.Parameters("""{
+            "primal_analysis_name"           : "",
+            "perturbation_size"              : 1e-8,
+            "evaluated_model_part_names"     : [
+                "PLEASE_PROVIDE_A_MODEL_PART_NAME"
+            ]
+        }""")
+        parameters.ValidateAndAssignDefaults(default_settings)
+
+        self.perturbation_size = parameters["perturbation_size"].GetDouble()
+        self.model = model
+        self.primal_analysis_execution_policy_decorator: ExecutionPolicyDecorator = optimization_problem.GetExecutionPolicy(parameters["primal_analysis_name"].GetString())
+
+        evaluated_model_part_names = parameters["evaluated_model_part_names"].GetStringArray()
+        if len(evaluated_model_part_names) == 0:
+            raise RuntimeError(f"No model parts were provided for LinearStrainEnergyResponseFunction. [ response name = \"{self.GetName()}\"]")
+
+        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"response_{self.GetName()}", evaluated_model_part_names, False)
+        self.model_part: Optional[Kratos.ModelPart] = None
+
+    def GetImplementedPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
+        return [KratosOA.SHAPE, Kratos.YOUNG_MODULUS, Kratos.THICKNESS, Kratos.POISSON_RATIO]
+
+    def Initialize(self) -> None:
+        self.model_part = self.model_part_operation.GetModelPart()
+
+    def Check(self) -> None:
+        pass
+
+    def Finalize(self) -> None:
+        pass
+
+    def GetEvaluatedModelPart(self) -> Kratos.ModelPart:
+        if self.model_part is None:
+            raise RuntimeError("Please call LinearStrainEnergyResponseFunction::Initialize first.")
+        return self.model_part
+
+    def GetAnalysisModelPart(self) -> Kratos.ModelPart:
+        return self.primal_analysis_execution_policy_decorator.GetAnalysisModelPart()
+
+    def CalculateValue(self) -> float:
+        self.primal_analysis_execution_policy_decorator.Execute()
+        return KratosOA.ResponseUtils.LinearStrainEnergyResponseUtils.CalculateValue(self.model_part)
+
+    def CalculateGradient(self, physical_variable_collective_expressions: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]') -> None:
+        # first merge all the model parts
+        merged_model_part_map = ModelPartUtilities.GetMergedMap(physical_variable_collective_expressions, False)
+
+        # now get the intersected model parts
+        intersected_model_part_map = ModelPartUtilities.GetIntersectedMap(self.model_part, merged_model_part_map, True)
+
+        # calculate the gradients
+        for physical_variable, merged_model_part in merged_model_part_map.items():
+            KratosOA.ResponseUtils.LinearStrainEnergyResponseUtils.CalculateGradient(
+                physical_variable,
+                merged_model_part,
+                intersected_model_part_map[physical_variable],
+                physical_variable_collective_expressions[physical_variable].GetContainerExpressions(),
+                self.perturbation_size)
+
+    def __str__(self) -> str:
         return f"Response [type = {self.__class__.__name__}, name = {self.GetName()}, model part name = {self.model_part.FullName()}]"
```

## KratosMultiphysics/OptimizationApplication/responses/mass_response_function.py

```diff
@@ -1,78 +1,83 @@
-from typing import Optional
-
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
-from KratosMultiphysics.OptimizationApplication.responses.response_function import SupportedSensitivityFieldVariableTypes
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
-from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
-from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartUtilities
-
-def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> ResponseFunction:
-    if not parameters.Has("name"):
-        raise RuntimeError(f"MassResponseFunction instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
-    if not parameters.Has("settings"):
-        raise RuntimeError(f"MassResponseFunction instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
-
-    return MassResponseFunction(parameters["name"].GetString(), model, parameters["settings"])
-
-class MassResponseFunction(ResponseFunction):
-    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters):
-        super().__init__(name)
-
-        default_settings = Kratos.Parameters("""{
-            "evaluated_model_part_names"     : [
-                "PLEASE_PROVIDE_A_MODEL_PART_NAME"
-            ]
-        }""")
-        parameters.ValidateAndAssignDefaults(default_settings)
-
-        self.model = model
-
-        evaluated_model_part_names = parameters["evaluated_model_part_names"].GetStringArray()
-        if len(evaluated_model_part_names) == 0:
-            raise RuntimeError(f"No model parts were provided for MassResponseFunction. [ response name = \"{self.GetName()}\"]")
-
-        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"response_{self.GetName()}", evaluated_model_part_names, False)
-        self.model_part: Optional[Kratos.ModelPart] = None
-
-    def GetImplementedPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
-        return [KratosOA.SHAPE, Kratos.DENSITY, Kratos.THICKNESS, KratosOA.CROSS_AREA]
-
-    def Initialize(self) -> None:
-        self.model_part = self.model_part_operation.GetModelPart()
-
-    def Check(self) -> None:
-        KratosOA.ResponseUtils.MassResponseUtils.Check(self.model_part)
-
-    def Finalize(self) -> None:
-        pass
-
-    def GetEvaluatedModelPart(self) -> Kratos.ModelPart:
-        if self.model_part is None:
-            raise RuntimeError("Please call MassResponseFunction::Initialize first.")
-        return self.model_part
-
-    def GetAnalysisModelPart(self) -> None:
-        return None
-
-    def CalculateValue(self) -> float:
-        return KratosOA.ResponseUtils.MassResponseUtils.CalculateValue(self.model_part)
-
-    def CalculateGradient(self, physical_variable_collective_expressions: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]') -> None:
-        # first merge all the model parts
-        merged_model_part_map = ModelPartUtilities.GetMergedMap(physical_variable_collective_expressions, False)
-
-        # now get the intersected model parts
-        intersected_model_part_map = ModelPartUtilities.GetIntersectedMap(self.model_part, merged_model_part_map, False)
-
-        # calculate the gradients
-        for physical_variable, merged_model_part in merged_model_part_map.items():
-            KratosOA.ResponseUtils.MassResponseUtils.CalculateGradient(
-                physical_variable,
-                merged_model_part,
-                intersected_model_part_map[physical_variable],
-                physical_variable_collective_expressions[physical_variable].GetContainerExpressions())
-
-    def __str__(self) -> str:
+from typing import Optional
+
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
+from KratosMultiphysics.OptimizationApplication.responses.response_function import SupportedSensitivityFieldVariableTypes
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
+from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartOperation
+from KratosMultiphysics.OptimizationApplication.utilities.model_part_utilities import ModelPartUtilities
+
+def Factory(model: Kratos.Model, parameters: Kratos.Parameters, _) -> ResponseFunction:
+    if not parameters.Has("name"):
+        raise RuntimeError(f"MassResponseFunction instantiation requires a \"name\" in parameters [ parameters = {parameters}].")
+    if not parameters.Has("settings"):
+        raise RuntimeError(f"MassResponseFunction instantiation requires a \"settings\" in parameters [ parameters = {parameters}].")
+
+    return MassResponseFunction(parameters["name"].GetString(), model, parameters["settings"])
+
+class MassResponseFunction(ResponseFunction):
+    def __init__(self, name: str, model: Kratos.Model, parameters: Kratos.Parameters):
+        super().__init__(name)
+
+        default_settings = Kratos.Parameters("""{
+            "evaluated_model_part_names"     : [
+                "PLEASE_PROVIDE_A_MODEL_PART_NAME"
+            ],
+            "perturbation_size": 1e-6
+        }""")
+        parameters.ValidateAndAssignDefaults(default_settings)
+
+        self.model = model
+
+        evaluated_model_part_names = parameters["evaluated_model_part_names"].GetStringArray()
+        if len(evaluated_model_part_names) == 0:
+            raise RuntimeError(f"No model parts were provided for MassResponseFunction. [ response name = \"{self.GetName()}\"]")
+
+        self.model_part_operation = ModelPartOperation(self.model, ModelPartOperation.OperationType.UNION, f"response_{self.GetName()}", evaluated_model_part_names, False)
+        self.model_part: Optional[Kratos.ModelPart] = None
+        self.perturbation_size = parameters["perturbation_size"].GetDouble()
+
+    def GetImplementedPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
+        return [KratosOA.SHAPE, Kratos.DENSITY, Kratos.THICKNESS, KratosOA.CROSS_AREA]
+
+    def Initialize(self) -> None:
+        self.model_part = self.model_part_operation.GetModelPart()
+
+    def Check(self) -> None:
+        if self.model_part is None:
+            raise RuntimeError("Please call MassResponseFunction::Initialize first.")
+        KratosOA.ResponseUtils.MassResponseUtils.Check(self.model_part)
+
+    def Finalize(self) -> None:
+        pass
+
+    def GetEvaluatedModelPart(self) -> Kratos.ModelPart:
+        if self.model_part is None:
+            raise RuntimeError("Please call MassResponseFunction::Initialize first.")
+        return self.model_part
+
+    def GetAnalysisModelPart(self) -> None:
+        return None
+
+    def CalculateValue(self) -> float:
+        return KratosOA.ResponseUtils.MassResponseUtils.CalculateValue(self.model_part)
+
+    def CalculateGradient(self, physical_variable_collective_expressions: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]') -> None:
+        # first merge all the model parts
+        merged_model_part_map = ModelPartUtilities.GetMergedMap(physical_variable_collective_expressions, False)
+
+        # now get the intersected model parts
+        intersected_model_part_map = ModelPartUtilities.GetIntersectedMap(self.model_part, merged_model_part_map, False)
+
+        # calculate the gradients
+        for physical_variable, merged_model_part in merged_model_part_map.items():
+            KratosOA.ResponseUtils.MassResponseUtils.CalculateGradient(
+                physical_variable,
+                merged_model_part,
+                intersected_model_part_map[physical_variable],
+                physical_variable_collective_expressions[physical_variable].GetContainerExpressions(),
+                self.perturbation_size)
+
+    def __str__(self) -> str:
         return f"Response [type = {self.__class__.__name__}, name = {self.GetName()}, model part name = {self.model_part.FullName()}]"
```

## KratosMultiphysics/OptimizationApplication/responses/response_function.py

 * *Ordering differences only*

```diff
@@ -1,115 +1,115 @@
-from abc import ABC, abstractmethod
-from typing import Union
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
-
-class ResponseFunction(ABC):
-    """Base response function.
-
-    This reponse function is the base response function. This is assumed to have following responsibilities.
-        1. CalculateValue for a new design. (@see CalculateValue)
-        2. CalculateSensitivity for a new design (@see CalculateSensitivity)
-
-    This response should only work on one model part. Hence, if multiple model parts required then,
-    a single model part should be created using Kratos.ModelPartOperationUtilities.
-    """
-    def __init__(self, response_name: str) -> None:
-        self.__name = response_name
-
-    def GetName(self) -> str:
-        return self.__name
-
-    @abstractmethod
-    def Initialize(self) -> None:
-        """Initializes the response.
-
-        This method initializes the response. This is only called once in the whole optimization process.
-
-        """
-        pass
-
-    @abstractmethod
-    def Check(self) -> None:
-        """Checks the response.
-
-        This method checks the response. This is only called once in the whole optimization process.
-
-        """
-        pass
-
-    @abstractmethod
-    def Finalize(self) -> None:
-        """Finalizes the response.
-
-        This method finalizes the response. This is only called once in the whole optimization process.
-
-        """
-        pass
-
-    @abstractmethod
-    def GetImplementedPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
-        """Returns all the dependent physical kratos variables of the response.
-
-        This method should return all the dependent physical variables of the response to make sure
-        that sensitivities w.r.t. those variables are requested from the response. If sensitivities
-        w.r.t. other variables are required from this response, they are ASSUMED TO BE ZERO.
-
-        Please return all the dependent physical variables, eventhough the gradient computation is not yet implemented
-        for some to avoid future bugs.
-
-        Returns:
-            list[SupportedSensitivityFieldVariableTypes]: All dependent physical variables of the response.
-        """
-        pass
-
-    @abstractmethod
-    def CalculateValue(self) -> float:
-        """Calculates the response value.
-
-        This method should always calculate the response value assuming the domain has changed.
-
-        Returns:
-            float: Calculated response value.
-        """
-        pass
-
-    @abstractmethod
-    def CalculateGradient(self, physical_variable_collective_expressions: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]') -> None:
-        """Calculate gradient w.r.t. given physical variables.
-
-        This method should always calculate the sensitivities w.r.t. requested physical variables on the given container expressions
-        in the collective expression. An error should be thrown if sensitivitiy computation w.r.t. one or more given physical variables
-        are not implemented.
-
-        This method should always calculate the sensitivities assuming the domain has changed.
-
-        physical_variable_collective_expressions is a map of physical variables, and their domains. The domains are represented by a CollectiveExpression
-        which contains list of empty ContainerExpression. Each empty ContainerExpression contains details of the model part's nodes/conditions/element/properties
-        container for which the sensitivities w.r.t. physical variable requested.
-
-        Args:
-            physical_variable_collective_expressions (dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]): Output containing calculated sensitivities w.r.t. requested physical variables.
-        """
-        pass
-
-    @abstractmethod
-    def GetEvaluatedModelPart(self) -> Kratos.ModelPart:
-        """Returns the model part for which this response is computed on.
-
-        Returns:
-            Kratos.ModelPart: Response function model part.
-        """
-        pass
-
-    @abstractmethod
-    def GetAnalysisModelPart(self) -> 'Union[Kratos.ModelPart, None]':
-        """Returns the analysis model part if exists. Otherwise returns None.
-
-        This method returns the analysis model part if an analysis is used (as in Adjoint case)
-        to compute the gradients. If it is not the case, then None should be returned.
-
-        Returns:
-            Union[Kratos.ModelPart, None]: Analysis model part if used, otherwise None
-        """
+from abc import ABC, abstractmethod
+from typing import Union
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
+
+class ResponseFunction(ABC):
+    """Base response function.
+
+    This reponse function is the base response function. This is assumed to have following responsibilities.
+        1. CalculateValue for a new design. (@see CalculateValue)
+        2. CalculateSensitivity for a new design (@see CalculateSensitivity)
+
+    This response should only work on one model part. Hence, if multiple model parts required then,
+    a single model part should be created using Kratos.ModelPartOperationUtilities.
+    """
+    def __init__(self, response_name: str) -> None:
+        self.__name = response_name
+
+    def GetName(self) -> str:
+        return self.__name
+
+    @abstractmethod
+    def Initialize(self) -> None:
+        """Initializes the response.
+
+        This method initializes the response. This is only called once in the whole optimization process.
+
+        """
+        pass
+
+    @abstractmethod
+    def Check(self) -> None:
+        """Checks the response.
+
+        This method checks the response. This is only called once in the whole optimization process.
+
+        """
+        pass
+
+    @abstractmethod
+    def Finalize(self) -> None:
+        """Finalizes the response.
+
+        This method finalizes the response. This is only called once in the whole optimization process.
+
+        """
+        pass
+
+    @abstractmethod
+    def GetImplementedPhysicalKratosVariables(self) -> 'list[SupportedSensitivityFieldVariableTypes]':
+        """Returns all the dependent physical kratos variables of the response.
+
+        This method should return all the dependent physical variables of the response to make sure
+        that sensitivities w.r.t. those variables are requested from the response. If sensitivities
+        w.r.t. other variables are required from this response, they are ASSUMED TO BE ZERO.
+
+        Please return all the dependent physical variables, eventhough the gradient computation is not yet implemented
+        for some to avoid future bugs.
+
+        Returns:
+            list[SupportedSensitivityFieldVariableTypes]: All dependent physical variables of the response.
+        """
+        pass
+
+    @abstractmethod
+    def CalculateValue(self) -> float:
+        """Calculates the response value.
+
+        This method should always calculate the response value assuming the domain has changed.
+
+        Returns:
+            float: Calculated response value.
+        """
+        pass
+
+    @abstractmethod
+    def CalculateGradient(self, physical_variable_collective_expressions: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]') -> None:
+        """Calculate gradient w.r.t. given physical variables.
+
+        This method should always calculate the sensitivities w.r.t. requested physical variables on the given container expressions
+        in the collective expression. An error should be thrown if sensitivitiy computation w.r.t. one or more given physical variables
+        are not implemented.
+
+        This method should always calculate the sensitivities assuming the domain has changed.
+
+        physical_variable_collective_expressions is a map of physical variables, and their domains. The domains are represented by a CollectiveExpression
+        which contains list of empty ContainerExpression. Each empty ContainerExpression contains details of the model part's nodes/conditions/element/properties
+        container for which the sensitivities w.r.t. physical variable requested.
+
+        Args:
+            physical_variable_collective_expressions (dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]): Output containing calculated sensitivities w.r.t. requested physical variables.
+        """
+        pass
+
+    @abstractmethod
+    def GetEvaluatedModelPart(self) -> Kratos.ModelPart:
+        """Returns the model part for which this response is computed on.
+
+        Returns:
+            Kratos.ModelPart: Response function model part.
+        """
+        pass
+
+    @abstractmethod
+    def GetAnalysisModelPart(self) -> 'Union[Kratos.ModelPart, None]':
+        """Returns the analysis model part if exists. Otherwise returns None.
+
+        This method returns the analysis model part if an analysis is used (as in Adjoint case)
+        to compute the gradients. If it is not the case, then None should be returned.
+
+        Returns:
+            Union[Kratos.ModelPart, None]: Analysis model part if used, otherwise None
+        """
         pass
```

## KratosMultiphysics/OptimizationApplication/responses/response_routine.py

```diff
@@ -1,145 +1,145 @@
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.controls.control import Control
-from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
-from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
-
-class ResponseRoutine:
-    """A class which adds optimization-specific utilities to simplify routines
-       and synchronization between the control field from algorithms and analysis models.
-    """
-    def __init__(self, master_control: MasterControl, response: ResponseFunction) -> None:
-        # set the master control
-        self.__master_control = master_control
-
-        # set the response
-        self.__response = response
-        self.__response_value = None
-
-        self.__contributing_controls_list: 'list[Control]' = []
-        self.__required_physical_gradients: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]' = {}
-
-    def GetMasterControl(self) -> MasterControl:
-        return self.__master_control
-
-    def Initialize(self):
-        """Initializes the response routine.
-
-        Raises:
-            RuntimeError: If control domain and response domain does not have any intersection.
-        """
-        # create the required physical control fields to compute gradients
-        self.__response.Initialize()
-        self.__required_physical_gradients = self.__master_control.GetPhysicalKratosVariableCollectiveExpressionsMap()
-
-        # now check which are the dependent physical space variables for the response, if not then remove
-        # that variable
-        list_of_independent_variables = []
-        for required_physical_variable in self.__required_physical_gradients.keys():
-            if required_physical_variable not in self.__response.GetImplementedPhysicalKratosVariables():
-                list_of_independent_variables.append(required_physical_variable)
-
-        # now remove this independent collective expression from the require collective expressions map.
-        for independent_variable in list_of_independent_variables:
-            del self.__required_physical_gradients[independent_variable]
-
-        for control in self.__master_control.GetListOfControls():
-            # check whether control has keys given by required gradients
-            if set(control.GetPhysicalKratosVariables()).intersection(self.__required_physical_gradients.keys()):
-                # check whether there is an intersection of model parts between respones domain and control domain.
-                #   1. in the case where response does not require an analysis, then intersection between evaluated and control domain is checked.
-                #   2. in the case where response require an analysis, then intersection between analysis and control domain is checked.
-                if self.__response.GetAnalysisModelPart() is None:
-                    checked_model_part: Kratos.ModelPart = self.__response.GetEvaluatedModelPart()
-                else:
-                    checked_model_part: Kratos.ModelPart = self.__response.GetAnalysisModelPart()
-
-                if Kratos.ModelPartOperationUtilities.HasIntersection([checked_model_part, control.GetEmptyField().GetModelPart()]):
-                    self.__contributing_controls_list.append(control)
-
-        if not self.__contributing_controls_list:
-            raise RuntimeError(f"The controls does not have any influence over the response {self.GetResponseName()}.")
-
-    def Check(self):
-        pass
-
-    def Finalize(self):
-        pass
-
-    def GetResponseName(self):
-        return self.__response.GetName()
-
-    def GetReponse(self) -> ResponseFunction:
-        return self.__response
-
-    def CalculateValue(self, control_field: KratosOA.CollectiveExpression) -> float:
-        """Calculates the value of the response.
-
-        This method updates the design with the provided control field. If a control field is updated
-        which affects the this response value, then a new value is computed. Otherwise, the previous
-        value is returned.
-
-        Args:
-            control_field (KratosOA.CollectiveExpression): Control field of the new design.
-
-        Returns:
-            float: Respone value.
-        """
-        # update using the master control and get updated states.
-        self.__master_control.Update(control_field)
-        compute_response_value_flag = False
-        if self.__response_value is None:
-            self.my_current_control_field = control_field.Clone()
-        diff = self.my_current_control_field - control_field
-        norm = KratosOA.ExpressionUtils.NormInf(diff)
-        if norm > 1e-12:
-            compute_response_value_flag = True
-        compute_response_value_flag = compute_response_value_flag or self.__response_value is None
-
-        # TODO: In the case of having two analysis with the same mesh (model parts) for two different
-        #       responses, we need to flag all the anayses which are affected by the control update_state
-        #       from the first call, otherwise the second call will not update anything, hence no execution
-        #       policies will be executed.
-
-        #       Example: Drag 1 with 10m/s, Drag 2 with 20 m/s using the same mesh and model parts with two
-        #                different analyses.
-        # # now set the response value in response data container
-        # if len(modified_model_parts) > 0:
-        #     # if there are any modified model parts, then this changes state of is_executed to false
-        #     # in the execution policies which has some intersection with the modified model parts.
-        #     ChangeExecutionPolicyStates(modified_model_parts, False, self.__optimization_problem)
-
-        if compute_response_value_flag:
-            self.__response_value = self.__response.CalculateValue()
-
-        return self.__response_value
-
-    def CalculateGradient(self) -> KratosOA.CollectiveExpression:
-        """Returns Collective expression containing all the control space gradients for all control variable types (fields).
-
-        Notes:
-            1. It expects that the CalculateValue is called.
-            2. The gradients are computed with respect to updates from master control.
-
-        Returns:
-            KratosOA.CollectiveExpression: Returns mapped gradients collective expression.
-        """
-        # fills the proper physical gradients from the response
-        self.__response.CalculateGradient(self.__required_physical_gradients)
-
-        # calculate and return the control space gradients from respective controls
-        return self.__master_control.MapGradient(self.__required_physical_gradients)
-
-    def GetRequiredPhysicalGradients(self) -> 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]':
-        """Returns required physical gradients by this response
-
-        This method returns required physical gradients. The expressions may or not be empty field
-        depending on CalculateGradient is called or not.
-
-        Returns:
-            dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]: Required physical gradients.
-        """
-        return self.__required_physical_gradients
-
-
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.controls.control import Control
+from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
+from KratosMultiphysics.OptimizationApplication.controls.master_control import MasterControl
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import SupportedSensitivityFieldVariableTypes
+
+class ResponseRoutine:
+    """A class which adds optimization-specific utilities to simplify routines
+       and synchronization between the control field from algorithms and analysis models.
+    """
+    def __init__(self, master_control: MasterControl, response: ResponseFunction) -> None:
+        # set the master control
+        self.__master_control = master_control
+
+        # set the response
+        self.__response = response
+        self.__response_value = None
+
+        self.__contributing_controls_list: 'list[Control]' = []
+        self.__required_physical_gradients: 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]' = {}
+
+    def GetMasterControl(self) -> MasterControl:
+        return self.__master_control
+
+    def Initialize(self):
+        """Initializes the response routine.
+
+        Raises:
+            RuntimeError: If control domain and response domain does not have any intersection.
+        """
+        # create the required physical control fields to compute gradients
+        self.__response.Initialize()
+        self.__required_physical_gradients = self.__master_control.GetPhysicalKratosVariableCollectiveExpressionsMap()
+
+        # now check which are the dependent physical space variables for the response, if not then remove
+        # that variable
+        list_of_independent_variables = []
+        for required_physical_variable in self.__required_physical_gradients.keys():
+            if required_physical_variable not in self.__response.GetImplementedPhysicalKratosVariables():
+                list_of_independent_variables.append(required_physical_variable)
+
+        # now remove this independent collective expression from the require collective expressions map.
+        for independent_variable in list_of_independent_variables:
+            del self.__required_physical_gradients[independent_variable]
+
+        for control in self.__master_control.GetListOfControls():
+            # check whether control has keys given by required gradients
+            if set(control.GetPhysicalKratosVariables()).intersection(self.__required_physical_gradients.keys()):
+                # check whether there is an intersection of model parts between respones domain and control domain.
+                #   1. in the case where response does not require an analysis, then intersection between evaluated and control domain is checked.
+                #   2. in the case where response require an analysis, then intersection between analysis and control domain is checked.
+                if self.__response.GetAnalysisModelPart() is None:
+                    checked_model_part: Kratos.ModelPart = self.__response.GetEvaluatedModelPart()
+                else:
+                    checked_model_part: Kratos.ModelPart = self.__response.GetAnalysisModelPart()
+
+                if Kratos.ModelPartOperationUtilities.HasIntersection([checked_model_part, control.GetEmptyField().GetModelPart()]):
+                    self.__contributing_controls_list.append(control)
+
+        if not self.__contributing_controls_list:
+            raise RuntimeError(f"The controls does not have any influence over the response {self.GetResponseName()}.")
+
+    def Check(self):
+        self.__response.Check()
+
+    def Finalize(self):
+        self.__response.Finalize()
+
+    def GetResponseName(self):
+        return self.__response.GetName()
+
+    def GetReponse(self) -> ResponseFunction:
+        return self.__response
+
+    def CalculateValue(self, control_field: KratosOA.CollectiveExpression) -> float:
+        """Calculates the value of the response.
+
+        This method updates the design with the provided control field. If a control field is updated
+        which affects the this response value, then a new value is computed. Otherwise, the previous
+        value is returned.
+
+        Args:
+            control_field (KratosOA.CollectiveExpression): Control field of the new design.
+
+        Returns:
+            float: Respone value.
+        """
+        # update using the master control and get updated states.
+        self.__master_control.Update(control_field)
+        compute_response_value_flag = False
+        if self.__response_value is None:
+            self.my_current_control_field = control_field.Clone()
+        diff = self.my_current_control_field - control_field
+        norm = KratosOA.ExpressionUtils.NormInf(diff)
+        if norm > 1e-12:
+            compute_response_value_flag = True
+        compute_response_value_flag = compute_response_value_flag or self.__response_value is None
+
+        # TODO: In the case of having two analysis with the same mesh (model parts) for two different
+        #       responses, we need to flag all the anayses which are affected by the control update_state
+        #       from the first call, otherwise the second call will not update anything, hence no execution
+        #       policies will be executed.
+
+        #       Example: Drag 1 with 10m/s, Drag 2 with 20 m/s using the same mesh and model parts with two
+        #                different analyses.
+        # # now set the response value in response data container
+        # if len(modified_model_parts) > 0:
+        #     # if there are any modified model parts, then this changes state of is_executed to false
+        #     # in the execution policies which has some intersection with the modified model parts.
+        #     ChangeExecutionPolicyStates(modified_model_parts, False, self.__optimization_problem)
+
+        if compute_response_value_flag:
+            self.__response_value = self.__response.CalculateValue()
+
+        return self.__response_value
+
+    def CalculateGradient(self) -> KratosOA.CollectiveExpression:
+        """Returns Collective expression containing all the control space gradients for all control variable types (fields).
+
+        Notes:
+            1. It expects that the CalculateValue is called.
+            2. The gradients are computed with respect to updates from master control.
+
+        Returns:
+            KratosOA.CollectiveExpression: Returns mapped gradients collective expression.
+        """
+        # fills the proper physical gradients from the response
+        self.__response.CalculateGradient(self.__required_physical_gradients)
+
+        # calculate and return the control space gradients from respective controls
+        return self.__master_control.MapGradient(self.__required_physical_gradients)
+
+    def GetRequiredPhysicalGradients(self) -> 'dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]':
+        """Returns required physical gradients by this response
+
+        This method returns required physical gradients. The expressions may or not be empty field
+        depending on CalculateGradient is called or not.
+
+        Returns:
+            dict[SupportedSensitivityFieldVariableTypes, KratosOA.CollectiveExpression]: Required physical gradients.
+        """
+        return self.__required_physical_gradients
+
+
```

## KratosMultiphysics/OptimizationApplication/responses/structural_responses.py

 * *Ordering differences only*

```diff
@@ -1,335 +1,335 @@
-# importing the Kratos Library
-from numpy import gradient
-from . import base_response
-import KratosMultiphysics as KM
-from KratosMultiphysics import Parameters, Logger
-import KratosMultiphysics.OptimizationApplication as KOA
-from KratosMultiphysics.OptimizationApplication.responses.base_response import BaseResponseFunction
-import KratosMultiphysics.StructuralMechanicsApplication as KSM
-
-import time as timer
-import numpy as np
-
-# ==============================================================================
-class StressResponseFunction(BaseResponseFunction):
-    """Stress response function. It triggers the primal analysis and
-    uses the primal analysis results to calculate response value and gradient.
-
-    Attributes
-    ----------
-
-    """
-
-    def __init__(self,response_name, response_settings,response_analysis,model):
-
-        self.type = "stress"
-        self.variable = "STRESS"
-        super().__init__(response_name, response_settings, model, response_analysis)
-
-        if not self.response_settings.Has("gradient_settings"):
-            self.gradient_settings = KM.Parameters()
-            self.gradient_settings.AddString("gradient_mode","semi_analytic")
-            self.gradient_settings.AddDouble("step_size",1e-6)
-        else:
-            self.gradient_settings = self.response_settings["gradient_settings"]     
-
-        self.supported_control_types = ["shape","material"]
-        self.gradients_variables = {"shape":"D_STRESS_D_X","material":"D_STRESS_D_FD"}     
-
-        if len(self.evaluated_model_parts) != 1:
-            raise RuntimeError("StressResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name)) 
-
-        for control_type in self.control_types:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("StressResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
-        
-        # add vars
-        for control_type in self.control_types:
-            self.analysis_model_part.AddNodalSolutionStepVariable(KSM.ADJOINT_DISPLACEMENT)
-            self.analysis_model_part.AddNodalSolutionStepVariable(KOA.ADJOINT_RHS)
-            if control_type == "shape":
-                self.response_settings["gradient_settings"].AddString("shape_gradient_field_name",self.gradients_variables[control_type])
-                self.analysis_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-            if control_type == "material":
-                self.response_settings["gradient_settings"].AddString("material_gradient_field_name",self.gradients_variables[control_type])
-                self.analysis_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-
-        ## Construct the linear solver
-        import KratosMultiphysics.python_linear_solver_factory as python_linear_solver_factory
-        self.adj_solver_settings = KM.Parameters("""{
-                        "solver_type" : "amgcl",
-                        "smoother_type":"ilu0",
-                        "krylov_type": "gmres",
-                        "coarsening_type": "aggregation",
-                        "max_iteration": 200,
-                        "provide_coordinates": false,
-                        "gmres_krylov_space_dimension": 100,
-                        "verbosity" : 0,
-                        "tolerance": 1e-7,
-                        "scaling": false,
-                        "block_size": 1,
-                        "use_block_matrices_if_possible" : true,
-                        "coarse_enough" : 5000
-                }""")
-        self.linear_solvers = []
-        root_model_parts = []
-        for model_part_name in self.evaluated_model_parts:
-            extracted_root_model_part_name = model_part_name.split(".")[0]
-            if not extracted_root_model_part_name in root_model_parts:
-                root_model_parts.append(extracted_root_model_part_name)
-                self.linear_solvers.append(python_linear_solver_factory.ConstructSolver(self.adj_solver_settings))
-
-        # create response
-        self.response_function = KOA.StressOptResponse(response_name,model,self.response_settings,self.linear_solvers)
-
-    def GetVariableName(self):
-        return  self.variable
-
-    def GetGradientsVariablesName(self):
-        return self.gradients_variables
-
-    def GetGradientVariableNameForType(self,control_type, raise_error=True):
-        if raise_error:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("StressResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
-
-        return self.gradients_variables[control_type]
-
-    def Initialize(self):
-        super().Initialize()
-        self.response_function.Initialize()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("StressResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
-        startTime = timer.time()
-        self.value = self.response_function.CalculateValue()
-        Logger.PrintInfo("StressResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")        
-        return self.value
-
-    def GetValue(self):
-        self.value = self.response_function.CalculateValue()
-        return self.value        
-
-    def CalculateGradients(self):
-        Logger.PrintInfo("StressResponseFunction", "Starting gradient calculation for response ", self.name)
-        startTime = timer.time()
-        self.response_function.CalculateGradient()
-        Logger.PrintInfo("StressResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
-
-    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
-
-        if raise_error:
-            for itr in range(len(controlled_objects)):
-                controlled_object = controlled_objects[itr]
-                control_type = control_types[itr]
-                found = False
-                for itr_2 in range(len(self.controlled_model_parts)):
-                    controlled_model_part = self.controlled_model_parts[itr_2]
-                    controlled_type = self.control_types[itr_2]
-                    if controlled_type==control_type and controlled_model_part==controlled_object:
-                        found = True
-                        break
-                if not found:
-                    raise RuntimeError("StressResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
-
-        Logger.PrintInfo("StressResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)        
-        startTime = timer.time()
-        self.response_function.CalculateGradient()                                
-        Logger.PrintInfo("StressResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s") 
-
-# ==============================================================================
-class StrainEnergyResponseFunction(BaseResponseFunction):
-    """Linear strain energy response function. It triggers the primal analysis and
-    uses the primal analysis results to calculate response value and gradient.
-
-    Attributes
-    ----------
-    primal_model_part : Model part of the primal analysis object
-    primal_analysis : Primal analysis object of the response function
-    response_function: Cpp utilities object doing the actual computation of response value and gradient.
-    """
-
-    def __init__(self,response_name, response_settings,response_analysis,model):
-
-        self.type = "strain_energy"
-        super().__init__(response_name, response_settings, model, response_analysis)
-
-        if not self.response_settings.Has("gradient_settings"):
-            self.gradient_settings = KM.Parameters()
-            self.gradient_settings.AddString("gradient_mode","semi_analytic")
-            self.gradient_settings.AddDouble("step_size",1e-6)
-        else:
-            self.gradient_settings = self.response_settings["gradient_settings"]     
-
-        if not self.analysis_model_part.HasNodalSolutionStepVariable(KM.KratosGlobals.GetVariable("D_STRAIN_ENERGY_1_D_X")):
-            self.variable = "STRAIN_ENERGY_1"
-        elif not self.analysis_model_part.HasNodalSolutionStepVariable(KM.KratosGlobals.GetVariable("D_STRAIN_ENERGY_2_D_X")):
-            self.variable = "STRAIN_ENERGY_2"
-        elif not self.analysis_model_part.HasNodalSolutionStepVariable(KM.KratosGlobals.GetVariable("D_STRAIN_ENERGY_3_D_X")):
-            self.variable = "STRAIN_ENERGY_3"
-
-        self.supported_control_types = ["shape","thickness","material"]
-        self.gradients_variables = {"shape":"D_"+self.variable+"_D_X","thickness":"D_"+self.variable+"_D_FT","material":"D_"+self.variable+"_D_FD"}         
-
-        if len(self.evaluated_model_parts) != 1:
-            raise RuntimeError("StrainEnergyResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name)) 
-
-        for control_type in self.control_types:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("StrainEnergyResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
-        
-        # add vars
-        for control_type in self.control_types:
-            if control_type == "shape":
-                self.response_settings["gradient_settings"].AddString("shape_gradient_field_name",self.gradients_variables[control_type])
-                self.analysis_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-            if control_type == "thickness":
-                self.response_settings["gradient_settings"].AddString("thickness_gradient_field_name",self.gradients_variables[control_type])
-                self.analysis_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-            if control_type == "material":
-                self.response_settings["gradient_settings"].AddString("material_gradient_field_name",self.gradients_variables[control_type])
-                self.analysis_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-
-        # create response
-        self.response_function = KOA.LinearStrainEnergyOptResponse(response_name,model,self.response_settings)
-
-    def GetVariableName(self):
-        return  self.variable
-
-    def GetGradientsVariablesName(self):
-        return self.gradients_variables
-
-    def GetGradientVariableNameForType(self,control_type, raise_error=True):
-        if raise_error:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("StrainEnergyResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
-
-        return self.gradients_variables[control_type]
-
-    def Initialize(self):
-        super().Initialize()
-        self.response_function.Initialize()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("StrainEnergyResponse:CalculateValue: Starting value calculation for response ", self.name)
-        startTime = timer.time()
-        self.value = self.response_function.CalculateValue()
-        Logger.PrintInfo("StrainEnergyResponse:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")        
-        return self.value
-
-    def GetValue(self):
-        self.value = self.response_function.CalculateValue()
-        return self.value        
-
-    def CalculateGradients(self):
-        Logger.PrintInfo("StrainEnergyResponse", "Starting gradient calculation for response ", self.name)
-        startTime = timer.time()
-        self.response_function.CalculateGradient()
-        Logger.PrintInfo("StrainEnergyResponse", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
-
-    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
-
-        if raise_error:
-            for itr in range(len(controlled_objects)):
-                controlled_object = controlled_objects[itr]
-                control_type = control_types[itr]
-                found = False
-                for itr_2 in range(len(self.controlled_model_parts)):
-                    controlled_model_part = self.controlled_model_parts[itr_2]
-                    controlled_type = self.control_types[itr_2]
-                    if controlled_type==control_type and controlled_model_part==controlled_object:
-                        found = True
-                        break
-                if not found:
-                    raise RuntimeError("StrainEnergyResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
-
-        Logger.PrintInfo("StrainEnergyResponse", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)        
-        startTime = timer.time()
-        self.response_function.CalculateGradient()                                
-        Logger.PrintInfo("StrainEnergyResponse", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")  
-
-
-class MassResponseFunction(BaseResponseFunction):
-
-    def __init__(self,response_name, response_settings,model):
-
-        self.type = "mass"
-        self.variable = "MASS"
-        super().__init__(response_name, response_settings, model)
-
-        if not self.response_settings.Has("gradient_settings"):
-            self.gradient_settings = KM.Parameters()
-            self.gradient_settings.AddString("gradient_mode","semi_analytic")
-            self.gradient_settings.AddDouble("step_size",1e-6)
-        else:
-            self.gradient_settings = self.response_settings["gradient_settings"]     
-
-        self.supported_control_types = ["shape","thickness","material"]
-        self.gradients_variables = {"shape":"D_MASS_D_X","thickness":"D_MASS_D_FT","material":"D_MASS_D_FD"}
-
-        if len(self.evaluated_model_parts) != 1:
-            raise RuntimeError("MassResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name)) 
-
-        for control_type in self.control_types:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("MassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
-
-        
-        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
-        for evaluated_model_part in self.evaluated_model_parts:
-            if evaluated_model_part.split(".")[0] != root_model_part_name:
-                raise RuntimeError("MassResponseFunction: evaluated_model_parts of mass response must have the same root model part !")
-
-        self.root_model_part = self.model.GetModelPart(root_model_part_name)
-
-        # add vars and response
-        self.response_function = KOA.MassOptResponse(response_name,model,self.response_settings)
-        for control_type in self.control_types:
-            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
-
-        
-    def GetVariableName(self):
-        return  self.variable
-
-    def GetGradientsVariablesName(self):
-        return self.gradients_variables
-
-    def GetGradientVariableNameForType(self,control_type, raise_error=True):
-        if raise_error:
-            if not control_type in self.supported_control_types:
-                raise RuntimeError("MassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
-
-        return self.gradients_variables[control_type]
-
-    def Initialize(self):
-        super().Initialize()
-        self.response_function.Initialize()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("MassResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
-        startTime = timer.time()
-        self.value = self.response_function.CalculateValue()
-        Logger.PrintInfo("MassResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")        
-        return self.value
-
-    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
-
-        if raise_error:
-            for itr in range(len(controlled_objects)):
-                controlled_object = controlled_objects[itr]
-                control_type = control_types[itr]
-                found = False
-                for itr_2 in range(len(self.controlled_model_parts)):
-                    controlled_model_part = self.controlled_model_parts[itr_2]
-                    controlled_type = self.control_types[itr_2]
-                    if controlled_type==control_type and controlled_model_part==controlled_object:
-                        found = True
-                        break
-                if not found:
-                    raise RuntimeError("MassResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
-
-        Logger.PrintInfo("MassResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
-        startTime = timer.time()
-        self.response_function.CalculateGradient()               
-        Logger.PrintInfo("MassResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")  
+# importing the Kratos Library
+from numpy import gradient
+from . import base_response
+import KratosMultiphysics as KM
+from KratosMultiphysics import Parameters, Logger
+import KratosMultiphysics.OptimizationApplication as KOA
+from KratosMultiphysics.OptimizationApplication.responses.base_response import BaseResponseFunction
+import KratosMultiphysics.StructuralMechanicsApplication as KSM
+
+import time as timer
+import numpy as np
+
+# ==============================================================================
+class StressResponseFunction(BaseResponseFunction):
+    """Stress response function. It triggers the primal analysis and
+    uses the primal analysis results to calculate response value and gradient.
+
+    Attributes
+    ----------
+
+    """
+
+    def __init__(self,response_name, response_settings,response_analysis,model):
+
+        self.type = "stress"
+        self.variable = "STRESS"
+        super().__init__(response_name, response_settings, model, response_analysis)
+
+        if not self.response_settings.Has("gradient_settings"):
+            self.gradient_settings = KM.Parameters()
+            self.gradient_settings.AddString("gradient_mode","semi_analytic")
+            self.gradient_settings.AddDouble("step_size",1e-6)
+        else:
+            self.gradient_settings = self.response_settings["gradient_settings"]     
+
+        self.supported_control_types = ["shape","material"]
+        self.gradients_variables = {"shape":"D_STRESS_D_X","material":"D_STRESS_D_FD"}     
+
+        if len(self.evaluated_model_parts) != 1:
+            raise RuntimeError("StressResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name)) 
+
+        for control_type in self.control_types:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("StressResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
+        
+        # add vars
+        for control_type in self.control_types:
+            self.analysis_model_part.AddNodalSolutionStepVariable(KSM.ADJOINT_DISPLACEMENT)
+            self.analysis_model_part.AddNodalSolutionStepVariable(KOA.ADJOINT_RHS)
+            if control_type == "shape":
+                self.response_settings["gradient_settings"].AddString("shape_gradient_field_name",self.gradients_variables[control_type])
+                self.analysis_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+            if control_type == "material":
+                self.response_settings["gradient_settings"].AddString("material_gradient_field_name",self.gradients_variables[control_type])
+                self.analysis_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+
+        ## Construct the linear solver
+        import KratosMultiphysics.python_linear_solver_factory as python_linear_solver_factory
+        self.adj_solver_settings = KM.Parameters("""{
+                        "solver_type" : "amgcl",
+                        "smoother_type":"ilu0",
+                        "krylov_type": "gmres",
+                        "coarsening_type": "aggregation",
+                        "max_iteration": 200,
+                        "provide_coordinates": false,
+                        "gmres_krylov_space_dimension": 100,
+                        "verbosity" : 0,
+                        "tolerance": 1e-7,
+                        "scaling": false,
+                        "block_size": 1,
+                        "use_block_matrices_if_possible" : true,
+                        "coarse_enough" : 5000
+                }""")
+        self.linear_solvers = []
+        root_model_parts = []
+        for model_part_name in self.evaluated_model_parts:
+            extracted_root_model_part_name = model_part_name.split(".")[0]
+            if not extracted_root_model_part_name in root_model_parts:
+                root_model_parts.append(extracted_root_model_part_name)
+                self.linear_solvers.append(python_linear_solver_factory.ConstructSolver(self.adj_solver_settings))
+
+        # create response
+        self.response_function = KOA.StressOptResponse(response_name,model,self.response_settings,self.linear_solvers)
+
+    def GetVariableName(self):
+        return  self.variable
+
+    def GetGradientsVariablesName(self):
+        return self.gradients_variables
+
+    def GetGradientVariableNameForType(self,control_type, raise_error=True):
+        if raise_error:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("StressResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
+
+        return self.gradients_variables[control_type]
+
+    def Initialize(self):
+        super().Initialize()
+        self.response_function.Initialize()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("StressResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
+        startTime = timer.time()
+        self.value = self.response_function.CalculateValue()
+        Logger.PrintInfo("StressResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")        
+        return self.value
+
+    def GetValue(self):
+        self.value = self.response_function.CalculateValue()
+        return self.value        
+
+    def CalculateGradients(self):
+        Logger.PrintInfo("StressResponseFunction", "Starting gradient calculation for response ", self.name)
+        startTime = timer.time()
+        self.response_function.CalculateGradient()
+        Logger.PrintInfo("StressResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
+
+    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
+
+        if raise_error:
+            for itr in range(len(controlled_objects)):
+                controlled_object = controlled_objects[itr]
+                control_type = control_types[itr]
+                found = False
+                for itr_2 in range(len(self.controlled_model_parts)):
+                    controlled_model_part = self.controlled_model_parts[itr_2]
+                    controlled_type = self.control_types[itr_2]
+                    if controlled_type==control_type and controlled_model_part==controlled_object:
+                        found = True
+                        break
+                if not found:
+                    raise RuntimeError("StressResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
+
+        Logger.PrintInfo("StressResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)        
+        startTime = timer.time()
+        self.response_function.CalculateGradient()                                
+        Logger.PrintInfo("StressResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s") 
+
+# ==============================================================================
+class StrainEnergyResponseFunction(BaseResponseFunction):
+    """Linear strain energy response function. It triggers the primal analysis and
+    uses the primal analysis results to calculate response value and gradient.
+
+    Attributes
+    ----------
+    primal_model_part : Model part of the primal analysis object
+    primal_analysis : Primal analysis object of the response function
+    response_function: Cpp utilities object doing the actual computation of response value and gradient.
+    """
+
+    def __init__(self,response_name, response_settings,response_analysis,model):
+
+        self.type = "strain_energy"
+        super().__init__(response_name, response_settings, model, response_analysis)
+
+        if not self.response_settings.Has("gradient_settings"):
+            self.gradient_settings = KM.Parameters()
+            self.gradient_settings.AddString("gradient_mode","semi_analytic")
+            self.gradient_settings.AddDouble("step_size",1e-6)
+        else:
+            self.gradient_settings = self.response_settings["gradient_settings"]     
+
+        if not self.analysis_model_part.HasNodalSolutionStepVariable(KM.KratosGlobals.GetVariable("D_STRAIN_ENERGY_1_D_X")):
+            self.variable = "STRAIN_ENERGY_1"
+        elif not self.analysis_model_part.HasNodalSolutionStepVariable(KM.KratosGlobals.GetVariable("D_STRAIN_ENERGY_2_D_X")):
+            self.variable = "STRAIN_ENERGY_2"
+        elif not self.analysis_model_part.HasNodalSolutionStepVariable(KM.KratosGlobals.GetVariable("D_STRAIN_ENERGY_3_D_X")):
+            self.variable = "STRAIN_ENERGY_3"
+
+        self.supported_control_types = ["shape","thickness","material"]
+        self.gradients_variables = {"shape":"D_"+self.variable+"_D_X","thickness":"D_"+self.variable+"_D_FT","material":"D_"+self.variable+"_D_FD"}         
+
+        if len(self.evaluated_model_parts) != 1:
+            raise RuntimeError("StrainEnergyResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name)) 
+
+        for control_type in self.control_types:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("StrainEnergyResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
+        
+        # add vars
+        for control_type in self.control_types:
+            if control_type == "shape":
+                self.response_settings["gradient_settings"].AddString("shape_gradient_field_name",self.gradients_variables[control_type])
+                self.analysis_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+            if control_type == "thickness":
+                self.response_settings["gradient_settings"].AddString("thickness_gradient_field_name",self.gradients_variables[control_type])
+                self.analysis_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+            if control_type == "material":
+                self.response_settings["gradient_settings"].AddString("material_gradient_field_name",self.gradients_variables[control_type])
+                self.analysis_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+
+        # create response
+        self.response_function = KOA.LinearStrainEnergyOptResponse(response_name,model,self.response_settings)
+
+    def GetVariableName(self):
+        return  self.variable
+
+    def GetGradientsVariablesName(self):
+        return self.gradients_variables
+
+    def GetGradientVariableNameForType(self,control_type, raise_error=True):
+        if raise_error:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("StrainEnergyResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
+
+        return self.gradients_variables[control_type]
+
+    def Initialize(self):
+        super().Initialize()
+        self.response_function.Initialize()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("StrainEnergyResponse:CalculateValue: Starting value calculation for response ", self.name)
+        startTime = timer.time()
+        self.value = self.response_function.CalculateValue()
+        Logger.PrintInfo("StrainEnergyResponse:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")        
+        return self.value
+
+    def GetValue(self):
+        self.value = self.response_function.CalculateValue()
+        return self.value        
+
+    def CalculateGradients(self):
+        Logger.PrintInfo("StrainEnergyResponse", "Starting gradient calculation for response ", self.name)
+        startTime = timer.time()
+        self.response_function.CalculateGradient()
+        Logger.PrintInfo("StrainEnergyResponse", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
+
+    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
+
+        if raise_error:
+            for itr in range(len(controlled_objects)):
+                controlled_object = controlled_objects[itr]
+                control_type = control_types[itr]
+                found = False
+                for itr_2 in range(len(self.controlled_model_parts)):
+                    controlled_model_part = self.controlled_model_parts[itr_2]
+                    controlled_type = self.control_types[itr_2]
+                    if controlled_type==control_type and controlled_model_part==controlled_object:
+                        found = True
+                        break
+                if not found:
+                    raise RuntimeError("StrainEnergyResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
+
+        Logger.PrintInfo("StrainEnergyResponse", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)        
+        startTime = timer.time()
+        self.response_function.CalculateGradient()                                
+        Logger.PrintInfo("StrainEnergyResponse", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")  
+
+
+class MassResponseFunction(BaseResponseFunction):
+
+    def __init__(self,response_name, response_settings,model):
+
+        self.type = "mass"
+        self.variable = "MASS"
+        super().__init__(response_name, response_settings, model)
+
+        if not self.response_settings.Has("gradient_settings"):
+            self.gradient_settings = KM.Parameters()
+            self.gradient_settings.AddString("gradient_mode","semi_analytic")
+            self.gradient_settings.AddDouble("step_size",1e-6)
+        else:
+            self.gradient_settings = self.response_settings["gradient_settings"]     
+
+        self.supported_control_types = ["shape","thickness","material"]
+        self.gradients_variables = {"shape":"D_MASS_D_X","thickness":"D_MASS_D_FT","material":"D_MASS_D_FD"}
+
+        if len(self.evaluated_model_parts) != 1:
+            raise RuntimeError("MassResponseFunction: 'evaluated_objects' of response '{}' must have only one entry !".format(self.name)) 
+
+        for control_type in self.control_types:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("MassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
+
+        
+        root_model_part_name = self.evaluated_model_parts[0].split(".")[0]
+        for evaluated_model_part in self.evaluated_model_parts:
+            if evaluated_model_part.split(".")[0] != root_model_part_name:
+                raise RuntimeError("MassResponseFunction: evaluated_model_parts of mass response must have the same root model part !")
+
+        self.root_model_part = self.model.GetModelPart(root_model_part_name)
+
+        # add vars and response
+        self.response_function = KOA.MassOptResponse(response_name,model,self.response_settings)
+        for control_type in self.control_types:
+            self.root_model_part.AddNodalSolutionStepVariable(KM.KratosGlobals.GetVariable(self.gradients_variables[control_type]))
+
+        
+    def GetVariableName(self):
+        return  self.variable
+
+    def GetGradientsVariablesName(self):
+        return self.gradients_variables
+
+    def GetGradientVariableNameForType(self,control_type, raise_error=True):
+        if raise_error:
+            if not control_type in self.supported_control_types:
+                raise RuntimeError("MassResponseFunction: type {} in 'control_types' of response '{}' is not supported, supported types are {}  !".format(control_type,self.name,self.supported_control_types)) 
+
+        return self.gradients_variables[control_type]
+
+    def Initialize(self):
+        super().Initialize()
+        self.response_function.Initialize()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("MassResponseFunction:CalculateValue: Starting value calculation for response ", self.name)
+        startTime = timer.time()
+        self.value = self.response_function.CalculateValue()
+        Logger.PrintInfo("MassResponseFunction:CalculateValue: Time needed for calculating value ",round(timer.time() - startTime,2),"s")        
+        return self.value
+
+    def CalculateGradientsForTypesAndObjects(self,control_types,controlled_objects,raise_error=True):
+
+        if raise_error:
+            for itr in range(len(controlled_objects)):
+                controlled_object = controlled_objects[itr]
+                control_type = control_types[itr]
+                found = False
+                for itr_2 in range(len(self.controlled_model_parts)):
+                    controlled_model_part = self.controlled_model_parts[itr_2]
+                    controlled_type = self.control_types[itr_2]
+                    if controlled_type==control_type and controlled_model_part==controlled_object:
+                        found = True
+                        break
+                if not found:
+                    raise RuntimeError("MassResponseFunction:CalculateGradientsForTypesAndObjects: control type {} of control object {} is not in the control_types of response {}".format(control_types[itr],controlled_object,self.name))
+
+        Logger.PrintInfo("MassResponseFunction", "Starting ", control_types," gradients calculation of response ", self.name," for ",controlled_objects)
+        startTime = timer.time()
+        self.response_function.CalculateGradient()               
+        Logger.PrintInfo("MassResponseFunction", "Time needed for calculating gradients ",round(timer.time() - startTime,2),"s")
```

## KratosMultiphysics/OptimizationApplication/utilities/buffered_dict.py

 * *Ordering differences only*

```diff
@@ -1,399 +1,399 @@
-from __future__ import annotations
-from typing import Any
-
-class BufferedDict:
-    """Buffered dict container with buffered data ability
-
-    Instances of this can hold (str, Any) data pairs in hierachychal data
-    structure where each sub item can have their own buffer sizes. Hence,
-    Different sub structures can have their own buffers and can be advanced
-    seperately or all together.
-
-    Overwriting of the existing data is not allowed because, this is used
-    as a central place to store data from various objects, hence allowing
-    overwriting will make difficult to track the changes.
-
-    Buffer size setting can only be done at the construction time
-    of the instance to not to allow re sizing because then it is not
-    clear how to handle the connected steps.
-
-    The buffered data is stored in a cyclic buffer.
-    """
-    def __init__(self, buffer_size: int = 1, clear_buffer_when_advancing: bool = True):
-        """Creates an instance of BufferedDict with specified buffer size
-
-        This creates an instance of buffered data with given buffer size.
-
-        Args:
-            buffer_size (int, optional): Cyclic buffer size. Defaults to 1.
-            clear_buffer_when_advancing (bool): Clears the buffer and sub item buffers when advancing.
-        """
-        self.__parent = None
-        self.__buffer_index = 0
-        self.__buffered_data: 'list[dict[str, Any]]' = []
-        self.__sub_items: 'dict[str, BufferedDict]' = {}
-        self.__clear_buffer_when_advancing = clear_buffer_when_advancing
-
-        # sets the buffer
-        self.__SetBufferSize(buffer_size)
-
-    def GetBufferSize(self) -> int:
-        """Returns the buffer size of current isntance of buffered data
-
-        Returns:
-            int: Buffer size of the cyclic buffer
-        """
-        return len(self.__buffered_data)
-
-    def AdvanceStep(self, recursive = True) -> None:
-        """Advances the buffered data containers
-
-        Advances to the next index of the buffer in the cyclic buffer
-        making the current index accesible as a past value indes (step_index = 1)
-
-        Clears the values in the current step after advancement.
-
-        Args:
-            recursive (bool, optional): Advance step recursively in sub items. Defaults to True.
-        """
-        # first advance the current instance
-        self.__buffer_index = (self.__buffer_index + 1) % self.GetBufferSize()
-        if self.__clear_buffer_when_advancing:
-            self.__buffered_data[self.__GetBufferIndex(0)] = {}
-
-        if recursive:
-            # now advance the sub items
-            for sub_item in self.__sub_items.values():
-                sub_item.AdvanceStep(recursive)
-
-    def HasValue(self, key: str, step_index: int = 0) -> bool:
-        """Checks whether key exists in the given step_index
-
-        The key in here should always be relative to the instance it is called upon.
-        Hence, this key can have "/" seperations for subitems, then this method
-        will navigate through the sub items as well to check whether given key is available.
-
-        Args:
-            key (str): Relative path of the key to be checked for.
-            step_index (int, optional): Step index to be looked for. Defaults to 0.
-
-        Returns:
-            bool: True if the key is found in given step index. False otherwise.
-        """
-        pos = key.find("/")
-
-        if pos == -1:
-            # this is a leaf key, then look for the value
-            # first in the value container
-            if step_index < self.GetBufferSize() and step_index >= 0:
-                if key in self.__buffered_data[self.__GetBufferIndex(step_index)].keys():
-                    return True
-            # now if it was not in the buffered data, then check it in sub items.
-            return key in self.__sub_items.keys()
-        else:
-            # not the leaf key. hence check for the sub items
-            current_key = key[:pos]
-            if current_key in self.__sub_items.keys():
-                # found the subkey. Call HasValue recursively
-                return self.__sub_items[current_key].HasValue(key[pos+1:], step_index)
-            else:
-                # not found the subkey. Hence the given key is not available.
-                return False
-
-    def GetValue(self, key: str, step_index: int = 0) -> Any:
-        """Get the value given by the key at the specified step_index.
-
-        This method retrieves the value given by the key at the specified step_index.
-        The key must be the relative path w.r.t. current instance of the BufferedDict.
-        It can include "/" seperators to get a value which is in sub items. In this case,
-        it will be retrieved by recursive calls.
-
-        Args:
-            key (str): Relative path to the value.
-            step_index (int, optional): Step index the value should be retrieved. Defaults to 0.
-
-        Raises:
-            RuntimeError: If the given key is not found.
-            RuntimeError: If parent keys are not found.
-
-        Returns:
-            Any: Value stored at the key for the specified step_index.
-        """
-        pos = key.find("/")
-
-        if pos == -1:
-            # this is a leaf key, then look for the value
-            if not self.HasValue(key, step_index):
-                raise RuntimeError(f"The key \"{key}\" not found in the buffered data [ step_index = {step_index} ]. BufferedDict:\n{self}")
-
-            # first in the value container
-            if step_index < self.GetBufferSize() and step_index >= 0:
-                buffer_data = self.__buffered_data[self.__GetBufferIndex(step_index)]
-                if key in buffer_data.keys():
-                    return buffer_data[key]
-
-            # now if it was not in the buffered data, then it is in sub items.
-            return self.__sub_items[key]
-        else:
-            current_key = key[:pos]
-            if current_key in self.__sub_items.keys():
-                return self.__sub_items[current_key].GetValue(key[pos+1:], step_index)
-            else:
-                raise RuntimeError(f"The key \"{current_key}\" not found in the buffered data which is a parent key for \"{key}\". BufferedDict:\n{self}")
-
-    def SetValue(self, key: str, value: Any, step_index: int = 0, overwrite: bool = False) -> None:
-        """Sets a value for specified key at specified step_index.
-
-        This method sets the value at the key at the specified step_index.
-        The key must be the relative path w.r.t. current instance of the BufferedDict.
-        It can include "/" seperators to set a value which is in sub items. In this case,
-        it will be set by recursive calls.
-
-        Args:
-            key (str): Relative path to the value.
-            value (Any): value to be set
-            step_index (int, optional): Step index the value should be set. Defaults to 0.
-            overwrite (bool): Overwrites if existing key is found with the new value, otherwise creates a key with the value.
-
-        Raises:
-            RuntimeError: If a value is overwritten.
-        """
-        pos = key.find("/")
-        if pos == -1:
-            # this is a leaf, then we check the type of the value and add appropriately
-            if isinstance(value, dict):
-                # if the given value is a dict, then convert the structure
-                # to BufferedDict while keeping the sub_item structure.
-                sub_item = BufferedDict(self.GetBufferSize(), self.__clear_buffer_when_advancing)
-                self.__AddSubItem(key, sub_item)
-
-                # now iterate through all the sub_keys and values of the dictionary and
-                # add them to sub_item
-                for sub_key, sub_value in value.items():
-                    sub_item.SetValue(f"{sub_key}", sub_value, step_index)
-            elif isinstance(value, BufferedDict):
-                # if the given value is of type BufferedDict, then put it to sub_items.
-                self.__AddSubItem(key, value)
-            else:
-                # if not any of the above, it is a normal value. Then put it to buffer.
-                self.__AddBufferedValue(key, value, step_index, overwrite)
-        else:
-            # if it is not a leaf key. then look for the sub_item, and recursively
-            # call the Set method.
-            current_key = key[:pos]
-            if not current_key in self.__sub_items.keys():
-                # no existing key found then create it.
-                self.__AddSubItem(current_key, BufferedDict(self.GetBufferSize()))
-
-            self.__sub_items[current_key].SetValue(key[pos+1:], value, step_index, overwrite)
-
-    def RemoveValue(self, key: str, step_index: int = 0) -> None:
-        """Remove value at the key in the specified step_index
-
-        This method removes value at the key specified at the step_index.
-        The key must be the relative path w.r.t. current instance of the BufferedDict.
-        It can include "/" seperators to remove a value which is in sub items. In this case,
-        it will be removed by recursive calls.
-
-        Args:
-            key (str): Relative path to the value.
-            step_index (int, optional): Step index the value should be removed from. Defaults to 0.
-
-        Raises:
-            RuntimeError: If the given key is not found.
-            RuntimeError: If the given parents of the key is not found.
-        """
-        pos = key.find("/")
-        if pos == -1:
-            # found a leaf key.
-            is_reomved = False
-
-            if step_index < self.GetBufferSize() and step_index >= 0:
-                buffer_data = self.__buffered_data[self.__GetBufferIndex(step_index)]
-                # check whether the key is available in the given step_index
-                if key in buffer_data.keys():
-                    is_reomved = True
-                    del buffer_data[key]
-
-            if not is_reomved:
-                # if it is not removed from the buffered data, then check whether it is available
-                # in the sub_items
-                if key in self.__sub_items.keys():
-                    is_reomved = True
-                    del self.__sub_items[key]
-
-            if not is_reomved:
-                raise RuntimeError(f"\"{key}\" is not found. BufferedDict:\n{self}")
-        else:
-            # it is not a leaf key
-            current_key = key[:pos]
-            if current_key in self.__sub_items.keys():
-                # call recursively the sub_items remove value
-                self.__sub_items[current_key].RemoveValue(key[pos+1:], step_index)
-            else:
-                raise RuntimeError(f"\"{key}\" is not found. BufferedDict:\n{self}")
-
-    def GetValueItems(self, step_index: int = 0) -> 'dict[str, Any]':
-        return self.__buffered_data[self.__GetBufferIndex(step_index)]
-
-    def GetSubItems(self) -> 'dict[str, BufferedDict]':
-        return self.__sub_items
-
-    def GetMap(self, step_index: int = 0) -> 'dict[str, Any]':
-        """Generates (str, Any) pair map with recursively collecting all items in the BufferedDict
-
-        This method recursively collects all items in the buffered data and returns a dict
-        with (str, Any) pairs. All the sub_items are also added as (str, BufferedDict) pairs.
-
-        Args:
-            step_index (int, optional):  Step index the value should be looked at. Defaults to 0.
-
-        Returns:
-            dict[str, Any]: (str, Any) map of all the items.
-        """
-        key_value_pair_map = {}
-        self.__AddKeyValuePairsToMap("", key_value_pair_map, step_index)
-        return key_value_pair_map
-
-    def GetParent(self) -> BufferedDict:
-        """Get the parent of the current buffered data
-
-        Returns:
-            BufferedDict: Returns parent of the current instance.
-        """
-        return self.__parent
-
-    def GetRoot(self) -> BufferedDict:
-        """Get the root parent of the current buffered data
-
-        Get the root parent of the current buffered data by recursive calls.
-
-        Returns:
-            BufferedDict: Root parent of the current buffered data.
-        """
-        if self.GetParent() is not None:
-            return self.GetParent().GetRoot()
-        else:
-            return self
-
-    def PrintData(self, step_index: int = -1, tabbing = "") -> str:
-        """Prints containing data in a json like structure.
-
-        This method prints containing data and sub_item data recursively.
-
-        If the step_index == -1 then, it prints all the values on all the steps of the buffer
-        in current and all the sub_items recursively.
-
-        If the step_index > 0 then, it will only print values at that specified buffer index for
-        current instance as well as all the sub_items.
-
-        Args:
-            step_index (int, optional): Step index to be printed. Defaults to -1.
-            tabbing (str, optional): Initial tabbing for json output.. Defaults to "".
-
-        Returns:
-            str: String will all the containing values formatted like json.
-        """
-        info = self.__Info(step_index, tabbing)
-        info = f"{tabbing}{info}"
-        return info
-
-    def __AddKeyValuePairsToMap(self, current_path: str, key_value_pair_map: 'dict[str, Any]', step_index: int) -> None:
-        # first add the buffered data
-        if step_index >= 0 and step_index < self.GetBufferSize():
-            buffer_data = self.__buffered_data[self.__GetBufferIndex(step_index)]
-            for k, v in buffer_data.items():
-                key_value_pair_map[f"{current_path}{k}"] = v
-
-        # now add the sub item data recursively
-        for k, v in self.__sub_items.items():
-            key_value_pair_map[f"{current_path}{k}"] = v
-            v.__AddKeyValuePairsToMap(f"{current_path}{k}/", key_value_pair_map, step_index)
-
-    def __AddBufferedValue(self, key: str, value: Any, step_index: int, overwrite: bool) -> None:
-        # first check whether this key exists in the specified step_index
-        buffer_data = self.__buffered_data[self.__GetBufferIndex(step_index)]
-        if not overwrite and key in buffer_data.keys():
-            raise RuntimeError(f"Trying to add a buffer value with key = \"{key}\" when already value exists for the key [ Existing value = {buffer_data[key]}]. BufferedDict:\n{self}")
-
-        # now check whether a sub item exists
-        if key in self.__sub_items.keys():
-            raise RuntimeError(f"Trying to add a buffer value with key = \"{key}\" when a subitem exists with the same key. BufferedDict:\n{self}")
-
-        # now add the buffer value
-        buffer_data[key] = value
-
-    def __AddSubItem(self, key: str, value: BufferedDict) -> None:
-        # first check if any of the buffered data has the same key.
-        # this is because, sub_items are valid for all step_indices.
-        if any([key in buffer_data.keys() for buffer_data in self.__buffered_data]):
-            raise RuntimeError(f"Trying to add a new a sub item with key = \"{key}\" when a value with the same key exists in buffered data. BufferedDict:\n{self}")
-
-        # now check if the item exists in the sub_items
-        if key in self.__sub_items.keys():
-            raise RuntimeError(f"Trying to add a new sub_item with key = \"{key}\" when already a sub item exists. BufferedDict:\n{self}")
-
-        # now add the sub_item
-        value.__parent = self
-        self.__sub_items[key] = value
-
-    def __SetBufferSize(self, buffer_size: int) -> None:
-        self.__buffer_index = 0
-        self.__buffered_data.clear()
-        for _ in range(buffer_size):
-            self.__buffered_data.append({})
-
-    def __GetBufferIndex(self, step_index: int) -> int:
-        if step_index >= self.GetBufferSize() or step_index < 0:
-            raise RuntimeError(f"Invalid step index. Allowed step indices are in [0, {self.GetBufferSize()}) [ StepIndex = {step_index} ]. BufferedDict:\n{self}")
-
-        return (self.__buffer_index - step_index) % self.GetBufferSize()
-
-    def __Info(self, step_index: int, tabbing: str) -> str:
-        info = "{"
-
-        if step_index == -1:
-            for i in range(self.GetBufferSize()):
-                info += f"\n{tabbing}\t--- Step = {i:2d} ---"
-                for key, value in self.__buffered_data[self.__GetBufferIndex(i)].items():
-                    info += f"\n{tabbing}\t\"{key}\": {value}"
-        else:
-            for key, value in self.__buffered_data[self.__GetBufferIndex(step_index)].items():
-                info += f"\n{tabbing}\t\"{key}\": {value}"
-
-        if step_index == -1:
-            info += f"\n{tabbing}\t--- Sub items ---"
-
-        next_tabbing = f"{tabbing}\t"
-        for sub_key, sub_value in self.__sub_items.items():
-            info += f"\n{tabbing}\t\"{sub_key}\": {sub_value.__Info(step_index, next_tabbing)}"
-
-        info += f"\n{tabbing}" + "}"
-        return info
-
-    def __getitem__(self, key: str) -> Any:
-        if isinstance(key, str):
-            return self.GetValue(key)
-        elif isinstance(key, tuple) and len(key) == 2:
-            return self.GetValue(key[0], key[1])
-        else:
-            raise RuntimeError(f"The key should be either a string (representing the key path) or (string, int) tuple (representing key path and step index) [ key = {key}].")
-
-    def __setitem__(self, key: str, value: Any) -> None:
-        if isinstance(key, str):
-            return self.SetValue(key, value)
-        elif isinstance(key, tuple) and len(key) == 2:
-            return self.SetValue(key[0], value, key[1])
-        else:
-            raise RuntimeError(f"The key should be either a string (representing the key path) or (string, int) tuple (representing key path and step index) [ key = {key}].")
-
-    def __delitem__(self, key: str) -> None:
-        if isinstance(key, str):
-            return self.RemoveValue(key)
-        elif isinstance(key, tuple) and len(key) == 2:
-            return self.RemoveValue(key[0], key[1])
-        else:
-            raise RuntimeError(f"The key should be either a string (representing the key path) or (string, int) tuple (representing key path and step index) [ key = {key}].")
-
-    def __str__(self) -> str:
-        return self.__Info(-1, "")
+from __future__ import annotations
+from typing import Any
+
+class BufferedDict:
+    """Buffered dict container with buffered data ability
+
+    Instances of this can hold (str, Any) data pairs in hierachychal data
+    structure where each sub item can have their own buffer sizes. Hence,
+    Different sub structures can have their own buffers and can be advanced
+    seperately or all together.
+
+    Overwriting of the existing data is not allowed because, this is used
+    as a central place to store data from various objects, hence allowing
+    overwriting will make difficult to track the changes.
+
+    Buffer size setting can only be done at the construction time
+    of the instance to not to allow re sizing because then it is not
+    clear how to handle the connected steps.
+
+    The buffered data is stored in a cyclic buffer.
+    """
+    def __init__(self, buffer_size: int = 1, clear_buffer_when_advancing: bool = True):
+        """Creates an instance of BufferedDict with specified buffer size
+
+        This creates an instance of buffered data with given buffer size.
+
+        Args:
+            buffer_size (int, optional): Cyclic buffer size. Defaults to 1.
+            clear_buffer_when_advancing (bool): Clears the buffer and sub item buffers when advancing.
+        """
+        self.__parent = None
+        self.__buffer_index = 0
+        self.__buffered_data: 'list[dict[str, Any]]' = []
+        self.__sub_items: 'dict[str, BufferedDict]' = {}
+        self.__clear_buffer_when_advancing = clear_buffer_when_advancing
+
+        # sets the buffer
+        self.__SetBufferSize(buffer_size)
+
+    def GetBufferSize(self) -> int:
+        """Returns the buffer size of current isntance of buffered data
+
+        Returns:
+            int: Buffer size of the cyclic buffer
+        """
+        return len(self.__buffered_data)
+
+    def AdvanceStep(self, recursive = True) -> None:
+        """Advances the buffered data containers
+
+        Advances to the next index of the buffer in the cyclic buffer
+        making the current index accesible as a past value indes (step_index = 1)
+
+        Clears the values in the current step after advancement.
+
+        Args:
+            recursive (bool, optional): Advance step recursively in sub items. Defaults to True.
+        """
+        # first advance the current instance
+        self.__buffer_index = (self.__buffer_index + 1) % self.GetBufferSize()
+        if self.__clear_buffer_when_advancing:
+            self.__buffered_data[self.__GetBufferIndex(0)] = {}
+
+        if recursive:
+            # now advance the sub items
+            for sub_item in self.__sub_items.values():
+                sub_item.AdvanceStep(recursive)
+
+    def HasValue(self, key: str, step_index: int = 0) -> bool:
+        """Checks whether key exists in the given step_index
+
+        The key in here should always be relative to the instance it is called upon.
+        Hence, this key can have "/" seperations for subitems, then this method
+        will navigate through the sub items as well to check whether given key is available.
+
+        Args:
+            key (str): Relative path of the key to be checked for.
+            step_index (int, optional): Step index to be looked for. Defaults to 0.
+
+        Returns:
+            bool: True if the key is found in given step index. False otherwise.
+        """
+        pos = key.find("/")
+
+        if pos == -1:
+            # this is a leaf key, then look for the value
+            # first in the value container
+            if step_index < self.GetBufferSize() and step_index >= 0:
+                if key in self.__buffered_data[self.__GetBufferIndex(step_index)].keys():
+                    return True
+            # now if it was not in the buffered data, then check it in sub items.
+            return key in self.__sub_items.keys()
+        else:
+            # not the leaf key. hence check for the sub items
+            current_key = key[:pos]
+            if current_key in self.__sub_items.keys():
+                # found the subkey. Call HasValue recursively
+                return self.__sub_items[current_key].HasValue(key[pos+1:], step_index)
+            else:
+                # not found the subkey. Hence the given key is not available.
+                return False
+
+    def GetValue(self, key: str, step_index: int = 0) -> Any:
+        """Get the value given by the key at the specified step_index.
+
+        This method retrieves the value given by the key at the specified step_index.
+        The key must be the relative path w.r.t. current instance of the BufferedDict.
+        It can include "/" seperators to get a value which is in sub items. In this case,
+        it will be retrieved by recursive calls.
+
+        Args:
+            key (str): Relative path to the value.
+            step_index (int, optional): Step index the value should be retrieved. Defaults to 0.
+
+        Raises:
+            RuntimeError: If the given key is not found.
+            RuntimeError: If parent keys are not found.
+
+        Returns:
+            Any: Value stored at the key for the specified step_index.
+        """
+        pos = key.find("/")
+
+        if pos == -1:
+            # this is a leaf key, then look for the value
+            if not self.HasValue(key, step_index):
+                raise RuntimeError(f"The key \"{key}\" not found in the buffered data [ step_index = {step_index} ]. BufferedDict:\n{self}")
+
+            # first in the value container
+            if step_index < self.GetBufferSize() and step_index >= 0:
+                buffer_data = self.__buffered_data[self.__GetBufferIndex(step_index)]
+                if key in buffer_data.keys():
+                    return buffer_data[key]
+
+            # now if it was not in the buffered data, then it is in sub items.
+            return self.__sub_items[key]
+        else:
+            current_key = key[:pos]
+            if current_key in self.__sub_items.keys():
+                return self.__sub_items[current_key].GetValue(key[pos+1:], step_index)
+            else:
+                raise RuntimeError(f"The key \"{current_key}\" not found in the buffered data which is a parent key for \"{key}\". BufferedDict:\n{self}")
+
+    def SetValue(self, key: str, value: Any, step_index: int = 0, overwrite: bool = False) -> None:
+        """Sets a value for specified key at specified step_index.
+
+        This method sets the value at the key at the specified step_index.
+        The key must be the relative path w.r.t. current instance of the BufferedDict.
+        It can include "/" seperators to set a value which is in sub items. In this case,
+        it will be set by recursive calls.
+
+        Args:
+            key (str): Relative path to the value.
+            value (Any): value to be set
+            step_index (int, optional): Step index the value should be set. Defaults to 0.
+            overwrite (bool): Overwrites if existing key is found with the new value, otherwise creates a key with the value.
+
+        Raises:
+            RuntimeError: If a value is overwritten.
+        """
+        pos = key.find("/")
+        if pos == -1:
+            # this is a leaf, then we check the type of the value and add appropriately
+            if isinstance(value, dict):
+                # if the given value is a dict, then convert the structure
+                # to BufferedDict while keeping the sub_item structure.
+                sub_item = BufferedDict(self.GetBufferSize(), self.__clear_buffer_when_advancing)
+                self.__AddSubItem(key, sub_item)
+
+                # now iterate through all the sub_keys and values of the dictionary and
+                # add them to sub_item
+                for sub_key, sub_value in value.items():
+                    sub_item.SetValue(f"{sub_key}", sub_value, step_index)
+            elif isinstance(value, BufferedDict):
+                # if the given value is of type BufferedDict, then put it to sub_items.
+                self.__AddSubItem(key, value)
+            else:
+                # if not any of the above, it is a normal value. Then put it to buffer.
+                self.__AddBufferedValue(key, value, step_index, overwrite)
+        else:
+            # if it is not a leaf key. then look for the sub_item, and recursively
+            # call the Set method.
+            current_key = key[:pos]
+            if not current_key in self.__sub_items.keys():
+                # no existing key found then create it.
+                self.__AddSubItem(current_key, BufferedDict(self.GetBufferSize()))
+
+            self.__sub_items[current_key].SetValue(key[pos+1:], value, step_index, overwrite)
+
+    def RemoveValue(self, key: str, step_index: int = 0) -> None:
+        """Remove value at the key in the specified step_index
+
+        This method removes value at the key specified at the step_index.
+        The key must be the relative path w.r.t. current instance of the BufferedDict.
+        It can include "/" seperators to remove a value which is in sub items. In this case,
+        it will be removed by recursive calls.
+
+        Args:
+            key (str): Relative path to the value.
+            step_index (int, optional): Step index the value should be removed from. Defaults to 0.
+
+        Raises:
+            RuntimeError: If the given key is not found.
+            RuntimeError: If the given parents of the key is not found.
+        """
+        pos = key.find("/")
+        if pos == -1:
+            # found a leaf key.
+            is_reomved = False
+
+            if step_index < self.GetBufferSize() and step_index >= 0:
+                buffer_data = self.__buffered_data[self.__GetBufferIndex(step_index)]
+                # check whether the key is available in the given step_index
+                if key in buffer_data.keys():
+                    is_reomved = True
+                    del buffer_data[key]
+
+            if not is_reomved:
+                # if it is not removed from the buffered data, then check whether it is available
+                # in the sub_items
+                if key in self.__sub_items.keys():
+                    is_reomved = True
+                    del self.__sub_items[key]
+
+            if not is_reomved:
+                raise RuntimeError(f"\"{key}\" is not found. BufferedDict:\n{self}")
+        else:
+            # it is not a leaf key
+            current_key = key[:pos]
+            if current_key in self.__sub_items.keys():
+                # call recursively the sub_items remove value
+                self.__sub_items[current_key].RemoveValue(key[pos+1:], step_index)
+            else:
+                raise RuntimeError(f"\"{key}\" is not found. BufferedDict:\n{self}")
+
+    def GetValueItems(self, step_index: int = 0) -> 'dict[str, Any]':
+        return self.__buffered_data[self.__GetBufferIndex(step_index)]
+
+    def GetSubItems(self) -> 'dict[str, BufferedDict]':
+        return self.__sub_items
+
+    def GetMap(self, step_index: int = 0) -> 'dict[str, Any]':
+        """Generates (str, Any) pair map with recursively collecting all items in the BufferedDict
+
+        This method recursively collects all items in the buffered data and returns a dict
+        with (str, Any) pairs. All the sub_items are also added as (str, BufferedDict) pairs.
+
+        Args:
+            step_index (int, optional):  Step index the value should be looked at. Defaults to 0.
+
+        Returns:
+            dict[str, Any]: (str, Any) map of all the items.
+        """
+        key_value_pair_map = {}
+        self.__AddKeyValuePairsToMap("", key_value_pair_map, step_index)
+        return key_value_pair_map
+
+    def GetParent(self) -> BufferedDict:
+        """Get the parent of the current buffered data
+
+        Returns:
+            BufferedDict: Returns parent of the current instance.
+        """
+        return self.__parent
+
+    def GetRoot(self) -> BufferedDict:
+        """Get the root parent of the current buffered data
+
+        Get the root parent of the current buffered data by recursive calls.
+
+        Returns:
+            BufferedDict: Root parent of the current buffered data.
+        """
+        if self.GetParent() is not None:
+            return self.GetParent().GetRoot()
+        else:
+            return self
+
+    def PrintData(self, step_index: int = -1, tabbing = "") -> str:
+        """Prints containing data in a json like structure.
+
+        This method prints containing data and sub_item data recursively.
+
+        If the step_index == -1 then, it prints all the values on all the steps of the buffer
+        in current and all the sub_items recursively.
+
+        If the step_index > 0 then, it will only print values at that specified buffer index for
+        current instance as well as all the sub_items.
+
+        Args:
+            step_index (int, optional): Step index to be printed. Defaults to -1.
+            tabbing (str, optional): Initial tabbing for json output.. Defaults to "".
+
+        Returns:
+            str: String will all the containing values formatted like json.
+        """
+        info = self.__Info(step_index, tabbing)
+        info = f"{tabbing}{info}"
+        return info
+
+    def __AddKeyValuePairsToMap(self, current_path: str, key_value_pair_map: 'dict[str, Any]', step_index: int) -> None:
+        # first add the buffered data
+        if step_index >= 0 and step_index < self.GetBufferSize():
+            buffer_data = self.__buffered_data[self.__GetBufferIndex(step_index)]
+            for k, v in buffer_data.items():
+                key_value_pair_map[f"{current_path}{k}"] = v
+
+        # now add the sub item data recursively
+        for k, v in self.__sub_items.items():
+            key_value_pair_map[f"{current_path}{k}"] = v
+            v.__AddKeyValuePairsToMap(f"{current_path}{k}/", key_value_pair_map, step_index)
+
+    def __AddBufferedValue(self, key: str, value: Any, step_index: int, overwrite: bool) -> None:
+        # first check whether this key exists in the specified step_index
+        buffer_data = self.__buffered_data[self.__GetBufferIndex(step_index)]
+        if not overwrite and key in buffer_data.keys():
+            raise RuntimeError(f"Trying to add a buffer value with key = \"{key}\" when already value exists for the key [ Existing value = {buffer_data[key]}]. BufferedDict:\n{self}")
+
+        # now check whether a sub item exists
+        if key in self.__sub_items.keys():
+            raise RuntimeError(f"Trying to add a buffer value with key = \"{key}\" when a subitem exists with the same key. BufferedDict:\n{self}")
+
+        # now add the buffer value
+        buffer_data[key] = value
+
+    def __AddSubItem(self, key: str, value: BufferedDict) -> None:
+        # first check if any of the buffered data has the same key.
+        # this is because, sub_items are valid for all step_indices.
+        if any([key in buffer_data.keys() for buffer_data in self.__buffered_data]):
+            raise RuntimeError(f"Trying to add a new a sub item with key = \"{key}\" when a value with the same key exists in buffered data. BufferedDict:\n{self}")
+
+        # now check if the item exists in the sub_items
+        if key in self.__sub_items.keys():
+            raise RuntimeError(f"Trying to add a new sub_item with key = \"{key}\" when already a sub item exists. BufferedDict:\n{self}")
+
+        # now add the sub_item
+        value.__parent = self
+        self.__sub_items[key] = value
+
+    def __SetBufferSize(self, buffer_size: int) -> None:
+        self.__buffer_index = 0
+        self.__buffered_data.clear()
+        for _ in range(buffer_size):
+            self.__buffered_data.append({})
+
+    def __GetBufferIndex(self, step_index: int) -> int:
+        if step_index >= self.GetBufferSize() or step_index < 0:
+            raise RuntimeError(f"Invalid step index. Allowed step indices are in [0, {self.GetBufferSize()}) [ StepIndex = {step_index} ]. BufferedDict:\n{self}")
+
+        return (self.__buffer_index - step_index) % self.GetBufferSize()
+
+    def __Info(self, step_index: int, tabbing: str) -> str:
+        info = "{"
+
+        if step_index == -1:
+            for i in range(self.GetBufferSize()):
+                info += f"\n{tabbing}\t--- Step = {i:2d} ---"
+                for key, value in self.__buffered_data[self.__GetBufferIndex(i)].items():
+                    info += f"\n{tabbing}\t\"{key}\": {value}"
+        else:
+            for key, value in self.__buffered_data[self.__GetBufferIndex(step_index)].items():
+                info += f"\n{tabbing}\t\"{key}\": {value}"
+
+        if step_index == -1:
+            info += f"\n{tabbing}\t--- Sub items ---"
+
+        next_tabbing = f"{tabbing}\t"
+        for sub_key, sub_value in self.__sub_items.items():
+            info += f"\n{tabbing}\t\"{sub_key}\": {sub_value.__Info(step_index, next_tabbing)}"
+
+        info += f"\n{tabbing}" + "}"
+        return info
+
+    def __getitem__(self, key: str) -> Any:
+        if isinstance(key, str):
+            return self.GetValue(key)
+        elif isinstance(key, tuple) and len(key) == 2:
+            return self.GetValue(key[0], key[1])
+        else:
+            raise RuntimeError(f"The key should be either a string (representing the key path) or (string, int) tuple (representing key path and step index) [ key = {key}].")
+
+    def __setitem__(self, key: str, value: Any) -> None:
+        if isinstance(key, str):
+            return self.SetValue(key, value)
+        elif isinstance(key, tuple) and len(key) == 2:
+            return self.SetValue(key[0], value, key[1])
+        else:
+            raise RuntimeError(f"The key should be either a string (representing the key path) or (string, int) tuple (representing key path and step index) [ key = {key}].")
+
+    def __delitem__(self, key: str) -> None:
+        if isinstance(key, str):
+            return self.RemoveValue(key)
+        elif isinstance(key, tuple) and len(key) == 2:
+            return self.RemoveValue(key[0], key[1])
+        else:
+            raise RuntimeError(f"The key should be either a string (representing the key path) or (string, int) tuple (representing key path and step index) [ key = {key}].")
+
+    def __str__(self) -> str:
+        return self.__Info(-1, "")
```

## KratosMultiphysics/OptimizationApplication/utilities/component_data_view.py

 * *Ordering differences only*

```diff
@@ -1,71 +1,71 @@
-from typing import Any
-from KratosMultiphysics.OptimizationApplication.utilities.buffered_dict import BufferedDict
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-
-class ComponentDataView:
-    """A viewer to view component's data in optimization problem.
-
-    Instances of this class create or view provided component's data in
-    the OptimizationProblem container. It will view both buffered and
-    unbuffered data.
-
-    The component must be first added to the OptimizationProblem
-    to use instances of this class to modify component data.
-
-    """
-    def __init__(self, component: Any, optimization_problem: OptimizationProblem):
-        self.__problem_data = optimization_problem.GetProblemDataContainer()
-
-        if isinstance(component, str):
-            self.__component_type = object
-            self.__component_name = component
-        else:
-            self.__component_type = optimization_problem.GetComponentType(component)
-            self.__component_name = optimization_problem.GetComponentName(component)
-
-        self.__data_name = f"{self.__component_type.__name__}/{self.__component_name}"
-        self.__buffered_data_name = f"{self.__data_name}/buffered"
-        self.__unbuffered_data_name = f"{self.__data_name}/unbuffered"
-        self.__component = component
-
-        # if the component data container not found, then create it.
-        if not self.__problem_data.HasValue(self.__data_name):
-            self.ResetData()
-
-    def ResetData(self):
-        if self.__problem_data.HasValue(self.__data_name):
-            # if exists, delete the current problem data
-            del self.__problem_data[self.__data_name]
-
-        self.__problem_data[self.__data_name] = BufferedDict(1)
-        # create the unbuffered data container
-        self.__problem_data[self.__unbuffered_data_name] = BufferedDict(1, False)
-
-    def SetDataBuffer(self, buffer_size: int):
-        if not self.__problem_data.HasValue(self.__buffered_data_name):
-            self.__problem_data[self.__buffered_data_name] = BufferedDict(buffer_size)
-        else:
-            buffered_data: BufferedDict = self.__problem_data[self.__buffered_data_name]
-            if buffered_data.GetBufferSize() < buffer_size:
-                raise RuntimeError(f"The required buffer size is not satisfied with the existing problem data container. [ component data container buffer size = {buffered_data.GetBufferSize()}, required buffer size = {buffer_size}, component = {self.__component_name}, component type = {self.__component_type}")
-
-    def GetComponent(self) -> Any:
-        return self.__component
-
-    def GetBufferedData(self) -> BufferedDict:
-        if not self.__problem_data.HasValue(self.__buffered_data_name):
-            raise RuntimeError(f"Buffered data is not set by calling ComponentData::SetBuffer for component of type \"{self.__component_type}\" with component name \"{self.__component_name}\".")
-
-        return self.__problem_data[self.__buffered_data_name]
-
-    def GetUnBufferedData(self) -> BufferedDict:
-        return self.__problem_data[self.__unbuffered_data_name]
-
-    def GetDataPath(self) -> str:
-        return self.__data_name
-
-    def GetComponentName(self):
-        if isinstance(self.__component, str):
-            return self.__component
-        else:
+from typing import Any
+from KratosMultiphysics.OptimizationApplication.utilities.buffered_dict import BufferedDict
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+
+class ComponentDataView:
+    """A viewer to view component's data in optimization problem.
+
+    Instances of this class create or view provided component's data in
+    the OptimizationProblem container. It will view both buffered and
+    unbuffered data.
+
+    The component must be first added to the OptimizationProblem
+    to use instances of this class to modify component data.
+
+    """
+    def __init__(self, component: Any, optimization_problem: OptimizationProblem):
+        self.__problem_data = optimization_problem.GetProblemDataContainer()
+
+        if isinstance(component, str):
+            self.__component_type = object
+            self.__component_name = component
+        else:
+            self.__component_type = optimization_problem.GetComponentType(component)
+            self.__component_name = optimization_problem.GetComponentName(component)
+
+        self.__data_name = f"{self.__component_type.__name__}/{self.__component_name}"
+        self.__buffered_data_name = f"{self.__data_name}/buffered"
+        self.__unbuffered_data_name = f"{self.__data_name}/unbuffered"
+        self.__component = component
+
+        # if the component data container not found, then create it.
+        if not self.__problem_data.HasValue(self.__data_name):
+            self.ResetData()
+
+    def ResetData(self):
+        if self.__problem_data.HasValue(self.__data_name):
+            # if exists, delete the current problem data
+            del self.__problem_data[self.__data_name]
+
+        self.__problem_data[self.__data_name] = BufferedDict(1)
+        # create the unbuffered data container
+        self.__problem_data[self.__unbuffered_data_name] = BufferedDict(1, False)
+
+    def SetDataBuffer(self, buffer_size: int):
+        if not self.__problem_data.HasValue(self.__buffered_data_name):
+            self.__problem_data[self.__buffered_data_name] = BufferedDict(buffer_size)
+        else:
+            buffered_data: BufferedDict = self.__problem_data[self.__buffered_data_name]
+            if buffered_data.GetBufferSize() < buffer_size:
+                raise RuntimeError(f"The required buffer size is not satisfied with the existing problem data container. [ component data container buffer size = {buffered_data.GetBufferSize()}, required buffer size = {buffer_size}, component = {self.__component_name}, component type = {self.__component_type}")
+
+    def GetComponent(self) -> Any:
+        return self.__component
+
+    def GetBufferedData(self) -> BufferedDict:
+        if not self.__problem_data.HasValue(self.__buffered_data_name):
+            raise RuntimeError(f"Buffered data is not set by calling ComponentData::SetBuffer for component of type \"{self.__component_type}\" with component name \"{self.__component_name}\".")
+
+        return self.__problem_data[self.__buffered_data_name]
+
+    def GetUnBufferedData(self) -> BufferedDict:
+        return self.__problem_data[self.__unbuffered_data_name]
+
+    def GetDataPath(self) -> str:
+        return self.__data_name
+
+    def GetComponentName(self):
+        if isinstance(self.__component, str):
+            return self.__component
+        else:
             return self.__component.GetName()
```

## KratosMultiphysics/OptimizationApplication/utilities/helper_utilities.py

 * *Ordering differences only*

```diff
@@ -1,118 +1,118 @@
-from pathlib import Path
-from importlib import import_module
-from typing import Any
-
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.kratos_utilities import GetListOfAvailableApplications
-from KratosMultiphysics.kratos_utilities import GetKratosMultiphysicsPath
-from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
-
-def GetClassModuleFromKratos(full_class_name: str) -> str:
-    sub_module_paths = full_class_name.split(".")
-
-    if not sub_module_paths:
-        raise RuntimeError("Empty class names are not allowed.")
-
-    relative_sub_module = Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(sub_module_paths[-1])
-    if len(sub_module_paths) > 1:
-        relative_sub_module = ".".join(sub_module_paths[:-1]) + f".{relative_sub_module}"
-
-    relative_sub_module_path = relative_sub_module.replace(".", "/")
-    kratos_path = GetKratosMultiphysicsPath()
-
-    # check whether it is in Kratos core
-    if Path(f"{kratos_path}/{relative_sub_module_path}.py").is_file():
-        return f"KratosMultiphysics.{relative_sub_module}", sub_module_paths[-1]
-
-    # now check if it is found in any of the compiled applications
-    list_of_available_appliacations = GetListOfAvailableApplications()
-
-    module_application = ""
-    for application in list_of_available_appliacations:
-        if Path(f"{kratos_path}/{application}/{relative_sub_module_path}.py").is_file():
-            module_application = f"KratosMultiphysics.{application}.{relative_sub_module}"
-
-    if module_application != "":
-        return module_application, sub_module_paths[-1]
-    else:
-        raise RuntimeError(f"{full_class_name} is not found in KratosMultiphysics core or any of the available application directories in Kratos. Available applications:\n\t" + "\n\t".join(list_of_available_appliacations))
-
-def CallOnAll(list_of_objects: 'list[Any]', method: Any, *args, **kwargs):
-    for obj in list_of_objects:
-        getattr(obj, method.__name__)(*args, **kwargs)
-
-def IsSameContainerExpression(container_expression_1: ContainerExpressionTypes, container_expression_2: ContainerExpressionTypes) -> bool:
-    if container_expression_1.GetModelPart().FullName() != container_expression_2.GetModelPart().FullName():
-        return False
-
-    if type(container_expression_1) != type(container_expression_2):
-        return False
-
-    return True
-
-def HasContainerExpression(container_expression: ContainerExpressionTypes, list_of_container_expressions: 'list[ContainerExpressionTypes]') -> bool:
-    return any([IsSameContainerExpression(container_expression, list_container_expression) for list_container_expression in list_of_container_expressions])
-
-def OptimizationComponentFactory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-    if not parameters.Has("type"):
-        raise RuntimeError(f"Components created from OptimizationComponentFactory require the \"type\" [ provided paramters = {parameters}].")
-
-    python_type = parameters["type"].GetString()
-
-    if not parameters.Has("module") or parameters["module"].GetString() == "":
-        # in the case python type comes without a module
-        # as in the case python_type is in the sys path or the current working directory.
-        full_module_name = python_type
-    else:
-        # in the case python type comes witha a module.
-        module = parameters["module"].GetString()
-        full_module_name = f"{module}.{python_type}"
-
-    module = import_module(full_module_name)
-    if not hasattr(module, "Factory"):
-        raise RuntimeError(f"Python module {full_module_name} does not have a Factory method.")
-
-    return getattr(module, "Factory")(model, parameters, optimization_problem)
-
-def GetAllComponentFullNamesWithData(optimization_problem: OptimizationProblem) -> 'list[str]':
-    data_container = optimization_problem.GetProblemDataContainer()
-
-    list_of_components_full_names_with_data: 'list[str]' = []
-    for component_type_str, components_dict in data_container.GetSubItems().items():
-        if component_type_str != "object":
-            component_type_str = Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(component_type_str) + "."
-        else:
-            component_type_str = ""
-        for component_name in components_dict.GetSubItems().keys():
-            list_of_components_full_names_with_data.append(f"{component_type_str}{component_name}")
-
-    return list_of_components_full_names_with_data
-
-def GetComponentHavingDataByFullName(component_full_name: str, optimization_problem: OptimizationProblem) -> Any:
-    data_container = optimization_problem.GetProblemDataContainer()
-
-    name_data = component_full_name.split(".")
-
-    if len(name_data) == 1:
-        if data_container.HasValue("object") and data_container["object"].HasValue(component_full_name):
-            return component_full_name
-    else:
-        component_type_str = Kratos.StringUtilities.ConvertSnakeCaseToCamelCase(name_data[0])
-        component_name = name_data[1]
-
-        for component_type in optimization_problem.GetComponentContainer().keys():
-            if component_type.__name__ == component_type_str:
-                return optimization_problem.GetComponent(component_name, component_type)
-
-    msg = ""
-    for component_type, dict_of_components in optimization_problem.GetComponentContainer().items():
-        for sub_item_name in dict_of_components.keys():
-            msg += "\n\t" + Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(component_type.__name__) + f".{sub_item_name}"
-    if data_container.HasValue("object"):
-        for sub_item_name in data_container["object"].GetSubItems().keys():
-            msg += "\n\t" + sub_item_name
-
-    raise RuntimeError(f"\"{component_full_name}\" full component name is not found in the optimization problem. Followings are supported component with full names:" + msg)
-
-
+from pathlib import Path
+from importlib import import_module
+from typing import Any
+
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.kratos_utilities import GetListOfAvailableApplications
+from KratosMultiphysics.kratos_utilities import GetKratosMultiphysicsPath
+from KratosMultiphysics.OptimizationApplication.utilities.union_utilities import ContainerExpressionTypes
+
+def GetClassModuleFromKratos(full_class_name: str) -> str:
+    sub_module_paths = full_class_name.split(".")
+
+    if not sub_module_paths:
+        raise RuntimeError("Empty class names are not allowed.")
+
+    relative_sub_module = Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(sub_module_paths[-1])
+    if len(sub_module_paths) > 1:
+        relative_sub_module = ".".join(sub_module_paths[:-1]) + f".{relative_sub_module}"
+
+    relative_sub_module_path = relative_sub_module.replace(".", "/")
+    kratos_path = GetKratosMultiphysicsPath()
+
+    # check whether it is in Kratos core
+    if Path(f"{kratos_path}/{relative_sub_module_path}.py").is_file():
+        return f"KratosMultiphysics.{relative_sub_module}", sub_module_paths[-1]
+
+    # now check if it is found in any of the compiled applications
+    list_of_available_appliacations = GetListOfAvailableApplications()
+
+    module_application = ""
+    for application in list_of_available_appliacations:
+        if Path(f"{kratos_path}/{application}/{relative_sub_module_path}.py").is_file():
+            module_application = f"KratosMultiphysics.{application}.{relative_sub_module}"
+
+    if module_application != "":
+        return module_application, sub_module_paths[-1]
+    else:
+        raise RuntimeError(f"{full_class_name} is not found in KratosMultiphysics core or any of the available application directories in Kratos. Available applications:\n\t" + "\n\t".join(list_of_available_appliacations))
+
+def CallOnAll(list_of_objects: 'list[Any]', method: Any, *args, **kwargs):
+    for obj in list_of_objects:
+        getattr(obj, method.__name__)(*args, **kwargs)
+
+def IsSameContainerExpression(container_expression_1: ContainerExpressionTypes, container_expression_2: ContainerExpressionTypes) -> bool:
+    if container_expression_1.GetModelPart().FullName() != container_expression_2.GetModelPart().FullName():
+        return False
+
+    if type(container_expression_1) != type(container_expression_2):
+        return False
+
+    return True
+
+def HasContainerExpression(container_expression: ContainerExpressionTypes, list_of_container_expressions: 'list[ContainerExpressionTypes]') -> bool:
+    return any([IsSameContainerExpression(container_expression, list_container_expression) for list_container_expression in list_of_container_expressions])
+
+def OptimizationComponentFactory(model: Kratos.Model, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+    if not parameters.Has("type"):
+        raise RuntimeError(f"Components created from OptimizationComponentFactory require the \"type\" [ provided paramters = {parameters}].")
+
+    python_type = parameters["type"].GetString()
+
+    if not parameters.Has("module") or parameters["module"].GetString() == "":
+        # in the case python type comes without a module
+        # as in the case python_type is in the sys path or the current working directory.
+        full_module_name = python_type
+    else:
+        # in the case python type comes witha a module.
+        module = parameters["module"].GetString()
+        full_module_name = f"{module}.{python_type}"
+
+    module = import_module(full_module_name)
+    if not hasattr(module, "Factory"):
+        raise RuntimeError(f"Python module {full_module_name} does not have a Factory method.")
+
+    return getattr(module, "Factory")(model, parameters, optimization_problem)
+
+def GetAllComponentFullNamesWithData(optimization_problem: OptimizationProblem) -> 'list[str]':
+    data_container = optimization_problem.GetProblemDataContainer()
+
+    list_of_components_full_names_with_data: 'list[str]' = []
+    for component_type_str, components_dict in data_container.GetSubItems().items():
+        if component_type_str != "object":
+            component_type_str = Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(component_type_str) + "."
+        else:
+            component_type_str = ""
+        for component_name in components_dict.GetSubItems().keys():
+            list_of_components_full_names_with_data.append(f"{component_type_str}{component_name}")
+
+    return list_of_components_full_names_with_data
+
+def GetComponentHavingDataByFullName(component_full_name: str, optimization_problem: OptimizationProblem) -> Any:
+    data_container = optimization_problem.GetProblemDataContainer()
+
+    name_data = component_full_name.split(".")
+
+    if len(name_data) == 1:
+        if data_container.HasValue("object") and data_container["object"].HasValue(component_full_name):
+            return component_full_name
+    else:
+        component_type_str = Kratos.StringUtilities.ConvertSnakeCaseToCamelCase(name_data[0])
+        component_name = name_data[1]
+
+        for component_type in optimization_problem.GetComponentContainer().keys():
+            if component_type.__name__ == component_type_str:
+                return optimization_problem.GetComponent(component_name, component_type)
+
+    msg = ""
+    for component_type, dict_of_components in optimization_problem.GetComponentContainer().items():
+        for sub_item_name in dict_of_components.keys():
+            msg += "\n\t" + Kratos.StringUtilities.ConvertCamelCaseToSnakeCase(component_type.__name__) + f".{sub_item_name}"
+    if data_container.HasValue("object"):
+        for sub_item_name in data_container["object"].GetSubItems().keys():
+            msg += "\n\t" + sub_item_name
+
+    raise RuntimeError(f"\"{component_full_name}\" full component name is not found in the optimization problem. Followings are supported component with full names:" + msg)
+
+
```

## KratosMultiphysics/OptimizationApplication/utilities/logger_utilities.py

 * *Ordering differences only*

```diff
@@ -1,181 +1,181 @@
-#    |  /           |
-#    ' /   __| _` | __|  _ \   __|
-#    . \  |   (   | |   (   |\__ `
-#   _|\_\_|  \__,_|\__|\___/ ____/
-#                   Multi-Physics
-#
-#  License:		 BSD License
-#					 license: OptimizationApplication/license.txt
-#
-#  Main authors:    Suneth Warnakulasuriya
-#
-
-import time as timer
-import datetime
-import KratosMultiphysics as Kratos
-from functools import wraps
-
-
-def AddFileLoggerOutput(logger_file_name):
-    logger_file = Kratos.FileLoggerOutput(logger_file_name)
-    default_severity = Kratos.Logger.GetDefaultOutput().GetSeverity()
-    Kratos.Logger.GetDefaultOutput().SetSeverity(Kratos.Logger.Severity.WARNING)
-    Kratos.Logger.AddOutput(logger_file)
-
-    return default_severity, logger_file
-
-def RemoveFileLoggerOutput(default_severity, logger_file):
-    Kratos.Logger.Flush()
-    Kratos.Logger.RemoveOutput(logger_file)
-    Kratos.Logger.GetDefaultOutput().SetSeverity(default_severity)
-
-class FileLogger:
-    """@brief A context responsible for managing the lifetime of logger files."""
-    def __init__(self, logger_file_name: str):
-        self.__logger_file_name = logger_file_name
-
-    def __enter__(self):
-        self.__default_severity, self.__logger_file = AddFileLoggerOutput(self.__logger_file_name)
-
-    def __exit__(self, exit_type, exit_value, exit_traceback):
-        RemoveFileLoggerOutput(self.__default_severity, self.__logger_file)
-
-class TimeLogger:
-    """@brief A context responsible for outputting execution times."""
-    def __init__(self, topic: str, entry_msg: str , exit_msg: str, end_new_line: bool=True):
-        self.topic = topic
-        self.entry_msg = entry_msg
-        self.exit_msg = exit_msg
-        self.start_time = None
-        self.end_new_line = end_new_line
-
-    def __enter__(self):
-        if self.entry_msg is not None:
-            Kratos.Logger.PrintInfo(self.topic, self.entry_msg)
-        self.start_time = timer.time()
-
-    def __exit__(self, exit_type, exit_value, exit_traceback):
-        if self.exit_msg is not None:
-            elapsed_time = timer.time() - self.start_time
-            if self.end_new_line:
-                Kratos.Logger.PrintInfo(self.topic, "{:s} - [ Elapsed time: {:s} ]".format(self.exit_msg, str(datetime.timedelta(seconds=round(elapsed_time))))+"\n")
-            else:
-                Kratos.Logger.PrintInfo(self.topic, "{:s} - [ Elapsed time: {:s} ]".format(self.exit_msg, str(datetime.timedelta(seconds=round(elapsed_time)))))
-
-class OptimizationAlgorithmTimeLogger:
-    """@brief A context responsible for outputting execution times."""
-    def __init__(self, optimizer_name: str, optimization_itr: int):
-        self.start_time = None
-        self.optimization_itr = optimization_itr
-        self.optimizer_name = optimizer_name
-
-    def __enter__(self):
-        self.start_time = timer.time()
-
-    def __exit__(self, exit_type, exit_value, exit_traceback):
-
-        current_time = timer.time()
-        elapsed_time = current_time - self.start_time
-        elapsed_time_string = str(datetime.timedelta(seconds=round(elapsed_time)))
-
-        iteration_text = f"{self.optimizer_name} EoF Iteration {self.optimization_itr}"
-        iteration_output = f"{'#'}  {iteration_text} [Elapsed Time: {elapsed_time_string}]  {'#'}"
-
-        divided_line = len(iteration_output) * '#'
-
-        to_print = f"{divided_line}\n{iteration_output}\n{divided_line}\n"
-
-        Kratos.Logger.PrintInfo(to_print)
-
-class OptimizationAnalysisTimeLogger:
-
-    def __enter__(self):
-        start_text = "Optimization Start"
-
-        self.start_time = datetime.datetime.now()
-        start_time_string = self.start_time.strftime("%Y-%m-%d %H:%M:%S")
-
-        time_string = f"**   {start_time_string}   **"
-        separator_string = len(time_string) * '*'
-        center_string = f"**{start_text.center(len(str(time_string))-4)}**"
-        final_string = f"{separator_string}\n{center_string}\n{time_string}\n{separator_string}"
-
-        Kratos.Logger.PrintInfo(final_string)
-
-    def __exit__(self, exit_type, exit_value, exit_traceback):
-
-        end_text = "Optimization End"
-
-        end_time = datetime.datetime.now()
-        end_time_string = end_time.strftime("%Y-%m-%d %H:%M:%S")
-
-        elapsed_time = end_time - self.start_time
-        elapsed_time_string = str(datetime.timedelta(seconds=round(elapsed_time.total_seconds())))
-
-        time_string = f"**   {end_time_string}  [Elapsed Time: {elapsed_time_string}]   **"
-        separator_string = len(time_string) * '*'
-        center_string = f"**{end_text.center(len(str(time_string))-4)}**"
-        final_string = f"{separator_string}\n{center_string}\n{time_string}\n{separator_string}"
-
-        Kratos.Logger.PrintInfo(final_string)
-
-def DictLogger(title: str, data: dict):
-
-    # First do the formatting and converting to strings
-    for key, value in data.items():
-        if isinstance(value, (float, int)):
-            if abs(value) >= 1e6 or abs(value) < 1e-6:
-                data[key] = "{:.6e}".format(value)
-            else:
-                data[key] = "{:.6f}".format(value)
-
-    # Determine the maximum length of labels
-    max_label_len = max(len(str(label)) for label in data.keys())
-    max_value_len = max(len(str(value)) for value in data.values())
-
-    title_len = len(str(title)) + 8
-
-    # Calculate the row width
-    if title_len > max_label_len + max_value_len + 7:
-        row_width = title_len
-        max_value_len = row_width - max_label_len - 7
-    else:
-        row_width = max_label_len + max_value_len + 7
-
-    # Create format strings for the labels and values
-    label_format = f"| {{:<{max_label_len}}} |"
-
-    # Build the table
-    table = '-' * row_width + "\n"
-    table += f"|{str(title).center(row_width - 2)}|\n"
-    table += '-' * row_width + "\n"
-
-    # Add the data to the table
-    for label, value in data.items():
-        table += f"{label_format.format(label)} {value:>{max_value_len}} |\n"
-
-    table += '-' * row_width
-
-    # now print
-    Kratos.Logger.PrintInfo(table)
-
-def time_decorator(arg1=None, arg2=None, methodName=None):
-    def inner_func(func):
-        @wraps(func)
-        def wrapper(self,*args, **kwargs):
-            start_time = timer.perf_counter()
-            if arg1:
-                Kratos.Logger.Print(f"{func.__qualname__.split('.')[0]}::{func.__name__}: {arg1}")
-            result = func(self,*args, **kwargs)
-            end_time = timer.perf_counter()
-            elapsed_time = end_time - start_time
-            if arg2:
-                Kratos.Logger.Print(f"{func.__qualname__.split('.')[0]}::{func.__name__}: {arg2} - [ Elapsed time: {datetime.timedelta(seconds=round(elapsed_time))}] \n")
-            elif methodName:
-                method_to_call = getattr(self, methodName)
-                Kratos.Logger.Print(f"{func.__qualname__.split('.')[0]}::{func.__name__}: {method_to_call()} finished - [ Elapsed time: {datetime.timedelta(seconds=round(elapsed_time))}] \n")
-            else:
-                Kratos.Logger.Print(f"{func.__qualname__.split('.')[0]}::{func.__name__}: Finished - [ Elapsed time: {datetime.timedelta(seconds=round(elapsed_time))}] \n")
-            return result
-        return wrapper
+#    |  /           |
+#    ' /   __| _` | __|  _ \   __|
+#    . \  |   (   | |   (   |\__ `
+#   _|\_\_|  \__,_|\__|\___/ ____/
+#                   Multi-Physics
+#
+#  License:		 BSD License
+#					 license: OptimizationApplication/license.txt
+#
+#  Main authors:    Suneth Warnakulasuriya
+#
+
+import time as timer
+import datetime
+import KratosMultiphysics as Kratos
+from functools import wraps
+
+
+def AddFileLoggerOutput(logger_file_name):
+    logger_file = Kratos.FileLoggerOutput(logger_file_name)
+    default_severity = Kratos.Logger.GetDefaultOutput().GetSeverity()
+    Kratos.Logger.GetDefaultOutput().SetSeverity(Kratos.Logger.Severity.WARNING)
+    Kratos.Logger.AddOutput(logger_file)
+
+    return default_severity, logger_file
+
+def RemoveFileLoggerOutput(default_severity, logger_file):
+    Kratos.Logger.Flush()
+    Kratos.Logger.RemoveOutput(logger_file)
+    Kratos.Logger.GetDefaultOutput().SetSeverity(default_severity)
+
+class FileLogger:
+    """@brief A context responsible for managing the lifetime of logger files."""
+    def __init__(self, logger_file_name: str):
+        self.__logger_file_name = logger_file_name
+
+    def __enter__(self):
+        self.__default_severity, self.__logger_file = AddFileLoggerOutput(self.__logger_file_name)
+
+    def __exit__(self, exit_type, exit_value, exit_traceback):
+        RemoveFileLoggerOutput(self.__default_severity, self.__logger_file)
+
+class TimeLogger:
+    """@brief A context responsible for outputting execution times."""
+    def __init__(self, topic: str, entry_msg: str , exit_msg: str, end_new_line: bool=True):
+        self.topic = topic
+        self.entry_msg = entry_msg
+        self.exit_msg = exit_msg
+        self.start_time = None
+        self.end_new_line = end_new_line
+
+    def __enter__(self):
+        if self.entry_msg is not None:
+            Kratos.Logger.PrintInfo(self.topic, self.entry_msg)
+        self.start_time = timer.time()
+
+    def __exit__(self, exit_type, exit_value, exit_traceback):
+        if self.exit_msg is not None:
+            elapsed_time = timer.time() - self.start_time
+            if self.end_new_line:
+                Kratos.Logger.PrintInfo(self.topic, "{:s} - [ Elapsed time: {:s} ]".format(self.exit_msg, str(datetime.timedelta(seconds=round(elapsed_time))))+"\n")
+            else:
+                Kratos.Logger.PrintInfo(self.topic, "{:s} - [ Elapsed time: {:s} ]".format(self.exit_msg, str(datetime.timedelta(seconds=round(elapsed_time)))))
+
+class OptimizationAlgorithmTimeLogger:
+    """@brief A context responsible for outputting execution times."""
+    def __init__(self, optimizer_name: str, optimization_itr: int):
+        self.start_time = None
+        self.optimization_itr = optimization_itr
+        self.optimizer_name = optimizer_name
+
+    def __enter__(self):
+        self.start_time = timer.time()
+
+    def __exit__(self, exit_type, exit_value, exit_traceback):
+
+        current_time = timer.time()
+        elapsed_time = current_time - self.start_time
+        elapsed_time_string = str(datetime.timedelta(seconds=round(elapsed_time)))
+
+        iteration_text = f"{self.optimizer_name} EoF Iteration {self.optimization_itr}"
+        iteration_output = f"{'#'}  {iteration_text} [Elapsed Time: {elapsed_time_string}]  {'#'}"
+
+        divided_line = len(iteration_output) * '#'
+
+        to_print = f"{divided_line}\n{iteration_output}\n{divided_line}\n"
+
+        Kratos.Logger.PrintInfo(to_print)
+
+class OptimizationAnalysisTimeLogger:
+
+    def __enter__(self):
+        start_text = "Optimization Start"
+
+        self.start_time = datetime.datetime.now()
+        start_time_string = self.start_time.strftime("%Y-%m-%d %H:%M:%S")
+
+        time_string = f"**   {start_time_string}   **"
+        separator_string = len(time_string) * '*'
+        center_string = f"**{start_text.center(len(str(time_string))-4)}**"
+        final_string = f"{separator_string}\n{center_string}\n{time_string}\n{separator_string}"
+
+        Kratos.Logger.PrintInfo(final_string)
+
+    def __exit__(self, exit_type, exit_value, exit_traceback):
+
+        end_text = "Optimization End"
+
+        end_time = datetime.datetime.now()
+        end_time_string = end_time.strftime("%Y-%m-%d %H:%M:%S")
+
+        elapsed_time = end_time - self.start_time
+        elapsed_time_string = str(datetime.timedelta(seconds=round(elapsed_time.total_seconds())))
+
+        time_string = f"**   {end_time_string}  [Elapsed Time: {elapsed_time_string}]   **"
+        separator_string = len(time_string) * '*'
+        center_string = f"**{end_text.center(len(str(time_string))-4)}**"
+        final_string = f"{separator_string}\n{center_string}\n{time_string}\n{separator_string}"
+
+        Kratos.Logger.PrintInfo(final_string)
+
+def DictLogger(title: str, data: dict):
+
+    # First do the formatting and converting to strings
+    for key, value in data.items():
+        if isinstance(value, (float, int)):
+            if abs(value) >= 1e6 or abs(value) < 1e-6:
+                data[key] = "{:.6e}".format(value)
+            else:
+                data[key] = "{:.6f}".format(value)
+
+    # Determine the maximum length of labels
+    max_label_len = max(len(str(label)) for label in data.keys())
+    max_value_len = max(len(str(value)) for value in data.values())
+
+    title_len = len(str(title)) + 8
+
+    # Calculate the row width
+    if title_len > max_label_len + max_value_len + 7:
+        row_width = title_len
+        max_value_len = row_width - max_label_len - 7
+    else:
+        row_width = max_label_len + max_value_len + 7
+
+    # Create format strings for the labels and values
+    label_format = f"| {{:<{max_label_len}}} |"
+
+    # Build the table
+    table = '-' * row_width + "\n"
+    table += f"|{str(title).center(row_width - 2)}|\n"
+    table += '-' * row_width + "\n"
+
+    # Add the data to the table
+    for label, value in data.items():
+        table += f"{label_format.format(label)} {value:>{max_value_len}} |\n"
+
+    table += '-' * row_width
+
+    # now print
+    Kratos.Logger.PrintInfo(table)
+
+def time_decorator(arg1=None, arg2=None, methodName=None):
+    def inner_func(func):
+        @wraps(func)
+        def wrapper(self,*args, **kwargs):
+            start_time = timer.perf_counter()
+            if arg1:
+                Kratos.Logger.Print(f"{func.__qualname__.split('.')[0]}::{func.__name__}: {arg1}")
+            result = func(self,*args, **kwargs)
+            end_time = timer.perf_counter()
+            elapsed_time = end_time - start_time
+            if arg2:
+                Kratos.Logger.Print(f"{func.__qualname__.split('.')[0]}::{func.__name__}: {arg2} - [ Elapsed time: {datetime.timedelta(seconds=round(elapsed_time))}] \n")
+            elif methodName:
+                method_to_call = getattr(self, methodName)
+                Kratos.Logger.Print(f"{func.__qualname__.split('.')[0]}::{func.__name__}: {method_to_call()} finished - [ Elapsed time: {datetime.timedelta(seconds=round(elapsed_time))}] \n")
+            else:
+                Kratos.Logger.Print(f"{func.__qualname__.split('.')[0]}::{func.__name__}: Finished - [ Elapsed time: {datetime.timedelta(seconds=round(elapsed_time))}] \n")
+            return result
+        return wrapper
     return inner_func
```

## KratosMultiphysics/OptimizationApplication/utilities/model_part_utilities.py

```diff
@@ -1,117 +1,117 @@
-from typing import Any
-from enum import Enum
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-
-class ModelPartOperation:
-    class OperationType(Enum):
-        UNION = 1,
-        INTERSECT = 2
-
-    def __init__(self, model: Kratos.Model, operation_type: OperationType, suggested_model_part_name: str, list_of_operation_model_part_full_names: 'list[str]', add_neighbours: bool) -> None:
-        self.model = model
-        self.operation_type = operation_type
-        self.suggested_model_part_name = suggested_model_part_name
-        self.list_of_operation_model_part_full_names = sorted(list(set(list_of_operation_model_part_full_names)))
-        self.add_neighbours = add_neighbours
-
-        if len(list_of_operation_model_part_full_names) == 0:
-            raise RuntimeError("No operating model part names are provided.")
-
-        if suggested_model_part_name.find("#") != -1 or any([mp_name.find("#") != -1 for mp_name in list_of_operation_model_part_full_names]):
-            # find '#' in the model part names which is not allwed.
-            raise RuntimeError(f"The model part names cannot contain '#' character. Parsed model part names are as followings:\n\t suggested model part name: \"{suggested_model_part_name}\"\n\toperation model part names:\n\t" + "\n\t\t".join(list_of_operation_model_part_full_names))
-
-        # set the root model part. This needs to always exist.
-        self.root_model_part = self.model[self.list_of_operation_model_part_full_names[0].split(".")[0]]
-        self.status_msg = ""
-
-    def GetRootModelPart(self) -> Kratos.ModelPart:
-        return self.root_model_part
-
-    def GetModelPartFullName(self) -> str:
-        # check whether is there a need to perform binary operations
-        if self.operation_type == ModelPartOperation.OperationType.UNION or self.operation_type == ModelPartOperation.OperationType.INTERSECT:
-            if len(self.list_of_operation_model_part_full_names) == 1:
-                # all the operation model parts are the same, hence no need of doing an operation.
-                self.status_msg = ""
-                return self.list_of_operation_model_part_full_names[0]
-
-        # now check in the status messages of the root model part whether this operation is already added.
-        status_msg_prefix = "ModelPartUtilities_created#"
-        status_msg_suffix = f"#{self.operation_type.name}#{self.add_neighbours:d}#" + "#".join(self.list_of_operation_model_part_full_names)
-        status_msg_log = KratosOA.ModelPartUtils.GetModelPartStatusLog(self.GetRootModelPart())
-        for status_msg in status_msg_log:
-            if status_msg.startswith(status_msg_prefix) and status_msg.endswith(status_msg_suffix):
-                # found the same operation done on a different model part, hence sending that name
-                self.status_msg = status_msg
-                full_model_part_name = f"{self.GetRootModelPart().FullName()}.{status_msg.split('#')[1]}"
-                Kratos.Logger.PrintInfo("ModelPartUtilities", f"Using \"{full_model_part_name}\" with the same operation instead of suggested model part with name = \"{self.GetRootModelPart().FullName()}.{self.suggested_model_part_name}\".")
-                return full_model_part_name
-
-        # it is not already called for creation. Then put that in the status msg.
-        if self.root_model_part.HasSubModelPart(self.suggested_model_part_name):
-            # this means, it already has a model part with suggeted name, but
-            # it does not match the operation identifier. So throw an error
-            raise RuntimeError(f"Found an already existing submodel part named \"{self.suggested_model_part_name}\" in {self.root_model_part.FullName()} without the required operation identifier = \"{status_msg_suffix}\".")
-
-        self.status_msg = f"{status_msg_prefix}{self.suggested_model_part_name}{status_msg_suffix}"
-        KratosOA.ModelPartUtils.LogModelPartStatus(self.GetRootModelPart(), self.status_msg)
-        return f"{self.GetRootModelPart().FullName()}.{self.suggested_model_part_name}"
-
-    def GetModelPart(self) -> Kratos.ModelPart:
-        model_part_name = self.GetModelPartFullName()
-        if self.status_msg == "" or self.model.HasModelPart(model_part_name):
-            # if it is already there, that means it is already created. Hence return it or
-            # if the self.status_msg == "" means, there is no need to do any model part operations.
-            # therefore the model part should exist already.
-            return self.model[model_part_name]
-        else:
-            # the model part with the required operation not found. Hence creating it.
-            sub_model_part = self.model.CreateModelPart(model_part_name)
-            # now fill the submodel part
-            operation_model_parts = [self.model[name] for name in self.list_of_operation_model_part_full_names]
-            if self.operation_type == ModelPartOperation.OperationType.UNION:
-                Kratos.ModelPartOperationUtilities.Union(sub_model_part, self.root_model_part, operation_model_parts, self.add_neighbours)
-            elif self.operation_type == ModelPartOperation.OperationType.INTERSECT:
-                Kratos.ModelPartOperationUtilities.Intersect(sub_model_part, self.root_model_part, operation_model_parts, self.add_neighbours)
-
-            Kratos.Logger.PrintInfo("ModelPartUtilities", f"Created sub model part \"{sub_model_part.FullName()}\".")
-
-            return sub_model_part
-
-class ModelPartUtilities:
-    @staticmethod
-    def __GenerateUniqueIdentifier(prefix: str, list_of_names: 'list[str]', add_neighbours: bool) -> str:
-        if not all([name.find("#") == -1 for name in list_of_names]):
-            raise RuntimeError(f"The provided model part names has \"#\" which is invalid. Please remove all occurances of \"#\" character. Provided model part names:\n\t" + "\n\t".join(list_of_names))
-
-        sorted_names = sorted(list_of_names)
-        post_fix = "IN" if add_neighbours else "EN"
-        return (f"{prefix}_{post_fix}_" + "_".join(sorted_names)).replace(".", "-")
-
-    @staticmethod
-    def GetMergedMap(input_dict: 'dict[Any, KratosOA.CollectiveExpression]', add_neghbours: bool) -> 'dict[Any, Kratos.ModelPart]':
-        result: 'dict[Any, Kratos.ModelPart]' = {}
-        for k, v in input_dict.items():
-            merging_model_part_names = [container_expression.GetModelPart().FullName() for container_expression in v.GetContainerExpressions()]
-
-            if not merging_model_part_names:
-                raise RuntimeError("Merging requires atleast one model part.")
-
-            uniqe_identifier_name = ModelPartUtilities.__GenerateUniqueIdentifier("UNION", merging_model_part_names, add_neghbours)
-            merged_model_part = ModelPartOperation(v.GetContainerExpressions()[0].GetModelPart().GetModel(), ModelPartOperation.OperationType.UNION, uniqe_identifier_name, merging_model_part_names, add_neghbours).GetModelPart()
-            result[k] = merged_model_part
-
-        return result
-
-    @staticmethod
-    def GetIntersectedMap(main_model_part: Kratos.ModelPart, input_dict: 'dict[Any, Kratos.ModelPart]', add_neghbours: bool) -> 'dict[Any, Kratos.ModelPart]':
-        result: 'dict[Any, Kratos.ModelPart]' = {}
-        for k, v in input_dict.items():
-            intersecting_model_part_names = [main_model_part.FullName(), v.FullName()]
-            uniqe_identifier_name = ModelPartUtilities.__GenerateUniqueIdentifier("INTERSECT", intersecting_model_part_names, add_neghbours)
-            intersected_model_part = ModelPartOperation(main_model_part.GetModel(), ModelPartOperation.OperationType.INTERSECT, uniqe_identifier_name, intersecting_model_part_names, add_neghbours).GetModelPart()
-            result[k] = intersected_model_part
-
+from typing import Any
+from enum import Enum
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+
+class ModelPartOperation:
+    class OperationType(Enum):
+        UNION = 1,
+        INTERSECT = 2
+
+    def __init__(self, model: Kratos.Model, operation_type: OperationType, suggested_model_part_name: str, list_of_operation_model_part_full_names: 'list[str]', add_neighbours: bool) -> None:
+        self.model = model
+        self.operation_type = operation_type
+        self.suggested_model_part_name = suggested_model_part_name
+        self.list_of_operation_model_part_full_names = sorted(list(set(list_of_operation_model_part_full_names)))
+        self.add_neighbours = add_neighbours
+
+        if len(list_of_operation_model_part_full_names) == 0:
+            raise RuntimeError("No operating model part names are provided.")
+
+        if suggested_model_part_name.find("#") != -1 or any([mp_name.find("#") != -1 for mp_name in list_of_operation_model_part_full_names]):
+            # find '#' in the model part names which is not allwed.
+            raise RuntimeError(f"The model part names cannot contain '#' character. Parsed model part names are as followings:\n\t suggested model part name: \"{suggested_model_part_name}\"\n\toperation model part names:\n\t" + "\n\t\t".join(list_of_operation_model_part_full_names))
+
+        # set the root model part. This needs to always exist.
+        self.root_model_part = self.model[self.list_of_operation_model_part_full_names[0].split(".")[0]]
+        self.status_msg = ""
+
+    def GetRootModelPart(self) -> Kratos.ModelPart:
+        return self.root_model_part
+
+    def GetModelPartFullName(self) -> str:
+        # check whether is there a need to perform binary operations
+        if self.operation_type == ModelPartOperation.OperationType.UNION or self.operation_type == ModelPartOperation.OperationType.INTERSECT:
+            if len(self.list_of_operation_model_part_full_names) == 1:
+                # all the operation model parts are the same, hence no need of doing an operation.
+                self.status_msg = ""
+                return self.list_of_operation_model_part_full_names[0]
+
+        # now check in the status messages of the root model part whether this operation is already added.
+        status_msg_prefix = "ModelPartUtilities_created#"
+        status_msg_suffix = f"#{self.operation_type.name}#{self.add_neighbours:d}#" + "#".join(self.list_of_operation_model_part_full_names)
+        status_msg_log = KratosOA.OptAppModelPartUtils.GetModelPartStatusLog(self.GetRootModelPart())
+        for status_msg in status_msg_log:
+            if status_msg.startswith(status_msg_prefix) and status_msg.endswith(status_msg_suffix):
+                # found the same operation done on a different model part, hence sending that name
+                self.status_msg = status_msg
+                full_model_part_name = f"{self.GetRootModelPart().FullName()}.{status_msg.split('#')[1]}"
+                Kratos.Logger.PrintInfo("ModelPartUtilities", f"Using \"{full_model_part_name}\" with the same operation instead of suggested model part with name = \"{self.GetRootModelPart().FullName()}.{self.suggested_model_part_name}\".")
+                return full_model_part_name
+
+        # it is not already called for creation. Then put that in the status msg.
+        if self.root_model_part.HasSubModelPart(self.suggested_model_part_name):
+            # this means, it already has a model part with suggeted name, but
+            # it does not match the operation identifier. So throw an error
+            raise RuntimeError(f"Found an already existing submodel part named \"{self.suggested_model_part_name}\" in {self.root_model_part.FullName()} without the required operation identifier = \"{status_msg_suffix}\".")
+
+        self.status_msg = f"{status_msg_prefix}{self.suggested_model_part_name}{status_msg_suffix}"
+        KratosOA.OptAppModelPartUtils.LogModelPartStatus(self.GetRootModelPart(), self.status_msg)
+        return f"{self.GetRootModelPart().FullName()}.{self.suggested_model_part_name}"
+
+    def GetModelPart(self) -> Kratos.ModelPart:
+        model_part_name = self.GetModelPartFullName()
+        if self.status_msg == "" or self.model.HasModelPart(model_part_name):
+            # if it is already there, that means it is already created. Hence return it or
+            # if the self.status_msg == "" means, there is no need to do any model part operations.
+            # therefore the model part should exist already.
+            return self.model[model_part_name]
+        else:
+            # the model part with the required operation not found. Hence creating it.
+            sub_model_part = self.model.CreateModelPart(model_part_name)
+            # now fill the submodel part
+            operation_model_parts = [self.model[name] for name in self.list_of_operation_model_part_full_names]
+            if self.operation_type == ModelPartOperation.OperationType.UNION:
+                Kratos.ModelPartOperationUtilities.Union(sub_model_part, self.root_model_part, operation_model_parts, self.add_neighbours)
+            elif self.operation_type == ModelPartOperation.OperationType.INTERSECT:
+                Kratos.ModelPartOperationUtilities.Intersect(sub_model_part, self.root_model_part, operation_model_parts, self.add_neighbours)
+
+            Kratos.Logger.PrintInfo("ModelPartUtilities", f"Created sub model part \"{sub_model_part.FullName()}\".")
+
+            return sub_model_part
+
+class ModelPartUtilities:
+    @staticmethod
+    def __GenerateUniqueIdentifier(prefix: str, list_of_names: 'list[str]', add_neighbours: bool) -> str:
+        if not all([name.find("#") == -1 for name in list_of_names]):
+            raise RuntimeError(f"The provided model part names has \"#\" which is invalid. Please remove all occurances of \"#\" character. Provided model part names:\n\t" + "\n\t".join(list_of_names))
+
+        sorted_names = sorted(list_of_names)
+        post_fix = "IN" if add_neighbours else "EN"
+        return (f"{prefix}_{post_fix}_" + "_".join(sorted_names)).replace(".", "-")
+
+    @staticmethod
+    def GetMergedMap(input_dict: 'dict[Any, KratosOA.CollectiveExpression]', add_neghbours: bool) -> 'dict[Any, Kratos.ModelPart]':
+        result: 'dict[Any, Kratos.ModelPart]' = {}
+        for k, v in input_dict.items():
+            merging_model_part_names = [container_expression.GetModelPart().FullName() for container_expression in v.GetContainerExpressions()]
+
+            if not merging_model_part_names:
+                raise RuntimeError("Merging requires atleast one model part.")
+
+            uniqe_identifier_name = ModelPartUtilities.__GenerateUniqueIdentifier("UNION", merging_model_part_names, add_neghbours)
+            merged_model_part = ModelPartOperation(v.GetContainerExpressions()[0].GetModelPart().GetModel(), ModelPartOperation.OperationType.UNION, uniqe_identifier_name, merging_model_part_names, add_neghbours).GetModelPart()
+            result[k] = merged_model_part
+
+        return result
+
+    @staticmethod
+    def GetIntersectedMap(main_model_part: Kratos.ModelPart, input_dict: 'dict[Any, Kratos.ModelPart]', add_neghbours: bool) -> 'dict[Any, Kratos.ModelPart]':
+        result: 'dict[Any, Kratos.ModelPart]' = {}
+        for k, v in input_dict.items():
+            intersecting_model_part_names = [main_model_part.FullName(), v.FullName()]
+            uniqe_identifier_name = ModelPartUtilities.__GenerateUniqueIdentifier("INTERSECT", intersecting_model_part_names, add_neghbours)
+            intersected_model_part = ModelPartOperation(main_model_part.GetModel(), ModelPartOperation.OperationType.INTERSECT, uniqe_identifier_name, intersecting_model_part_names, add_neghbours).GetModelPart()
+            result[k] = intersected_model_part
+
         return result
```

## KratosMultiphysics/OptimizationApplication/utilities/opt_convergence.py

```diff
@@ -1,83 +1,184 @@
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
-
-def CreateConvergenceCriteria(parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-    type = parameters["type"].GetString()
-    if type == "max_iter":
-        return MaxIterConvCriterion(parameters, optimization_problem)
-    elif type == "l2_norm":
-        return L2ConvCriterion(parameters, optimization_problem)
-    else:
-        raise RuntimeError(f"CreateConvergenceCriteria: unsupported convergence type {type}.")
-
-class MaxIterConvCriterion:
-    @classmethod
-    def GetDefaultParameters(cls):
-        return Kratos.Parameters("""{
-            "type"              : "max_iter",
-            "max_iter"          : 0
-        }""")
-
-    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
-        self.__max_iter = parameters["max_iter"].GetInt()
-        self.__optimization_problem = optimization_problem
-
-    @time_decorator()
-    def IsConverged(self, search_direction=None) -> bool:
-        iter = self.__optimization_problem.GetStep()
-        self.conv = iter >= self.__max_iter
-        DictLogger("Convergence info",self.GetInfo())
-        return self.conv
-
-    def GetInfo(self) -> dict:
-        info = {
-            "type": "max_iter",
-            "iter": f"{self.__optimization_problem.GetStep()} of {self.__max_iter}",
-            "status": str("converged" if self.conv else "not converged")
-        }
-        return info
-
-class L2ConvCriterion:
-    @classmethod
-    def GetDefaultParameters(cls):
-        return Kratos.Parameters("""{
-            "type"              : "l2_norm",
-            "max_iter"          : 0,
-            "tolerance"         : 1e-9
-        }""")
-
-    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
-        self.__max_iter = parameters["max_iter"].GetInt()
-        self.__optimization_problem = optimization_problem
-        self.__tolerance = parameters["tolerance"].GetDouble()
-
-    @time_decorator()
-    def IsConverged(self) -> bool:
-        iter = self.__optimization_problem.GetStep()
-        self.conv = iter >= self.__max_iter
-
-        algorithm_buffered_data = ComponentDataView("algorithm", self.__optimization_problem).GetBufferedData()
-        if not algorithm_buffered_data.HasValue("search_direction"):
-            raise RuntimeError(f"Algorithm data does not contain computed \"search_direction\".\nData:\n{algorithm_buffered_data}" )
-
-        self.norm = KratosOA.ExpressionUtils.NormL2(algorithm_buffered_data["search_direction"])
-        if not self.conv:
-            self.conv = self.norm <= self.__tolerance
-
-        DictLogger("Convergence info",self.GetInfo())
-
-        return self.conv
-
-    def GetInfo(self) -> dict:
-        info = {'type': 'l2_norm',
-                'l2_norm': self.norm,
-                'tolerance': self.__tolerance,
-                'status': str("converged" if self.conv else "not converged")}
-        return info
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import TimeLogger
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
+
+def CreateConvergenceCriteria(parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+    type = parameters["type"].GetString()
+    if type == "max_iter":
+        return MaxIterConvCriterion(parameters, optimization_problem)
+    elif type == "l2_norm":
+        return L2ConvCriterion(parameters, optimization_problem)
+    elif type == "aver_abs_delta":
+        return AverageAbsoluteImprovement(parameters, optimization_problem)
+    elif type == "target_value":
+        return TargetValueCriterion(parameters, optimization_problem)
+    else:
+        raise RuntimeError(f"CreateConvergenceCriteria: unsupported convergence type {type}.")
+
+class MaxIterConvCriterion:
+    @classmethod
+    def GetDefaultParameters(cls):
+        return Kratos.Parameters("""{
+            "type"              : "max_iter",
+            "max_iter"          : 0
+        }""")
+
+    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+        self.__max_iter = parameters["max_iter"].GetInt()
+        self.__optimization_problem = optimization_problem
+
+    @time_decorator()
+    def IsConverged(self, search_direction=None) -> bool:
+        iter = self.__optimization_problem.GetStep()
+        self.conv = iter >= self.__max_iter
+        DictLogger("Convergence info",self.GetInfo())
+        return self.conv
+
+    def GetInfo(self) -> dict:
+        info = {
+            "type": "max_iter",
+            "iter": f"{self.__optimization_problem.GetStep()} of {self.__max_iter}",
+            "status": str("converged" if self.conv else "not converged")
+        }
+        return info
+
+class L2ConvCriterion:
+    @classmethod
+    def GetDefaultParameters(cls):
+        return Kratos.Parameters("""{
+            "type"              : "l2_norm",
+            "max_iter"          : 0,
+            "tolerance"         : 1e-9
+        }""")
+
+    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+        self.__max_iter = parameters["max_iter"].GetInt()
+        self.__optimization_problem = optimization_problem
+        self.__tolerance = parameters["tolerance"].GetDouble()
+
+    @time_decorator()
+    def IsConverged(self) -> bool:
+        iter = self.__optimization_problem.GetStep()
+        self.conv = iter >= self.__max_iter
+
+        algorithm_buffered_data = ComponentDataView("algorithm", self.__optimization_problem).GetBufferedData()
+        if not algorithm_buffered_data.HasValue("search_direction"):
+            raise RuntimeError(f"Algorithm data does not contain computed \"search_direction\".\nData:\n{algorithm_buffered_data}" )
+
+        self.norm = KratosOA.ExpressionUtils.NormL2(algorithm_buffered_data["search_direction"])
+        if not self.conv:
+            self.conv = self.norm <= self.__tolerance
+
+        DictLogger("Convergence info",self.GetInfo())
+
+        return self.conv
+
+    def GetInfo(self) -> dict:
+        info = {'type': 'l2_norm',
+                'l2_norm': self.norm,
+                'tolerance': self.__tolerance,
+                "iter": f"{self.__optimization_problem.GetStep()} of {self.__max_iter}",
+                'status': str("converged" if self.conv else "not converged")}
+        return info
+
+class AverageAbsoluteImprovement:
+    @classmethod
+    def GetDefaultParameters(cls):
+        return Kratos.Parameters("""{
+            "type"              : "aver_abs_delta",
+            "max_iter"          : 0,
+            "tracked_iter"      : 5,
+            "tolerance"         : 1e-6
+        }""")
+
+    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+        self.__max_iter = parameters["max_iter"].GetInt()
+        self.__tracked_iter = parameters["tracked_iter"].GetInt()
+        self.__optimization_problem = optimization_problem
+        self.__tolerance = parameters["tolerance"].GetDouble()
+        self.__abs_value_change = []
+        self.value = None
+
+    @time_decorator()
+    def IsConverged(self) -> bool:
+        iter = self.__optimization_problem.GetStep()
+        self.conv = iter >= self.__max_iter
+
+        step = self.__optimization_problem.GetStep()
+        algorithm_buffered_data = ComponentDataView("algorithm", self.__optimization_problem).GetBufferedData()
+        if step == 0:
+            self.__init_value = algorithm_buffered_data.GetValue("std_obj_value", 0)
+            self.conv = False
+        if step > 0:
+            if not algorithm_buffered_data.HasValue("std_obj_value"):
+                raise RuntimeError(f"Algorithm data does not contain computed \"std_obj_value\".\nData:\n{algorithm_buffered_data}" )
+            value = algorithm_buffered_data.GetValue("std_obj_value", 0)
+            prev_value = algorithm_buffered_data.GetValue("std_obj_value", 1)
+            self.__abs_value_change.append((value - prev_value)/self.__init_value)
+
+        if step >= self.__tracked_iter - 1:
+            self.value = 0.0
+            for i in range(self.__tracked_iter - 1):
+                self.value += self.__abs_value_change[-1 - i]
+            self.value = abs(self.value) / (self.__tracked_iter - 1) 
+            if not self.conv:
+                self.conv = self.value <= self.__tolerance
+
+        DictLogger("Convergence info",self.GetInfo())
+
+        return self.conv
+
+    def GetInfo(self) -> dict:
+        info = {'type': 'aver_abs_delta',
+                'aver_abs_delta': str(self.value),
+                'tolerance': self.__tolerance,
+                'tracked_iter': self.__tracked_iter,
+                "iter": f"{self.__optimization_problem.GetStep()} of {self.__max_iter}",
+                'status': str("converged" if self.conv else "not converged")}
+        return info
+    
+class TargetValueCriterion:
+    @classmethod
+    def GetDefaultParameters(cls):
+        return Kratos.Parameters("""{
+            "type"              : "target_value",
+            "max_iter"          : 0,
+            "target_value"      : 1e-9
+        }""")
+
+    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+        self.__max_iter = parameters["max_iter"].GetInt()
+        self.__optimization_problem = optimization_problem
+        self.__target_value = parameters["target_value"].GetDouble()
+
+    @time_decorator()
+    def IsConverged(self) -> bool:
+        iter = self.__optimization_problem.GetStep()
+        self.conv = iter >= self.__max_iter
+
+        algorithm_buffered_data = ComponentDataView("algorithm", self.__optimization_problem).GetBufferedData()
+        if not algorithm_buffered_data.HasValue("std_obj_value"):
+            raise RuntimeError(f"Algorithm data does not contain computed \"std_obj_value\".\nData:\n{algorithm_buffered_data}" )
+        self.value = algorithm_buffered_data["std_obj_value"]
+        if not self.conv:
+            self.conv = self.value <= self.__target_value
+
+        DictLogger("Convergence info",self.GetInfo())
+
+        return self.conv
+
+    def GetInfo(self) -> dict:
+        info = {'type': 'value',
+                'current_value': self.value,
+                'target_value': self.__target_value,
+                "iter": f"{self.__optimization_problem.GetStep()} of {self.__max_iter}",
+                'status': str("converged" if self.conv else "not converged")}
+        return info
```

## KratosMultiphysics/OptimizationApplication/utilities/opt_line_search.py

```diff
@@ -1,173 +1,168 @@
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.OptimizationApplication as KratosOA
-from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
-from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
-from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
-import numpy
-
-import math
-
-def CreateLineSearch(parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-    type = parameters["type"].GetString()
-    if type == "const_step":
-        return ConstStep(parameters, optimization_problem)
-    elif type == "BB_step":
-        return BBStep(parameters, optimization_problem)
-    elif type == "QNBB_step":
-        return QNBBStep(parameters, optimization_problem)
-    else:
-        raise RuntimeError(f"CreateConvergenceCriteria: unsupported convergence type {type}.")
-
-class ConstStep():
-    @classmethod
-    def GetDefaultParameters(cls):
-        return Kratos.Parameters("""{
-            "type"               : "const_step",
-            "init_step"          : 0,
-            "gradient_scaling": ": inf_norm"
-        }""")
-
-    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
-        self._init_step = parameters["init_step"].GetDouble()
-        self._optimization_problem = optimization_problem
-        self._gradient_scaling = parameters["gradient_scaling"].GetString()
-        self.unscaled_step = self._init_step
-
-    def ComputeScaleFactor(self) -> float:
-        algorithm_buffered_data = ComponentDataView("algorithm", self._optimization_problem).GetBufferedData()
-
-        if not algorithm_buffered_data.HasValue("search_direction"):
-            raise RuntimeError(f"Algorithm data does not contain computed \"search_direction\".\nData:\n{algorithm_buffered_data}" )
-
-        if self._gradient_scaling == "inf_norm":
-            norm = KratosOA.ExpressionUtils.NormInf(algorithm_buffered_data["search_direction"])
-        elif self._gradient_scaling == "l2_norm":
-            norm = KratosOA.ExpressionUtils.NormL2(algorithm_buffered_data["search_direction"])
-        elif self._gradient_scaling == "none":
-            norm = 1.0
-        else:
-            raise RuntimeError("\"gradient_scaling\" has unknown type.")
-
-        return norm
-
-    @time_decorator()
-    def ComputeStep(self) -> float:
-        norm = self.ComputeScaleFactor()
-        if not math.isclose(norm, 0.0, abs_tol=1e-16):
-            self.step = self._init_step / norm
-        else:
-            self.step =  self._init_step
-
-        DictLogger("Line Search info",self.GetInfo())
-
-        return self.step
-
-    def GetInfo(self) -> dict:
-        info = {'type': 'constant',
-                'unscaled_step': self.unscaled_step,
-                'scaled_step': self.step}
-        return info
-
-class BBStep(ConstStep):
-    @classmethod
-    def GetDefaultParameters(cls):
-        return Kratos.Parameters("""{
-            "type"               : "BB_step",
-            "init_step"          : 0,
-            "max_step"           : 0,
-            "gradient_scaling"   : "inf_norm"
-        }""")
-
-    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
-        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
-        self._init_step = parameters["init_step"].GetDouble()
-        self._max_step = parameters["max_step"].GetDouble()
-        self._optimization_problem = optimization_problem
-        self._gradient_scaling = parameters["gradient_scaling"].GetString()
-
-    @time_decorator()
-    def ComputeStep(self) -> KratosOA.CollectiveExpression:
-        algorithm_buffered_data = ComponentDataView("algorithm", self._optimization_problem).GetBufferedData()
-        norm = self.ComputeScaleFactor()
-        if self._optimization_problem.GetStep() == 0:
-            self.unscaled_step = self._init_step
-        else:
-            current_search_direction = algorithm_buffered_data.GetValue("search_direction", 0)
-            previous_search_direction = algorithm_buffered_data.GetValue("search_direction", 1)
-            y = previous_search_direction - current_search_direction
-            d = algorithm_buffered_data.GetValue("control_field_update", 1)
-            dy = KratosOA.ExpressionUtils.InnerProduct(d,y)
-            dd = KratosOA.ExpressionUtils.InnerProduct(d,d)
-            if not math.isclose(dy, 0.0, abs_tol=1e-16):
-                self.unscaled_step = abs( dd / dy )
-            else:
-                self.unscaled_step = self._max_step
-
-        if not math.isclose(norm, 0.0, abs_tol=1e-16):
-            self.step = self.unscaled_step / norm
-        else:
-            self.step =  self.unscaled_step
-
-        if self.step > self._max_step:
-            self.step = self._max_step
-
-        DictLogger("Line Search info",self.GetInfo())
-
-        return self.step
-
-    def GetInfo(self) -> dict:
-        info = {'type': 'BB_step',
-                'unscaled_step': self.unscaled_step,
-                'scaled_step': self.step,
-                'max_step': self._max_step,
-                'init_step': self._init_step}
-
-        return info
-
-class QNBBStep(BBStep):
-    @time_decorator()
-    def ComputeStep(self) -> KratosOA.CollectiveExpression:
-        algorithm_buffered_data = ComponentDataView("algorithm", self._optimization_problem).GetBufferedData()
-        norm = self.ComputeScaleFactor()
-        self.step = algorithm_buffered_data.GetValue("search_direction", 0).Clone()
-        self.step *= 0.0
-        if not algorithm_buffered_data.HasValue("step_size"):
-            algorithm_buffered_data["step_size"] = self.step
-        self.step_numpy = self.step.Evaluate()
-        if self._optimization_problem.GetStep() == 0:
-            self.step_numpy[:] = self._init_step
-        else:
-            current_search_direction = algorithm_buffered_data.GetValue("search_direction", 0)
-            previous_search_direction = algorithm_buffered_data.GetValue("search_direction", 1)
-            y = previous_search_direction - current_search_direction
-            y = y.Evaluate()
-            d = algorithm_buffered_data.GetValue("control_field_update", 1)
-            d = d.Evaluate()
-            for i in range(len(y)):
-                yy = y[i] * y[i]
-                yd = y[i] * d[i]
-                if math.isclose(yy, 0.0, abs_tol=1e-16):
-                    self.step_numpy[i] = self._max_step
-                else:
-                    self.step_numpy[i] = abs( yd / yy )
-                if self.step_numpy[i] > self._max_step:
-                    self.step_numpy[i] = self._max_step
-
-        if not math.isclose(norm, 0.0, abs_tol=1e-16):
-            self.step_numpy[:] /= norm
-
-        DictLogger("Line Search info",self.GetInfo())
-
-        shape = [c.GetItemShape() for c in self.step.GetContainerExpressions()]
-        KratosOA.CollectiveExpressionIO.Read(self.step, self.step_numpy, shape)
-        return self.step
-
-    def GetInfo(self) -> dict:
-        info = {'type': 'QNBB_step',
-                # 'max scaled_step': self.step.max(),
-                'max_step': self._max_step,
-                'init_step': self._init_step}
-
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.OptimizationApplication as KratosOA
+from KratosMultiphysics.OptimizationApplication.utilities.optimization_problem import OptimizationProblem
+from KratosMultiphysics.OptimizationApplication.utilities.component_data_view import ComponentDataView
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import DictLogger
+from KratosMultiphysics.OptimizationApplication.utilities.logger_utilities import time_decorator
+import numpy
+
+import math
+
+def CreateLineSearch(parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+    type = parameters["type"].GetString()
+    if type == "const_step":
+        return ConstStep(parameters, optimization_problem)
+    elif type == "BB_step":
+        return BBStep(parameters, optimization_problem)
+    elif type == "QNBB_step":
+        return QNBBStep(parameters, optimization_problem)
+    else:
+        raise RuntimeError(f"CreateConvergenceCriteria: unsupported convergence type {type}.")
+
+class ConstStep():
+    @classmethod
+    def GetDefaultParameters(cls):
+        return Kratos.Parameters("""{
+            "type"               : "const_step",
+            "init_step"          : 0,
+            "gradient_scaling": ": inf_norm"
+        }""")
+
+    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+        self._init_step = parameters["init_step"].GetDouble()
+        self._optimization_problem = optimization_problem
+        self._gradient_scaling = parameters["gradient_scaling"].GetString()
+        self.unscaled_step = self._init_step
+
+    def ComputeScaleFactor(self) -> float:
+        algorithm_buffered_data = ComponentDataView("algorithm", self._optimization_problem).GetBufferedData()
+
+        if not algorithm_buffered_data.HasValue("search_direction"):
+            raise RuntimeError(f"Algorithm data does not contain computed \"search_direction\".\nData:\n{algorithm_buffered_data}" )
+
+        if self._gradient_scaling == "inf_norm":
+            norm = KratosOA.ExpressionUtils.NormInf(algorithm_buffered_data["search_direction"])
+        elif self._gradient_scaling == "l2_norm":
+            norm = KratosOA.ExpressionUtils.NormL2(algorithm_buffered_data["search_direction"])
+        elif self._gradient_scaling == "none":
+            norm = 1.0
+        else:
+            raise RuntimeError("\"gradient_scaling\" has unknown type.")
+
+        return norm
+
+    @time_decorator()
+    def ComputeStep(self) -> float:
+        norm = self.ComputeScaleFactor()
+        if not math.isclose(norm, 0.0, abs_tol=1e-16):
+            self.step = self._init_step / norm
+        else:
+            self.step =  self._init_step
+
+        DictLogger("Line Search info",self.GetInfo())
+
+        return self.step
+
+    def GetInfo(self) -> dict:
+        info = {'type': 'constant',
+                'unscaled_step': self.unscaled_step,
+                'scaled_step': self.step}
+        return info
+
+class BBStep(ConstStep):
+    @classmethod
+    def GetDefaultParameters(cls):
+        return Kratos.Parameters("""{
+            "type"               : "BB_step",
+            "init_step"          : 0,
+            "max_step"           : 0,
+            "gradient_scaling"   : "inf_norm"
+        }""")
+
+    def __init__(self, parameters: Kratos.Parameters, optimization_problem: OptimizationProblem):
+        parameters.ValidateAndAssignDefaults(self.GetDefaultParameters())
+        self._init_step = parameters["init_step"].GetDouble()
+        self._max_step = parameters["max_step"].GetDouble()
+        self._optimization_problem = optimization_problem
+        self._gradient_scaling = parameters["gradient_scaling"].GetString()
+
+    @time_decorator()
+    def ComputeStep(self) -> KratosOA.CollectiveExpression:
+        algorithm_buffered_data = ComponentDataView("algorithm", self._optimization_problem).GetBufferedData()
+        norm = self.ComputeScaleFactor()
+        if math.isclose(norm, 0.0, abs_tol=1e-16):
+            norm = 1.0
+        if self._optimization_problem.GetStep() == 0:
+            self.step = self._init_step / norm
+        else:
+            current_search_direction = algorithm_buffered_data.GetValue("search_direction", 0)
+            previous_search_direction = algorithm_buffered_data.GetValue("search_direction", 1)
+            y = previous_search_direction - current_search_direction
+            d = algorithm_buffered_data.GetValue("control_field_update", 1)
+            dy = KratosOA.ExpressionUtils.InnerProduct(d,y)
+            dd = KratosOA.ExpressionUtils.InnerProduct(d,d)
+            if not math.isclose(dy, 0.0, abs_tol=1e-16):
+                self.step = abs( dd / dy )
+            else:
+                self.step = self._max_step / norm
+
+            if self.step > self._max_step / norm:
+                self.step = self._max_step / norm
+
+        DictLogger("Line Search info",self.GetInfo())
+
+        return self.step
+
+    def GetInfo(self) -> dict:
+        info = {'type': 'BB_step',
+                'step': self.step,
+                'max_step': self._max_step,
+                'init_step': self._init_step}
+
+        return info
+
+class QNBBStep(BBStep):
+    @time_decorator()
+    def ComputeStep(self) -> KratosOA.CollectiveExpression:
+        algorithm_buffered_data = ComponentDataView("algorithm", self._optimization_problem).GetBufferedData()
+        norm = self.ComputeScaleFactor()
+        if math.isclose(norm, 0.0, abs_tol=1e-16):
+            norm = 1.0
+        self.step = algorithm_buffered_data.GetValue("search_direction", 0).Clone()
+        self.step *= 0.0
+        if not algorithm_buffered_data.HasValue("step_size"):
+            algorithm_buffered_data["step_size"] = self.step
+        self.step_numpy = self.step.Evaluate()
+        if self._optimization_problem.GetStep() == 0:
+            self.step_numpy[:] = self._init_step / norm
+        else:
+            current_search_direction = algorithm_buffered_data.GetValue("search_direction", 0)
+            previous_search_direction = algorithm_buffered_data.GetValue("search_direction", 1)
+            y = previous_search_direction - current_search_direction
+            y = y.Evaluate()
+            d = algorithm_buffered_data.GetValue("control_field_update", 1)
+            d = d.Evaluate()
+            for i in range(len(y)):
+                yy = y[i] * y[i]
+                yd = y[i] * d[i]
+                if math.isclose(yy, 0.0, abs_tol=1e-16):
+                    self.step_numpy[i] = self._max_step / norm
+                else:
+                    self.step_numpy[i] = abs( yd / yy )
+                if self.step_numpy[i] > self._max_step / norm:
+                    self.step_numpy[i] = self._max_step / norm
+
+        DictLogger("Line Search info",self.GetInfo())
+
+        shape = [c.GetItemShape() for c in self.step.GetContainerExpressions()]
+        KratosOA.CollectiveExpressionIO.Read(self.step, self.step_numpy, shape)
+        return self.step
+
+    def GetInfo(self) -> dict:
+        info = {'type': 'QNBB_step',
+                # 'max scaled_step': self.step.max(),
+                'max_step': self._max_step,
+                'init_step': self._init_step}
+
         return info
```

## KratosMultiphysics/OptimizationApplication/utilities/optimization_problem.py

 * *Ordering differences only*

```diff
@@ -1,175 +1,175 @@
-from __future__ import annotations
-from typing import Any, Union
-
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.OptimizationApplication.utilities.buffered_dict import BufferedDict
-from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
-from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
-from KratosMultiphysics.OptimizationApplication.controls.control import Control
-
-class OptimizationProblem:
-    """This is the main data holder for optimization problems
-
-    This class holds one private @ref BufferedDict container
-    which is used to hold components of the optimization problem being solved,
-    and the problem data generated while solving the optimization problem.
-
-    """
-    def __init__(self, echo_level: int = 0) -> None:
-        """Creates an instance of Optimization info
-
-        Creates an instance of optimization info with most basic structure
-        for the BufferedDict container and components container.
-
-        """
-        self.__echo_level = echo_level
-
-        # create the optimization components data container with basic types
-        self.__components: 'dict[Any, dict[str, Any]]' = {
-            ResponseFunction: {},
-            ExecutionPolicy: {},
-            Control: {}
-        }
-
-        # now set the processes dict with different categories of processes
-        # such as initialization, output processes
-        self.__proceses: 'dict[str, list[Kratos.Process]]' = {}
-
-        # create the unbufferd optimization problem data container
-        self.__problem_data = BufferedDict(1)
-
-        # initialize the step
-        self.__problem_data["step"] = 0
-
-    def GetComponentType(self, component: Union[ExecutionPolicy, ResponseFunction, Control]) -> Any:
-        for k in self.__components.keys():
-            if isinstance(component, k):
-                return k
-
-        return None
-
-    def GetComponentName(self, component: Union[ExecutionPolicy, ResponseFunction, Control]) -> str:
-        component_type = self.GetComponentType(component)
-        if not component_type is None:
-            components = self.__components[component_type]
-        else:
-            raise RuntimeError(f"Unsupported component type {component} provided.")
-
-        for comp_name, current_component in components.items():
-            if component == current_component:
-                return comp_name
-
-        raise RuntimeError(f"The given {component} not found in components of type {component_type}.")
-
-    def AddComponent(self, component: Union[ExecutionPolicy, ResponseFunction, Control]) -> None:
-        for k, v in self.__components.items():
-            if isinstance(component, k):
-                added_component_type = k.__name__
-                v[component.GetName()] = component
-                break
-
-        if added_component_type is None:
-            raise RuntimeError(f"The given compoennt is of not supported types. Supported types:\n\tKratos.Process\n\t" + "\n\t".join([k.__name__ for k in self.__components.keys()]))
-        else:
-            if self.__echo_level > 0:
-                Kratos.Logger.PrintInfo(self.__class__.__name__, f"Added \"{component.GetName()}\" to \"{added_component_type}\".")
-
-    def GetResponse(self, name: str) -> ResponseFunction:
-        return self.GetComponent(name, ResponseFunction)
-
-    def GetListOfResponses(self) -> 'list[ResponseFunction]':
-        return self.__components[ResponseFunction].values()
-
-    def RemoveResponse(self, name: str) -> None:
-        self.RemoveComponent(name, ResponseFunction)
-
-    def GetExecutionPolicy(self, name: str) -> ExecutionPolicy:
-        return self.GetComponent(name, ExecutionPolicy)
-
-    def GetListOfExecutionPolicies(self) -> 'list[ExecutionPolicy]':
-        return self.__components[ExecutionPolicy].values()
-
-    def RemoveExecutionPolicy(self, name: str) -> None:
-        self.RemoveComponent(name, ExecutionPolicy)
-
-    def GetControl(self, name: str) -> Control:
-        return self.GetComponent(name, Control)
-
-    def GetListOfControls(self) -> 'list[Control]':
-        return self.__components[Control].values()
-
-    def RemoveControl(self, name: str) -> None:
-        self.RemoveComponent(name, Control)
-
-    def AddProcessType(self, process_type: str) -> None:
-        self.__proceses[process_type] = []
-
-    def AddProcess(self, process_type: str, process: Kratos.Process) -> None:
-        if process_type not in self.__proceses.keys():
-            self.__proceses[process_type]: 'list[Kratos.Process]' = []
-
-        if not isinstance(process, Kratos.Process):
-            raise RuntimeError(f"The provided process is not of type Kratos.Process. [ process = {process}]")
-
-        if self.__echo_level > 0:
-            Kratos.Logger.PrintInfo(self.__class__.__name__, f"Added \"{process.__class__.__name__}\" to \"{process_type}\".")
-        self.__proceses[process_type].append(process)
-
-    def GetAvailableProcessTypes(self) -> 'list[str]':
-        return self.__proceses.keys()
-
-    def GetListOfProcesses(self, process_type: str) -> 'list[Kratos.Process]':
-        if process_type not in self.__proceses.keys():
-            raise RuntimeError(f"The process type = \"{process_type}\" not found. Followings are available process types:\n\t" + "\n\t".join([k for k in self.__proceses.keys()]))
-
-        return self.__proceses[process_type]
-
-    def GetStep(self) -> int:
-        """Gets the current step of the optimization info
-
-        Returns:
-            int: Current step of the optimization info.
-        """
-        return self.__problem_data["step"]
-
-    def AdvanceStep(self) -> None:
-        """Advances the problem data by one step.
-
-        This method advances problem data by one step and
-        clears all the data in the advanced step.
-
-        """
-        current_step = self.__problem_data["step"]
-        self.__problem_data.AdvanceStep()
-        self.__problem_data["step"] = current_step + 1
-
-    def GetProblemDataContainer(self) -> BufferedDict:
-        """Gets the global problem data container.
-
-        Returns:
-            BufferedDict: Global problem data container.
-        """
-        return self.__problem_data
-
-    def GetComponentContainer(self) -> 'dict[Any, dict[str, Any]]':
-        return self.__components
-
-    def GetComponent(self, name: str, component_type: Any) -> Any:
-        if component_type not in self.__components.keys():
-            raise RuntimeError(f"Unsupported component type requested from GetComponent. [ requested component type = \"{component_type}\" ]. Followings are supported component types:\n\t" + "\n\t".join([component_type.__name__ for component_type in list(self.__components.keys())]))
-
-        components = self.__components[component_type]
-        if name in components.keys():
-            return components[name]
-        else:
-            raise RuntimeError(f"No {component_type.__name__} with name = \"{name}\" exists. Followings are the available {component_type.__name__}:\n" + "\n\t".join(components.keys()))
-
-    def RemoveComponent(self, name: str, component_type: Any) -> None:
-        if component_type not in self.__components.keys():
-            raise RuntimeError(f"Unsupported component type requested from RemoveComponent. [ requested component type = \"{str(component_type)}\" ]. Followings are supported component types:\n\t" + "\n\t".join([component_type.__name__ for component_type in list(self.__components.keys())]))
-
-        components = self.__components[component_type]
-        if name in components.keys():
-            del components[name]
-        else:
-            raise RuntimeError(f"No {component_type.__name__} with name = \"{name}\" exists. Followings are the available {component_type.__name__}:\n" + "\n\t".join(components.keys()))
+from __future__ import annotations
+from typing import Any, Union
+
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.OptimizationApplication.utilities.buffered_dict import BufferedDict
+from KratosMultiphysics.OptimizationApplication.execution_policies.execution_policy import ExecutionPolicy
+from KratosMultiphysics.OptimizationApplication.responses.response_function import ResponseFunction
+from KratosMultiphysics.OptimizationApplication.controls.control import Control
+
+class OptimizationProblem:
+    """This is the main data holder for optimization problems
+
+    This class holds one private @ref BufferedDict container
+    which is used to hold components of the optimization problem being solved,
+    and the problem data generated while solving the optimization problem.
+
+    """
+    def __init__(self, echo_level: int = 0) -> None:
+        """Creates an instance of Optimization info
+
+        Creates an instance of optimization info with most basic structure
+        for the BufferedDict container and components container.
+
+        """
+        self.__echo_level = echo_level
+
+        # create the optimization components data container with basic types
+        self.__components: 'dict[Any, dict[str, Any]]' = {
+            ResponseFunction: {},
+            ExecutionPolicy: {},
+            Control: {}
+        }
+
+        # now set the processes dict with different categories of processes
+        # such as initialization, output processes
+        self.__proceses: 'dict[str, list[Kratos.Process]]' = {}
+
+        # create the unbufferd optimization problem data container
+        self.__problem_data = BufferedDict(1)
+
+        # initialize the step
+        self.__problem_data["step"] = 0
+
+    def GetComponentType(self, component: Union[ExecutionPolicy, ResponseFunction, Control]) -> Any:
+        for k in self.__components.keys():
+            if isinstance(component, k):
+                return k
+
+        return None
+
+    def GetComponentName(self, component: Union[ExecutionPolicy, ResponseFunction, Control]) -> str:
+        component_type = self.GetComponentType(component)
+        if not component_type is None:
+            components = self.__components[component_type]
+        else:
+            raise RuntimeError(f"Unsupported component type {component} provided.")
+
+        for comp_name, current_component in components.items():
+            if component == current_component:
+                return comp_name
+
+        raise RuntimeError(f"The given {component} not found in components of type {component_type}.")
+
+    def AddComponent(self, component: Union[ExecutionPolicy, ResponseFunction, Control]) -> None:
+        for k, v in self.__components.items():
+            if isinstance(component, k):
+                added_component_type = k.__name__
+                v[component.GetName()] = component
+                break
+
+        if added_component_type is None:
+            raise RuntimeError(f"The given compoennt is of not supported types. Supported types:\n\tKratos.Process\n\t" + "\n\t".join([k.__name__ for k in self.__components.keys()]))
+        else:
+            if self.__echo_level > 0:
+                Kratos.Logger.PrintInfo(self.__class__.__name__, f"Added \"{component.GetName()}\" to \"{added_component_type}\".")
+
+    def GetResponse(self, name: str) -> ResponseFunction:
+        return self.GetComponent(name, ResponseFunction)
+
+    def GetListOfResponses(self) -> 'list[ResponseFunction]':
+        return self.__components[ResponseFunction].values()
+
+    def RemoveResponse(self, name: str) -> None:
+        self.RemoveComponent(name, ResponseFunction)
+
+    def GetExecutionPolicy(self, name: str) -> ExecutionPolicy:
+        return self.GetComponent(name, ExecutionPolicy)
+
+    def GetListOfExecutionPolicies(self) -> 'list[ExecutionPolicy]':
+        return self.__components[ExecutionPolicy].values()
+
+    def RemoveExecutionPolicy(self, name: str) -> None:
+        self.RemoveComponent(name, ExecutionPolicy)
+
+    def GetControl(self, name: str) -> Control:
+        return self.GetComponent(name, Control)
+
+    def GetListOfControls(self) -> 'list[Control]':
+        return self.__components[Control].values()
+
+    def RemoveControl(self, name: str) -> None:
+        self.RemoveComponent(name, Control)
+
+    def AddProcessType(self, process_type: str) -> None:
+        self.__proceses[process_type] = []
+
+    def AddProcess(self, process_type: str, process: Kratos.Process) -> None:
+        if process_type not in self.__proceses.keys():
+            self.__proceses[process_type]: 'list[Kratos.Process]' = []
+
+        if not isinstance(process, Kratos.Process):
+            raise RuntimeError(f"The provided process is not of type Kratos.Process. [ process = {process}]")
+
+        if self.__echo_level > 0:
+            Kratos.Logger.PrintInfo(self.__class__.__name__, f"Added \"{process.__class__.__name__}\" to \"{process_type}\".")
+        self.__proceses[process_type].append(process)
+
+    def GetAvailableProcessTypes(self) -> 'list[str]':
+        return self.__proceses.keys()
+
+    def GetListOfProcesses(self, process_type: str) -> 'list[Kratos.Process]':
+        if process_type not in self.__proceses.keys():
+            raise RuntimeError(f"The process type = \"{process_type}\" not found. Followings are available process types:\n\t" + "\n\t".join([k for k in self.__proceses.keys()]))
+
+        return self.__proceses[process_type]
+
+    def GetStep(self) -> int:
+        """Gets the current step of the optimization info
+
+        Returns:
+            int: Current step of the optimization info.
+        """
+        return self.__problem_data["step"]
+
+    def AdvanceStep(self) -> None:
+        """Advances the problem data by one step.
+
+        This method advances problem data by one step and
+        clears all the data in the advanced step.
+
+        """
+        current_step = self.__problem_data["step"]
+        self.__problem_data.AdvanceStep()
+        self.__problem_data["step"] = current_step + 1
+
+    def GetProblemDataContainer(self) -> BufferedDict:
+        """Gets the global problem data container.
+
+        Returns:
+            BufferedDict: Global problem data container.
+        """
+        return self.__problem_data
+
+    def GetComponentContainer(self) -> 'dict[Any, dict[str, Any]]':
+        return self.__components
+
+    def GetComponent(self, name: str, component_type: Any) -> Any:
+        if component_type not in self.__components.keys():
+            raise RuntimeError(f"Unsupported component type requested from GetComponent. [ requested component type = \"{component_type}\" ]. Followings are supported component types:\n\t" + "\n\t".join([component_type.__name__ for component_type in list(self.__components.keys())]))
+
+        components = self.__components[component_type]
+        if name in components.keys():
+            return components[name]
+        else:
+            raise RuntimeError(f"No {component_type.__name__} with name = \"{name}\" exists. Followings are the available {component_type.__name__}:\n" + "\n\t".join(components.keys()))
+
+    def RemoveComponent(self, name: str, component_type: Any) -> None:
+        if component_type not in self.__components.keys():
+            raise RuntimeError(f"Unsupported component type requested from RemoveComponent. [ requested component type = \"{str(component_type)}\" ]. Followings are supported component types:\n\t" + "\n\t".join([component_type.__name__ for component_type in list(self.__components.keys())]))
+
+        components = self.__components[component_type]
+        if name in components.keys():
+            del components[name]
+        else:
+            raise RuntimeError(f"No {component_type.__name__} with name = \"{name}\" exists. Followings are the available {component_type.__name__}:\n" + "\n\t".join(components.keys()))
```

## KratosMultiphysics/OptimizationApplication/utilities/timer.py

 * *Ordering differences only*

```diff
@@ -1,45 +1,45 @@
-# ==============================================================================
-#  KratosOptimizationApplication
-#
-#  License:         BSD License
-#                   license: OptimizationApplication/license.txt
-#
-#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
-#
-# ==============================================================================
-
-# Import additional libraries
-import time
-
-# ==============================================================================
-class Timer:
-    # --------------------------------------------------------------------------
-    def __init__( self ):
-        self.Precision = 3
-        self.StartGlobalTime = None
-        self.StartLapTime = None
-        self.LapTime = None
-    # --------------------------------------------------------------------------
-    def StartTimer( self ):
-        self.StartGlobalTime = time.time()
-        self.StartLapTime = time.time()
-
-    # --------------------------------------------------------------------------
-    def GetLapTime( self ):
-        LapTime = time.time() - self.StartLapTime
-        return round( LapTime, self.Precision )
-
-    # --------------------------------------------------------------------------
-    def StartNewLap( self ):
-        self.StartLapTime = time.time()
-
-    #---------------------------------------------------------------------------
-    def GetTotalTime( self ):
-        totalTime = time.time() - self.StartGlobalTime
-        return round( totalTime, self.Precision )
-
-    # --------------------------------------------------------------------------
-    def GetTimeStamp( self ):
-        return time.ctime()
-
-# ==============================================================================
+# ==============================================================================
+#  KratosOptimizationApplication
+#
+#  License:         BSD License
+#                   license: OptimizationApplication/license.txt
+#
+#  Main authors:    Reza Najian Asl, https://github.com/RezaNajian
+#
+# ==============================================================================
+
+# Import additional libraries
+import time
+
+# ==============================================================================
+class Timer:
+    # --------------------------------------------------------------------------
+    def __init__( self ):
+        self.Precision = 3
+        self.StartGlobalTime = None
+        self.StartLapTime = None
+        self.LapTime = None
+    # --------------------------------------------------------------------------
+    def StartTimer( self ):
+        self.StartGlobalTime = time.time()
+        self.StartLapTime = time.time()
+
+    # --------------------------------------------------------------------------
+    def GetLapTime( self ):
+        LapTime = time.time() - self.StartLapTime
+        return round( LapTime, self.Precision )
+
+    # --------------------------------------------------------------------------
+    def StartNewLap( self ):
+        self.StartLapTime = time.time()
+
+    #---------------------------------------------------------------------------
+    def GetTotalTime( self ):
+        totalTime = time.time() - self.StartGlobalTime
+        return round( totalTime, self.Precision )
+
+    # --------------------------------------------------------------------------
+    def GetTimeStamp( self ):
+        return time.ctime()
+
+# ==============================================================================
```

## KratosMultiphysics/OptimizationApplication/utilities/union_utilities.py

 * *Ordering differences only*

```diff
@@ -1,11 +1,11 @@
-from typing import Union
-
-import KratosMultiphysics as Kratos
-
-# used union types for type hinting in python and for automated documentation generation
-SupportedSensitivityFieldVariableTypes = Union[Kratos.DoubleVariable, Kratos.Array1DVariable3]
-
-ContainerExpressionTypes = Union[
-                                Kratos.Expression.NodalExpression,
-                                Kratos.Expression.ConditionExpression,
+from typing import Union
+
+import KratosMultiphysics as Kratos
+
+# used union types for type hinting in python and for automated documentation generation
+SupportedSensitivityFieldVariableTypes = Union[Kratos.DoubleVariable, Kratos.Array1DVariable3]
+
+ContainerExpressionTypes = Union[
+                                Kratos.Expression.NodalExpression,
+                                Kratos.Expression.ConditionExpression,
                                 Kratos.Expression.ElementExpression]
```

## Comparing `KratosOptimizationApplication-9.4.5.dist-info/METADATA` & `KratosOptimizationApplication-9.5.dist-info/METADATA`

 * *Files 14% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-Metadata-Version: 2.1
-Name: KratosOptimizationApplication
-Version: 9.4.5
-Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
-Home-page: https://github.com/KratosMultiphysics/
-Author: Kratos Team
-Author-email: kratos@listas.cimne.upc.edu
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: C++
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Scientific/Engineering :: Physics
-Classifier: Topic :: Scientific/Engineering :: Mathematics
-Classifier: Natural Language :: English
-Classifier: Intended Audience :: Science/Research
-Classifier: Intended Audience :: Other Audience
-Classifier: Intended Audience :: Developers
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Environment :: Console
-Classifier: License :: OSI Approved :: BSD License
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Requires-Dist: KratosMultiphysics (==9.4.5)
-
-# OptimizationApplication
-
-The Kratos OptimizationApplication is a framework for solving optimization problems in continuum mechanics. It is supposed to handle both gradient-based (adjoint-based) and gradient-free methods. 
-
-## Main Features
-
-* State-of-the-art techniques and algorithms for shape, thickness and material/topology optimization. 
-* Efficient and consistent filtering techniques for parametrization-free shape, thickness and material/topology optimization.       
-* Abstract problem formulation which enables concurrent and nested multilevel-multi-scale optimization problems.    
-* Adaptive gradient-projection technique, developed specially for problems with an arbitrary large number of design variables of different scales.
-* Modular implementation which enables analysis and optimization of multi-physics problems.    
-* Realization and implementation of additive manufacturing constraints, e.g. hangover conditions (support structures), stackability and geometric limitations.   
+Metadata-Version: 2.1
+Name: KratosOptimizationApplication
+Version: 9.5
+Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
+Home-page: https://github.com/KratosMultiphysics/
+Author: Kratos Team
+Author-email: kratos@listas.cimne.upc.edu
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: C++
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Scientific/Engineering :: Physics
+Classifier: Topic :: Scientific/Engineering :: Mathematics
+Classifier: Natural Language :: English
+Classifier: Intended Audience :: Science/Research
+Classifier: Intended Audience :: Other Audience
+Classifier: Intended Audience :: Developers
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Environment :: Console
+Classifier: License :: OSI Approved :: BSD License
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+Requires-Dist: KratosMultiphysics ==9.5
+
+# OptimizationApplication
+
+The Kratos OptimizationApplication is a framework for solving optimization problems in continuum mechanics. It is supposed to handle both gradient-based (adjoint-based) and gradient-free methods. 
+
+## Main Features
+
+* State-of-the-art techniques and algorithms for shape, thickness and material/topology optimization. 
+* Efficient and consistent filtering techniques for parametrization-free shape, thickness and material/topology optimization.       
+* Abstract problem formulation which enables concurrent and nested multilevel-multi-scale optimization problems.    
+* Adaptive gradient-projection technique, developed specially for problems with an arbitrary large number of design variables of different scales.
+* Modular implementation which enables analysis and optimization of multi-physics problems.    
+* Realization and implementation of additive manufacturing constraints, e.g. hangover conditions (support structures), stackability and geometric limitations.
```

## Comparing `KratosOptimizationApplication-9.4.5.dist-info/RECORD` & `KratosOptimizationApplication-9.5.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,75 +1,81 @@
-KratosMultiphysics/.libs/KratosOptimizationApplication.pyd,sha256=OKtLO_2fl26mCJw-osRHRCDx7LS9o4ksWDR2XSchL7I,1787904
-KratosMultiphysics/.libs/KratosOptimizationCore.dll,sha256=9Ym_IBFtjsdiZb6gqR0HHDpEwnH_uCW-Yya8OOY5Bqc,2697728
-KratosMultiphysics/.libs/KratosOptimizationCore.lib,sha256=cEbIyw1OLtIWKLx8jX14Yhl2e9RTt46lPSA-SjdjFeg,902258
-KratosMultiphysics/OptimizationApplication/__init__.py,sha256=JMMbFHeEaieZmLqECeGb1zLPiLhMux9LDTsFJ-Y2JiI,797
-KratosMultiphysics/OptimizationApplication/analyses_controller.py,sha256=InYTHdjEoe1kQIlLnedgX1sgrV1hs9ZuyL7_Oppolvc,4205
-KratosMultiphysics/OptimizationApplication/controls_controller.py,sha256=DlflUz5XBsuheFPdWVbjWalFv_1UMbMr11EdwlOEDKA,12537
-KratosMultiphysics/OptimizationApplication/model_parts_controller.py,sha256=PWiB1W2fmFvlXQZ1fnuDUtb2e_cwbslwVEIDPsNUrHU,5354
-KratosMultiphysics/OptimizationApplication/optimization_analysis.py,sha256=upxexvCamb6PBqZNKiETvt_3q7r_N5sE-j_aVPJAO-A,8423
-KratosMultiphysics/OptimizationApplication/optimizations_controller.py,sha256=Czt7tqq_JCroFvxUmuozd0qHhOOiTnTNRY1L-yjGKxs,12820
-KratosMultiphysics/OptimizationApplication/optimizer.py,sha256=P6jiX-4L8lF3P0Sr2Xq0ed41XMqiZtYaSsN8WAJBJHw,3108
-KratosMultiphysics/OptimizationApplication/responses_controller.py,sha256=CTKfuOQmB1u_ckvda1O-XT3ItKmlVZkdBVBP-fgEnWE,23372
-KratosMultiphysics/OptimizationApplication/algorithms/NLOPT_algorithms.py,sha256=R1xVfgF8kH_KNpBTF21PyQ24zlaAPTy3Bc3uHrw7_n4,13643
-KratosMultiphysics/OptimizationApplication/algorithms/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/OptimizationApplication/algorithms/algorithm.py,sha256=-_zvRjmmisK5NBIkC7PU4FN1JYvWuB9yMS1f823DjKA,1015
-KratosMultiphysics/OptimizationApplication/algorithms/algorithm_base.py,sha256=E4qsjcEnwtlS_mZxYirzE2CM4k22GX6PzCbut01FLM0,24169
-KratosMultiphysics/OptimizationApplication/algorithms/algorithm_gradient_projection.py,sha256=S05a35VrWj3XoQmCV6WDnIiLe8FA95hLTG7wYwy1TRQ,11993
-KratosMultiphysics/OptimizationApplication/algorithms/algorithm_steepest_descent.py,sha256=hlh5ubuK_1Fvx_dw63PpQraNcnq4sdcr1lzp369dtUM,6617
-KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_constraint.py,sha256=qH3eVWhZx4j-32lfDEzrSXIXoBdb-0Z6mrU0t4lT4Wk,9467
-KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_objective.py,sha256=aVjsr6qj-SaJbmoUKKuSi27EjAlZ1kqephj26YPbqD4,9797
-KratosMultiphysics/OptimizationApplication/algorithms/standardized_constraint.py,sha256=rhTLVwb-KJpfkuVA1c15hBRNi7GBVsQKHCDW9o6xzn0,9272
-KratosMultiphysics/OptimizationApplication/algorithms/standardized_objective.py,sha256=tl4gd7gMJ4M4l5XceS1MzWwSVhDplG8hxlzKjfd-8w8,6788
-KratosMultiphysics/OptimizationApplication/controls/control.py,sha256=6nhtKH1j9J5Ewblv1ZsY66pppkFEPcdV0qabaWay9ew,6203
-KratosMultiphysics/OptimizationApplication/controls/master_control.py,sha256=t48CEAqAGy0PT-mEuz-UOfuGnRh1imzuwDD7Ro6gtOM,10153
-KratosMultiphysics/OptimizationApplication/controls/material/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_material.py,sha256=dgvN01CSK-R9fEE7yZhG1iT3P5vsbdim2X9fbJ3dfeg,4112
-KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_partition.py,sha256=iyqQOhHZBkUsL9Zg4cbS-gs3IugWzc7W0ticlZ5bxo0,3564
-KratosMultiphysics/OptimizationApplication/controls/material/material_control.py,sha256=5pWzkjD7b6jLM2rjtDSaSXITHrJh0I1DJifydDKB10c,3424
-KratosMultiphysics/OptimizationApplication/controls/material/material_properties_control.py,sha256=H-gQd6OdCGUCkNTYnKyGUfikGmbfdbeOTIapVNr_3t8,6636
-KratosMultiphysics/OptimizationApplication/controls/shape/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/OptimizationApplication/controls/shape/explicit_vertex_morphing.py,sha256=o0jCtZWiNYeSHczmK2iPPpOg3GuAWouMpIEAFA21TPc,2778
-KratosMultiphysics/OptimizationApplication/controls/shape/implicit_vertex_morphing.py,sha256=_EPlSE9sI-ZuxUfGToPfBumzVwMZJSPfWTJ9z8N86bM,7395
-KratosMultiphysics/OptimizationApplication/controls/shape/shape_control.py,sha256=DjmYdf1Top1YnDy-24F6Ip9HnaGA3P3t4nzHXBKKcPU,3734
-KratosMultiphysics/OptimizationApplication/controls/shape/vertex_morphing_shape_control.py,sha256=8Qu5aiuH0Qh_ZlioHJKrRHFbyGkB7WG9HUvC2gQCVQ4,20431
-KratosMultiphysics/OptimizationApplication/controls/thickness/helmholtz_thickness.py,sha256=QiGA3QahItHNJnojt2s1jLUBEGJbpfZjtiYcVF8xEyE,4852
-KratosMultiphysics/OptimizationApplication/controls/thickness/shell_thickness_control.py,sha256=xb2UCmEIVi3Ps_DDh9UeBHzz8BTd9Jo_bvz5qct_XHs,15302
-KratosMultiphysics/OptimizationApplication/controls/thickness/thickness_control.py,sha256=zX49-kZ-kTe8A0z_ZESCg_L_ly7CzjGJSgm9dXK-NNw,3432
-KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy.py,sha256=Xle0b06Twr3uFvXnz-NZ5CxCjBI2h7m2SyH98jVrJIw,642
-KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy_decorator.py,sha256=ka2nZunMCFUv8dEHzi-S6vnwiqoiGmeoO4my7-YnRoc,3332
-KratosMultiphysics/OptimizationApplication/execution_policies/independent_analysis_execution_policy.py,sha256=OnGb94dKlXAQyumz-mQgaNHBBkGbIdmN2m1rGnVlviE,4192
-KratosMultiphysics/OptimizationApplication/execution_policies/kratos_analysis_execution_policy.py,sha256=EvDOBTfuOgPxi_yQhHOo1-MIhvsnBx2xaoR0w1CFQTI,6449
-KratosMultiphysics/OptimizationApplication/execution_policies/stepping_analysis_execution_policy.py,sha256=h0xiPANQoh6x66-fcOXxjbMjQGdgLq3a8r5gRTuQUjU,4191
-KratosMultiphysics/OptimizationApplication/filtering/helmholtz_analysis.py,sha256=0wylTJb7RroWKxrdUweQ_LIaXttIsQU212uJSqTVXzY,7361
-KratosMultiphysics/OptimizationApplication/filtering/helmholtz_scalar_solver.py,sha256=1D9IEnyVZW4PQfHhp4mOGkRx6f-wgIhIUbN5mIiLxgw,2512
-KratosMultiphysics/OptimizationApplication/filtering/helmholtz_solver_base.py,sha256=qKSQv4dOUgahuFrSEaB13GDziOdsxeCseEIfyd5oltU,8579
-KratosMultiphysics/OptimizationApplication/filtering/helmholtz_vector_solver.py,sha256=MEHQqj603zrvy8bP8H597p-WPGb9TvkBqTQoXJ8PLxc,6510
-KratosMultiphysics/OptimizationApplication/filtering/python_solvers_wrapper_implicit_filters.py,sha256=GDvA0gwoIdwV1RJ3P2rg6vXFhmhQAeZId9p5X-0-glM,2597
-KratosMultiphysics/OptimizationApplication/model_part_controllers/mdpa_model_part_controller.py,sha256=GiZHze89g40JGPA4ovKm1owi2kkGMmAfwIv-sIcrXnI,2234
-KratosMultiphysics/OptimizationApplication/model_part_controllers/model_part_controller.py,sha256=RLx210E6wj4XG1vUOV65DFWn6xPg6Pc2K2GSYC7NeJ0,374
-KratosMultiphysics/OptimizationApplication/processes/optimization_problem_ascii_output_process.py,sha256=nIEVsyEQMHSkHGcAojrNHFzX1-1B0klF5DYKten5n1s,10851
-KratosMultiphysics/OptimizationApplication/processes/optimization_problem_vtu_output_process.py,sha256=_gzVu6ddbUAUFjnvPyLvEIpkr9W7pi2y80qvLCfpPQk,13852
-KratosMultiphysics/OptimizationApplication/responses/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/OptimizationApplication/responses/additive_manufacturing_responses.py,sha256=7yhr4QooOwt56NrPSiTJiLc-WW25W7tTw5_ksF3Rx1U,22408
-KratosMultiphysics/OptimizationApplication/responses/analysis_based_response_function_factory.py,sha256=LI_jlJiOVVzikJdtWJjxE9z7ITHUcZBNyXUadhJd808,739
-KratosMultiphysics/OptimizationApplication/responses/analysis_free_response_function_factory.py,sha256=qNwuWf0bvBA-IrmtTQZd6VxIowzN47gCDCjb5EaAjoc,820
-KratosMultiphysics/OptimizationApplication/responses/base_response.py,sha256=NCEYN03_POr97r3qbos8LleAo_8nfKxmRxgPJbtdZ_E,3342
-KratosMultiphysics/OptimizationApplication/responses/geometric_centroid_deviation_response_function.py,sha256=-cVXwe6sG4Zq6WYZpbuvghI4Op5a9Pq6RXRHWXwmaI8,5940
-KratosMultiphysics/OptimizationApplication/responses/linear_strain_energy_response_function.py,sha256=ofWXpi_TsNv017ivbkfklakWkiCLi4cYLLWK19bKMQA,4963
-KratosMultiphysics/OptimizationApplication/responses/mass_response_function.py,sha256=L8-GPnMVPyoF_g4RuSZqS7KzSAojWBGMzFPHPQNwBuQ,4143
-KratosMultiphysics/OptimizationApplication/responses/response_function.py,sha256=3Mgy1j3wvpNr-gTCQ3H2qGF3XL4JjHi-p1yc8GC16Cs,4826
-KratosMultiphysics/OptimizationApplication/responses/response_routine.py,sha256=33eI2ykAjz6aluX0ejgP6zvZf_A42N5GI2dx3iQa0sU,7551
-KratosMultiphysics/OptimizationApplication/responses/structural_responses.py,sha256=HT24jot3Z9Zeemuk6bV300h92yHDoasgqKfaC_hCGcU,18706
-KratosMultiphysics/OptimizationApplication/utilities/buffered_dict.py,sha256=UD6T-iwflwMfuYGO-lPsb9aNP_rXMKdAd6THalOMToQ,18507
-KratosMultiphysics/OptimizationApplication/utilities/component_data_view.py,sha256=IjH3tK6A4V9RZgOnV3ku9eGiHTbxQdtlEeObo46-MWk,3455
-KratosMultiphysics/OptimizationApplication/utilities/helper_utilities.py,sha256=Cafk4EtTja1mJLgE1CZJwF8qPgVcLXkkFpufruBVlgo,6120
-KratosMultiphysics/OptimizationApplication/utilities/logger_utilities.py,sha256=lWyJXLc8F9846l0PSILixZuGUxaMxrafKiG-o3Xfczc,7350
-KratosMultiphysics/OptimizationApplication/utilities/model_part_utilities.py,sha256=6s8R8pF19XPZmQ9msKmm-aR2Ri0HlUKG3_XBY8eHcAw,7937
-KratosMultiphysics/OptimizationApplication/utilities/opt_convergence.py,sha256=vM007ZDEAaSjQqp4LnjVojFwpJK5Jz4Eo-hExFE2w-w,3728
-KratosMultiphysics/OptimizationApplication/utilities/opt_line_search.py,sha256=vlZ43MOeDCchfWknri2s079gdBo4nOsUVhWKvRa34rw,7553
-KratosMultiphysics/OptimizationApplication/utilities/optimization_problem.py,sha256=ayuxRpy66e2XkksI5SJ8QXqx7ZmF7aEPPKzC9dyHOM8,7970
-KratosMultiphysics/OptimizationApplication/utilities/timer.py,sha256=aeZgMxavOfohjPyXCPCCk43ZIEEl1U4TWtYgRIx3BDs,1769
-KratosMultiphysics/OptimizationApplication/utilities/union_utilities.py,sha256=Qj1ESucKDavLmXJhddwi4TRIjH4MCNO5urdaLtjZVg0,498
-KratosOptimizationApplication-9.4.5.dist-info/METADATA,sha256=f45N8Q1wQ6IS6GEtlAXopfl4GlXpvyE9y-Uz8W9LHoM,2399
-KratosOptimizationApplication-9.4.5.dist-info/WHEEL,sha256=J_4V_gB-O6Y7Pn6lk91K27JaIhI-q07YM5J8Ufzqla4,100
-KratosOptimizationApplication-9.4.5.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
-KratosOptimizationApplication-9.4.5.dist-info/RECORD,,
+KratosOptimizationApplication-9.5.dist-info/METADATA,sha256=v8gPSET0dNUaDxUW6M9n2RN4rs4zPmo4KqX0EskjbrU,2353
+KratosOptimizationApplication-9.5.dist-info/WHEEL,sha256=rY0Y6THYM7EImsHfF-zs67o8pQciAsMw9_YuSvftjrQ,148
+KratosOptimizationApplication-9.5.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
+KratosOptimizationApplication-9.5.dist-info/RECORD,,
+KratosMultiphysics/OptimizationApplication/controls_controller.py,sha256=6tAwdVHgWBztpvc0UsHieNUHp-OEZ0m8zGusN4SKUrA,12333
+KratosMultiphysics/OptimizationApplication/analyses_controller.py,sha256=cEjXryoRcAQwl1yV84yLsyg4j73oTEwKtD4kcivNDAI,4130
+KratosMultiphysics/OptimizationApplication/model_parts_controller.py,sha256=X8g283E8EE9By6E7P5v283c_bEbs5Qba3lvt7Ldq_a0,5262
+KratosMultiphysics/OptimizationApplication/responses_controller.py,sha256=XQwzBukmAFHBrUVrbqzimeQpLayKRJNa0CiNYx0dHik,22982
+KratosMultiphysics/OptimizationApplication/optimization_analysis.py,sha256=afZXHp5cMCRMbLwb6FjSfEMxWFdnOJqFzduia9MOVN8,7739
+KratosMultiphysics/OptimizationApplication/__init__.py,sha256=gAh661XHyKlmRncykK7oAiXnqQiqz3FH1fwzkmUT5OQ,779
+KratosMultiphysics/OptimizationApplication/optimizations_controller.py,sha256=11DFnhJeF9ciRhrowGszZVW-930TnV85D-wSutGkhm4,12597
+KratosMultiphysics/OptimizationApplication/optimizer.py,sha256=E5ZytMXClU6hYtz6BvlUepf2tNxv25YDXBhkpO8IsKw,3047
+KratosMultiphysics/OptimizationApplication/processes/optimization_problem_vtu_output_process.py,sha256=-b6fSkEGpmNzSa9ak_TTy56KHSDpTubGD523gAVzxZY,13622
+KratosMultiphysics/OptimizationApplication/processes/optimization_problem_graph_output_process.py,sha256=KZVWYSi9c2SI9X2x3khYLv5CFe5KPrUyElC4JCBLhc4,8614
+KratosMultiphysics/OptimizationApplication/processes/optimization_problem_ascii_output_process.py,sha256=diqRY9kQ6egCd8-V-mWGZGuqXTjZjAgUj4reFlsY1Qw,10644
+KratosMultiphysics/OptimizationApplication/model_part_controllers/mdpa_model_part_controller.py,sha256=b6P_yJRci7P-TJrMM7HYgzCxK4GWGsbcZ-Mha-8MIgY,2190
+KratosMultiphysics/OptimizationApplication/model_part_controllers/model_part_controller.py,sha256=9wtXqPKKtP5yrx1cv1lqBmn3j3S18hd0qMDz7YID4bU,355
+KratosMultiphysics/OptimizationApplication/model_part_controllers/connectivity_preserving_model_part_controller.py,sha256=FkS4bv99BWNX7DTwXDGgsvMehAszBEYQv0WfBmCTNHA,3717
+KratosMultiphysics/OptimizationApplication/filtering/explicit_filter.py,sha256=4PnCKERFt0k7F3_8dDl8dov_xjJB2fmnQHGKgzOLcBw,6460
+KratosMultiphysics/OptimizationApplication/filtering/filter_utils.py,sha256=6raHCGmjBzo2deyRDzACDR837Jtqvv_OC_sOJaxZJHk,3855
+KratosMultiphysics/OptimizationApplication/filtering/helmholtz_scalar_solver.py,sha256=YvZlonJsSl-TRawWsXvrBUE6lyzp9BEsV9D3vYJ45NM,2326
+KratosMultiphysics/OptimizationApplication/filtering/helmholtz_vector_solver.py,sha256=3DXT4sHcGgtDPLATQRJre21IEWGW10_j3YZzofUWyuo,2346
+KratosMultiphysics/OptimizationApplication/filtering/helmholtz_analysis.py,sha256=sH5YVlqvmNtOqYIB5J2TxAHYzgmF-GlUxONRglNrMtY,7080
+KratosMultiphysics/OptimizationApplication/filtering/python_solvers_wrapper_implicit_filters.py,sha256=EikpXp3mMQY9QpGSSKRbTx2xxNyB_m4tYOoBRD_t3Dc,2809
+KratosMultiphysics/OptimizationApplication/filtering/filter.py,sha256=mBgVVUFV0b1O1AvgrPVxaiRIKezb5yhZDeM-jcsqZSE,7742
+KratosMultiphysics/OptimizationApplication/filtering/helmholtz_solver_base.py,sha256=ZLdo1RIuoapoQh-k3t9USKPUacI9K-KeO-OhhWyr5WM,12319
+KratosMultiphysics/OptimizationApplication/filtering/implicit_filter.py,sha256=JZy9qLYlSH9BNZXzKWBaJN7xc5YGV4MWvTuSiQJqGNM,11012
+KratosMultiphysics/OptimizationApplication/filtering/helmholtz_shape_solver.py,sha256=7mSwooWqFdSTLnYV4wNoMdUqlKbC0Lv4-tIBj-IFZm8,3995
+KratosMultiphysics/OptimizationApplication/controls/control.py,sha256=NjqIoDI7Ul902Nz2apRZavDLeSsdrULnaK6owOx6_8k,6069
+KratosMultiphysics/OptimizationApplication/controls/master_control.py,sha256=DyJev2it3NkmNV2Zrekkm78H8xPSB90fwVnmauwHW5c,10257
+KratosMultiphysics/OptimizationApplication/controls/shape/vertex_morphing_shape_control.py,sha256=Y9IxO1QrMOegMFfLG-m8v0bw0eZryo_fw7yyugeBfYc,16048
+KratosMultiphysics/OptimizationApplication/controls/thickness/shell_thickness_control.py,sha256=P_LYFF06CX0GOqjkKzLQMZPGHW8UQX1hMREwImZEc8I,12544
+KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_material.py,sha256=xXNPMAVectl1GQKbpVVnNKj4QKbXGRViSx0HZLrfTPk,4019
+KratosMultiphysics/OptimizationApplication/controls/material/helmholtz_partition.py,sha256=ngwfKOHvhWc63Xm-8ekHVK5BgdXJvh6Y43IZpy3AUdY,3483
+KratosMultiphysics/OptimizationApplication/controls/material/material_control.py,sha256=Y5mzOPaleH7fvHMinZihyA2SJ7Brswo1RdRi5je41gY,3353
+KratosMultiphysics/OptimizationApplication/controls/material/material_properties_control.py,sha256=LQq8CUKadAUXEpYn5zpwK09QXOFtfORhPjl9w9aRo4I,6537
+KratosMultiphysics/OptimizationApplication/controls/material/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/OptimizationApplication/execution_policies/kratos_analysis_execution_policy.py,sha256=5ZgOeCdh1-eKDniftEpezED60y4WO37zE7tJidsMyD0,6339
+KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy.py,sha256=Yx0cizsjrhyzPO4epxmYK9pk-RoY5FmhEF427zsDwAM,1199
+KratosMultiphysics/OptimizationApplication/execution_policies/stepping_analysis_execution_policy.py,sha256=48tCRwBVEgWPpXr8V1hrSGDHqfD_0gtGuWSguDrl6mw,4103
+KratosMultiphysics/OptimizationApplication/execution_policies/execution_policy_decorator.py,sha256=CAHd5bAYhsG2e9_myJ6oEUyJoC59T47yixYnrbSwIJ8,3265
+KratosMultiphysics/OptimizationApplication/execution_policies/independent_analysis_execution_policy.py,sha256=qhK9plq7HpJxCv5TXZhWbU-fyztECe52ZB-Ytp6Mwlg,4114
+KratosMultiphysics/OptimizationApplication/utilities/timer.py,sha256=pqCxshFQUeNhGEktJKYBrLRXylpkEG1QOjESt98SUbo,1724
+KratosMultiphysics/OptimizationApplication/utilities/opt_convergence.py,sha256=A_vFuvUXRzKx-A7-AMuLWu7zXADyBB_PoG9zW69NX58,8154
+KratosMultiphysics/OptimizationApplication/utilities/opt_line_search.py,sha256=8mnkvFW1HPcSxGmbtIuA-RsH2zNIPEhpqZxGjnPhKXo,7247
+KratosMultiphysics/OptimizationApplication/utilities/union_utilities.py,sha256=oeQpXU21AhaHMKRsnRR811EUcdBBEJPWPTyLmaQLzko,488
+KratosMultiphysics/OptimizationApplication/utilities/list_collective_expression_utilities.py,sha256=u37vsK_PPsnUU0x8onszN6MTtrskzZhSclgV_JNAfas,1107
+KratosMultiphysics/OptimizationApplication/utilities/helper_utilities.py,sha256=2TsZw_BQUBCDCE6Rs9nIoanC2fE_n9cfXdDC9Z7hMso,6002
+KratosMultiphysics/OptimizationApplication/utilities/buffered_dict.py,sha256=g73xSBfnJQvSneZEgCq9-KjHXlmUQXk_1TWGi2pZsUY,18108
+KratosMultiphysics/OptimizationApplication/utilities/logger_utilities.py,sha256=hQGBy5eVACE7rUrCQbTImDi4SrFlf43Ovk_jpeUpGLA,7170
+KratosMultiphysics/OptimizationApplication/utilities/optimization_problem.py,sha256=Xmp6ITb3_aht9uwIpiC1Dk7YHOo5nUY2VbPHmxVLH4I,7795
+KratosMultiphysics/OptimizationApplication/utilities/model_part_utilities.py,sha256=D-4XWAb4B2aMmY3301d3a_pS6OYXhnsqCP2I5pk_SoU,7833
+KratosMultiphysics/OptimizationApplication/utilities/component_data_view.py,sha256=S3LuQoCMabYArUvV-ZFapaIt_UOZUFyLZnVkl83VkWE,3385
+KratosMultiphysics/OptimizationApplication/responses/response_routine.py,sha256=cUO2o4j3npyMjHM3Xo1kV4lpnQKdupuBAnsSy6LSde4,7447
+KratosMultiphysics/OptimizationApplication/responses/structural_responses.py,sha256=psUWT97axOgjcgI8rfF2fvp2neFKXLvlYHgbYmTaa6w,18372
+KratosMultiphysics/OptimizationApplication/responses/analysis_based_response_function_factory.py,sha256=QeRc-L6hQUhe7J8WO50yc2P9q_iVYvQMOrlpHPzGljs,725
+KratosMultiphysics/OptimizationApplication/responses/linear_strain_energy_response_function.py,sha256=7lK6f7Gn1uPBzm1Z_8Ooa2d_SHkgTbSQx85NTOmzxQk,4879
+KratosMultiphysics/OptimizationApplication/responses/base_response.py,sha256=oOm8Jfw8DHskqKtK0K7O48i3Z-Nrzfs1tMH0pMSbBfk,3277
+KratosMultiphysics/OptimizationApplication/responses/geometric_centroid_deviation_response_function.py,sha256=493srwUd5FdvYbmXXqcR3gjcRUTnL4O8nfGtOytF-fY,5835
+KratosMultiphysics/OptimizationApplication/responses/response_function.py,sha256=B87GV-1cOO7Fo40mJQLgg3hriOnOwUicXYpDiw4ybqw,4712
+KratosMultiphysics/OptimizationApplication/responses/additive_manufacturing_responses.py,sha256=h8qED3ZW2wnjqEqembbM3-Y1TbCOyy9hVqr9xl-DWL8,21998
+KratosMultiphysics/OptimizationApplication/responses/mass_response_function.py,sha256=xeRrk6n0zB7d6dsEWdae8k7kKzsA0NYma69r6RBIpLU,4344
+KratosMultiphysics/OptimizationApplication/responses/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/OptimizationApplication/responses/analysis_free_response_function_factory.py,sha256=qIgpe-ydBinfepefE-xS2np4uXcZy6BnClXY90xN8OM,807
+KratosMultiphysics/OptimizationApplication/algorithms/NLOPT_algorithms.py,sha256=PMW_uf8FYu8-yRXVThCB0M0Quv2GIRYsNQR9UtMNKRo,13524
+KratosMultiphysics/OptimizationApplication/algorithms/algorithm_momentum_relaxed_gradient_projection.py,sha256=vkUxPBssxoEOXy0bVpKTgZwCaDKiaAsjtNq1DRcaU_Q,3131
+KratosMultiphysics/OptimizationApplication/algorithms/algorithm_nesterov_accelarated_gradient.py,sha256=JqR5Rcj_c67wVxn2i_k_kORgPDB6Qb-dzRK2XQZeP98,2722
+KratosMultiphysics/OptimizationApplication/algorithms/standardized_constraint.py,sha256=j5qMw5ykLJravPoAi0ImcOwyNBcOccSw45k30sr0-nU,9105
+KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_constraint.py,sha256=P1Vn8qx7rBIAyREtPcELR_NUi0qtVj8SWhFq2MY2LMk,9283
+KratosMultiphysics/OptimizationApplication/algorithms/algorithm_steepest_descent.py,sha256=VdYuJbTSjsgAkgLtCq7hA0UMXdhdP7c3n6v0KEohiNA,6538
+KratosMultiphysics/OptimizationApplication/algorithms/algorithm.py,sha256=a4yy8qaa2obtEkM9u4xQwFr27yQUXWcn9sLstg4-J8c,3185
+KratosMultiphysics/OptimizationApplication/algorithms/algorithm_gradient_projection.py,sha256=WrDpZrkUDYyLSFQJFx8UiKlhmDlECmGGLLrTlIw9OOg,11017
+KratosMultiphysics/OptimizationApplication/algorithms/algorithm_relaxed_gradient_projection.py,sha256=E7ellbBJcRyI2FpoS3Hdqk_aCQCtD5Mi4pIN23Lk5Xo,15556
+KratosMultiphysics/OptimizationApplication/algorithms/algorithm_base.py,sha256=iNsOlNWc-W2OMQSnAh1PpdOXNvUymOTEHzdSRMQ-jH0,23776
+KratosMultiphysics/OptimizationApplication/algorithms/standardized_rgp_constraint.py,sha256=LU1vcU4awWv6qIKG7x9a-XC1lRaNTdXgm778fsaosSI,12915
+KratosMultiphysics/OptimizationApplication/algorithms/standardized_objective.py,sha256=_pfwcWBCwO2I-Fp_14oA6Wc6qZHOBJKq6htPjFKKxmc,6717
+KratosMultiphysics/OptimizationApplication/algorithms/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/OptimizationApplication/algorithms/standardized_NLOPT_objective.py,sha256=nBTR9ooJQuXLdw1vYiDM3yBOmfdg7MJLbsIWxJ5omx4,9617
+KratosMultiphysics/.libs/libKratosOptimizationCore.so,sha256=Ik6WoW2BAL84Q5EWXDzBrgReJ6TCKtE9M6xmo4IlfJE,10245273
+KratosMultiphysics/.libs/KratosOptimizationApplication.cpython-39-x86_64-linux-gnu.so,sha256=Z3aEYl7-C7VzVPyoUoZshXST2MhWXIOb3q8bdrEwEWY,4162097
+KratosOptimizationApplication.libs/libKratosOptimizationCore-c5761cae.so,sha256=TW6Cb4vXed2sVwqnrx00PkYGtlw4dXWFdlSEOz9crys,10895897
```

