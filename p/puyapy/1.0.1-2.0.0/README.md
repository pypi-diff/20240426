# Comparing `tmp/puyapy-1.0.1-py3-none-any.whl.zip` & `tmp/puyapy-2.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,107 +1,107 @@
-Zip file size: 2081150 bytes, number of entries: 960
+Zip file size: 2109864 bytes, number of entries: 965
 -rw-r--r--  2.0 unx      453 b- defN 80-Jan-01 00:00 puya/ARCHITECTURE.md
 -rw-r--r--  2.0 unx      123 b- defN 80-Jan-01 00:00 puya/__init__.py
 -rw-r--r--  2.0 unx     3727 b- defN 80-Jan-01 00:00 puya/__main__.py
 -rw-r--r--  2.0 unx      564 b- defN 80-Jan-01 00:00 puya/_typeshed/README.md
--rw-r--r--  2.0 unx     5573 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/VERSIONS
--rw-r--r--  2.0 unx     2476 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/_collections_abc.pyi
--rw-r--r--  2.0 unx    11385 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/_typeshed/__init__.pyi
--rw-r--r--  2.0 unx     1794 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/abc.pyi
--rw-r--r--  2.0 unx    81222 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/builtins.pyi
+-rw-r--r--  2.0 unx     5587 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/VERSIONS
+-rw-r--r--  2.0 unx     2479 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/_collections_abc.pyi
+-rw-r--r--  2.0 unx    11408 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/_typeshed/__init__.pyi
+-rw-r--r--  2.0 unx     2023 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/abc.pyi
+-rw-r--r--  2.0 unx    81291 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/builtins.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/collections/__init__.pyi
 -rw-r--r--  2.0 unx       79 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/collections/abc.pyi
--rw-r--r--  2.0 unx    12333 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/sys/__init__.pyi
--rw-r--r--  2.0 unx    20245 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/types.pyi
--rw-r--r--  2.0 unx    33638 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/typing.pyi
--rw-r--r--  2.0 unx    15035 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/typing_extensions.pyi
+-rw-r--r--  2.0 unx    12402 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/sys/__init__.pyi
+-rw-r--r--  2.0 unx    20405 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/types.pyi
+-rw-r--r--  2.0 unx    33870 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/typing.pyi
+-rw-r--r--  2.0 unx    15184 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/typing_extensions.pyi
 -rw-r--r--  2.0 unx     8892 b- defN 80-Jan-01 00:00 puya/_typeshed/stubs/mypy-extensions/mypy_extensions.pyi
--rw-r--r--  2.0 unx       47 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/.version
+-rw-r--r--  2.0 unx       49 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/.version
 -rw-r--r--  2.0 unx       37 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/__init__.py
 -rw-r--r--  2.0 unx     1061 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/__main__.py
 -rw-r--r--  2.0 unx     2922 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/api.py
--rw-r--r--  2.0 unx     6009 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/applytype.py
+-rw-r--r--  2.0 unx     6545 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/applytype.py
 -rw-r--r--  2.0 unx    11300 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/argmap.py
 -rw-r--r--  2.0 unx    21037 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/binder.py
 -rw-r--r--  2.0 unx      816 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/bogus_type.py
 -rw-r--r--  2.0 unx   144784 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/build.py
--rw-r--r--  2.0 unx   375773 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/checker.py
--rw-r--r--  2.0 unx   288076 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/checkexpr.py
--rw-r--r--  2.0 unx    53621 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/checkmember.py
--rw-r--r--  2.0 unx    32908 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/checkpattern.py
+-rw-r--r--  2.0 unx   379921 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/checker.py
+-rw-r--r--  2.0 unx   288412 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/checkexpr.py
+-rw-r--r--  2.0 unx    53886 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/checkmember.py
+-rw-r--r--  2.0 unx    32916 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/checkpattern.py
 -rw-r--r--  2.0 unx    46273 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/checkstrformat.py
 -rw-r--r--  2.0 unx    23389 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/config_parser.py
 -rw-r--r--  2.0 unx     6071 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/constant_fold.py
--rw-r--r--  2.0 unx    75662 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/constraints.py
+-rw-r--r--  2.0 unx    76295 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/constraints.py
 -rw-r--r--  2.0 unx     4425 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/copytype.py
 -rw-r--r--  2.0 unx     1558 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/defaults.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/dmypy/__init__.py
 -rw-r--r--  2.0 unx      128 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/dmypy/__main__.py
 -rw-r--r--  2.0 unx    24616 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/dmypy/client.py
 -rw-r--r--  2.0 unx     1154 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/dmypy_os.py
 -rw-r--r--  2.0 unx    44588 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/dmypy_server.py
 -rw-r--r--  2.0 unx     2995 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/dmypy_util.py
 -rw-r--r--  2.0 unx    10382 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/erasetype.py
--rw-r--r--  2.0 unx    10507 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/errorcodes.py
+-rw-r--r--  2.0 unx    10702 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/errorcodes.py
 -rw-r--r--  2.0 unx    47836 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/errors.py
 -rw-r--r--  2.0 unx     6562 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/evalexpr.py
--rw-r--r--  2.0 unx    21102 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/expandtype.py
--rw-r--r--  2.0 unx     7582 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/exprtotype.py
+-rw-r--r--  2.0 unx    22005 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/expandtype.py
+-rw-r--r--  2.0 unx     7674 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/exprtotype.py
 -rw-r--r--  2.0 unx    82599 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/fastparse.py
 -rw-r--r--  2.0 unx     9362 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/find_sources.py
--rw-r--r--  2.0 unx    15803 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/fixup.py
+-rw-r--r--  2.0 unx    15874 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/fixup.py
 -rw-r--r--  2.0 unx      617 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/freetree.py
 -rw-r--r--  2.0 unx    11328 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/fscache.py
 -rw-r--r--  2.0 unx     3969 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/fswatcher.py
 -rw-r--r--  2.0 unx     1641 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/gclogger.py
 -rw-r--r--  2.0 unx      980 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/git.py
 -rw-r--r--  2.0 unx     3343 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/graph_utils.py
 -rw-r--r--  2.0 unx     4595 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/indirection.py
 -rw-r--r--  2.0 unx     2511 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/infer.py
 -rw-r--r--  2.0 unx    23820 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/inspections.py
 -rw-r--r--  2.0 unx    11702 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/ipc.py
--rw-r--r--  2.0 unx    36109 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/join.py
+-rw-r--r--  2.0 unx    36433 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/join.py
 -rw-r--r--  2.0 unx     8749 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/literals.py
 -rw-r--r--  2.0 unx     2054 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/lookup.py
 -rw-r--r--  2.0 unx    58327 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/main.py
 -rw-r--r--  2.0 unx     4331 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/maptype.py
 -rw-r--r--  2.0 unx    47442 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/meet.py
 -rw-r--r--  2.0 unx     4153 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/memprofile.py
--rw-r--r--  2.0 unx    15478 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/message_registry.py
--rw-r--r--  2.0 unx   125104 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/messages.py
+-rw-r--r--  2.0 unx    15616 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/message_registry.py
+-rw-r--r--  2.0 unx   125738 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/messages.py
 -rw-r--r--  2.0 unx     6708 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/metastore.py
 -rw-r--r--  2.0 unx     3205 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/mixedtraverser.py
 -rw-r--r--  2.0 unx    37888 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/modulefinder.py
 -rw-r--r--  2.0 unx     6326 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/moduleinspect.py
 -rw-r--r--  2.0 unx     1993 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/mro.py
--rw-r--r--  2.0 unx   134416 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/nodes.py
+-rw-r--r--  2.0 unx   134517 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/nodes.py
 -rw-r--r--  2.0 unx     2866 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/operators.py
 -rw-r--r--  2.0 unx    22845 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/options.py
 -rw-r--r--  2.0 unx      913 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/parse.py
 -rw-r--r--  2.0 unx    25368 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/partially_defined.py
 -rw-r--r--  2.0 unx     4048 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/patterns.py
 -rw-r--r--  2.0 unx    35435 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugin.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/__init__.py
--rw-r--r--  2.0 unx    45109 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/attrs.py
+-rw-r--r--  2.0 unx    45794 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/attrs.py
 -rw-r--r--  2.0 unx    14148 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/common.py
 -rw-r--r--  2.0 unx    10675 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/ctypes.py
--rw-r--r--  2.0 unx    45569 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/dataclasses.py
--rw-r--r--  2.0 unx    20704 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/default.py
+-rw-r--r--  2.0 unx    46008 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/dataclasses.py
+-rw-r--r--  2.0 unx    21160 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/default.py
 -rw-r--r--  2.0 unx    10441 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/enums.py
 -rw-r--r--  2.0 unx     4004 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/functools.py
 -rw-r--r--  2.0 unx     6442 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/proper_plugin.py
 -rw-r--r--  2.0 unx     8446 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/plugins/singledispatch.py
 -rw-r--r--  2.0 unx       64 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/py.typed
 -rw-r--r--  2.0 unx     2941 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/pyinfo.py
 -rw-r--r--  2.0 unx    12690 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/reachability.py
 -rw-r--r--  2.0 unx     2784 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/refinfo.py
 -rw-r--r--  2.0 unx    19910 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/renaming.py
 -rw-r--r--  2.0 unx    34288 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/report.py
 -rw-r--r--  2.0 unx     4258 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/scope.py
--rw-r--r--  2.0 unx   300858 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/semanal.py
+-rw-r--r--  2.0 unx   308533 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/semanal.py
 -rw-r--r--  2.0 unx     7687 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/semanal_classprop.py
 -rw-r--r--  2.0 unx     9395 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/semanal_enum.py
 -rw-r--r--  2.0 unx     5180 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/semanal_infer.py
 -rw-r--r--  2.0 unx    20430 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/semanal_main.py
 -rw-r--r--  2.0 unx    28624 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/semanal_namedtuple.py
 -rw-r--r--  2.0 unx    10577 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/semanal_newtype.py
 -rw-r--r--  2.0 unx     5439 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/semanal_pass1.py
@@ -122,25 +122,25 @@
 -rw-r--r--  2.0 unx     2102 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/sharedparse.py
 -rw-r--r--  2.0 unx    22796 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/solve.py
 -rw-r--r--  2.0 unx     1289 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/split_namespace.py
 -rw-r--r--  2.0 unx      824 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/state.py
 -rw-r--r--  2.0 unx    16562 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stats.py
 -rw-r--r--  2.0 unx    23394 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/strconv.py
 -rw-r--r--  2.0 unx    16799 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stubdoc.py
--rwxr-xr-x  2.0 unx    71012 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stubgen.py
--rwxr-xr-x  2.0 unx    37237 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stubgenc.py
+-rwxr-xr-x  2.0 unx    71705 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stubgen.py
+-rwxr-xr-x  2.0 unx    37229 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stubgenc.py
 -rw-r--r--  2.0 unx     6232 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stubinfo.py
--rw-r--r--  2.0 unx    82825 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stubtest.py
--rw-r--r--  2.0 unx    30268 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stubutil.py
--rw-r--r--  2.0 unx    86045 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/subtypes.py
+-rw-r--r--  2.0 unx    82842 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stubtest.py
+-rw-r--r--  2.0 unx    31386 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/stubutil.py
+-rw-r--r--  2.0 unx    86810 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/subtypes.py
 -rw-r--r--  2.0 unx    38070 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/suggestions.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/__init__.py
 -rw-r--r--  2.0 unx     1160 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/config.py
--rw-r--r--  2.0 unx    29976 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/data.py
--rw-r--r--  2.0 unx    16231 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/helpers.py
+-rw-r--r--  2.0 unx    29913 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/data.py
+-rw-r--r--  2.0 unx    16234 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/helpers.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/meta/__init__.py
 -rw-r--r--  2.0 unx     2267 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/meta/_pytest.py
 -rw-r--r--  2.0 unx     1692 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/meta/test_diff_helper.py
 -rw-r--r--  2.0 unx     1931 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/meta/test_parse_data.py
 -rw-r--r--  2.0 unx     4814 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/meta/test_update_data.py
 -rw-r--r--  2.0 unx    13684 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/test_find_sources.py
 -rw-r--r--  2.0 unx     1432 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/test_ref_info.py
@@ -178,157 +178,158 @@
 -rw-r--r--  2.0 unx    61897 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/testtypes.py
 -rw-r--r--  2.0 unx     4233 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/testutil.py
 -rw-r--r--  2.0 unx    15758 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/typefixture.py
 -rw-r--r--  2.0 unx     3676 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/update_data.py
 -rw-r--r--  2.0 unx     2089 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/test/visitors.py
 -rw-r--r--  2.0 unx    26863 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/traverser.py
 -rw-r--r--  2.0 unx    28486 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/treetransform.py
--rw-r--r--  2.0 unx     5099 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/tvar_scope.py
+-rw-r--r--  2.0 unx     5839 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/tvar_scope.py
 -rw-r--r--  2.0 unx    18092 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/type_visitor.py
--rw-r--r--  2.0 unx   105972 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeanal.py
+-rw-r--r--  2.0 unx   109791 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeanal.py
 -rw-r--r--  2.0 unx    41115 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeops.py
--rw-r--r--  2.0 unx   132958 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/types.py
+-rw-r--r--  2.0 unx   133873 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/types.py
 -rw-r--r--  2.0 unx     5671 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/types_utils.py
 -rw-r--r--  2.0 unx    12657 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/LICENSE
--rw-r--r--  2.0 unx     5573 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/VERSIONS
+-rw-r--r--  2.0 unx     5587 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/VERSIONS
 -rw-r--r--  2.0 unx      915 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/__future__.pyi
 -rw-r--r--  2.0 unx       63 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/__main__.pyi
--rw-r--r--  2.0 unx    15352 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_ast.pyi
+-rw-r--r--  2.0 unx    15576 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_ast.pyi
 -rw-r--r--  2.0 unx     2651 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_bisect.pyi
 -rw-r--r--  2.0 unx       64 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_bootlocale.pyi
--rw-r--r--  2.0 unx     7042 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_codecs.pyi
--rw-r--r--  2.0 unx     2476 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_collections_abc.pyi
+-rw-r--r--  2.0 unx     6961 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_codecs.pyi
+-rw-r--r--  2.0 unx     2479 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_collections_abc.pyi
 -rw-r--r--  2.0 unx      356 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_compat_pickle.pyi
--rw-r--r--  2.0 unx      814 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_compression.pyi
+-rw-r--r--  2.0 unx      816 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_compression.pyi
 -rw-r--r--  2.0 unx     2499 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_csv.pyi
--rw-r--r--  2.0 unx     8144 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_ctypes.pyi
--rw-r--r--  2.0 unx    17423 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_curses.pyi
--rw-r--r--  2.0 unx    13776 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_decimal.pyi
--rw-r--r--  2.0 unx     1046 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_dummy_thread.pyi
+-rw-r--r--  2.0 unx     8139 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_ctypes.pyi
+-rw-r--r--  2.0 unx    15379 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_curses.pyi
+-rw-r--r--  2.0 unx    13802 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_decimal.pyi
+-rw-r--r--  2.0 unx     1252 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_dummy_thread.pyi
 -rw-r--r--  2.0 unx     5087 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_dummy_threading.pyi
--rw-r--r--  2.0 unx      338 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_heapq.pyi
--rw-r--r--  2.0 unx     1114 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_imp.pyi
+-rw-r--r--  2.0 unx      337 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_heapq.pyi
+-rw-r--r--  2.0 unx     1121 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_imp.pyi
 -rw-r--r--  2.0 unx     1452 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_json.pyi
--rw-r--r--  2.0 unx     2268 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_locale.pyi
+-rw-r--r--  2.0 unx     2264 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_locale.pyi
+-rw-r--r--  2.0 unx     1264 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_lsprof.pyi
 -rw-r--r--  2.0 unx      722 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_markupbase.pyi
 -rw-r--r--  2.0 unx     3260 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_msi.pyi
--rw-r--r--  2.0 unx     6079 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_operator.pyi
+-rw-r--r--  2.0 unx     6044 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_operator.pyi
 -rw-r--r--  2.0 unx     1865 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_osx_support.pyi
--rw-r--r--  2.0 unx      966 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_posixsubprocess.pyi
--rw-r--r--  2.0 unx      402 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_py_abc.pyi
+-rw-r--r--  2.0 unx      931 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_posixsubprocess.pyi
+-rw-r--r--  2.0 unx      397 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_py_abc.pyi
 -rw-r--r--  2.0 unx      895 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_pydecimal.pyi
--rw-r--r--  2.0 unx      405 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_random.pyi
+-rw-r--r--  2.0 unx      408 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_random.pyi
 -rw-r--r--  2.0 unx      518 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_sitebuiltins.pyi
--rw-r--r--  2.0 unx    21636 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_socket.pyi
+-rw-r--r--  2.0 unx    21634 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_socket.pyi
 -rw-r--r--  2.0 unx     2902 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_stat.pyi
--rw-r--r--  2.0 unx     1799 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_thread.pyi
+-rw-r--r--  2.0 unx     2005 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_thread.pyi
 -rw-r--r--  2.0 unx      516 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_threading_local.pyi
--rw-r--r--  2.0 unx     3965 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_tkinter.pyi
--rw-r--r--  2.0 unx      546 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_tracemalloc.pyi
+-rw-r--r--  2.0 unx     3976 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_tkinter.pyi
+-rw-r--r--  2.0 unx      548 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_tracemalloc.pyi
 -rw-r--r--  2.0 unx     1043 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_typeshed/README.md
--rw-r--r--  2.0 unx    11385 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_typeshed/__init__.pyi
--rw-r--r--  2.0 unx     1638 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_typeshed/dbapi.pyi
--rw-r--r--  2.0 unx     1635 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_typeshed/wsgi.pyi
--rw-r--r--  2.0 unx      506 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_typeshed/xml.pyi
+-rw-r--r--  2.0 unx    11408 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_typeshed/__init__.pyi
+-rw-r--r--  2.0 unx     1636 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_typeshed/dbapi.pyi
+-rw-r--r--  2.0 unx     1637 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_typeshed/wsgi.pyi
+-rw-r--r--  2.0 unx      499 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_typeshed/xml.pyi
 -rw-r--r--  2.0 unx     1562 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_warnings.pyi
--rw-r--r--  2.0 unx     1426 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_weakref.pyi
+-rw-r--r--  2.0 unx     1428 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_weakref.pyi
 -rw-r--r--  2.0 unx     2361 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_weakrefset.pyi
--rw-r--r--  2.0 unx     9415 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_winapi.pyi
--rw-r--r--  2.0 unx     1794 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/abc.pyi
+-rw-r--r--  2.0 unx     9390 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/_winapi.pyi
+-rw-r--r--  2.0 unx     2023 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/abc.pyi
 -rw-r--r--  2.0 unx     3354 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/aifc.pyi
 -rw-r--r--  2.0 unx      123 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/antigravity.pyi
--rw-r--r--  2.0 unx    21654 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/argparse.pyi
--rw-r--r--  2.0 unx     4043 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/array.pyi
+-rw-r--r--  2.0 unx    22493 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/argparse.pyi
+-rw-r--r--  2.0 unx     4058 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/array.pyi
 -rw-r--r--  2.0 unx    11480 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ast.pyi
 -rw-r--r--  2.0 unx      787 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asynchat.pyi
 -rw-r--r--  2.0 unx     1181 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/__init__.pyi
 -rw-r--r--  2.0 unx    17849 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/base_events.pyi
 -rw-r--r--  2.0 unx      719 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/base_futures.pyi
 -rw-r--r--  2.0 unx     2680 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/base_subprocess.pyi
 -rw-r--r--  2.0 unx      404 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/base_tasks.pyi
 -rw-r--r--  2.0 unx      568 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/constants.pyi
 -rw-r--r--  2.0 unx     1031 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/coroutines.pyi
--rw-r--r--  2.0 unx    21824 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/events.pyi
+-rw-r--r--  2.0 unx    22233 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/events.pyi
 -rw-r--r--  2.0 unx     1099 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/exceptions.pyi
 -rw-r--r--  2.0 unx      887 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/format_helpers.pyi
--rw-r--r--  2.0 unx     2325 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/futures.pyi
+-rw-r--r--  2.0 unx     2329 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/futures.pyi
 -rw-r--r--  2.0 unx     4288 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/locks.pyi
 -rw-r--r--  2.0 unx       39 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/log.pyi
 -rw-r--r--  2.0 unx      215 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/mixins.pyi
 -rw-r--r--  2.0 unx     2532 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/proactor_events.pyi
 -rw-r--r--  2.0 unx     1631 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/protocols.pyi
 -rw-r--r--  2.0 unx     1544 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/queues.pyi
 -rw-r--r--  2.0 unx     1141 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/runners.pyi
 -rw-r--r--  2.0 unx      223 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/selector_events.pyi
--rw-r--r--  2.0 unx     6286 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/sslproto.pyi
+-rw-r--r--  2.0 unx     6356 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/sslproto.pyi
 -rw-r--r--  2.0 unx      341 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/staggered.pyi
--rw-r--r--  2.0 unx     5659 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/streams.pyi
+-rw-r--r--  2.0 unx     5807 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/streams.pyi
 -rw-r--r--  2.0 unx     9237 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/subprocess.pyi
 -rw-r--r--  2.0 unx      794 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/taskgroups.pyi
--rw-r--r--  2.0 unx    18364 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/tasks.pyi
--rw-r--r--  2.0 unx      265 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/threads.pyi
+-rw-r--r--  2.0 unx    18566 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/tasks.pyi
+-rw-r--r--  2.0 unx      266 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/threads.pyi
 -rw-r--r--  2.0 unx      653 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/timeouts.pyi
 -rw-r--r--  2.0 unx     2040 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/transports.pyi
--rw-r--r--  2.0 unx     4703 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/trsock.pyi
--rw-r--r--  2.0 unx     8477 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/unix_events.pyi
--rw-r--r--  2.0 unx     4068 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/windows_events.pyi
+-rw-r--r--  2.0 unx     4644 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/trsock.pyi
+-rw-r--r--  2.0 unx     8856 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/unix_events.pyi
+-rw-r--r--  2.0 unx     4070 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/windows_events.pyi
 -rw-r--r--  2.0 unx     1941 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncio/windows_utils.pyi
 -rw-r--r--  2.0 unx     3670 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/asyncore.pyi
 -rw-r--r--  2.0 unx      392 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/atexit.pyi
--rw-r--r--  2.0 unx     2141 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/audioop.pyi
+-rw-r--r--  2.0 unx     2085 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/audioop.pyi
 -rw-r--r--  2.0 unx     2188 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/base64.pyi
--rw-r--r--  2.0 unx     4640 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/bdb.pyi
--rw-r--r--  2.0 unx     1517 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/binascii.pyi
+-rw-r--r--  2.0 unx     4641 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/bdb.pyi
+-rw-r--r--  2.0 unx     1526 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/binascii.pyi
 -rw-r--r--  2.0 unx     1279 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/binhex.pyi
 -rw-r--r--  2.0 unx       67 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/bisect.pyi
--rw-r--r--  2.0 unx    81222 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/builtins.pyi
--rw-r--r--  2.0 unx     4870 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/bz2.pyi
--rw-r--r--  2.0 unx     1484 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/cProfile.pyi
--rw-r--r--  2.0 unx     7323 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/calendar.pyi
--rw-r--r--  2.0 unx     3699 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/cgi.pyi
+-rw-r--r--  2.0 unx    81291 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/builtins.pyi
+-rw-r--r--  2.0 unx     4872 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/bz2.pyi
+-rw-r--r--  2.0 unx     1298 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/cProfile.pyi
+-rw-r--r--  2.0 unx     7327 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/calendar.pyi
+-rw-r--r--  2.0 unx     3700 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/cgi.pyi
 -rw-r--r--  2.0 unx     1394 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/cgitb.pyi
 -rw-r--r--  2.0 unx      614 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/chunk.pyi
--rw-r--r--  2.0 unx     1157 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/cmath.pyi
+-rw-r--r--  2.0 unx     1175 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/cmath.pyi
 -rw-r--r--  2.0 unx     1725 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/cmd.pyi
 -rw-r--r--  2.0 unx     1481 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/code.pyi
--rw-r--r--  2.0 unx    11816 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/codecs.pyi
+-rw-r--r--  2.0 unx    11812 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/codecs.pyi
 -rw-r--r--  2.0 unx      466 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/codeop.pyi
--rw-r--r--  2.0 unx    22788 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/collections/__init__.pyi
+-rw-r--r--  2.0 unx    23112 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/collections/__init__.pyi
 -rw-r--r--  2.0 unx       79 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/collections/abc.pyi
 -rw-r--r--  2.0 unx      648 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/colorsys.pyi
--rw-r--r--  2.0 unx     3440 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/compileall.pyi
+-rw-r--r--  2.0 unx     3441 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/compileall.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/concurrent/__init__.pyi
 -rw-r--r--  2.0 unx      818 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/__init__.pyi
--rw-r--r--  2.0 unx     4375 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/_base.pyi
+-rw-r--r--  2.0 unx     4593 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/_base.pyi
 -rw-r--r--  2.0 unx     7977 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/process.pyi
 -rw-r--r--  2.0 unx     2326 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/thread.pyi
 -rw-r--r--  2.0 unx    12657 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/configparser.pyi
--rw-r--r--  2.0 unx     8938 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/contextlib.pyi
--rw-r--r--  2.0 unx     2160 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/contextvars.pyi
+-rw-r--r--  2.0 unx     8930 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/contextlib.pyi
+-rw-r--r--  2.0 unx     2163 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/contextvars.pyi
 -rw-r--r--  2.0 unx      350 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/copy.pyi
 -rw-r--r--  2.0 unx      983 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/copyreg.pyi
 -rw-r--r--  2.0 unx      383 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/crypt.pyi
 -rw-r--r--  2.0 unx     4323 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/csv.pyi
 -rw-r--r--  2.0 unx     6646 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ctypes/__init__.pyi
 -rw-r--r--  2.0 unx      757 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ctypes/_endian.pyi
 -rw-r--r--  2.0 unx      129 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ctypes/util.pyi
 -rw-r--r--  2.0 unx     6341 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ctypes/wintypes.pyi
--rw-r--r--  2.0 unx      573 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/curses/__init__.pyi
--rw-r--r--  2.0 unx     1393 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/curses/ascii.pyi
--rw-r--r--  2.0 unx       84 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/curses/has_key.pyi
--rw-r--r--  2.0 unx      931 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/curses/panel.pyi
--rw-r--r--  2.0 unx      514 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/curses/textpad.pyi
--rw-r--r--  2.0 unx     9152 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/dataclasses.pyi
--rw-r--r--  2.0 unx    10561 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/datetime.pyi
+-rw-r--r--  2.0 unx      653 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/curses/__init__.pyi
+-rw-r--r--  2.0 unx     1127 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/curses/ascii.pyi
+-rw-r--r--  2.0 unx       40 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/curses/has_key.pyi
+-rw-r--r--  2.0 unx      816 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/curses/panel.pyi
+-rw-r--r--  2.0 unx      443 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/curses/textpad.pyi
+-rw-r--r--  2.0 unx     9326 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/dataclasses.pyi
+-rw-r--r--  2.0 unx    10818 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/datetime.pyi
 -rw-r--r--  2.0 unx     1787 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/dbm/__init__.pyi
 -rw-r--r--  2.0 unx     1287 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/dbm/dumb.pyi
--rw-r--r--  2.0 unx     1665 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/dbm/gnu.pyi
--rw-r--r--  2.0 unx     1451 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/dbm/ndbm.pyi
+-rw-r--r--  2.0 unx     1663 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/dbm/gnu.pyi
+-rw-r--r--  2.0 unx     1449 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/dbm/ndbm.pyi
 -rw-r--r--  2.0 unx      117 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/decimal.pyi
--rw-r--r--  2.0 unx     4504 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/difflib.pyi
+-rw-r--r--  2.0 unx     4557 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/difflib.pyi
 -rw-r--r--  2.0 unx     4646 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/dis.pyi
 -rw-r--r--  2.0 unx      351 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/__init__.pyi
 -rw-r--r--  2.0 unx      545 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/archive_util.pyi
 -rw-r--r--  2.0 unx       78 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/bcppcompiler.pyi
 -rw-r--r--  2.0 unx     6346 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/ccompiler.pyi
 -rw-r--r--  2.0 unx     2896 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/cmd.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/command/__init__.pyi
@@ -352,125 +353,125 @@
 -rw-r--r--  2.0 unx      387 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/command/install_headers.pyi
 -rw-r--r--  2.0 unx      598 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/command/install_lib.pyi
 -rw-r--r--  2.0 unx      426 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/command/install_scripts.pyi
 -rw-r--r--  2.0 unx      570 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/command/register.pyi
 -rw-r--r--  2.0 unx     1118 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/command/sdist.pyi
 -rw-r--r--  2.0 unx      462 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/command/upload.pyi
 -rw-r--r--  2.0 unx      497 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/config.pyi
--rw-r--r--  2.0 unx     1841 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/core.pyi
+-rw-r--r--  2.0 unx     1849 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/core.pyi
 -rw-r--r--  2.0 unx      534 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/cygwinccompiler.pyi
 -rw-r--r--  2.0 unx       19 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/debug.pyi
 -rw-r--r--  2.0 unx      224 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/dep_util.pyi
 -rw-r--r--  2.0 unx      510 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/dir_util.pyi
 -rw-r--r--  2.0 unx     5879 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/dist.pyi
 -rw-r--r--  2.0 unx      852 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/errors.pyi
 -rw-r--r--  2.0 unx     1236 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/extension.pyi
 -rw-r--r--  2.0 unx     1162 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/fancy_getopt.pyi
 -rw-r--r--  2.0 unx      429 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/file_util.pyi
 -rw-r--r--  2.0 unx     2175 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/filelist.pyi
 -rw-r--r--  2.0 unx      843 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/log.pyi
 -rw-r--r--  2.0 unx       78 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/msvccompiler.pyi
 -rw-r--r--  2.0 unx      187 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/spawn.pyi
--rw-r--r--  2.0 unx      791 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/sysconfig.pyi
+-rw-r--r--  2.0 unx     1113 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/sysconfig.pyi
 -rw-r--r--  2.0 unx      682 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/text_file.pyi
 -rw-r--r--  2.0 unx       79 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/unixccompiler.pyi
 -rw-r--r--  2.0 unx     1550 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/util.pyi
 -rw-r--r--  2.0 unx     1308 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/distutils/version.pyi
 -rw-r--r--  2.0 unx     7401 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/doctest.pyi
 -rw-r--r--  2.0 unx       79 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/dummy_threading.pyi
 -rw-r--r--  2.0 unx     1054 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/__init__.pyi
 -rw-r--r--  2.0 unx    11135 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/_header_value_parser.pyi
 -rw-r--r--  2.0 unx     1971 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/_policybase.pyi
 -rw-r--r--  2.0 unx      559 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/base64mime.pyi
--rw-r--r--  2.0 unx     1273 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/charset.pyi
+-rw-r--r--  2.0 unx     1274 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/charset.pyi
 -rw-r--r--  2.0 unx      480 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/contentmanager.pyi
 -rw-r--r--  2.0 unx      293 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/encoders.pyi
 -rw-r--r--  2.0 unx     1533 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/errors.pyi
 -rw-r--r--  2.0 unx      956 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/feedparser.pyi
 -rw-r--r--  2.0 unx     1175 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/generator.pyi
--rw-r--r--  2.0 unx     1264 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/header.pyi
+-rw-r--r--  2.0 unx     1265 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/header.pyi
 -rw-r--r--  2.0 unx     6129 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/headerregistry.pyi
 -rw-r--r--  2.0 unx      648 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/iterators.pyi
--rw-r--r--  2.0 unx     8170 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/message.pyi
+-rw-r--r--  2.0 unx     8423 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/message.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/mime/__init__.pyi
 -rw-r--r--  2.0 unx      498 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/mime/application.pyi
 -rw-r--r--  2.0 unx      482 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/mime/audio.pyi
 -rw-r--r--  2.0 unx      271 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/mime/base.pyi
 -rw-r--r--  2.0 unx      482 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/mime/image.pyi
 -rw-r--r--  2.0 unx      294 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/mime/message.pyi
 -rw-r--r--  2.0 unx      485 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/mime/multipart.pyi
 -rw-r--r--  2.0 unx      108 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/mime/nonmultipart.pyi
 -rw-r--r--  2.0 unx      293 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/mime/text.pyi
 -rw-r--r--  2.0 unx     1328 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/parser.pyi
 -rw-r--r--  2.0 unx     1390 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/policy.pyi
 -rw-r--r--  2.0 unx      835 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/quoprimime.pyi
--rw-r--r--  2.0 unx     2367 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/utils.pyi
+-rw-r--r--  2.0 unx     2578 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/email/utils.pyi
 -rw-r--r--  2.0 unx      309 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/encodings/__init__.pyi
--rw-r--r--  2.0 unx      904 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/encodings/utf_8.pyi
+-rw-r--r--  2.0 unx      896 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/encodings/utf_8.pyi
 -rw-r--r--  2.0 unx     1059 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/encodings/utf_8_sig.pyi
 -rw-r--r--  2.0 unx      264 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ensurepip/__init__.pyi
--rw-r--r--  2.0 unx    11271 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/enum.pyi
+-rw-r--r--  2.0 unx    11274 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/enum.pyi
 -rw-r--r--  2.0 unx     3957 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/errno.pyi
 -rw-r--r--  2.0 unx      644 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/faulthandler.pyi
--rw-r--r--  2.0 unx     3830 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/fcntl.pyi
+-rw-r--r--  2.0 unx     3796 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/fcntl.pyi
 -rw-r--r--  2.0 unx     1936 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/filecmp.pyi
 -rw-r--r--  2.0 unx     7161 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/fileinput.pyi
 -rw-r--r--  2.0 unx      339 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/fnmatch.pyi
 -rw-r--r--  2.0 unx     3711 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/formatter.pyi
--rw-r--r--  2.0 unx     5091 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/fractions.pyi
--rw-r--r--  2.0 unx     6491 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ftplib.pyi
--rw-r--r--  2.0 unx     7334 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/functools.pyi
--rw-r--r--  2.0 unx     1197 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/gc.pyi
+-rw-r--r--  2.0 unx     5092 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/fractions.pyi
+-rw-r--r--  2.0 unx     6535 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ftplib.pyi
+-rw-r--r--  2.0 unx     8281 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/functools.pyi
+-rw-r--r--  2.0 unx     1200 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/gc.pyi
 -rw-r--r--  2.0 unx     1924 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/genericpath.pyi
 -rw-r--r--  2.0 unx      439 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/getopt.pyi
 -rw-r--r--  2.0 unx      227 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/getpass.pyi
 -rw-r--r--  2.0 unx     6121 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/gettext.pyi
 -rw-r--r--  2.0 unx     1421 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/glob.pyi
 -rw-r--r--  2.0 unx      914 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/graphlib.pyi
--rw-r--r--  2.0 unx      701 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/grp.pyi
--rw-r--r--  2.0 unx     4858 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/gzip.pyi
--rw-r--r--  2.0 unx     5006 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/hashlib.pyi
--rw-r--r--  2.0 unx      759 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/heapq.pyi
--rw-r--r--  2.0 unx     1345 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/hmac.pyi
+-rw-r--r--  2.0 unx      702 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/grp.pyi
+-rw-r--r--  2.0 unx     4861 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/gzip.pyi
+-rw-r--r--  2.0 unx     5036 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/hashlib.pyi
+-rw-r--r--  2.0 unx      760 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/heapq.pyi
+-rw-r--r--  2.0 unx     1343 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/hmac.pyi
 -rw-r--r--  2.0 unx      157 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/html/__init__.pyi
 -rw-r--r--  2.0 unx      182 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/html/entities.pyi
 -rw-r--r--  2.0 unx     1714 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/html/parser.pyi
 -rw-r--r--  2.0 unx     2674 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/http/__init__.pyi
 -rw-r--r--  2.0 unx     8396 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/http/client.pyi
 -rw-r--r--  2.0 unx     6688 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/http/cookiejar.pyi
 -rw-r--r--  2.0 unx     2312 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/http/cookies.pyi
 -rw-r--r--  2.0 unx     3471 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/http/server.pyi
 -rw-r--r--  2.0 unx     7857 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/imaplib.pyi
--rw-r--r--  2.0 unx      505 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/imghdr.pyi
--rw-r--r--  2.0 unx     2386 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/imp.pyi
+-rw-r--r--  2.0 unx      507 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/imghdr.pyi
+-rw-r--r--  2.0 unx     2383 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/imp.pyi
 -rw-r--r--  2.0 unx      849 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/__init__.pyi
 -rw-r--r--  2.0 unx      609 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/_abc.pyi
--rw-r--r--  2.0 unx     6888 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/abc.pyi
+-rw-r--r--  2.0 unx     6887 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/abc.pyi
 -rw-r--r--  2.0 unx     7004 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/machinery.pyi
--rw-r--r--  2.0 unx     9020 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/metadata/__init__.pyi
--rw-r--r--  2.0 unx     1471 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/metadata/_meta.pyi
+-rw-r--r--  2.0 unx     9284 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/metadata/__init__.pyi
+-rw-r--r--  2.0 unx     2010 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/metadata/_meta.pyi
 -rw-r--r--  2.0 unx     2584 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/readers.pyi
 -rw-r--r--  2.0 unx     1678 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/resources/__init__.pyi
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/resources/abc.pyi
 -rw-r--r--  2.0 unx      398 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/resources/readers.pyi
--rw-r--r--  2.0 unx     2149 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/resources/simple.pyi
+-rw-r--r--  2.0 unx     2200 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/resources/simple.pyi
 -rw-r--r--  2.0 unx      354 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/simple.pyi
 -rw-r--r--  2.0 unx     1826 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/importlib/util.pyi
--rw-r--r--  2.0 unx    20239 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/inspect.pyi
--rw-r--r--  2.0 unx     8156 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/io.pyi
+-rw-r--r--  2.0 unx    20241 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/inspect.pyi
+-rw-r--r--  2.0 unx     9705 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/io.pyi
 -rw-r--r--  2.0 unx     7328 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ipaddress.pyi
--rw-r--r--  2.0 unx    11637 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/itertools.pyi
+-rw-r--r--  2.0 unx    11055 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/itertools.pyi
 -rw-r--r--  2.0 unx     2061 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/json/__init__.pyi
 -rw-r--r--  2.0 unx     1117 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/json/decoder.pyi
--rw-r--r--  2.0 unx     1073 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/json/encoder.pyi
+-rw-r--r--  2.0 unx     1195 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/json/encoder.pyi
 -rw-r--r--  2.0 unx       24 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/json/tool.pyi
 -rw-r--r--  2.0 unx      565 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/keyword.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/__init__.pyi
 -rw-r--r--  2.0 unx      860 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/btm_matcher.pyi
--rw-r--r--  2.0 unx     1693 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixer_base.pyi
+-rw-r--r--  2.0 unx     1692 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixer_base.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/__init__.pyi
 -rw-r--r--  2.0 unx      215 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_apply.pyi
 -rw-r--r--  2.0 unx      245 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_asserts.pyi
 -rw-r--r--  2.0 unx      240 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_basestring.pyi
 -rw-r--r--  2.0 unx      224 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_buffer.pyi
 -rw-r--r--  2.0 unx      424 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_dict.pyi
 -rw-r--r--  2.0 unx      415 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_except.pyi
@@ -530,433 +531,437 @@
 -rw-r--r--  2.0 unx      958 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/pgen2/token.pyi
 -rw-r--r--  2.0 unx     1972 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/pgen2/tokenize.pyi
 -rw-r--r--  2.0 unx     2253 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/pygram.pyi
 -rw-r--r--  2.0 unx     4118 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/pytree.pyi
 -rw-r--r--  2.0 unx     3946 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lib2to3/refactor.pyi
 -rw-r--r--  2.0 unx      958 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/linecache.pyi
 -rw-r--r--  2.0 unx     4341 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/locale.pyi
--rw-r--r--  2.0 unx    19919 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/logging/__init__.pyi
+-rw-r--r--  2.0 unx    19986 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/logging/__init__.pyi
 -rw-r--r--  2.0 unx     5742 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/logging/config.pyi
--rw-r--r--  2.0 unx     9606 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/logging/handlers.pyi
--rw-r--r--  2.0 unx     5342 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lzma.pyi
+-rw-r--r--  2.0 unx     9607 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/logging/handlers.pyi
+-rw-r--r--  2.0 unx     5344 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/lzma.pyi
 -rw-r--r--  2.0 unx    10459 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/mailbox.pyi
 -rw-r--r--  2.0 unx      388 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/mailcap.pyi
--rw-r--r--  2.0 unx      841 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/marshal.pyi
--rw-r--r--  2.0 unx     4808 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/math.pyi
+-rw-r--r--  2.0 unx      839 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/marshal.pyi
+-rw-r--r--  2.0 unx     4838 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/math.pyi
 -rw-r--r--  2.0 unx     1672 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/mimetypes.pyi
--rw-r--r--  2.0 unx     3999 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/mmap.pyi
+-rw-r--r--  2.0 unx     4003 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/mmap.pyi
 -rw-r--r--  2.0 unx     3294 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/modulefinder.pyi
--rw-r--r--  2.0 unx     5852 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/msilib/__init__.pyi
+-rw-r--r--  2.0 unx     5853 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/msilib/__init__.pyi
 -rw-r--r--  2.0 unx     2141 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/msilib/schema.pyi
 -rw-r--r--  2.0 unx      362 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/msilib/sequence.pyi
 -rw-r--r--  2.0 unx      170 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/msilib/text.pyi
--rw-r--r--  2.0 unx     1165 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/msvcrt.pyi
+-rw-r--r--  2.0 unx     1166 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/msvcrt.pyi
 -rw-r--r--  2.0 unx     3132 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/__init__.pyi
 -rw-r--r--  2.0 unx     2969 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/connection.pyi
--rw-r--r--  2.0 unx     7786 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/context.pyi
+-rw-r--r--  2.0 unx     7821 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/context.pyi
 -rw-r--r--  2.0 unx     1935 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/dummy/__init__.pyi
 -rw-r--r--  2.0 unx     1282 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/dummy/connection.pyi
 -rw-r--r--  2.0 unx     1058 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/forkserver.pyi
 -rw-r--r--  2.0 unx     1046 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/heap.pyi
--rw-r--r--  2.0 unx     8886 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/managers.pyi
+-rw-r--r--  2.0 unx     8899 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/managers.pyi
 -rw-r--r--  2.0 unx     3888 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/pool.pyi
 -rw-r--r--  2.0 unx      724 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/popen_fork.pyi
 -rw-r--r--  2.0 unx      353 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/popen_forkserver.pyi
 -rw-r--r--  2.0 unx      524 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/popen_spawn_posix.pyi
 -rw-r--r--  2.0 unx      738 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/popen_spawn_win32.pyi
 -rw-r--r--  2.0 unx     1177 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/process.pyi
--rw-r--r--  2.0 unx     1486 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/queues.pyi
--rw-r--r--  2.0 unx     3134 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/reduction.pyi
+-rw-r--r--  2.0 unx     1487 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/queues.pyi
+-rw-r--r--  2.0 unx     3135 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/reduction.pyi
 -rw-r--r--  2.0 unx      420 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/resource_sharer.pyi
--rw-r--r--  2.0 unx      635 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/resource_tracker.pyi
+-rw-r--r--  2.0 unx      609 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/resource_tracker.pyi
 -rw-r--r--  2.0 unx     1389 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/shared_memory.pyi
--rw-r--r--  2.0 unx     4023 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/sharedctypes.pyi
+-rw-r--r--  2.0 unx     4200 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/sharedctypes.pyi
 -rw-r--r--  2.0 unx      861 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/spawn.pyi
--rw-r--r--  2.0 unx     2128 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/synchronize.pyi
--rw-r--r--  2.0 unx     2227 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/util.pyi
+-rw-r--r--  2.0 unx     2122 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/synchronize.pyi
+-rw-r--r--  2.0 unx     2810 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/util.pyi
 -rw-r--r--  2.0 unx      745 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/netrc.pyi
 -rw-r--r--  2.0 unx      293 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/nis.pyi
 -rw-r--r--  2.0 unx     4490 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/nntplib.pyi
 -rw-r--r--  2.0 unx     3273 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/nt.pyi
--rw-r--r--  2.0 unx     2870 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ntpath.pyi
+-rw-r--r--  2.0 unx     2873 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ntpath.pyi
 -rw-r--r--  2.0 unx       76 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/nturl2path.pyi
--rw-r--r--  2.0 unx     5481 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/numbers.pyi
--rw-r--r--  2.0 unx     1273 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/opcode.pyi
+-rw-r--r--  2.0 unx     7370 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/numbers.pyi
+-rw-r--r--  2.0 unx     1272 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/opcode.pyi
 -rw-r--r--  2.0 unx     1644 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/operator.pyi
--rw-r--r--  2.0 unx    10286 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/optparse.pyi
--rw-r--r--  2.0 unx    39824 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/os/__init__.pyi
+-rw-r--r--  2.0 unx    10527 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/optparse.pyi
+-rw-r--r--  2.0 unx    40258 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/os/__init__.pyi
 -rw-r--r--  2.0 unx      186 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/os/path.pyi
 -rw-r--r--  2.0 unx     3589 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ossaudiodev.pyi
 -rw-r--r--  2.0 unx     1017 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/parser.pyi
--rw-r--r--  2.0 unx     9020 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pathlib.pyi
+-rw-r--r--  2.0 unx     9022 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pathlib.pyi
 -rw-r--r--  2.0 unx     7549 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pdb.pyi
--rw-r--r--  2.0 unx     5719 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pickle.pyi
+-rw-r--r--  2.0 unx     5727 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pickle.pyi
 -rw-r--r--  2.0 unx     3813 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pickletools.pyi
 -rw-r--r--  2.0 unx      502 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pipes.pyi
 -rw-r--r--  2.0 unx     1914 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pkgutil.pyi
 -rw-r--r--  2.0 unx     1660 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/platform.pyi
 -rw-r--r--  2.0 unx     3724 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/plistlib.pyi
 -rw-r--r--  2.0 unx     2487 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/poplib.pyi
--rw-r--r--  2.0 unx    12035 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/posix.pyi
--rw-r--r--  2.0 unx     4640 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/posixpath.pyi
+-rw-r--r--  2.0 unx    12107 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/posix.pyi
+-rw-r--r--  2.0 unx     4643 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/posixpath.pyi
 -rw-r--r--  2.0 unx     2984 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pprint.pyi
--rw-r--r--  2.0 unx     1400 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/profile.pyi
--rw-r--r--  2.0 unx     2794 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pstats.pyi
+-rw-r--r--  2.0 unx     1401 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/profile.pyi
+-rw-r--r--  2.0 unx     2804 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pstats.pyi
 -rw-r--r--  2.0 unx      697 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pty.pyi
--rw-r--r--  2.0 unx      902 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pwd.pyi
+-rw-r--r--  2.0 unx      905 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pwd.pyi
 -rw-r--r--  2.0 unx      897 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/py_compile.pyi
 -rw-r--r--  2.0 unx     2284 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pyclbr.pyi
 -rw-r--r--  2.0 unx    10881 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pydoc.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pydoc_data/__init__.pyi
 -rw-r--r--  2.0 unx       23 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pydoc_data/topics.pyi
--rw-r--r--  2.0 unx     3396 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pyexpat/__init__.pyi
+-rw-r--r--  2.0 unx     3549 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pyexpat/__init__.pyi
 -rw-r--r--  2.0 unx     1477 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pyexpat/errors.pyi
 -rw-r--r--  2.0 unx      205 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/pyexpat/model.pyi
--rw-r--r--  2.0 unx     2042 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/queue.pyi
+-rw-r--r--  2.0 unx     2290 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/queue.pyi
 -rw-r--r--  2.0 unx      635 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/quopri.pyi
 -rw-r--r--  2.0 unx     5012 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/random.pyi
--rw-r--r--  2.0 unx    11305 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/re.pyi
--rw-r--r--  2.0 unx     1862 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/readline.pyi
+-rw-r--r--  2.0 unx    11314 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/re.pyi
+-rw-r--r--  2.0 unx     1875 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/readline.pyi
 -rw-r--r--  2.0 unx     1986 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/reprlib.pyi
--rw-r--r--  2.0 unx     2807 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/resource.pyi
+-rw-r--r--  2.0 unx     2804 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/resource.pyi
 -rw-r--r--  2.0 unx      322 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/rlcompleter.pyi
 -rw-r--r--  2.0 unx      811 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/runpy.pyi
 -rw-r--r--  2.0 unx     1333 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sched.pyi
 -rw-r--r--  2.0 unx      624 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/secrets.pyi
--rw-r--r--  2.0 unx     4538 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/select.pyi
+-rw-r--r--  2.0 unx     4544 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/select.pyi
 -rw-r--r--  2.0 unx     2782 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/selectors.pyi
 -rw-r--r--  2.0 unx     1892 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/shelve.pyi
--rw-r--r--  2.0 unx     1371 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/shlex.pyi
--rw-r--r--  2.0 unx     6750 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/shutil.pyi
--rw-r--r--  2.0 unx     5642 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/signal.pyi
+-rw-r--r--  2.0 unx     2206 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/shlex.pyi
+-rw-r--r--  2.0 unx     6892 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/shutil.pyi
+-rw-r--r--  2.0 unx     5404 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/signal.pyi
 -rw-r--r--  2.0 unx     1358 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/site.pyi
 -rw-r--r--  2.0 unx     2998 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/smtpd.pyi
--rw-r--r--  2.0 unx     6722 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/smtplib.pyi
+-rw-r--r--  2.0 unx     6724 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/smtplib.pyi
 -rw-r--r--  2.0 unx      353 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sndhdr.pyi
--rw-r--r--  2.0 unx    29303 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/socket.pyi
+-rw-r--r--  2.0 unx    29277 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/socket.pyi
 -rw-r--r--  2.0 unx     6732 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/socketserver.pyi
--rw-r--r--  2.0 unx     1151 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/spwd.pyi
+-rw-r--r--  2.0 unx     1153 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/spwd.pyi
 -rw-r--r--  2.0 unx       29 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sqlite3/__init__.pyi
--rw-r--r--  2.0 unx    17192 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sqlite3/dbapi2.pyi
+-rw-r--r--  2.0 unx    19822 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sqlite3/dbapi2.pyi
 -rw-r--r--  2.0 unx      332 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sre_compile.pyi
 -rw-r--r--  2.0 unx     3986 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sre_constants.pyi
 -rw-r--r--  2.0 unx     3790 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sre_parse.pyi
--rw-r--r--  2.0 unx    18909 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ssl.pyi
+-rw-r--r--  2.0 unx    19244 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/ssl.pyi
 -rw-r--r--  2.0 unx       20 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/stat.pyi
--rw-r--r--  2.0 unx     4808 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/statistics.pyi
--rw-r--r--  2.0 unx     3097 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/string.pyi
+-rw-r--r--  2.0 unx     4803 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/statistics.pyi
+-rw-r--r--  2.0 unx     3108 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/string.pyi
 -rw-r--r--  2.0 unx      910 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/stringprep.pyi
 -rw-r--r--  2.0 unx     1271 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/struct.pyi
--rw-r--r--  2.0 unx    90836 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/subprocess.pyi
+-rw-r--r--  2.0 unx    90809 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/subprocess.pyi
 -rw-r--r--  2.0 unx     2937 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sunau.pyi
 -rw-r--r--  2.0 unx     1467 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/symbol.pyi
 -rw-r--r--  2.0 unx     2146 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/symtable.pyi
--rw-r--r--  2.0 unx    12333 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sys/__init__.pyi
--rw-r--r--  2.0 unx     1498 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sys/_monitoring.pyi
--rw-r--r--  2.0 unx     1370 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sysconfig.pyi
--rw-r--r--  2.0 unx     1344 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/syslog.pyi
+-rw-r--r--  2.0 unx    12402 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sys/__init__.pyi
+-rw-r--r--  2.0 unx     1492 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sys/_monitoring.pyi
+-rw-r--r--  2.0 unx     1569 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/sysconfig.pyi
+-rw-r--r--  2.0 unx     1347 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/syslog.pyi
 -rw-r--r--  2.0 unx      514 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tabnanny.pyi
--rw-r--r--  2.0 unx    14143 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tarfile.pyi
+-rw-r--r--  2.0 unx    14357 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tarfile.pyi
 -rw-r--r--  2.0 unx     2862 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/telnetlib.pyi
--rw-r--r--  2.0 unx    16449 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tempfile.pyi
--rw-r--r--  2.0 unx     5172 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/termios.pyi
+-rw-r--r--  2.0 unx    16453 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tempfile.pyi
+-rw-r--r--  2.0 unx     5168 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/termios.pyi
 -rw-r--r--  2.0 unx     3233 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/textwrap.pyi
 -rw-r--r--  2.0 unx       25 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/this.pyi
 -rw-r--r--  2.0 unx     5932 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/threading.pyi
--rw-r--r--  2.0 unx     3681 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/time.pyi
+-rw-r--r--  2.0 unx     3682 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/time.pyi
 -rw-r--r--  2.0 unx     1240 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/timeit.pyi
--rw-r--r--  2.0 unx   137019 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/__init__.pyi
+-rw-r--r--  2.0 unx   137438 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/__init__.pyi
 -rw-r--r--  2.0 unx      654 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/colorchooser.pyi
--rw-r--r--  2.0 unx      436 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/commondialog.pyi
+-rw-r--r--  2.0 unx      398 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/commondialog.pyi
 -rw-r--r--  2.0 unx     1875 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/constants.pyi
--rw-r--r--  2.0 unx      413 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/dialog.pyi
--rw-r--r--  2.0 unx      787 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/dnd.pyi
+-rw-r--r--  2.0 unx      401 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/dialog.pyi
+-rw-r--r--  2.0 unx      786 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/dnd.pyi
 -rw-r--r--  2.0 unx     5203 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/filedialog.pyi
--rw-r--r--  2.0 unx     4342 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/font.pyi
+-rw-r--r--  2.0 unx     4344 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/font.pyi
 -rw-r--r--  2.0 unx     1321 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/messagebox.pyi
--rw-r--r--  2.0 unx      347 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/scrolledtext.pyi
+-rw-r--r--  2.0 unx      302 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/scrolledtext.pyi
 -rw-r--r--  2.0 unx     1596 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/simpledialog.pyi
 -rw-r--r--  2.0 unx    14405 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/tix.pyi
--rw-r--r--  2.0 unx    45070 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/ttk.pyi
+-rw-r--r--  2.0 unx    45734 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tkinter/ttk.pyi
 -rw-r--r--  2.0 unx     2494 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/token.pyi
 -rw-r--r--  2.0 unx     4268 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tokenize.pyi
--rw-r--r--  2.0 unx      374 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tomllib.pyi
--rw-r--r--  2.0 unx     3447 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/trace.pyi
--rw-r--r--  2.0 unx     8954 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/traceback.pyi
+-rw-r--r--  2.0 unx      376 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tomllib.pyi
+-rw-r--r--  2.0 unx     3448 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/trace.pyi
+-rw-r--r--  2.0 unx     9056 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/traceback.pyi
 -rw-r--r--  2.0 unx     4575 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tracemalloc.pyi
 -rw-r--r--  2.0 unx      822 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/tty.pyi
 -rw-r--r--  2.0 unx    22749 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/turtle.pyi
--rw-r--r--  2.0 unx    20245 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/types.pyi
--rw-r--r--  2.0 unx    33638 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/typing.pyi
--rw-r--r--  2.0 unx    15035 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/typing_extensions.pyi
--rw-r--r--  2.0 unx     2434 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unicodedata.pyi
+-rw-r--r--  2.0 unx    20405 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/types.pyi
+-rw-r--r--  2.0 unx    33870 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/typing.pyi
+-rw-r--r--  2.0 unx    15184 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/typing_extensions.pyi
+-rw-r--r--  2.0 unx     2575 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unicodedata.pyi
 -rw-r--r--  2.0 unx     1813 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/__init__.pyi
 -rw-r--r--  2.0 unx      912 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/_log.pyi
--rw-r--r--  2.0 unx      737 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/async_case.pyi
--rw-r--r--  2.0 unx    14659 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/case.pyi
+-rw-r--r--  2.0 unx      738 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/async_case.pyi
+-rw-r--r--  2.0 unx    14662 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/case.pyi
 -rw-r--r--  2.0 unx     2181 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/loader.pyi
--rw-r--r--  2.0 unx     2429 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/main.pyi
--rw-r--r--  2.0 unx    14563 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/mock.pyi
--rw-r--r--  2.0 unx     2028 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/result.pyi
+-rw-r--r--  2.0 unx     2430 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/main.pyi
+-rw-r--r--  2.0 unx    14562 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/mock.pyi
+-rw-r--r--  2.0 unx     2029 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/result.pyi
 -rw-r--r--  2.0 unx     2506 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/runner.pyi
 -rw-r--r--  2.0 unx      488 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/signals.pyi
 -rw-r--r--  2.0 unx      983 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/suite.pyi
 -rw-r--r--  2.0 unx     1009 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/unittest/util.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/urllib/__init__.pyi
 -rw-r--r--  2.0 unx      816 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/urllib/error.pyi
 -rw-r--r--  2.0 unx     6532 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/urllib/parse.pyi
--rw-r--r--  2.0 unx    18000 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/urllib/request.pyi
+-rw-r--r--  2.0 unx    18009 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/urllib/request.pyi
 -rw-r--r--  2.0 unx     1635 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/urllib/response.pyi
 -rw-r--r--  2.0 unx      683 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/urllib/robotparser.pyi
 -rw-r--r--  2.0 unx      431 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/uu.pyi
 -rw-r--r--  2.0 unx     2677 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/uuid.pyi
 -rw-r--r--  2.0 unx     2665 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/venv/__init__.pyi
 -rw-r--r--  2.0 unx     3682 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/warnings.pyi
 -rw-r--r--  2.0 unx     3240 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/wave.pyi
--rw-r--r--  2.0 unx     6424 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/weakref.pyi
+-rw-r--r--  2.0 unx     6350 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/weakref.pyi
 -rw-r--r--  2.0 unx     2563 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/webbrowser.pyi
--rw-r--r--  2.0 unx     4439 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/winreg.pyi
+-rw-r--r--  2.0 unx     5494 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/winreg.pyi
 -rw-r--r--  2.0 unx      956 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/winsound.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/wsgiref/__init__.pyi
 -rw-r--r--  2.0 unx     3068 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/wsgiref/handlers.pyi
 -rw-r--r--  2.0 unx     1036 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/wsgiref/headers.pyi
 -rw-r--r--  2.0 unx     1398 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/wsgiref/simple_server.pyi
--rw-r--r--  2.0 unx     1258 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/wsgiref/types.pyi
+-rw-r--r--  2.0 unx     1260 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/wsgiref/types.pyi
 -rw-r--r--  2.0 unx      995 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/wsgiref/util.pyi
 -rw-r--r--  2.0 unx     1737 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/wsgiref/validate.pyi
 -rw-r--r--  2.0 unx     2368 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xdrlib.pyi
 -rw-r--r--  2.0 unx       35 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/__init__.pyi
 -rw-r--r--  2.0 unx      457 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/dom/NodeFilter.pyi
 -rw-r--r--  2.0 unx     1889 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/dom/__init__.pyi
 -rw-r--r--  2.0 unx      418 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/dom/domreg.pyi
 -rw-r--r--  2.0 unx     4847 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/dom/expatbuilder.pyi
 -rw-r--r--  2.0 unx      678 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/dom/minicompat.pyi
--rw-r--r--  2.0 unx    15038 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/dom/minidom.pyi
+-rw-r--r--  2.0 unx    15066 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/dom/minidom.pyi
 -rw-r--r--  2.0 unx     3453 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/dom/pulldom.pyi
--rw-r--r--  2.0 unx     4206 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/dom/xmlbuilder.pyi
+-rw-r--r--  2.0 unx     4199 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/dom/xmlbuilder.pyi
 -rw-r--r--  2.0 unx      983 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/etree/ElementInclude.pyi
 -rw-r--r--  2.0 unx     1636 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/etree/ElementPath.pyi
--rw-r--r--  2.0 unx    12341 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/etree/ElementTree.pyi
+-rw-r--r--  2.0 unx    12618 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/etree/ElementTree.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/etree/__init__.pyi
 -rw-r--r--  2.0 unx       36 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/etree/cElementTree.pyi
 -rw-r--r--  2.0 unx       39 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/parsers/__init__.pyi
 -rw-r--r--  2.0 unx       22 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/parsers/expat/__init__.pyi
 -rw-r--r--  2.0 unx       29 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/parsers/expat/errors.pyi
 -rw-r--r--  2.0 unx       28 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/parsers/expat/model.pyi
 -rw-r--r--  2.0 unx     1148 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/sax/__init__.pyi
 -rw-r--r--  2.0 unx      755 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/sax/_exceptions.pyi
 -rw-r--r--  2.0 unx     2102 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/sax/handler.pyi
 -rw-r--r--  2.0 unx     3187 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/sax/saxutils.pyi
 -rw-r--r--  2.0 unx     3829 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xml/sax/xmlreader.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xmlrpc/__init__.pyi
 -rw-r--r--  2.0 unx    11757 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xmlrpc/client.pyi
--rw-r--r--  2.0 unx     6073 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xmlrpc/server.pyi
+-rw-r--r--  2.0 unx     6065 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xmlrpc/server.pyi
 -rw-r--r--  2.0 unx      423 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/xxlimited.pyi
 -rw-r--r--  2.0 unx      553 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/zipapp.pyi
--rw-r--r--  2.0 unx    10208 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/zipfile/__init__.pyi
+-rw-r--r--  2.0 unx    10211 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/zipfile/__init__.pyi
 -rw-r--r--  2.0 unx     3640 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/zipfile/_path.pyi
 -rw-r--r--  2.0 unx     1349 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/zipimport.pyi
--rw-r--r--  2.0 unx     1776 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/zlib.pyi
--rw-r--r--  2.0 unx     1513 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/zoneinfo/__init__.pyi
+-rw-r--r--  2.0 unx     1777 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/zlib.pyi
+-rw-r--r--  2.0 unx     1517 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stdlib/zoneinfo/__init__.pyi
 -rw-r--r--  2.0 unx       56 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stubs/mypy-extensions/@tests/stubtest_allowlist.txt
 -rw-r--r--  2.0 unx       63 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stubs/mypy-extensions/METADATA.toml
 -rw-r--r--  2.0 unx     8892 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typeshed/stubs/mypy-extensions/mypy_extensions.pyi
 -rw-r--r--  2.0 unx    15736 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typestate.py
--rw-r--r--  2.0 unx     3724 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typetraverser.py
+-rw-r--r--  2.0 unx     3924 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typetraverser.py
 -rw-r--r--  2.0 unx     3297 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typevars.py
 -rw-r--r--  2.0 unx      901 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/typevartuples.py
--rw-r--r--  2.0 unx    30284 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/util.py
--rw-r--r--  2.0 unx      594 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/version.py
+-rw-r--r--  2.0 unx    30250 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/util.py
+-rw-r--r--  2.0 unx      595 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/version.py
 -rw-r--r--  2.0 unx    15882 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/visitor.py
 -rw-r--r--  2.0 unx     1409 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/xml/mypy-html.css
 -rw-r--r--  2.0 unx     3824 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/xml/mypy-html.xslt
 -rw-r--r--  2.0 unx     4686 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/xml/mypy-txt.xslt
 -rw-r--r--  2.0 unx     2173 b- defN 80-Jan-01 00:00 puya/_vendor/mypy/xml/mypy.xsd
 -rw-r--r--  2.0 unx      661 b- defN 80-Jan-01 00:00 puya/algo_constants.py
 -rw-r--r--  2.0 unx    10673 b- defN 80-Jan-01 00:00 puya/arc32.py
--rw-r--r--  2.0 unx     6325 b- defN 80-Jan-01 00:00 puya/arc4_util.py
+-rw-r--r--  2.0 unx     7435 b- defN 80-Jan-01 00:00 puya/arc4_util.py
 -rw-r--r--  2.0 unx      127 b- defN 80-Jan-01 00:00 puya/avm_type.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/awst/__init__.py
--rw-r--r--  2.0 unx     9831 b- defN 80-Jan-01 00:00 puya/awst/function_traverser.py
--rw-r--r--  2.0 unx    54659 b- defN 80-Jan-01 00:00 puya/awst/nodes.py
--rw-r--r--  2.0 unx    22234 b- defN 80-Jan-01 00:00 puya/awst/to_code_visitor.py
--rw-r--r--  2.0 unx     8928 b- defN 80-Jan-01 00:00 puya/awst/visitors.py
--rw-r--r--  2.0 unx    18374 b- defN 80-Jan-01 00:00 puya/awst/wtypes.py
+-rw-r--r--  2.0 unx     9829 b- defN 80-Jan-01 00:00 puya/awst/function_traverser.py
+-rw-r--r--  2.0 unx    55887 b- defN 80-Jan-01 00:00 puya/awst/nodes.py
+-rw-r--r--  2.0 unx    21981 b- defN 80-Jan-01 00:00 puya/awst/to_code_visitor.py
+-rw-r--r--  2.0 unx     8282 b- defN 80-Jan-01 00:00 puya/awst/visitors.py
+-rw-r--r--  2.0 unx    17861 b- defN 80-Jan-01 00:00 puya/awst/wtypes.py
 -rw-r--r--  2.0 unx     1211 b- defN 80-Jan-01 00:00 puya/awst_build/README.md
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/awst_build/__init__.py
--rw-r--r--  2.0 unx    13207 b- defN 80-Jan-01 00:00 puya/awst_build/arc4_utils.py
--rw-r--r--  2.0 unx    12168 b- defN 80-Jan-01 00:00 puya/awst_build/base_mypy_visitor.py
--rw-r--r--  2.0 unx     5444 b- defN 80-Jan-01 00:00 puya/awst_build/constants.py
--rw-r--r--  2.0 unx     9500 b- defN 80-Jan-01 00:00 puya/awst_build/context.py
--rw-r--r--  2.0 unx    22165 b- defN 80-Jan-01 00:00 puya/awst_build/contract.py
+-rw-r--r--  2.0 unx    13210 b- defN 80-Jan-01 00:00 puya/awst_build/arc4_utils.py
+-rw-r--r--  2.0 unx    12152 b- defN 80-Jan-01 00:00 puya/awst_build/base_mypy_visitor.py
+-rw-r--r--  2.0 unx     5442 b- defN 80-Jan-01 00:00 puya/awst_build/constants.py
+-rw-r--r--  2.0 unx     9138 b- defN 80-Jan-01 00:00 puya/awst_build/context.py
+-rw-r--r--  2.0 unx    22200 b- defN 80-Jan-01 00:00 puya/awst_build/contract.py
 -rw-r--r--  2.0 unx      667 b- defN 80-Jan-01 00:00 puya/awst_build/contract_data.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/awst_build/eb/__init__.py
 -rw-r--r--  2.0 unx     1099 b- defN 80-Jan-01 00:00 puya/awst_build/eb/_utils.py
 -rw-r--r--  2.0 unx     9182 b- defN 80-Jan-01 00:00 puya/awst_build/eb/app_account_state.py
--rw-r--r--  2.0 unx     8089 b- defN 80-Jan-01 00:00 puya/awst_build/eb/app_state.py
+-rw-r--r--  2.0 unx     8336 b- defN 80-Jan-01 00:00 puya/awst_build/eb/app_state.py
 -rw-r--r--  2.0 unx      429 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/__init__.py
--rw-r--r--  2.0 unx    10630 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/_utils.py
--rw-r--r--  2.0 unx    13048 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/abi_call.py
--rw-r--r--  2.0 unx    22133 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/arrays.py
--rw-r--r--  2.0 unx     8003 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/base.py
--rw-r--r--  2.0 unx     1955 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/bool.py
--rw-r--r--  2.0 unx     2745 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/dynamic_bytes.py
--rw-r--r--  2.0 unx     2459 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/emit.py
--rw-r--r--  2.0 unx     8437 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/numeric.py
+-rw-r--r--  2.0 unx    10375 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/_utils.py
+-rw-r--r--  2.0 unx    13733 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/abi_call.py
+-rw-r--r--  2.0 unx    21741 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/arrays.py
+-rw-r--r--  2.0 unx     7079 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/base.py
+-rw-r--r--  2.0 unx     1958 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/bool.py
+-rw-r--r--  2.0 unx     2856 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/dynamic_bytes.py
+-rw-r--r--  2.0 unx     2267 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/emit.py
+-rw-r--r--  2.0 unx     8276 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/numeric.py
 -rw-r--r--  2.0 unx     5591 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/string.py
--rw-r--r--  2.0 unx     4077 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/struct.py
--rw-r--r--  2.0 unx     6091 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/tuple.py
--rw-r--r--  2.0 unx     4446 b- defN 80-Jan-01 00:00 puya/awst_build/eb/array.py
--rw-r--r--  2.0 unx    14959 b- defN 80-Jan-01 00:00 puya/awst_build/eb/base.py
--rw-r--r--  2.0 unx     6518 b- defN 80-Jan-01 00:00 puya/awst_build/eb/biguint.py
+-rw-r--r--  2.0 unx     3832 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/struct.py
+-rw-r--r--  2.0 unx     4583 b- defN 80-Jan-01 00:00 puya/awst_build/eb/arc4/tuple.py
+-rw-r--r--  2.0 unx     4444 b- defN 80-Jan-01 00:00 puya/awst_build/eb/array.py
+-rw-r--r--  2.0 unx    15064 b- defN 80-Jan-01 00:00 puya/awst_build/eb/base.py
+-rw-r--r--  2.0 unx     6237 b- defN 80-Jan-01 00:00 puya/awst_build/eb/biguint.py
 -rw-r--r--  2.0 unx     2267 b- defN 80-Jan-01 00:00 puya/awst_build/eb/bool.py
--rw-r--r--  2.0 unx    12068 b- defN 80-Jan-01 00:00 puya/awst_build/eb/bytes.py
+-rw-r--r--  2.0 unx    12185 b- defN 80-Jan-01 00:00 puya/awst_build/eb/bytes.py
 -rw-r--r--  2.0 unx     1974 b- defN 80-Jan-01 00:00 puya/awst_build/eb/bytes_backed.py
 -rw-r--r--  2.0 unx     3239 b- defN 80-Jan-01 00:00 puya/awst_build/eb/contracts.py
 -rw-r--r--  2.0 unx     3442 b- defN 80-Jan-01 00:00 puya/awst_build/eb/ensure_budget.py
--rw-r--r--  2.0 unx    11829 b- defN 80-Jan-01 00:00 puya/awst_build/eb/intrinsics.py
--rw-r--r--  2.0 unx     3640 b- defN 80-Jan-01 00:00 puya/awst_build/eb/log.py
+-rw-r--r--  2.0 unx     9453 b- defN 80-Jan-01 00:00 puya/awst_build/eb/intrinsics.py
+-rw-r--r--  2.0 unx     3521 b- defN 80-Jan-01 00:00 puya/awst_build/eb/log.py
 -rw-r--r--  2.0 unx     1128 b- defN 80-Jan-01 00:00 puya/awst_build/eb/named_int_constants.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/awst_build/eb/reference_types/__init__.py
--rw-r--r--  2.0 unx     7489 b- defN 80-Jan-01 00:00 puya/awst_build/eb/reference_types/account.py
--rw-r--r--  2.0 unx     2482 b- defN 80-Jan-01 00:00 puya/awst_build/eb/reference_types/application.py
--rw-r--r--  2.0 unx     4426 b- defN 80-Jan-01 00:00 puya/awst_build/eb/reference_types/asset.py
+-rw-r--r--  2.0 unx     7556 b- defN 80-Jan-01 00:00 puya/awst_build/eb/reference_types/account.py
+-rw-r--r--  2.0 unx     2638 b- defN 80-Jan-01 00:00 puya/awst_build/eb/reference_types/application.py
+-rw-r--r--  2.0 unx     4575 b- defN 80-Jan-01 00:00 puya/awst_build/eb/reference_types/asset.py
 -rw-r--r--  2.0 unx     3237 b- defN 80-Jan-01 00:00 puya/awst_build/eb/reference_types/base.py
--rw-r--r--  2.0 unx     9403 b- defN 80-Jan-01 00:00 puya/awst_build/eb/string.py
--rw-r--r--  2.0 unx     2020 b- defN 80-Jan-01 00:00 puya/awst_build/eb/struct.py
+-rw-r--r--  2.0 unx     9618 b- defN 80-Jan-01 00:00 puya/awst_build/eb/string.py
+-rw-r--r--  2.0 unx     1586 b- defN 80-Jan-01 00:00 puya/awst_build/eb/struct.py
 -rw-r--r--  2.0 unx     4078 b- defN 80-Jan-01 00:00 puya/awst_build/eb/subroutine.py
 -rw-r--r--  2.0 unx     2963 b- defN 80-Jan-01 00:00 puya/awst_build/eb/template_variables.py
 -rw-r--r--  2.0 unx      934 b- defN 80-Jan-01 00:00 puya/awst_build/eb/transaction/__init__.py
--rw-r--r--  2.0 unx     1746 b- defN 80-Jan-01 00:00 puya/awst_build/eb/transaction/base.py
+-rw-r--r--  2.0 unx     1730 b- defN 80-Jan-01 00:00 puya/awst_build/eb/transaction/base.py
 -rw-r--r--  2.0 unx     1360 b- defN 80-Jan-01 00:00 puya/awst_build/eb/transaction/fields.py
 -rw-r--r--  2.0 unx     5282 b- defN 80-Jan-01 00:00 puya/awst_build/eb/transaction/group.py
 -rw-r--r--  2.0 unx     4833 b- defN 80-Jan-01 00:00 puya/awst_build/eb/transaction/inner.py
--rw-r--r--  2.0 unx     7768 b- defN 80-Jan-01 00:00 puya/awst_build/eb/transaction/inner_params.py
--rw-r--r--  2.0 unx     7634 b- defN 80-Jan-01 00:00 puya/awst_build/eb/tuple.py
--rw-r--r--  2.0 unx     6998 b- defN 80-Jan-01 00:00 puya/awst_build/eb/type_registry.py
--rw-r--r--  2.0 unx     5806 b- defN 80-Jan-01 00:00 puya/awst_build/eb/uint64.py
+-rw-r--r--  2.0 unx     7915 b- defN 80-Jan-01 00:00 puya/awst_build/eb/transaction/inner_params.py
+-rw-r--r--  2.0 unx     7696 b- defN 80-Jan-01 00:00 puya/awst_build/eb/tuple.py
+-rw-r--r--  2.0 unx     7019 b- defN 80-Jan-01 00:00 puya/awst_build/eb/type_registry.py
+-rw-r--r--  2.0 unx     5527 b- defN 80-Jan-01 00:00 puya/awst_build/eb/uint64.py
 -rw-r--r--  2.0 unx     4633 b- defN 80-Jan-01 00:00 puya/awst_build/eb/unsigned_builtins.py
 -rw-r--r--  2.0 unx     3103 b- defN 80-Jan-01 00:00 puya/awst_build/eb/value_proxy.py
 -rw-r--r--  2.0 unx      250 b- defN 80-Jan-01 00:00 puya/awst_build/eb/var_factory.py
 -rw-r--r--  2.0 unx      602 b- defN 80-Jan-01 00:00 puya/awst_build/eb/void.py
 -rw-r--r--  2.0 unx      447 b- defN 80-Jan-01 00:00 puya/awst_build/exceptions.py
--rw-r--r--  2.0 unx   296370 b- defN 80-Jan-01 00:00 puya/awst_build/intrinsic_data.py
+-rw-r--r--  2.0 unx   281089 b- defN 80-Jan-01 00:00 puya/awst_build/intrinsic_data.py
 -rw-r--r--  2.0 unx     3576 b- defN 80-Jan-01 00:00 puya/awst_build/intrinsic_factory.py
--rw-r--r--  2.0 unx     1585 b- defN 80-Jan-01 00:00 puya/awst_build/intrinsic_models.py
+-rw-r--r--  2.0 unx     1671 b- defN 80-Jan-01 00:00 puya/awst_build/intrinsic_models.py
 -rw-r--r--  2.0 unx     2821 b- defN 80-Jan-01 00:00 puya/awst_build/main.py
--rw-r--r--  2.0 unx    32183 b- defN 80-Jan-01 00:00 puya/awst_build/module.py
--rw-r--r--  2.0 unx    55861 b- defN 80-Jan-01 00:00 puya/awst_build/subroutine.py
--rw-r--r--  2.0 unx    11148 b- defN 80-Jan-01 00:00 puya/awst_build/utils.py
+-rw-r--r--  2.0 unx    32231 b- defN 80-Jan-01 00:00 puya/awst_build/module.py
+-rw-r--r--  2.0 unx    55795 b- defN 80-Jan-01 00:00 puya/awst_build/subroutine.py
+-rw-r--r--  2.0 unx    11343 b- defN 80-Jan-01 00:00 puya/awst_build/utils.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/awst_build/validation/__init__.py
--rw-r--r--  2.0 unx     5239 b- defN 80-Jan-01 00:00 puya/awst_build/validation/arc4_copy.py
+-rw-r--r--  2.0 unx     4893 b- defN 80-Jan-01 00:00 puya/awst_build/validation/arc4_copy.py
 -rw-r--r--  2.0 unx     1806 b- defN 80-Jan-01 00:00 puya/awst_build/validation/awst_traverser.py
 -rw-r--r--  2.0 unx     2032 b- defN 80-Jan-01 00:00 puya/awst_build/validation/base_invoker.py
--rw-r--r--  2.0 unx     7333 b- defN 80-Jan-01 00:00 puya/awst_build/validation/inner_transactions.py
--rw-r--r--  2.0 unx      590 b- defN 80-Jan-01 00:00 puya/awst_build/validation/main.py
+-rw-r--r--  2.0 unx    17439 b- defN 80-Jan-01 00:00 puya/awst_build/validation/inner_transactions.py
+-rw-r--r--  2.0 unx      689 b- defN 80-Jan-01 00:00 puya/awst_build/validation/main.py
 -rw-r--r--  2.0 unx     2083 b- defN 80-Jan-01 00:00 puya/awst_build/validation/scratch_slots.py
 -rw-r--r--  2.0 unx     6511 b- defN 80-Jan-01 00:00 puya/client_gen.py
--rw-r--r--  2.0 unx    12793 b- defN 80-Jan-01 00:00 puya/compile.py
+-rw-r--r--  2.0 unx    13918 b- defN 80-Jan-01 00:00 puya/compile.py
 -rw-r--r--  2.0 unx     1858 b- defN 80-Jan-01 00:00 puya/context.py
--rw-r--r--  2.0 unx     2285 b- defN 80-Jan-01 00:00 puya/errors.py
+-rw-r--r--  2.0 unx     2039 b- defN 80-Jan-01 00:00 puya/errors.py
 -rw-r--r--  2.0 unx      105 b- defN 80-Jan-01 00:00 puya/ir/__init__.py
--rw-r--r--  2.0 unx    26799 b- defN 80-Jan-01 00:00 puya/ir/arc4_router.py
--rw-r--r--  2.0 unx   183593 b- defN 80-Jan-01 00:00 puya/ir/avm_ops.py
+-rw-r--r--  2.0 unx    26535 b- defN 80-Jan-01 00:00 puya/ir/arc4_router.py
+-rw-r--r--  2.0 unx   183589 b- defN 80-Jan-01 00:00 puya/ir/avm_ops.py
 -rw-r--r--  2.0 unx     1352 b- defN 80-Jan-01 00:00 puya/ir/avm_ops_models.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/ir/builder/__init__.py
--rw-r--r--  2.0 unx     6706 b- defN 80-Jan-01 00:00 puya/ir/builder/_utils.py
--rw-r--r--  2.0 unx    57672 b- defN 80-Jan-01 00:00 puya/ir/builder/arc4.py
--rw-r--r--  2.0 unx     5212 b- defN 80-Jan-01 00:00 puya/ir/builder/assignment.py
--rw-r--r--  2.0 unx     6173 b- defN 80-Jan-01 00:00 puya/ir/builder/blocks.py
+-rw-r--r--  2.0 unx     6675 b- defN 80-Jan-01 00:00 puya/ir/builder/_utils.py
+-rw-r--r--  2.0 unx    57659 b- defN 80-Jan-01 00:00 puya/ir/builder/arc4.py
+-rw-r--r--  2.0 unx     6201 b- defN 80-Jan-01 00:00 puya/ir/builder/assignment.py
+-rw-r--r--  2.0 unx     6175 b- defN 80-Jan-01 00:00 puya/ir/builder/blocks.py
 -rw-r--r--  2.0 unx     3195 b- defN 80-Jan-01 00:00 puya/ir/builder/callsub.py
 -rw-r--r--  2.0 unx     8738 b- defN 80-Jan-01 00:00 puya/ir/builder/flow_control.py
--rw-r--r--  2.0 unx    23932 b- defN 80-Jan-01 00:00 puya/ir/builder/iteration.py
--rw-r--r--  2.0 unx    23427 b- defN 80-Jan-01 00:00 puya/ir/builder/itxn.py
--rw-r--r--  2.0 unx    42045 b- defN 80-Jan-01 00:00 puya/ir/builder/main.py
--rw-r--r--  2.0 unx     4985 b- defN 80-Jan-01 00:00 puya/ir/builder/state.py
+-rw-r--r--  2.0 unx    24002 b- defN 80-Jan-01 00:00 puya/ir/builder/iteration.py
+-rw-r--r--  2.0 unx    25112 b- defN 80-Jan-01 00:00 puya/ir/builder/itxn.py
+-rw-r--r--  2.0 unx    43992 b- defN 80-Jan-01 00:00 puya/ir/builder/main.py
+-rw-r--r--  2.0 unx     5148 b- defN 80-Jan-01 00:00 puya/ir/builder/state.py
 -rw-r--r--  2.0 unx     6658 b- defN 80-Jan-01 00:00 puya/ir/context.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/ir/destructure/__init__.py
--rw-r--r--  2.0 unx     6730 b- defN 80-Jan-01 00:00 puya/ir/destructure/coalesce_locals.py
+-rw-r--r--  2.0 unx     7028 b- defN 80-Jan-01 00:00 puya/ir/destructure/coalesce_locals.py
 -rw-r--r--  2.0 unx      899 b- defN 80-Jan-01 00:00 puya/ir/destructure/main.py
 -rw-r--r--  2.0 unx     2619 b- defN 80-Jan-01 00:00 puya/ir/destructure/optimize.py
--rw-r--r--  2.0 unx     4397 b- defN 80-Jan-01 00:00 puya/ir/destructure/parcopy.py
--rw-r--r--  2.0 unx     4333 b- defN 80-Jan-01 00:00 puya/ir/destructure/remove_phi.py
--rw-r--r--  2.0 unx    19194 b- defN 80-Jan-01 00:00 puya/ir/main.py
--rw-r--r--  2.0 unx    26813 b- defN 80-Jan-01 00:00 puya/ir/models.py
+-rw-r--r--  2.0 unx     4401 b- defN 80-Jan-01 00:00 puya/ir/destructure/parcopy.py
+-rw-r--r--  2.0 unx     4337 b- defN 80-Jan-01 00:00 puya/ir/destructure/remove_phi.py
+-rw-r--r--  2.0 unx    19492 b- defN 80-Jan-01 00:00 puya/ir/main.py
+-rw-r--r--  2.0 unx    29547 b- defN 80-Jan-01 00:00 puya/ir/models.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/ir/optimize/__init__.py
 -rw-r--r--  2.0 unx     1117 b- defN 80-Jan-01 00:00 puya/ir/optimize/_utils.py
 -rw-r--r--  2.0 unx     2822 b- defN 80-Jan-01 00:00 puya/ir/optimize/assignments.py
 -rw-r--r--  2.0 unx     5791 b- defN 80-Jan-01 00:00 puya/ir/optimize/collapse_blocks.py
 -rw-r--r--  2.0 unx     2074 b- defN 80-Jan-01 00:00 puya/ir/optimize/constant_propagation.py
--rw-r--r--  2.0 unx    11834 b- defN 80-Jan-01 00:00 puya/ir/optimize/control_op_simplification.py
--rw-r--r--  2.0 unx    10193 b- defN 80-Jan-01 00:00 puya/ir/optimize/dead_code_elimination.py
--rw-r--r--  2.0 unx    28317 b- defN 80-Jan-01 00:00 puya/ir/optimize/intrinsic_simplification.py
--rw-r--r--  2.0 unx     5279 b- defN 80-Jan-01 00:00 puya/ir/optimize/main.py
+-rw-r--r--  2.0 unx    11867 b- defN 80-Jan-01 00:00 puya/ir/optimize/control_op_simplification.py
+-rw-r--r--  2.0 unx    10226 b- defN 80-Jan-01 00:00 puya/ir/optimize/dead_code_elimination.py
+-rw-r--r--  2.0 unx     2372 b- defN 80-Jan-01 00:00 puya/ir/optimize/inner_txn.py
+-rw-r--r--  2.0 unx    28845 b- defN 80-Jan-01 00:00 puya/ir/optimize/intrinsic_simplification.py
+-rw-r--r--  2.0 unx     5597 b- defN 80-Jan-01 00:00 puya/ir/optimize/main.py
 -rw-r--r--  2.0 unx     5402 b- defN 80-Jan-01 00:00 puya/ir/optimize/repeated_code_elimination.py
--rw-r--r--  2.0 unx     9233 b- defN 80-Jan-01 00:00 puya/ir/ssa.py
--rw-r--r--  2.0 unx     6962 b- defN 80-Jan-01 00:00 puya/ir/to_text_visitor.py
--rw-r--r--  2.0 unx     2969 b- defN 80-Jan-01 00:00 puya/ir/types_.py
--rw-r--r--  2.0 unx     2139 b- defN 80-Jan-01 00:00 puya/ir/utils.py
+-rw-r--r--  2.0 unx     9253 b- defN 80-Jan-01 00:00 puya/ir/ssa.py
+-rw-r--r--  2.0 unx     7359 b- defN 80-Jan-01 00:00 puya/ir/to_text_visitor.py
+-rw-r--r--  2.0 unx     5999 b- defN 80-Jan-01 00:00 puya/ir/types_.py
+-rw-r--r--  2.0 unx     2534 b- defN 80-Jan-01 00:00 puya/ir/utils.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/ir/validation/__init__.py
--rw-r--r--  2.0 unx      422 b- defN 80-Jan-01 00:00 puya/ir/validation/main.py
--rw-r--r--  2.0 unx     1652 b- defN 80-Jan-01 00:00 puya/ir/validation/min_avm_version_validator.py
--rw-r--r--  2.0 unx     2111 b- defN 80-Jan-01 00:00 puya/ir/validation/op_run_mode_validator.py
--rw-r--r--  2.0 unx     7393 b- defN 80-Jan-01 00:00 puya/ir/visitor.py
+-rw-r--r--  2.0 unx     1426 b- defN 80-Jan-01 00:00 puya/ir/validation/_base.py
+-rw-r--r--  2.0 unx      867 b- defN 80-Jan-01 00:00 puya/ir/validation/itxn_result_field_validator.py
+-rw-r--r--  2.0 unx      630 b- defN 80-Jan-01 00:00 puya/ir/validation/main.py
+-rw-r--r--  2.0 unx      721 b- defN 80-Jan-01 00:00 puya/ir/validation/min_avm_version_validator.py
+-rw-r--r--  2.0 unx     1138 b- defN 80-Jan-01 00:00 puya/ir/validation/op_run_mode_validator.py
+-rw-r--r--  2.0 unx     8061 b- defN 80-Jan-01 00:00 puya/ir/visitor.py
 -rw-r--r--  2.0 unx      824 b- defN 80-Jan-01 00:00 puya/ir/visitor_mem_replacer.py
--rw-r--r--  2.0 unx     4565 b- defN 80-Jan-01 00:00 puya/ir/visitor_mutator.py
+-rw-r--r--  2.0 unx     5073 b- defN 80-Jan-01 00:00 puya/ir/visitor_mutator.py
 -rw-r--r--  2.0 unx     4360 b- defN 80-Jan-01 00:00 puya/ir/vla.py
 -rw-r--r--  2.0 unx     1196 b- defN 80-Jan-01 00:00 puya/lib_embedded/_algopy_.py
 -rw-r--r--  2.0 unx     7432 b- defN 80-Jan-01 00:00 puya/lib_embedded/algopy_lib_arc4.py
 -rw-r--r--  2.0 unx      388 b- defN 80-Jan-01 00:00 puya/lib_embedded/algopy_lib_bytes.py
--rw-r--r--  2.0 unx    11991 b- defN 80-Jan-01 00:00 puya/log.py
+-rw-r--r--  2.0 unx    12195 b- defN 80-Jan-01 00:00 puya/log.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/mir/__init__.py
--rw-r--r--  2.0 unx     8583 b- defN 80-Jan-01 00:00 puya/mir/annotaters.py
--rw-r--r--  2.0 unx    10708 b- defN 80-Jan-01 00:00 puya/mir/builder.py
+-rw-r--r--  2.0 unx     8551 b- defN 80-Jan-01 00:00 puya/mir/annotaters.py
+-rw-r--r--  2.0 unx    10947 b- defN 80-Jan-01 00:00 puya/mir/builder.py
 -rw-r--r--  2.0 unx     2001 b- defN 80-Jan-01 00:00 puya/mir/context.py
--rw-r--r--  2.0 unx     2426 b- defN 80-Jan-01 00:00 puya/mir/main.py
--rw-r--r--  2.0 unx    13745 b- defN 80-Jan-01 00:00 puya/mir/models.py
--rw-r--r--  2.0 unx     3445 b- defN 80-Jan-01 00:00 puya/mir/output.py
--rw-r--r--  2.0 unx    16390 b- defN 80-Jan-01 00:00 puya/mir/stack.py
+-rw-r--r--  2.0 unx     2448 b- defN 80-Jan-01 00:00 puya/mir/main.py
+-rw-r--r--  2.0 unx    14201 b- defN 80-Jan-01 00:00 puya/mir/models.py
+-rw-r--r--  2.0 unx     3447 b- defN 80-Jan-01 00:00 puya/mir/output.py
+-rw-r--r--  2.0 unx    16518 b- defN 80-Jan-01 00:00 puya/mir/stack.py
 -rw-r--r--  2.0 unx     1035 b- defN 80-Jan-01 00:00 puya/mir/stack_allocation/__init__.py
 -rw-r--r--  2.0 unx    12592 b- defN 80-Jan-01 00:00 puya/mir/stack_allocation/baileys.py
--rw-r--r--  2.0 unx     4872 b- defN 80-Jan-01 00:00 puya/mir/stack_allocation/frame_allocation.py
+-rw-r--r--  2.0 unx     5021 b- defN 80-Jan-01 00:00 puya/mir/stack_allocation/frame_allocation.py
 -rw-r--r--  2.0 unx     4365 b- defN 80-Jan-01 00:00 puya/mir/stack_allocation/koopmans.py
 -rw-r--r--  2.0 unx     8061 b- defN 80-Jan-01 00:00 puya/mir/stack_allocation/peephole.py
--rw-r--r--  2.0 unx     2515 b- defN 80-Jan-01 00:00 puya/mir/visitor.py
+-rw-r--r--  2.0 unx     2331 b- defN 80-Jan-01 00:00 puya/mir/visitor.py
 -rw-r--r--  2.0 unx     4891 b- defN 80-Jan-01 00:00 puya/mir/vla.py
 -rw-r--r--  2.0 unx     3320 b- defN 80-Jan-01 00:00 puya/models.py
 -rw-r--r--  2.0 unx     1267 b- defN 80-Jan-01 00:00 puya/options.py
--rw-r--r--  2.0 unx    15756 b- defN 80-Jan-01 00:00 puya/parse.py
+-rw-r--r--  2.0 unx    15722 b- defN 80-Jan-01 00:00 puya/parse.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/py.typed
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/teal/__init__.py
--rw-r--r--  2.0 unx     2432 b- defN 80-Jan-01 00:00 puya/teal/main.py
--rw-r--r--  2.0 unx     8352 b- defN 80-Jan-01 00:00 puya/teal/models.py
+-rw-r--r--  2.0 unx     2488 b- defN 80-Jan-01 00:00 puya/teal/main.py
+-rw-r--r--  2.0 unx     8386 b- defN 80-Jan-01 00:00 puya/teal/models.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 puya/teal/optimize/__init__.py
 -rw-r--r--  2.0 unx     1645 b- defN 80-Jan-01 00:00 puya/teal/optimize/_data.py
 -rw-r--r--  2.0 unx     2703 b- defN 80-Jan-01 00:00 puya/teal/optimize/constant_stack_shuffling.py
 -rw-r--r--  2.0 unx     1618 b- defN 80-Jan-01 00:00 puya/teal/optimize/main.py
 -rw-r--r--  2.0 unx     8381 b- defN 80-Jan-01 00:00 puya/teal/optimize/peephole.py
 -rw-r--r--  2.0 unx     1557 b- defN 80-Jan-01 00:00 puya/teal/optimize/repeated_rotations.py
 -rw-r--r--  2.0 unx     4276 b- defN 80-Jan-01 00:00 puya/teal/optimize/repeated_rotations_search.py
--rw-r--r--  2.0 unx     1547 b- defN 80-Jan-01 00:00 puya/teal/output.py
--rw-r--r--  2.0 unx     7433 b- defN 80-Jan-01 00:00 puya/utils.py
+-rw-r--r--  2.0 unx     1554 b- defN 80-Jan-01 00:00 puya/teal/output.py
+-rw-r--r--  2.0 unx     7535 b- defN 80-Jan-01 00:00 puya/utils.py
 -rw-r--r--  2.0 unx      904 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/__init__.pyi
 -rw-r--r--  2.0 unx     1806 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_constants.pyi
--rw-r--r--  2.0 unx     4045 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_contract.pyi
+-rw-r--r--  2.0 unx     4047 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_contract.pyi
 -rw-r--r--  2.0 unx      648 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_hints.pyi
 -rw-r--r--  2.0 unx      370 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_logic_sig.pyi
--rw-r--r--  2.0 unx    20805 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_primitives.pyi
--rw-r--r--  2.0 unx     9617 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_reference.pyi
--rw-r--r--  2.0 unx     4375 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_state.pyi
+-rw-r--r--  2.0 unx    20981 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_primitives.pyi
+-rw-r--r--  2.0 unx     9783 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_reference.pyi
+-rw-r--r--  2.0 unx     4332 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_state.pyi
 -rw-r--r--  2.0 unx      549 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_template_variables.pyi
--rw-r--r--  2.0 unx     5384 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_transaction.pyi
+-rw-r--r--  2.0 unx     5404 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_transaction.pyi
 -rw-r--r--  2.0 unx     1416 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_unsigned_builtins.pyi
--rw-r--r--  2.0 unx     1032 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_util.pyi
--rw-r--r--  2.0 unx    20317 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/arc4.pyi
+-rw-r--r--  2.0 unx     1040 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/_util.pyi
+-rw-r--r--  2.0 unx    20353 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/arc4.pyi
 -rw-r--r--  2.0 unx     1491 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/gtxn.pyi
--rw-r--r--  2.0 unx    21327 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/itxn.pyi
--rw-r--r--  2.0 unx   150074 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/op.pyi
--rw-r--r--  2.0 unx      657 b- defN 80-Jan-01 00:00 puyapy-1.0.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     5134 b- defN 80-Jan-01 00:00 puyapy-1.0.1.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 puyapy-1.0.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       83 b- defN 80-Jan-01 00:00 puyapy-1.0.1.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx    96678 b- defN 16-Jan-01 00:00 puyapy-1.0.1.dist-info/RECORD
-960 files, 8521909 bytes uncompressed, 1923736 bytes compressed:  77.4%
+-rw-r--r--  2.0 unx    21474 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/itxn.pyi
+-rw-r--r--  2.0 unx   150962 b- defN 80-Jan-01 00:00 puya/_typeshed/stdlib/algopy/op.pyi
+-rw-r--r--  2.0 unx    34523 b- defN 80-Jan-01 00:00 puyapy-2.0.0.dist-info/COPYING
+-rw-r--r--  2.0 unx      657 b- defN 80-Jan-01 00:00 puyapy-2.0.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     5101 b- defN 80-Jan-01 00:00 puyapy-2.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 puyapy-2.0.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       83 b- defN 80-Jan-01 00:00 puyapy-2.0.0.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx    97143 b- defN 16-Jan-01 00:00 puyapy-2.0.0.dist-info/RECORD
+965 files, 8611512 bytes uncompressed, 1951710 bytes compressed:  77.3%
```

## zipnote {}

```diff
@@ -624,14 +624,17 @@
 
 Filename: puya/_vendor/mypy/typeshed/stdlib/_json.pyi
 Comment: 
 
 Filename: puya/_vendor/mypy/typeshed/stdlib/_locale.pyi
 Comment: 
 
+Filename: puya/_vendor/mypy/typeshed/stdlib/_lsprof.pyi
+Comment: 
+
 Filename: puya/_vendor/mypy/typeshed/stdlib/_markupbase.pyi
 Comment: 
 
 Filename: puya/_vendor/mypy/typeshed/stdlib/_msi.pyi
 Comment: 
 
 Filename: puya/_vendor/mypy/typeshed/stdlib/_operator.pyi
@@ -2661,14 +2664,17 @@
 
 Filename: puya/ir/optimize/control_op_simplification.py
 Comment: 
 
 Filename: puya/ir/optimize/dead_code_elimination.py
 Comment: 
 
+Filename: puya/ir/optimize/inner_txn.py
+Comment: 
+
 Filename: puya/ir/optimize/intrinsic_simplification.py
 Comment: 
 
 Filename: puya/ir/optimize/main.py
 Comment: 
 
 Filename: puya/ir/optimize/repeated_code_elimination.py
@@ -2685,14 +2691,20 @@
 
 Filename: puya/ir/utils.py
 Comment: 
 
 Filename: puya/ir/validation/__init__.py
 Comment: 
 
+Filename: puya/ir/validation/_base.py
+Comment: 
+
+Filename: puya/ir/validation/itxn_result_field_validator.py
+Comment: 
+
 Filename: puya/ir/validation/main.py
 Comment: 
 
 Filename: puya/ir/validation/min_avm_version_validator.py
 Comment: 
 
 Filename: puya/ir/validation/op_run_mode_validator.py
@@ -2859,23 +2871,26 @@
 
 Filename: puya/_typeshed/stdlib/algopy/itxn.pyi
 Comment: 
 
 Filename: puya/_typeshed/stdlib/algopy/op.pyi
 Comment: 
 
-Filename: puyapy-1.0.1.dist-info/LICENSE
+Filename: puyapy-2.0.0.dist-info/COPYING
+Comment: 
+
+Filename: puyapy-2.0.0.dist-info/LICENSE
 Comment: 
 
-Filename: puyapy-1.0.1.dist-info/METADATA
+Filename: puyapy-2.0.0.dist-info/METADATA
 Comment: 
 
-Filename: puyapy-1.0.1.dist-info/WHEEL
+Filename: puyapy-2.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: puyapy-1.0.1.dist-info/entry_points.txt
+Filename: puyapy-2.0.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: puyapy-1.0.1.dist-info/RECORD
+Filename: puyapy-2.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## puya/_typeshed/stdlib/VERSIONS

```diff
@@ -32,14 +32,15 @@
 _decimal: 3.3-
 _dummy_thread: 3.0-3.8
 _dummy_threading: 3.0-3.8
 _heapq: 3.0-
 _imp: 3.0-
 _json: 3.0-
 _locale: 3.0-
+_lsprof: 3.0-
 _markupbase: 3.0-
 _msi: 3.0-
 _operator: 3.4-
 _osx_support: 3.0-
 _posixsubprocess: 3.2-
 _py_abc: 3.7-
 _pydecimal: 3.5-
```

## puya/_typeshed/stdlib/_collections_abc.pyi

```diff
@@ -65,30 +65,30 @@
     __all__ += ["Buffer"]
 
 _KT_co = TypeVar("_KT_co", covariant=True)  # Key type covariant containers.
 _VT_co = TypeVar("_VT_co", covariant=True)  # Value type covariant containers.
 
 @final
 class dict_keys(KeysView[_KT_co], Generic[_KT_co, _VT_co]):  # undocumented
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     if sys.version_info >= (3, 10):
         @property
         def mapping(self) -> MappingProxyType[_KT_co, _VT_co]: ...
 
 @final
 class dict_values(ValuesView[_VT_co], Generic[_KT_co, _VT_co]):  # undocumented
     if sys.version_info >= (3, 10):
         @property
         def mapping(self) -> MappingProxyType[_KT_co, _VT_co]: ...
 
 @final
 class dict_items(ItemsView[_KT_co, _VT_co]):  # undocumented
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     if sys.version_info >= (3, 10):
         @property
         def mapping(self) -> MappingProxyType[_KT_co, _VT_co]: ...
 
 if sys.version_info >= (3, 12):
     @runtime_checkable
     class Buffer(Protocol):
         @abstractmethod
-        def __buffer__(self, __flags: int) -> memoryview: ...
+        def __buffer__(self, flags: int, /) -> memoryview: ...
```

## puya/_typeshed/stdlib/_typeshed/__init__.pyi

```diff
@@ -63,102 +63,102 @@
 # _SentinelType = NewType("_SentinelType", object)
 # sentinel: _SentinelType
 # def foo(x: int | None | _SentinelType = ...) -> None: ...
 sentinel: Any
 
 # stable
 class IdentityFunction(Protocol):
-    def __call__(self, __x: _T) -> _T: ...
+    def __call__(self, x: _T, /) -> _T: ...
 
 # stable
 class SupportsNext(Protocol[_T_co]):
     def __next__(self) -> _T_co: ...
 
 # stable
 class SupportsAnext(Protocol[_T_co]):
     def __anext__(self) -> Awaitable[_T_co]: ...
 
 # Comparison protocols
 
 class SupportsDunderLT(Protocol[_T_contra]):
-    def __lt__(self, __other: _T_contra) -> bool: ...
+    def __lt__(self, other: _T_contra, /) -> bool: ...
 
 class SupportsDunderGT(Protocol[_T_contra]):
-    def __gt__(self, __other: _T_contra) -> bool: ...
+    def __gt__(self, other: _T_contra, /) -> bool: ...
 
 class SupportsDunderLE(Protocol[_T_contra]):
-    def __le__(self, __other: _T_contra) -> bool: ...
+    def __le__(self, other: _T_contra, /) -> bool: ...
 
 class SupportsDunderGE(Protocol[_T_contra]):
-    def __ge__(self, __other: _T_contra) -> bool: ...
+    def __ge__(self, other: _T_contra, /) -> bool: ...
 
 class SupportsAllComparisons(
     SupportsDunderLT[Any], SupportsDunderGT[Any], SupportsDunderLE[Any], SupportsDunderGE[Any], Protocol
 ): ...
 
 SupportsRichComparison: TypeAlias = SupportsDunderLT[Any] | SupportsDunderGT[Any]
 SupportsRichComparisonT = TypeVar("SupportsRichComparisonT", bound=SupportsRichComparison)  # noqa: Y001
 
 # Dunder protocols
 
 class SupportsAdd(Protocol[_T_contra, _T_co]):
-    def __add__(self, __x: _T_contra) -> _T_co: ...
+    def __add__(self, x: _T_contra, /) -> _T_co: ...
 
 class SupportsRAdd(Protocol[_T_contra, _T_co]):
-    def __radd__(self, __x: _T_contra) -> _T_co: ...
+    def __radd__(self, x: _T_contra, /) -> _T_co: ...
 
 class SupportsSub(Protocol[_T_contra, _T_co]):
-    def __sub__(self, __x: _T_contra) -> _T_co: ...
+    def __sub__(self, x: _T_contra, /) -> _T_co: ...
 
 class SupportsRSub(Protocol[_T_contra, _T_co]):
-    def __rsub__(self, __x: _T_contra) -> _T_co: ...
+    def __rsub__(self, x: _T_contra, /) -> _T_co: ...
 
 class SupportsDivMod(Protocol[_T_contra, _T_co]):
-    def __divmod__(self, __other: _T_contra) -> _T_co: ...
+    def __divmod__(self, other: _T_contra, /) -> _T_co: ...
 
 class SupportsRDivMod(Protocol[_T_contra, _T_co]):
-    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...
+    def __rdivmod__(self, other: _T_contra, /) -> _T_co: ...
 
 # This protocol is generic over the iterator type, while Iterable is
 # generic over the type that is iterated over.
 class SupportsIter(Protocol[_T_co]):
     def __iter__(self) -> _T_co: ...
 
 # This protocol is generic over the iterator type, while AsyncIterable is
 # generic over the type that is iterated over.
 class SupportsAiter(Protocol[_T_co]):
     def __aiter__(self) -> _T_co: ...
 
 class SupportsLenAndGetItem(Protocol[_T_co]):
     def __len__(self) -> int: ...
-    def __getitem__(self, __k: int) -> _T_co: ...
+    def __getitem__(self, k: int, /) -> _T_co: ...
 
 class SupportsTrunc(Protocol):
     def __trunc__(self) -> int: ...
 
 # Mapping-like protocols
 
 # stable
 class SupportsItems(Protocol[_KT_co, _VT_co]):
     def items(self) -> AbstractSet[tuple[_KT_co, _VT_co]]: ...
 
 # stable
 class SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):
     def keys(self) -> Iterable[_KT]: ...
-    def __getitem__(self, __key: _KT) -> _VT_co: ...
+    def __getitem__(self, key: _KT, /) -> _VT_co: ...
 
 # stable
 class SupportsGetItem(Protocol[_KT_contra, _VT_co]):
-    def __contains__(self, __x: Any) -> bool: ...
-    def __getitem__(self, __key: _KT_contra) -> _VT_co: ...
+    def __contains__(self, x: Any, /) -> bool: ...
+    def __getitem__(self, key: _KT_contra, /) -> _VT_co: ...
 
 # stable
 class SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):
-    def __setitem__(self, __key: _KT_contra, __value: _VT) -> None: ...
-    def __delitem__(self, __key: _KT_contra) -> None: ...
+    def __setitem__(self, key: _KT_contra, value: _VT, /) -> None: ...
+    def __delitem__(self, key: _KT_contra, /) -> None: ...
 
 StrPath: TypeAlias = str | PathLike[str]  # stable
 BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable
 GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]
 StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  # stable
 
 OpenTextModeUpdating: TypeAlias = Literal[
@@ -234,27 +234,27 @@
 
 FileDescriptor: TypeAlias = int  # stable
 FileDescriptorLike: TypeAlias = int | HasFileno  # stable
 FileDescriptorOrPath: TypeAlias = int | StrOrBytesPath
 
 # stable
 class SupportsRead(Protocol[_T_co]):
-    def read(self, __length: int = ...) -> _T_co: ...
+    def read(self, length: int = ..., /) -> _T_co: ...
 
 # stable
 class SupportsReadline(Protocol[_T_co]):
-    def readline(self, __length: int = ...) -> _T_co: ...
+    def readline(self, length: int = ..., /) -> _T_co: ...
 
 # stable
 class SupportsNoArgReadline(Protocol[_T_co]):
     def readline(self) -> _T_co: ...
 
 # stable
 class SupportsWrite(Protocol[_T_contra]):
-    def write(self, __s: _T_contra) -> object: ...
+    def write(self, s: _T_contra, /) -> object: ...
 
 # stable
 class SupportsFlush(Protocol):
     def flush(self) -> object: ...
 
 # Unfortunately PEP 688 does not allow us to distinguish read-only
 # from writable buffers. We use these aliases for readability for now.
@@ -263,25 +263,25 @@
 ReadOnlyBuffer: TypeAlias = Buffer  # stable
 # Anything that implements the read-write buffer interface.
 WriteableBuffer: TypeAlias = Buffer
 # Same as WriteableBuffer, but also includes read-only buffer types (like bytes).
 ReadableBuffer: TypeAlias = Buffer  # stable
 
 class SliceableBuffer(Buffer, Protocol):
-    def __getitem__(self, __slice: slice) -> Sequence[int]: ...
+    def __getitem__(self, slice: slice, /) -> Sequence[int]: ...
 
 class IndexableBuffer(Buffer, Protocol):
-    def __getitem__(self, __i: int) -> int: ...
+    def __getitem__(self, i: int, /) -> int: ...
 
 class SupportsGetItemBuffer(SliceableBuffer, IndexableBuffer, Protocol):
-    def __contains__(self, __x: Any) -> bool: ...
+    def __contains__(self, x: Any, /) -> bool: ...
     @overload
-    def __getitem__(self, __slice: slice) -> Sequence[int]: ...
+    def __getitem__(self, slice: slice, /) -> Sequence[int]: ...
     @overload
-    def __getitem__(self, __i: int) -> int: ...
+    def __getitem__(self, i: int, /) -> int: ...
 
 class SizedBuffer(Sized, Buffer, Protocol): ...
 
 # for compatibility with third-party stubs that may use this
 _BufferWithLen: TypeAlias = SizedBuffer  # not stable  # noqa: Y047
 
 ExcInfo: TypeAlias = tuple[type[BaseException], BaseException, TracebackType]
```

## puya/_typeshed/stdlib/abc.pyi

```diff
@@ -1,46 +1,48 @@
 import _typeshed
 import sys
 from _typeshed import SupportsWrite
 from collections.abc import Callable
 from typing import Any, Literal, TypeVar
-from typing_extensions import Concatenate, ParamSpec
+from typing_extensions import Concatenate, ParamSpec, deprecated
 
 _T = TypeVar("_T")
 _R_co = TypeVar("_R_co", covariant=True)
 _FuncT = TypeVar("_FuncT", bound=Callable[..., Any])
 _P = ParamSpec("_P")
 
 # These definitions have special processing in mypy
 class ABCMeta(type):
     __abstractmethods__: frozenset[str]
     if sys.version_info >= (3, 11):
         def __new__(
-            __mcls: type[_typeshed.Self], __name: str, __bases: tuple[type, ...], __namespace: dict[str, Any], **kwargs: Any
+            mcls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], /, **kwargs: Any
         ) -> _typeshed.Self: ...
     else:
         def __new__(
             mcls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], **kwargs: Any
         ) -> _typeshed.Self: ...
 
     def __instancecheck__(cls: ABCMeta, instance: Any) -> bool: ...
     def __subclasscheck__(cls: ABCMeta, subclass: type) -> bool: ...
     def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = None) -> None: ...
     def register(cls: ABCMeta, subclass: type[_T]) -> type[_T]: ...
 
 def abstractmethod(funcobj: _FuncT) -> _FuncT: ...
-
+@deprecated("Deprecated, use 'classmethod' with 'abstractmethod' instead")
 class abstractclassmethod(classmethod[_T, _P, _R_co]):
     __isabstractmethod__: Literal[True]
     def __init__(self, callable: Callable[Concatenate[type[_T], _P], _R_co]) -> None: ...
 
+@deprecated("Deprecated, use 'staticmethod' with 'abstractmethod' instead")
 class abstractstaticmethod(staticmethod[_P, _R_co]):
     __isabstractmethod__: Literal[True]
     def __init__(self, callable: Callable[_P, _R_co]) -> None: ...
 
+@deprecated("Deprecated, use 'property' with 'abstractmethod' instead")
 class abstractproperty(property):
     __isabstractmethod__: Literal[True]
 
 class ABC(metaclass=ABCMeta):
     __slots__ = ()
 
 def get_cache_token() -> object: ...
```

## puya/_typeshed/stdlib/builtins.pyi

```diff
@@ -93,70 +93,69 @@
 class object:
     __doc__: str | None
     __dict__: dict[str, Any]
     __module__: str
     __annotations__: dict[str, Any]
     @property
     def __class__(self) -> type[Self]: ...
-    # Ignore errors about type mismatch between property getter and setter
     @__class__.setter
-    def __class__(self, __type: type[object]) -> None: ...  # noqa: F811
+    def __class__(self, type: type[object], /) -> None: ...
     def __init__(self) -> None: ...
     def __new__(cls) -> Self: ...
     # N.B. `object.__setattr__` and `object.__delattr__` are heavily special-cased by type checkers.
     # Overriding them in subclasses has different semantics, even if the override has an identical signature.
-    def __setattr__(self, __name: str, __value: Any) -> None: ...
-    def __delattr__(self, __name: str) -> None: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
+    def __setattr__(self, name: str, value: Any, /) -> None: ...
+    def __delattr__(self, name: str, /) -> None: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
     def __str__(self) -> str: ...  # noqa: Y029
     def __repr__(self) -> str: ...  # noqa: Y029
     def __hash__(self) -> int: ...
-    def __format__(self, __format_spec: str) -> str: ...
-    def __getattribute__(self, __name: str) -> Any: ...
+    def __format__(self, format_spec: str, /) -> str: ...
+    def __getattribute__(self, name: str, /) -> Any: ...
     def __sizeof__(self) -> int: ...
     # return type of pickle methods is rather hard to express in the current type system
     # see #6661 and https://docs.python.org/3/library/pickle.html#object.__reduce__
     def __reduce__(self) -> str | tuple[Any, ...]: ...
-    def __reduce_ex__(self, __protocol: SupportsIndex) -> str | tuple[Any, ...]: ...
+    def __reduce_ex__(self, protocol: SupportsIndex, /) -> str | tuple[Any, ...]: ...
     if sys.version_info >= (3, 11):
         def __getstate__(self) -> object: ...
 
     def __dir__(self) -> Iterable[str]: ...
     def __init_subclass__(cls) -> None: ...
     @classmethod
-    def __subclasshook__(cls, __subclass: type) -> bool: ...
+    def __subclasshook__(cls, subclass: type, /) -> bool: ...
 
 class staticmethod(Generic[_P, _R_co]):
     @property
     def __func__(self) -> Callable[_P, _R_co]: ...
     @property
     def __isabstractmethod__(self) -> bool: ...
-    def __init__(self, __f: Callable[_P, _R_co]) -> None: ...
+    def __init__(self, f: Callable[_P, _R_co], /) -> None: ...
     @overload
-    def __get__(self, __instance: None, __owner: type) -> Callable[_P, _R_co]: ...
+    def __get__(self, instance: None, owner: type, /) -> Callable[_P, _R_co]: ...
     @overload
-    def __get__(self, __instance: _T, __owner: type[_T] | None = None) -> Callable[_P, _R_co]: ...
+    def __get__(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...
     if sys.version_info >= (3, 10):
         __name__: str
         __qualname__: str
         @property
         def __wrapped__(self) -> Callable[_P, _R_co]: ...
         def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R_co: ...
 
 class classmethod(Generic[_T, _P, _R_co]):
     @property
     def __func__(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...
     @property
     def __isabstractmethod__(self) -> bool: ...
-    def __init__(self, __f: Callable[Concatenate[type[_T], _P], _R_co]) -> None: ...
+    def __init__(self, f: Callable[Concatenate[type[_T], _P], _R_co], /) -> None: ...
     @overload
-    def __get__(self, __instance: _T, __owner: type[_T] | None = None) -> Callable[_P, _R_co]: ...
+    def __get__(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...
     @overload
-    def __get__(self, __instance: None, __owner: type[_T]) -> Callable[_P, _R_co]: ...
+    def __get__(self, instance: None, owner: type[_T], /) -> Callable[_P, _R_co]: ...
     if sys.version_info >= (3, 10):
         __name__: str
         __qualname__: str
         @property
         def __wrapped__(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...
 
 class type:
@@ -180,55 +179,55 @@
     __name__: str
     __qualname__: str
     @property
     def __text_signature__(self) -> str | None: ...
     @property
     def __weakrefoffset__(self) -> int: ...
     @overload
-    def __init__(self, __o: object) -> None: ...
+    def __init__(self, o: object, /) -> None: ...
     @overload
-    def __init__(self, __name: str, __bases: tuple[type, ...], __dict: dict[str, Any], **kwds: Any) -> None: ...
+    def __init__(self, name: str, bases: tuple[type, ...], dict: dict[str, Any], /, **kwds: Any) -> None: ...
     @overload
-    def __new__(cls, __o: object) -> type: ...
+    def __new__(cls, o: object, /) -> type: ...
     @overload
     def __new__(
-        cls: type[_typeshed.Self], __name: str, __bases: tuple[type, ...], __namespace: dict[str, Any], **kwds: Any
+        cls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], /, **kwds: Any
     ) -> _typeshed.Self: ...
     def __call__(self, *args: Any, **kwds: Any) -> Any: ...
     def __subclasses__(self: _typeshed.Self) -> list[_typeshed.Self]: ...
     # Note: the documentation doesn't specify what the return type is, the standard
     # implementation seems to be returning a list.
     def mro(self) -> list[type]: ...
-    def __instancecheck__(self, __instance: Any) -> bool: ...
-    def __subclasscheck__(self, __subclass: type) -> bool: ...
+    def __instancecheck__(self, instance: Any, /) -> bool: ...
+    def __subclasscheck__(self, subclass: type, /) -> bool: ...
     @classmethod
-    def __prepare__(metacls, __name: str, __bases: tuple[type, ...], **kwds: Any) -> MutableMapping[str, object]: ...
+    def __prepare__(metacls, name: str, bases: tuple[type, ...], /, **kwds: Any) -> MutableMapping[str, object]: ...
     if sys.version_info >= (3, 10):
-        def __or__(self, __value: Any) -> types.UnionType: ...
-        def __ror__(self, __value: Any) -> types.UnionType: ...
+        def __or__(self, value: Any, /) -> types.UnionType: ...
+        def __ror__(self, value: Any, /) -> types.UnionType: ...
     if sys.version_info >= (3, 12):
         __type_params__: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]
 
 class super:
     @overload
-    def __init__(self, __t: Any, __obj: Any) -> None: ...
+    def __init__(self, t: Any, obj: Any, /) -> None: ...
     @overload
-    def __init__(self, __t: Any) -> None: ...
+    def __init__(self, t: Any, /) -> None: ...
     @overload
     def __init__(self) -> None: ...
 
 _PositiveInteger: TypeAlias = Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
 _NegativeInteger: TypeAlias = Literal[-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20]
 _LiteralInteger = _PositiveInteger | _NegativeInteger | Literal[0]  # noqa: Y026  # TODO: Use TypeAlias once mypy bugs are fixed
 
 class int:
     @overload
-    def __new__(cls, __x: ConvertibleToInt = ...) -> Self: ...
+    def __new__(cls, x: ConvertibleToInt = ..., /) -> Self: ...
     @overload
-    def __new__(cls, __x: str | bytes | bytearray, base: SupportsIndex) -> Self: ...
+    def __new__(cls, x: str | bytes | bytearray, /, base: SupportsIndex) -> Self: ...
     def as_integer_ratio(self) -> tuple[int, Literal[1]]: ...
     @property
     def real(self) -> int: ...
     @property
     def imag(self) -> Literal[0]: ...
     @property
     def numerator(self) -> int: ...
@@ -261,129 +260,129 @@
             *,
             signed: bool = False,
         ) -> Self: ...
 
     if sys.version_info >= (3, 12):
         def is_integer(self) -> Literal[True]: ...
 
-    def __add__(self, __value: int) -> int: ...
-    def __sub__(self, __value: int) -> int: ...
-    def __mul__(self, __value: int) -> int: ...
-    def __floordiv__(self, __value: int) -> int: ...
-    def __truediv__(self, __value: int) -> float: ...
-    def __mod__(self, __value: int) -> int: ...
-    def __divmod__(self, __value: int) -> tuple[int, int]: ...
-    def __radd__(self, __value: int) -> int: ...
-    def __rsub__(self, __value: int) -> int: ...
-    def __rmul__(self, __value: int) -> int: ...
-    def __rfloordiv__(self, __value: int) -> int: ...
-    def __rtruediv__(self, __value: int) -> float: ...
-    def __rmod__(self, __value: int) -> int: ...
-    def __rdivmod__(self, __value: int) -> tuple[int, int]: ...
+    def __add__(self, value: int, /) -> int: ...
+    def __sub__(self, value: int, /) -> int: ...
+    def __mul__(self, value: int, /) -> int: ...
+    def __floordiv__(self, value: int, /) -> int: ...
+    def __truediv__(self, value: int, /) -> float: ...
+    def __mod__(self, value: int, /) -> int: ...
+    def __divmod__(self, value: int, /) -> tuple[int, int]: ...
+    def __radd__(self, value: int, /) -> int: ...
+    def __rsub__(self, value: int, /) -> int: ...
+    def __rmul__(self, value: int, /) -> int: ...
+    def __rfloordiv__(self, value: int, /) -> int: ...
+    def __rtruediv__(self, value: int, /) -> float: ...
+    def __rmod__(self, value: int, /) -> int: ...
+    def __rdivmod__(self, value: int, /) -> tuple[int, int]: ...
     @overload
-    def __pow__(self, __x: Literal[0]) -> Literal[1]: ...
+    def __pow__(self, x: Literal[0], /) -> Literal[1]: ...
     @overload
-    def __pow__(self, __value: Literal[0], __mod: None) -> Literal[1]: ...
+    def __pow__(self, value: Literal[0], mod: None, /) -> Literal[1]: ...
     @overload
-    def __pow__(self, __value: _PositiveInteger, __mod: None = None) -> int: ...
+    def __pow__(self, value: _PositiveInteger, mod: None = None, /) -> int: ...
     @overload
-    def __pow__(self, __value: _NegativeInteger, __mod: None = None) -> float: ...
+    def __pow__(self, value: _NegativeInteger, mod: None = None, /) -> float: ...
     # positive __value -> int; negative __value -> float
     # return type must be Any as `int | float` causes too many false-positive errors
     @overload
-    def __pow__(self, __value: int, __mod: None = None) -> Any: ...
+    def __pow__(self, value: int, mod: None = None, /) -> Any: ...
     @overload
-    def __pow__(self, __value: int, __mod: int) -> int: ...
-    def __rpow__(self, __value: int, __mod: int | None = None) -> Any: ...
-    def __and__(self, __value: int) -> int: ...
-    def __or__(self, __value: int) -> int: ...
-    def __xor__(self, __value: int) -> int: ...
-    def __lshift__(self, __value: int) -> int: ...
-    def __rshift__(self, __value: int) -> int: ...
-    def __rand__(self, __value: int) -> int: ...
-    def __ror__(self, __value: int) -> int: ...
-    def __rxor__(self, __value: int) -> int: ...
-    def __rlshift__(self, __value: int) -> int: ...
-    def __rrshift__(self, __value: int) -> int: ...
+    def __pow__(self, value: int, mod: int, /) -> int: ...
+    def __rpow__(self, value: int, mod: int | None = None, /) -> Any: ...
+    def __and__(self, value: int, /) -> int: ...
+    def __or__(self, value: int, /) -> int: ...
+    def __xor__(self, value: int, /) -> int: ...
+    def __lshift__(self, value: int, /) -> int: ...
+    def __rshift__(self, value: int, /) -> int: ...
+    def __rand__(self, value: int, /) -> int: ...
+    def __ror__(self, value: int, /) -> int: ...
+    def __rxor__(self, value: int, /) -> int: ...
+    def __rlshift__(self, value: int, /) -> int: ...
+    def __rrshift__(self, value: int, /) -> int: ...
     def __neg__(self) -> int: ...
     def __pos__(self) -> int: ...
     def __invert__(self) -> int: ...
     def __trunc__(self) -> int: ...
     def __ceil__(self) -> int: ...
     def __floor__(self) -> int: ...
-    def __round__(self, __ndigits: SupportsIndex = ...) -> int: ...
+    def __round__(self, ndigits: SupportsIndex = ..., /) -> int: ...
     def __getnewargs__(self) -> tuple[int]: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
-    def __lt__(self, __value: int) -> bool: ...
-    def __le__(self, __value: int) -> bool: ...
-    def __gt__(self, __value: int) -> bool: ...
-    def __ge__(self, __value: int) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
+    def __lt__(self, value: int, /) -> bool: ...
+    def __le__(self, value: int, /) -> bool: ...
+    def __gt__(self, value: int, /) -> bool: ...
+    def __ge__(self, value: int, /) -> bool: ...
     def __float__(self) -> float: ...
     def __int__(self) -> int: ...
     def __abs__(self) -> int: ...
     def __hash__(self) -> int: ...
     def __bool__(self) -> bool: ...
     def __index__(self) -> int: ...
 
 class float:
-    def __new__(cls, __x: ConvertibleToFloat = ...) -> Self: ...
+    def __new__(cls, x: ConvertibleToFloat = ..., /) -> Self: ...
     def as_integer_ratio(self) -> tuple[int, int]: ...
     def hex(self) -> str: ...
     def is_integer(self) -> bool: ...
     @classmethod
-    def fromhex(cls, __string: str) -> Self: ...
+    def fromhex(cls, string: str, /) -> Self: ...
     @property
     def real(self) -> float: ...
     @property
     def imag(self) -> float: ...
     def conjugate(self) -> float: ...
-    def __add__(self, __value: float) -> float: ...
-    def __sub__(self, __value: float) -> float: ...
-    def __mul__(self, __value: float) -> float: ...
-    def __floordiv__(self, __value: float) -> float: ...
-    def __truediv__(self, __value: float) -> float: ...
-    def __mod__(self, __value: float) -> float: ...
-    def __divmod__(self, __value: float) -> tuple[float, float]: ...
+    def __add__(self, value: float, /) -> float: ...
+    def __sub__(self, value: float, /) -> float: ...
+    def __mul__(self, value: float, /) -> float: ...
+    def __floordiv__(self, value: float, /) -> float: ...
+    def __truediv__(self, value: float, /) -> float: ...
+    def __mod__(self, value: float, /) -> float: ...
+    def __divmod__(self, value: float, /) -> tuple[float, float]: ...
     @overload
-    def __pow__(self, __value: int, __mod: None = None) -> float: ...
+    def __pow__(self, value: int, mod: None = None, /) -> float: ...
     # positive __value -> float; negative __value -> complex
     # return type must be Any as `float | complex` causes too many false-positive errors
     @overload
-    def __pow__(self, __value: float, __mod: None = None) -> Any: ...
-    def __radd__(self, __value: float) -> float: ...
-    def __rsub__(self, __value: float) -> float: ...
-    def __rmul__(self, __value: float) -> float: ...
-    def __rfloordiv__(self, __value: float) -> float: ...
-    def __rtruediv__(self, __value: float) -> float: ...
-    def __rmod__(self, __value: float) -> float: ...
-    def __rdivmod__(self, __value: float) -> tuple[float, float]: ...
+    def __pow__(self, value: float, mod: None = None, /) -> Any: ...
+    def __radd__(self, value: float, /) -> float: ...
+    def __rsub__(self, value: float, /) -> float: ...
+    def __rmul__(self, value: float, /) -> float: ...
+    def __rfloordiv__(self, value: float, /) -> float: ...
+    def __rtruediv__(self, value: float, /) -> float: ...
+    def __rmod__(self, value: float, /) -> float: ...
+    def __rdivmod__(self, value: float, /) -> tuple[float, float]: ...
     @overload
-    def __rpow__(self, __value: _PositiveInteger, __mod: None = None) -> float: ...
+    def __rpow__(self, value: _PositiveInteger, mod: None = None, /) -> float: ...
     @overload
-    def __rpow__(self, __value: _NegativeInteger, __mod: None = None) -> complex: ...
+    def __rpow__(self, value: _NegativeInteger, mod: None = None, /) -> complex: ...
     # Returning `complex` for the general case gives too many false-positive errors.
     @overload
-    def __rpow__(self, __value: float, __mod: None = None) -> Any: ...
+    def __rpow__(self, value: float, mod: None = None, /) -> Any: ...
     def __getnewargs__(self) -> tuple[float]: ...
     def __trunc__(self) -> int: ...
     if sys.version_info >= (3, 9):
         def __ceil__(self) -> int: ...
         def __floor__(self) -> int: ...
 
     @overload
-    def __round__(self, __ndigits: None = None) -> int: ...
+    def __round__(self, ndigits: None = None, /) -> int: ...
     @overload
-    def __round__(self, __ndigits: SupportsIndex) -> float: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
-    def __lt__(self, __value: float) -> bool: ...
-    def __le__(self, __value: float) -> bool: ...
-    def __gt__(self, __value: float) -> bool: ...
-    def __ge__(self, __value: float) -> bool: ...
+    def __round__(self, ndigits: SupportsIndex, /) -> float: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
+    def __lt__(self, value: float, /) -> bool: ...
+    def __le__(self, value: float, /) -> bool: ...
+    def __gt__(self, value: float, /) -> bool: ...
+    def __ge__(self, value: float, /) -> bool: ...
     def __neg__(self) -> float: ...
     def __pos__(self) -> float: ...
     def __int__(self) -> int: ...
     def __float__(self) -> float: ...
     def __abs__(self) -> float: ...
     def __hash__(self) -> int: ...
     def __bool__(self) -> bool: ...
@@ -399,331 +398,335 @@
     @overload
     def __new__(cls, real: str | SupportsComplex | SupportsFloat | SupportsIndex | complex) -> Self: ...
     @property
     def real(self) -> float: ...
     @property
     def imag(self) -> float: ...
     def conjugate(self) -> complex: ...
-    def __add__(self, __value: complex) -> complex: ...
-    def __sub__(self, __value: complex) -> complex: ...
-    def __mul__(self, __value: complex) -> complex: ...
-    def __pow__(self, __value: complex, __mod: None = None) -> complex: ...
-    def __truediv__(self, __value: complex) -> complex: ...
-    def __radd__(self, __value: complex) -> complex: ...
-    def __rsub__(self, __value: complex) -> complex: ...
-    def __rmul__(self, __value: complex) -> complex: ...
-    def __rpow__(self, __value: complex, __mod: None = None) -> complex: ...
-    def __rtruediv__(self, __value: complex) -> complex: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
+    def __add__(self, value: complex, /) -> complex: ...
+    def __sub__(self, value: complex, /) -> complex: ...
+    def __mul__(self, value: complex, /) -> complex: ...
+    def __pow__(self, value: complex, mod: None = None, /) -> complex: ...
+    def __truediv__(self, value: complex, /) -> complex: ...
+    def __radd__(self, value: complex, /) -> complex: ...
+    def __rsub__(self, value: complex, /) -> complex: ...
+    def __rmul__(self, value: complex, /) -> complex: ...
+    def __rpow__(self, value: complex, mod: None = None, /) -> complex: ...
+    def __rtruediv__(self, value: complex, /) -> complex: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
     def __neg__(self) -> complex: ...
     def __pos__(self) -> complex: ...
     def __abs__(self) -> float: ...
     def __hash__(self) -> int: ...
     def __bool__(self) -> bool: ...
     if sys.version_info >= (3, 11):
         def __complex__(self) -> complex: ...
 
 class _FormatMapMapping(Protocol):
-    def __getitem__(self, __key: str) -> Any: ...
+    def __getitem__(self, key: str, /) -> Any: ...
 
 class _TranslateTable(Protocol):
-    def __getitem__(self, __key: int) -> str | int | None: ...
+    def __getitem__(self, key: int, /) -> str | int | None: ...
 
 class str(Sequence[str]):
     @overload
     def __new__(cls, object: object = ...) -> Self: ...
     @overload
     def __new__(cls, object: ReadableBuffer, encoding: str = ..., errors: str = ...) -> Self: ...
     def capitalize(self) -> str: ...  # type: ignore[misc]
     def casefold(self) -> str: ...  # type: ignore[misc]
-    def center(self, __width: SupportsIndex, __fillchar: str = " ") -> str: ...  # type: ignore[misc]
-    def count(self, x: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...
+    def center(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ...  # type: ignore[misc]
+    def count(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
     def encode(self, encoding: str = "utf-8", errors: str = "strict") -> bytes: ...
     def endswith(
-        self, __suffix: str | tuple[str, ...], __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, suffix: str | tuple[str, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> bool: ...
     def expandtabs(self, tabsize: SupportsIndex = 8) -> str: ...  # type: ignore[misc]
-    def find(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...
+    def find(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
     def format(self, *args: object, **kwargs: object) -> str: ...
     def format_map(self, map: _FormatMapMapping) -> str: ...
-    def index(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...
+    def index(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
     def isalnum(self) -> bool: ...
     def isalpha(self) -> bool: ...
     def isascii(self) -> bool: ...
     def isdecimal(self) -> bool: ...
     def isdigit(self) -> bool: ...
     def isidentifier(self) -> bool: ...
     def islower(self) -> bool: ...
     def isnumeric(self) -> bool: ...
     def isprintable(self) -> bool: ...
     def isspace(self) -> bool: ...
     def istitle(self) -> bool: ...
     def isupper(self) -> bool: ...
-    def join(self, __iterable: Iterable[str]) -> str: ...  # type: ignore[misc]
-    def ljust(self, __width: SupportsIndex, __fillchar: str = " ") -> str: ...  # type: ignore[misc]
+    def join(self, iterable: Iterable[str], /) -> str: ...  # type: ignore[misc]
+    def ljust(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ...  # type: ignore[misc]
     def lower(self) -> str: ...  # type: ignore[misc]
-    def lstrip(self, __chars: str | None = None) -> str: ...  # type: ignore[misc]
-    def partition(self, __sep: str) -> tuple[str, str, str]: ...  # type: ignore[misc]
-    def replace(self, __old: str, __new: str, __count: SupportsIndex = -1) -> str: ...  # type: ignore[misc]
+    def lstrip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]
+    def partition(self, sep: str, /) -> tuple[str, str, str]: ...  # type: ignore[misc]
+    def replace(self, old: str, new: str, count: SupportsIndex = -1, /) -> str: ...  # type: ignore[misc]
     if sys.version_info >= (3, 9):
-        def removeprefix(self, __prefix: str) -> str: ...  # type: ignore[misc]
-        def removesuffix(self, __suffix: str) -> str: ...  # type: ignore[misc]
+        def removeprefix(self, prefix: str, /) -> str: ...  # type: ignore[misc]
+        def removesuffix(self, suffix: str, /) -> str: ...  # type: ignore[misc]
 
-    def rfind(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...
-    def rindex(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...
-    def rjust(self, __width: SupportsIndex, __fillchar: str = " ") -> str: ...  # type: ignore[misc]
-    def rpartition(self, __sep: str) -> tuple[str, str, str]: ...  # type: ignore[misc]
+    def rfind(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
+    def rindex(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
+    def rjust(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ...  # type: ignore[misc]
+    def rpartition(self, sep: str, /) -> tuple[str, str, str]: ...  # type: ignore[misc]
     def rsplit(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]
-    def rstrip(self, __chars: str | None = None) -> str: ...  # type: ignore[misc]
+    def rstrip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]
     def split(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]
     def splitlines(self, keepends: bool = False) -> list[str]: ...  # type: ignore[misc]
     def startswith(
-        self, __prefix: str | tuple[str, ...], __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, prefix: str | tuple[str, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> bool: ...
-    def strip(self, __chars: str | None = None) -> str: ...  # type: ignore[misc]
+    def strip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]
     def swapcase(self) -> str: ...  # type: ignore[misc]
     def title(self) -> str: ...  # type: ignore[misc]
-    def translate(self, __table: _TranslateTable) -> str: ...
+    def translate(self, table: _TranslateTable, /) -> str: ...
     def upper(self) -> str: ...  # type: ignore[misc]
-    def zfill(self, __width: SupportsIndex) -> str: ...  # type: ignore[misc]
+    def zfill(self, width: SupportsIndex, /) -> str: ...  # type: ignore[misc]
     @staticmethod
     @overload
-    def maketrans(__x: dict[int, _T] | dict[str, _T] | dict[str | int, _T]) -> dict[int, _T]: ...
+    def maketrans(x: dict[int, _T] | dict[str, _T] | dict[str | int, _T], /) -> dict[int, _T]: ...
     @staticmethod
     @overload
-    def maketrans(__x: str, __y: str) -> dict[int, int]: ...
+    def maketrans(x: str, y: str, /) -> dict[int, int]: ...
     @staticmethod
     @overload
-    def maketrans(__x: str, __y: str, __z: str) -> dict[int, int | None]: ...
-    def __add__(self, __value: str) -> str: ...  # type: ignore[misc]
+    def maketrans(x: str, y: str, z: str, /) -> dict[int, int | None]: ...
+    def __add__(self, value: str, /) -> str: ...  # type: ignore[misc]
     # Incompatible with Sequence.__contains__
-    def __contains__(self, __key: str) -> bool: ...  # type: ignore[override]
-    def __eq__(self, __value: object) -> bool: ...
-    def __ge__(self, __value: str) -> bool: ...
-    def __getitem__(self, __key: SupportsIndex | slice) -> str: ...
-    def __gt__(self, __value: str) -> bool: ...
+    def __contains__(self, key: str, /) -> bool: ...  # type: ignore[override]
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ge__(self, value: str, /) -> bool: ...
+    def __getitem__(self, key: SupportsIndex | slice, /) -> str: ...
+    def __gt__(self, value: str, /) -> bool: ...
     def __hash__(self) -> int: ...
     def __iter__(self) -> Iterator[str]: ...  # type: ignore[misc]
-    def __le__(self, __value: str) -> bool: ...
+    def __le__(self, value: str, /) -> bool: ...
     def __len__(self) -> int: ...
-    def __lt__(self, __value: str) -> bool: ...
-    def __mod__(self, __value: Any) -> str: ...
-    def __mul__(self, __value: SupportsIndex) -> str: ...  # type: ignore[misc]
-    def __ne__(self, __value: object) -> bool: ...
-    def __rmul__(self, __value: SupportsIndex) -> str: ...  # type: ignore[misc]
+    def __lt__(self, value: str, /) -> bool: ...
+    def __mod__(self, value: Any, /) -> str: ...
+    def __mul__(self, value: SupportsIndex, /) -> str: ...  # type: ignore[misc]
+    def __ne__(self, value: object, /) -> bool: ...
+    def __rmul__(self, value: SupportsIndex, /) -> str: ...  # type: ignore[misc]
     def __getnewargs__(self) -> tuple[str]: ...
 
 class bytes(Sequence[int]):
     @overload
-    def __new__(cls, __o: Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | ReadableBuffer) -> Self: ...
+    def __new__(cls, o: Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | ReadableBuffer, /) -> Self: ...
     @overload
-    def __new__(cls, __string: str, encoding: str, errors: str = ...) -> Self: ...
+    def __new__(cls, string: str, /, encoding: str, errors: str = ...) -> Self: ...
     @overload
     def __new__(cls) -> Self: ...
     def capitalize(self) -> bytes: ...
-    def center(self, __width: SupportsIndex, __fillchar: bytes = b" ") -> bytes: ...
+    def center(self, width: SupportsIndex, fillchar: bytes = b" ", /) -> bytes: ...
     def count(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def decode(self, encoding: str = "utf-8", errors: str = "strict") -> str: ...
     def endswith(
         self,
-        __suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
-        __start: SupportsIndex | None = ...,
-        __end: SupportsIndex | None = ...,
+        suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
+        start: SupportsIndex | None = ...,
+        end: SupportsIndex | None = ...,
+        /,
     ) -> bool: ...
     def expandtabs(self, tabsize: SupportsIndex = 8) -> bytes: ...
     def find(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
     def index(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def isalnum(self) -> bool: ...
     def isalpha(self) -> bool: ...
     def isascii(self) -> bool: ...
     def isdigit(self) -> bool: ...
     def islower(self) -> bool: ...
     def isspace(self) -> bool: ...
     def istitle(self) -> bool: ...
     def isupper(self) -> bool: ...
-    def join(self, __iterable_of_bytes: Iterable[ReadableBuffer]) -> bytes: ...
-    def ljust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b" ") -> bytes: ...
+    def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytes: ...
+    def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytes: ...
     def lower(self) -> bytes: ...
-    def lstrip(self, __bytes: ReadableBuffer | None = None) -> bytes: ...
-    def partition(self, __sep: ReadableBuffer) -> tuple[bytes, bytes, bytes]: ...
-    def replace(self, __old: ReadableBuffer, __new: ReadableBuffer, __count: SupportsIndex = -1) -> bytes: ...
+    def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
+    def partition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...
+    def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytes: ...
     if sys.version_info >= (3, 9):
-        def removeprefix(self, __prefix: ReadableBuffer) -> bytes: ...
-        def removesuffix(self, __suffix: ReadableBuffer) -> bytes: ...
+        def removeprefix(self, prefix: ReadableBuffer, /) -> bytes: ...
+        def removesuffix(self, suffix: ReadableBuffer, /) -> bytes: ...
 
     def rfind(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def rindex(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
-    def rjust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b" ") -> bytes: ...
-    def rpartition(self, __sep: ReadableBuffer) -> tuple[bytes, bytes, bytes]: ...
+    def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytes: ...
+    def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...
     def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...
-    def rstrip(self, __bytes: ReadableBuffer | None = None) -> bytes: ...
+    def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
     def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...
     def splitlines(self, keepends: bool = False) -> list[bytes]: ...
     def startswith(
         self,
-        __prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
-        __start: SupportsIndex | None = ...,
-        __end: SupportsIndex | None = ...,
+        prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
+        start: SupportsIndex | None = ...,
+        end: SupportsIndex | None = ...,
+        /,
     ) -> bool: ...
-    def strip(self, __bytes: ReadableBuffer | None = None) -> bytes: ...
+    def strip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
     def swapcase(self) -> bytes: ...
     def title(self) -> bytes: ...
-    def translate(self, __table: ReadableBuffer | None, delete: bytes = b"") -> bytes: ...
+    def translate(self, table: ReadableBuffer | None, /, delete: bytes = b"") -> bytes: ...
     def upper(self) -> bytes: ...
-    def zfill(self, __width: SupportsIndex) -> bytes: ...
+    def zfill(self, width: SupportsIndex, /) -> bytes: ...
     @classmethod
-    def fromhex(cls, __string: str) -> Self: ...
+    def fromhex(cls, string: str, /) -> Self: ...
     @staticmethod
-    def maketrans(__frm: ReadableBuffer, __to: ReadableBuffer) -> bytes: ...
+    def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...
     def __len__(self) -> int: ...
     def __iter__(self) -> Iterator[int]: ...
     def __hash__(self) -> int: ...
     @overload
-    def __getitem__(self, __key: SupportsIndex) -> int: ...
+    def __getitem__(self, key: SupportsIndex, /) -> int: ...
     @overload
-    def __getitem__(self, __key: slice) -> bytes: ...
-    def __add__(self, __value: ReadableBuffer) -> bytes: ...
-    def __mul__(self, __value: SupportsIndex) -> bytes: ...
-    def __rmul__(self, __value: SupportsIndex) -> bytes: ...
-    def __mod__(self, __value: Any) -> bytes: ...
+    def __getitem__(self, key: slice, /) -> bytes: ...
+    def __add__(self, value: ReadableBuffer, /) -> bytes: ...
+    def __mul__(self, value: SupportsIndex, /) -> bytes: ...
+    def __rmul__(self, value: SupportsIndex, /) -> bytes: ...
+    def __mod__(self, value: Any, /) -> bytes: ...
     # Incompatible with Sequence.__contains__
-    def __contains__(self, __key: SupportsIndex | ReadableBuffer) -> bool: ...  # type: ignore[override]
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
-    def __lt__(self, __value: bytes) -> bool: ...
-    def __le__(self, __value: bytes) -> bool: ...
-    def __gt__(self, __value: bytes) -> bool: ...
-    def __ge__(self, __value: bytes) -> bool: ...
+    def __contains__(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ...  # type: ignore[override]
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
+    def __lt__(self, value: bytes, /) -> bool: ...
+    def __le__(self, value: bytes, /) -> bool: ...
+    def __gt__(self, value: bytes, /) -> bool: ...
+    def __ge__(self, value: bytes, /) -> bool: ...
     def __getnewargs__(self) -> tuple[bytes]: ...
     if sys.version_info >= (3, 11):
         def __bytes__(self) -> bytes: ...
 
-    def __buffer__(self, __flags: int) -> memoryview: ...
+    def __buffer__(self, flags: int, /) -> memoryview: ...
 
 class bytearray(MutableSequence[int]):
     @overload
     def __init__(self) -> None: ...
     @overload
-    def __init__(self, __ints: Iterable[SupportsIndex] | SupportsIndex | ReadableBuffer) -> None: ...
+    def __init__(self, ints: Iterable[SupportsIndex] | SupportsIndex | ReadableBuffer, /) -> None: ...
     @overload
-    def __init__(self, __string: str, encoding: str, errors: str = ...) -> None: ...
-    def append(self, __item: SupportsIndex) -> None: ...
+    def __init__(self, string: str, /, encoding: str, errors: str = ...) -> None: ...
+    def append(self, item: SupportsIndex, /) -> None: ...
     def capitalize(self) -> bytearray: ...
-    def center(self, __width: SupportsIndex, __fillchar: bytes = b" ") -> bytearray: ...
+    def center(self, width: SupportsIndex, fillchar: bytes = b" ", /) -> bytearray: ...
     def count(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def copy(self) -> bytearray: ...
     def decode(self, encoding: str = "utf-8", errors: str = "strict") -> str: ...
     def endswith(
         self,
-        __suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
-        __start: SupportsIndex | None = ...,
-        __end: SupportsIndex | None = ...,
+        suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
+        start: SupportsIndex | None = ...,
+        end: SupportsIndex | None = ...,
+        /,
     ) -> bool: ...
     def expandtabs(self, tabsize: SupportsIndex = 8) -> bytearray: ...
-    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...
+    def extend(self, iterable_of_ints: Iterable[SupportsIndex], /) -> None: ...
     def find(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
     def index(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
-    def insert(self, __index: SupportsIndex, __item: SupportsIndex) -> None: ...
+    def insert(self, index: SupportsIndex, item: SupportsIndex, /) -> None: ...
     def isalnum(self) -> bool: ...
     def isalpha(self) -> bool: ...
     def isascii(self) -> bool: ...
     def isdigit(self) -> bool: ...
     def islower(self) -> bool: ...
     def isspace(self) -> bool: ...
     def istitle(self) -> bool: ...
     def isupper(self) -> bool: ...
-    def join(self, __iterable_of_bytes: Iterable[ReadableBuffer]) -> bytearray: ...
-    def ljust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b" ") -> bytearray: ...
+    def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytearray: ...
+    def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytearray: ...
     def lower(self) -> bytearray: ...
-    def lstrip(self, __bytes: ReadableBuffer | None = None) -> bytearray: ...
-    def partition(self, __sep: ReadableBuffer) -> tuple[bytearray, bytearray, bytearray]: ...
-    def pop(self, __index: int = -1) -> int: ...
-    def remove(self, __value: int) -> None: ...
+    def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...
+    def partition(self, sep: ReadableBuffer, /) -> tuple[bytearray, bytearray, bytearray]: ...
+    def pop(self, index: int = -1, /) -> int: ...
+    def remove(self, value: int, /) -> None: ...
     if sys.version_info >= (3, 9):
-        def removeprefix(self, __prefix: ReadableBuffer) -> bytearray: ...
-        def removesuffix(self, __suffix: ReadableBuffer) -> bytearray: ...
+        def removeprefix(self, prefix: ReadableBuffer, /) -> bytearray: ...
+        def removesuffix(self, suffix: ReadableBuffer, /) -> bytearray: ...
 
-    def replace(self, __old: ReadableBuffer, __new: ReadableBuffer, __count: SupportsIndex = -1) -> bytearray: ...
+    def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytearray: ...
     def rfind(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def rindex(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
-    def rjust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b" ") -> bytearray: ...
-    def rpartition(self, __sep: ReadableBuffer) -> tuple[bytearray, bytearray, bytearray]: ...
+    def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytearray: ...
+    def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytearray, bytearray, bytearray]: ...
     def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...
-    def rstrip(self, __bytes: ReadableBuffer | None = None) -> bytearray: ...
+    def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...
     def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...
     def splitlines(self, keepends: bool = False) -> list[bytearray]: ...
     def startswith(
         self,
-        __prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
-        __start: SupportsIndex | None = ...,
-        __end: SupportsIndex | None = ...,
+        prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
+        start: SupportsIndex | None = ...,
+        end: SupportsIndex | None = ...,
+        /,
     ) -> bool: ...
-    def strip(self, __bytes: ReadableBuffer | None = None) -> bytearray: ...
+    def strip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...
     def swapcase(self) -> bytearray: ...
     def title(self) -> bytearray: ...
-    def translate(self, __table: ReadableBuffer | None, delete: bytes = b"") -> bytearray: ...
+    def translate(self, table: ReadableBuffer | None, /, delete: bytes = b"") -> bytearray: ...
     def upper(self) -> bytearray: ...
-    def zfill(self, __width: SupportsIndex) -> bytearray: ...
+    def zfill(self, width: SupportsIndex, /) -> bytearray: ...
     @classmethod
-    def fromhex(cls, __string: str) -> Self: ...
+    def fromhex(cls, string: str, /) -> Self: ...
     @staticmethod
-    def maketrans(__frm: ReadableBuffer, __to: ReadableBuffer) -> bytes: ...
+    def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...
     def __len__(self) -> int: ...
     def __iter__(self) -> Iterator[int]: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
     @overload
-    def __getitem__(self, __key: SupportsIndex) -> int: ...
+    def __getitem__(self, key: SupportsIndex, /) -> int: ...
     @overload
-    def __getitem__(self, __key: slice) -> bytearray: ...
+    def __getitem__(self, key: slice, /) -> bytearray: ...
     @overload
-    def __setitem__(self, __key: SupportsIndex, __value: SupportsIndex) -> None: ...
+    def __setitem__(self, key: SupportsIndex, value: SupportsIndex, /) -> None: ...
     @overload
-    def __setitem__(self, __key: slice, __value: Iterable[SupportsIndex] | bytes) -> None: ...
-    def __delitem__(self, __key: SupportsIndex | slice) -> None: ...
-    def __add__(self, __value: ReadableBuffer) -> bytearray: ...
+    def __setitem__(self, key: slice, value: Iterable[SupportsIndex] | bytes, /) -> None: ...
+    def __delitem__(self, key: SupportsIndex | slice, /) -> None: ...
+    def __add__(self, value: ReadableBuffer, /) -> bytearray: ...
     # The superclass wants us to accept Iterable[int], but that fails at runtime.
-    def __iadd__(self, __value: ReadableBuffer) -> Self: ...  # type: ignore[override]
-    def __mul__(self, __value: SupportsIndex) -> bytearray: ...
-    def __rmul__(self, __value: SupportsIndex) -> bytearray: ...
-    def __imul__(self, __value: SupportsIndex) -> Self: ...
-    def __mod__(self, __value: Any) -> bytes: ...
+    def __iadd__(self, value: ReadableBuffer, /) -> Self: ...  # type: ignore[override]
+    def __mul__(self, value: SupportsIndex, /) -> bytearray: ...
+    def __rmul__(self, value: SupportsIndex, /) -> bytearray: ...
+    def __imul__(self, value: SupportsIndex, /) -> Self: ...
+    def __mod__(self, value: Any, /) -> bytes: ...
     # Incompatible with Sequence.__contains__
-    def __contains__(self, __key: SupportsIndex | ReadableBuffer) -> bool: ...  # type: ignore[override]
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
-    def __lt__(self, __value: ReadableBuffer) -> bool: ...
-    def __le__(self, __value: ReadableBuffer) -> bool: ...
-    def __gt__(self, __value: ReadableBuffer) -> bool: ...
-    def __ge__(self, __value: ReadableBuffer) -> bool: ...
+    def __contains__(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ...  # type: ignore[override]
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
+    def __lt__(self, value: ReadableBuffer, /) -> bool: ...
+    def __le__(self, value: ReadableBuffer, /) -> bool: ...
+    def __gt__(self, value: ReadableBuffer, /) -> bool: ...
+    def __ge__(self, value: ReadableBuffer, /) -> bool: ...
     def __alloc__(self) -> int: ...
-    def __buffer__(self, __flags: int) -> memoryview: ...
-    def __release_buffer__(self, __buffer: memoryview) -> None: ...
+    def __buffer__(self, flags: int, /) -> memoryview: ...
+    def __release_buffer__(self, buffer: memoryview, /) -> None: ...
 
 @final
 class memoryview(Sequence[int]):
     @property
     def format(self) -> str: ...
     @property
     def itemsize(self) -> int: ...
@@ -746,116 +749,116 @@
     @property
     def contiguous(self) -> bool: ...
     @property
     def nbytes(self) -> int: ...
     def __new__(cls, obj: ReadableBuffer) -> Self: ...
     def __enter__(self) -> Self: ...
     def __exit__(
-        self, __exc_type: type[BaseException] | None, __exc_val: BaseException | None, __exc_tb: TracebackType | None
+        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None, /
     ) -> None: ...
     def cast(self, format: str, shape: list[int] | tuple[int, ...] = ...) -> memoryview: ...
     @overload
-    def __getitem__(self, __key: SupportsIndex | tuple[SupportsIndex, ...]) -> int: ...
+    def __getitem__(self, key: SupportsIndex | tuple[SupportsIndex, ...], /) -> int: ...
     @overload
-    def __getitem__(self, __key: slice) -> memoryview: ...
-    def __contains__(self, __x: object) -> bool: ...
+    def __getitem__(self, key: slice, /) -> memoryview: ...
+    def __contains__(self, x: object, /) -> bool: ...
     def __iter__(self) -> Iterator[int]: ...
     def __len__(self) -> int: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     @overload
-    def __setitem__(self, __key: slice, __value: ReadableBuffer) -> None: ...
+    def __setitem__(self, key: slice, value: ReadableBuffer, /) -> None: ...
     @overload
-    def __setitem__(self, __key: SupportsIndex | tuple[SupportsIndex, ...], __value: SupportsIndex) -> None: ...
+    def __setitem__(self, key: SupportsIndex | tuple[SupportsIndex, ...], value: SupportsIndex, /) -> None: ...
     if sys.version_info >= (3, 10):
         def tobytes(self, order: Literal["C", "F", "A"] | None = "C") -> bytes: ...
     else:
         def tobytes(self, order: Literal["C", "F", "A"] | None = None) -> bytes: ...
 
     def tolist(self) -> list[int]: ...
     def toreadonly(self) -> memoryview: ...
     def release(self) -> None: ...
     def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
-    def __buffer__(self, __flags: int) -> memoryview: ...
-    def __release_buffer__(self, __buffer: memoryview) -> None: ...
+    def __buffer__(self, flags: int, /) -> memoryview: ...
+    def __release_buffer__(self, buffer: memoryview, /) -> None: ...
 
 @final
 class bool(int):
-    def __new__(cls, __o: object = ...) -> Self: ...
+    def __new__(cls, o: object = ..., /) -> Self: ...
     # The following overloads could be represented more elegantly with a TypeVar("_B", bool, int),
     # however mypy has a bug regarding TypeVar constraints (https://github.com/python/mypy/issues/11880).
     @overload
-    def __and__(self, __value: bool) -> bool: ...
+    def __and__(self, value: bool, /) -> bool: ...
     @overload
-    def __and__(self, __value: int) -> int: ...
+    def __and__(self, value: int, /) -> int: ...
     @overload
-    def __or__(self, __value: bool) -> bool: ...
+    def __or__(self, value: bool, /) -> bool: ...
     @overload
-    def __or__(self, __value: int) -> int: ...
+    def __or__(self, value: int, /) -> int: ...
     @overload
-    def __xor__(self, __value: bool) -> bool: ...
+    def __xor__(self, value: bool, /) -> bool: ...
     @overload
-    def __xor__(self, __value: int) -> int: ...
+    def __xor__(self, value: int, /) -> int: ...
     @overload
-    def __rand__(self, __value: bool) -> bool: ...
+    def __rand__(self, value: bool, /) -> bool: ...
     @overload
-    def __rand__(self, __value: int) -> int: ...
+    def __rand__(self, value: int, /) -> int: ...
     @overload
-    def __ror__(self, __value: bool) -> bool: ...
+    def __ror__(self, value: bool, /) -> bool: ...
     @overload
-    def __ror__(self, __value: int) -> int: ...
+    def __ror__(self, value: int, /) -> int: ...
     @overload
-    def __rxor__(self, __value: bool) -> bool: ...
+    def __rxor__(self, value: bool, /) -> bool: ...
     @overload
-    def __rxor__(self, __value: int) -> int: ...
+    def __rxor__(self, value: int, /) -> int: ...
     def __getnewargs__(self) -> tuple[int]: ...
     @deprecated("Will throw an error in Python 3.14. Use `not` for logical negation of bools instead.")
     def __invert__(self) -> int: ...
 
 @final
 class slice:
     @property
     def start(self) -> Any: ...
     @property
     def step(self) -> Any: ...
     @property
     def stop(self) -> Any: ...
     @overload
-    def __new__(cls, __stop: Any) -> Self: ...
+    def __new__(cls, stop: Any, /) -> Self: ...
     @overload
-    def __new__(cls, __start: Any, __stop: Any, __step: Any = ...) -> Self: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __new__(cls, start: Any, stop: Any, step: Any = ..., /) -> Self: ...
+    def __eq__(self, value: object, /) -> bool: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
-    def indices(self, __len: SupportsIndex) -> tuple[int, int, int]: ...
+    def indices(self, len: SupportsIndex, /) -> tuple[int, int, int]: ...
 
 class tuple(Sequence[_T_co]):
-    def __new__(cls, __iterable: Iterable[_T_co] = ...) -> Self: ...
+    def __new__(cls, iterable: Iterable[_T_co] = ..., /) -> Self: ...
     def __len__(self) -> int: ...
-    def __contains__(self, __key: object) -> bool: ...
+    def __contains__(self, key: object, /) -> bool: ...
     @overload
-    def __getitem__(self, __key: SupportsIndex) -> _T_co: ...
+    def __getitem__(self, key: SupportsIndex, /) -> _T_co: ...
     @overload
-    def __getitem__(self, __key: slice) -> tuple[_T_co, ...]: ...
+    def __getitem__(self, key: slice, /) -> tuple[_T_co, ...]: ...
     def __iter__(self) -> Iterator[_T_co]: ...
-    def __lt__(self, __value: tuple[_T_co, ...]) -> bool: ...
-    def __le__(self, __value: tuple[_T_co, ...]) -> bool: ...
-    def __gt__(self, __value: tuple[_T_co, ...]) -> bool: ...
-    def __ge__(self, __value: tuple[_T_co, ...]) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __lt__(self, value: tuple[_T_co, ...], /) -> bool: ...
+    def __le__(self, value: tuple[_T_co, ...], /) -> bool: ...
+    def __gt__(self, value: tuple[_T_co, ...], /) -> bool: ...
+    def __ge__(self, value: tuple[_T_co, ...], /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     @overload
-    def __add__(self, __value: tuple[_T_co, ...]) -> tuple[_T_co, ...]: ...
+    def __add__(self, value: tuple[_T_co, ...], /) -> tuple[_T_co, ...]: ...
     @overload
-    def __add__(self, __value: tuple[_T, ...]) -> tuple[_T_co | _T, ...]: ...
-    def __mul__(self, __value: SupportsIndex) -> tuple[_T_co, ...]: ...
-    def __rmul__(self, __value: SupportsIndex) -> tuple[_T_co, ...]: ...
-    def count(self, __value: Any) -> int: ...
-    def index(self, __value: Any, __start: SupportsIndex = 0, __stop: SupportsIndex = sys.maxsize) -> int: ...
+    def __add__(self, value: tuple[_T, ...], /) -> tuple[_T_co | _T, ...]: ...
+    def __mul__(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...
+    def __rmul__(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...
+    def count(self, value: Any, /) -> int: ...
+    def index(self, value: Any, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 # Doesn't exist at runtime, but deleting this breaks mypy. See #2999
 @final
 @type_check_only
 class function:
     # Make sure this class definition stays roughly in line with `types.FunctionType`
     @property
@@ -873,298 +876,298 @@
         @property
         def __builtins__(self) -> dict[str, Any]: ...
     if sys.version_info >= (3, 12):
         __type_params__: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]
 
     __module__: str
     # mypy uses `builtins.function.__get__` to represent methods, properties, and getset_descriptors so we type the return as Any.
-    def __get__(self, __instance: object, __owner: type | None = None) -> Any: ...
+    def __get__(self, instance: object, owner: type | None = None, /) -> Any: ...
 
 class list(MutableSequence[_T]):
     @overload
     def __init__(self) -> None: ...
     @overload
-    def __init__(self, __iterable: Iterable[_T]) -> None: ...
+    def __init__(self, iterable: Iterable[_T], /) -> None: ...
     def copy(self) -> list[_T]: ...
-    def append(self, __object: _T) -> None: ...
-    def extend(self, __iterable: Iterable[_T]) -> None: ...
-    def pop(self, __index: SupportsIndex = -1) -> _T: ...
+    def append(self, object: _T, /) -> None: ...
+    def extend(self, iterable: Iterable[_T], /) -> None: ...
+    def pop(self, index: SupportsIndex = -1, /) -> _T: ...
     # Signature of `list.index` should be kept in line with `collections.UserList.index()`
     # and multiprocessing.managers.ListProxy.index()
-    def index(self, __value: _T, __start: SupportsIndex = 0, __stop: SupportsIndex = sys.maxsize) -> int: ...
-    def count(self, __value: _T) -> int: ...
-    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...
-    def remove(self, __value: _T) -> None: ...
+    def index(self, value: _T, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...
+    def count(self, value: _T, /) -> int: ...
+    def insert(self, index: SupportsIndex, object: _T, /) -> None: ...
+    def remove(self, value: _T, /) -> None: ...
     # Signature of `list.sort` should be kept inline with `collections.UserList.sort()`
     # and multiprocessing.managers.ListProxy.sort()
     #
     # Use list[SupportsRichComparisonT] for the first overload rather than [SupportsRichComparison]
     # to work around invariance
     @overload
     def sort(self: list[SupportsRichComparisonT], *, key: None = None, reverse: bool = False) -> None: ...
     @overload
     def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> None: ...
     def __len__(self) -> int: ...
     def __iter__(self) -> Iterator[_T]: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
     @overload
-    def __getitem__(self, __i: SupportsIndex) -> _T: ...
+    def __getitem__(self, i: SupportsIndex, /) -> _T: ...
     @overload
-    def __getitem__(self, __s: slice) -> list[_T]: ...
+    def __getitem__(self, s: slice, /) -> list[_T]: ...
     @overload
-    def __setitem__(self, __key: SupportsIndex, __value: _T) -> None: ...
+    def __setitem__(self, key: SupportsIndex, value: _T, /) -> None: ...
     @overload
-    def __setitem__(self, __key: slice, __value: Iterable[_T]) -> None: ...
-    def __delitem__(self, __key: SupportsIndex | slice) -> None: ...
+    def __setitem__(self, key: slice, value: Iterable[_T], /) -> None: ...
+    def __delitem__(self, key: SupportsIndex | slice, /) -> None: ...
     # Overloading looks unnecessary, but is needed to work around complex mypy problems
     @overload
-    def __add__(self, __value: list[_T]) -> list[_T]: ...
+    def __add__(self, value: list[_T], /) -> list[_T]: ...
     @overload
-    def __add__(self, __value: list[_S]) -> list[_S | _T]: ...
-    def __iadd__(self, __value: Iterable[_T]) -> Self: ...  # type: ignore[misc]
-    def __mul__(self, __value: SupportsIndex) -> list[_T]: ...
-    def __rmul__(self, __value: SupportsIndex) -> list[_T]: ...
-    def __imul__(self, __value: SupportsIndex) -> Self: ...
-    def __contains__(self, __key: object) -> bool: ...
+    def __add__(self, value: list[_S], /) -> list[_S | _T]: ...
+    def __iadd__(self, value: Iterable[_T], /) -> Self: ...  # type: ignore[misc]
+    def __mul__(self, value: SupportsIndex, /) -> list[_T]: ...
+    def __rmul__(self, value: SupportsIndex, /) -> list[_T]: ...
+    def __imul__(self, value: SupportsIndex, /) -> Self: ...
+    def __contains__(self, key: object, /) -> bool: ...
     def __reversed__(self) -> Iterator[_T]: ...
-    def __gt__(self, __value: list[_T]) -> bool: ...
-    def __ge__(self, __value: list[_T]) -> bool: ...
-    def __lt__(self, __value: list[_T]) -> bool: ...
-    def __le__(self, __value: list[_T]) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __gt__(self, value: list[_T], /) -> bool: ...
+    def __ge__(self, value: list[_T], /) -> bool: ...
+    def __lt__(self, value: list[_T], /) -> bool: ...
+    def __le__(self, value: list[_T], /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 class dict(MutableMapping[_KT, _VT]):
     # __init__ should be kept roughly in line with `collections.UserDict.__init__`, which has similar semantics
     # Also multiprocessing.managers.SyncManager.dict()
     @overload
     def __init__(self) -> None: ...
     @overload
     def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...
     @overload
-    def __init__(self, __map: SupportsKeysAndGetItem[_KT, _VT]) -> None: ...
+    def __init__(self, map: SupportsKeysAndGetItem[_KT, _VT], /) -> None: ...
     @overload
-    def __init__(self: dict[str, _VT], __map: SupportsKeysAndGetItem[str, _VT], **kwargs: _VT) -> None: ...
+    def __init__(self: dict[str, _VT], map: SupportsKeysAndGetItem[str, _VT], /, **kwargs: _VT) -> None: ...
     @overload
-    def __init__(self, __iterable: Iterable[tuple[_KT, _VT]]) -> None: ...
+    def __init__(self, iterable: Iterable[tuple[_KT, _VT]], /) -> None: ...
     @overload
-    def __init__(self: dict[str, _VT], __iterable: Iterable[tuple[str, _VT]], **kwargs: _VT) -> None: ...
+    def __init__(self: dict[str, _VT], iterable: Iterable[tuple[str, _VT]], /, **kwargs: _VT) -> None: ...
     # Next two overloads are for dict(string.split(sep) for string in iterable)
     # Cannot be Iterable[Sequence[_T]] or otherwise dict(["foo", "bar", "baz"]) is not an error
     @overload
-    def __init__(self: dict[str, str], __iterable: Iterable[list[str]]) -> None: ...
+    def __init__(self: dict[str, str], iterable: Iterable[list[str]], /) -> None: ...
     @overload
-    def __init__(self: dict[bytes, bytes], __iterable: Iterable[list[bytes]]) -> None: ...
+    def __init__(self: dict[bytes, bytes], iterable: Iterable[list[bytes]], /) -> None: ...
     def __new__(cls, *args: Any, **kwargs: Any) -> Self: ...
     def copy(self) -> dict[_KT, _VT]: ...
     def keys(self) -> dict_keys[_KT, _VT]: ...
     def values(self) -> dict_values[_KT, _VT]: ...
     def items(self) -> dict_items[_KT, _VT]: ...
     # Signature of `dict.fromkeys` should be kept identical to `fromkeys` methods of `OrderedDict`/`ChainMap`/`UserDict` in `collections`
     # TODO: the true signature of `dict.fromkeys` is not expressible in the current type system.
     # See #3800 & https://github.com/python/typing/issues/548#issuecomment-683336963.
     @classmethod
     @overload
-    def fromkeys(cls, __iterable: Iterable[_T], __value: None = None) -> dict[_T, Any | None]: ...
+    def fromkeys(cls, iterable: Iterable[_T], value: None = None, /) -> dict[_T, Any | None]: ...
     @classmethod
     @overload
-    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...
+    def fromkeys(cls, iterable: Iterable[_T], value: _S, /) -> dict[_T, _S]: ...
     # Positional-only in dict, but not in MutableMapping
     @overload  # type: ignore[override]
-    def get(self, __key: _KT) -> _VT | None: ...
+    def get(self, key: _KT, /) -> _VT | None: ...
     @overload
-    def get(self, __key: _KT, __default: _VT) -> _VT: ...
+    def get(self, key: _KT, default: _VT, /) -> _VT: ...
     @overload
-    def get(self, __key: _KT, __default: _T) -> _VT | _T: ...
+    def get(self, key: _KT, default: _T, /) -> _VT | _T: ...
     @overload
-    def pop(self, __key: _KT) -> _VT: ...
+    def pop(self, key: _KT, /) -> _VT: ...
     @overload
-    def pop(self, __key: _KT, __default: _VT) -> _VT: ...
+    def pop(self, key: _KT, default: _VT, /) -> _VT: ...
     @overload
-    def pop(self, __key: _KT, __default: _T) -> _VT | _T: ...
+    def pop(self, key: _KT, default: _T, /) -> _VT | _T: ...
     def __len__(self) -> int: ...
-    def __getitem__(self, __key: _KT) -> _VT: ...
-    def __setitem__(self, __key: _KT, __value: _VT) -> None: ...
-    def __delitem__(self, __key: _KT) -> None: ...
+    def __getitem__(self, key: _KT, /) -> _VT: ...
+    def __setitem__(self, key: _KT, value: _VT, /) -> None: ...
+    def __delitem__(self, key: _KT, /) -> None: ...
     def __iter__(self) -> Iterator[_KT]: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __reversed__(self) -> Iterator[_KT]: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
         @overload
-        def __or__(self, __value: dict[_KT, _VT]) -> dict[_KT, _VT]: ...
+        def __or__(self, value: dict[_KT, _VT], /) -> dict[_KT, _VT]: ...
         @overload
-        def __or__(self, __value: dict[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...
+        def __or__(self, value: dict[_T1, _T2], /) -> dict[_KT | _T1, _VT | _T2]: ...
         @overload
-        def __ror__(self, __value: dict[_KT, _VT]) -> dict[_KT, _VT]: ...
+        def __ror__(self, value: dict[_KT, _VT], /) -> dict[_KT, _VT]: ...
         @overload
-        def __ror__(self, __value: dict[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...
+        def __ror__(self, value: dict[_T1, _T2], /) -> dict[_KT | _T1, _VT | _T2]: ...
         # dict.__ior__ should be kept roughly in line with MutableMapping.update()
         @overload  # type: ignore[misc]
-        def __ior__(self, __value: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...
+        def __ior__(self, value: SupportsKeysAndGetItem[_KT, _VT], /) -> Self: ...
         @overload
-        def __ior__(self, __value: Iterable[tuple[_KT, _VT]]) -> Self: ...
+        def __ior__(self, value: Iterable[tuple[_KT, _VT]], /) -> Self: ...
 
 class set(MutableSet[_T]):
     @overload
     def __init__(self) -> None: ...
     @overload
-    def __init__(self, __iterable: Iterable[_T]) -> None: ...
-    def add(self, __element: _T) -> None: ...
+    def __init__(self, iterable: Iterable[_T], /) -> None: ...
+    def add(self, element: _T, /) -> None: ...
     def copy(self) -> set[_T]: ...
     def difference(self, *s: Iterable[Any]) -> set[_T]: ...
     def difference_update(self, *s: Iterable[Any]) -> None: ...
-    def discard(self, __element: _T) -> None: ...
+    def discard(self, element: _T, /) -> None: ...
     def intersection(self, *s: Iterable[Any]) -> set[_T]: ...
     def intersection_update(self, *s: Iterable[Any]) -> None: ...
-    def isdisjoint(self, __s: Iterable[Any]) -> bool: ...
-    def issubset(self, __s: Iterable[Any]) -> bool: ...
-    def issuperset(self, __s: Iterable[Any]) -> bool: ...
-    def remove(self, __element: _T) -> None: ...
-    def symmetric_difference(self, __s: Iterable[_T]) -> set[_T]: ...
-    def symmetric_difference_update(self, __s: Iterable[_T]) -> None: ...
+    def isdisjoint(self, s: Iterable[Any], /) -> bool: ...
+    def issubset(self, s: Iterable[Any], /) -> bool: ...
+    def issuperset(self, s: Iterable[Any], /) -> bool: ...
+    def remove(self, element: _T, /) -> None: ...
+    def symmetric_difference(self, s: Iterable[_T], /) -> set[_T]: ...
+    def symmetric_difference_update(self, s: Iterable[_T], /) -> None: ...
     def union(self, *s: Iterable[_S]) -> set[_T | _S]: ...
     def update(self, *s: Iterable[_T]) -> None: ...
     def __len__(self) -> int: ...
-    def __contains__(self, __o: object) -> bool: ...
+    def __contains__(self, o: object, /) -> bool: ...
     def __iter__(self) -> Iterator[_T]: ...
-    def __and__(self, __value: AbstractSet[object]) -> set[_T]: ...
-    def __iand__(self, __value: AbstractSet[object]) -> Self: ...
-    def __or__(self, __value: AbstractSet[_S]) -> set[_T | _S]: ...
-    def __ior__(self, __value: AbstractSet[_T]) -> Self: ...  # type: ignore[override,misc]
-    def __sub__(self, __value: AbstractSet[_T | None]) -> set[_T]: ...
-    def __isub__(self, __value: AbstractSet[object]) -> Self: ...
-    def __xor__(self, __value: AbstractSet[_S]) -> set[_T | _S]: ...
-    def __ixor__(self, __value: AbstractSet[_T]) -> Self: ...  # type: ignore[override,misc]
-    def __le__(self, __value: AbstractSet[object]) -> bool: ...
-    def __lt__(self, __value: AbstractSet[object]) -> bool: ...
-    def __ge__(self, __value: AbstractSet[object]) -> bool: ...
-    def __gt__(self, __value: AbstractSet[object]) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __and__(self, value: AbstractSet[object], /) -> set[_T]: ...
+    def __iand__(self, value: AbstractSet[object], /) -> Self: ...
+    def __or__(self, value: AbstractSet[_S], /) -> set[_T | _S]: ...
+    def __ior__(self, value: AbstractSet[_T], /) -> Self: ...  # type: ignore[override,misc]
+    def __sub__(self, value: AbstractSet[_T | None], /) -> set[_T]: ...
+    def __isub__(self, value: AbstractSet[object], /) -> Self: ...
+    def __xor__(self, value: AbstractSet[_S], /) -> set[_T | _S]: ...
+    def __ixor__(self, value: AbstractSet[_T], /) -> Self: ...  # type: ignore[override,misc]
+    def __le__(self, value: AbstractSet[object], /) -> bool: ...
+    def __lt__(self, value: AbstractSet[object], /) -> bool: ...
+    def __ge__(self, value: AbstractSet[object], /) -> bool: ...
+    def __gt__(self, value: AbstractSet[object], /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 class frozenset(AbstractSet[_T_co]):
     @overload
     def __new__(cls) -> Self: ...
     @overload
-    def __new__(cls, __iterable: Iterable[_T_co]) -> Self: ...
+    def __new__(cls, iterable: Iterable[_T_co], /) -> Self: ...
     def copy(self) -> frozenset[_T_co]: ...
     def difference(self, *s: Iterable[object]) -> frozenset[_T_co]: ...
     def intersection(self, *s: Iterable[object]) -> frozenset[_T_co]: ...
-    def isdisjoint(self, __s: Iterable[_T_co]) -> bool: ...
-    def issubset(self, __s: Iterable[object]) -> bool: ...
-    def issuperset(self, __s: Iterable[object]) -> bool: ...
-    def symmetric_difference(self, __s: Iterable[_T_co]) -> frozenset[_T_co]: ...
+    def isdisjoint(self, s: Iterable[_T_co], /) -> bool: ...
+    def issubset(self, s: Iterable[object], /) -> bool: ...
+    def issuperset(self, s: Iterable[object], /) -> bool: ...
+    def symmetric_difference(self, s: Iterable[_T_co], /) -> frozenset[_T_co]: ...
     def union(self, *s: Iterable[_S]) -> frozenset[_T_co | _S]: ...
     def __len__(self) -> int: ...
-    def __contains__(self, __o: object) -> bool: ...
+    def __contains__(self, o: object, /) -> bool: ...
     def __iter__(self) -> Iterator[_T_co]: ...
-    def __and__(self, __value: AbstractSet[_T_co]) -> frozenset[_T_co]: ...
-    def __or__(self, __value: AbstractSet[_S]) -> frozenset[_T_co | _S]: ...
-    def __sub__(self, __value: AbstractSet[_T_co]) -> frozenset[_T_co]: ...
-    def __xor__(self, __value: AbstractSet[_S]) -> frozenset[_T_co | _S]: ...
-    def __le__(self, __value: AbstractSet[object]) -> bool: ...
-    def __lt__(self, __value: AbstractSet[object]) -> bool: ...
-    def __ge__(self, __value: AbstractSet[object]) -> bool: ...
-    def __gt__(self, __value: AbstractSet[object]) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __and__(self, value: AbstractSet[_T_co], /) -> frozenset[_T_co]: ...
+    def __or__(self, value: AbstractSet[_S], /) -> frozenset[_T_co | _S]: ...
+    def __sub__(self, value: AbstractSet[_T_co], /) -> frozenset[_T_co]: ...
+    def __xor__(self, value: AbstractSet[_S], /) -> frozenset[_T_co | _S]: ...
+    def __le__(self, value: AbstractSet[object], /) -> bool: ...
+    def __lt__(self, value: AbstractSet[object], /) -> bool: ...
+    def __ge__(self, value: AbstractSet[object], /) -> bool: ...
+    def __gt__(self, value: AbstractSet[object], /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 class enumerate(Iterator[tuple[int, _T]]):
     def __new__(cls, iterable: Iterable[_T], start: int = ...) -> Self: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> tuple[int, _T]: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 @final
 class range(Sequence[int]):
     @property
     def start(self) -> int: ...
     @property
     def stop(self) -> int: ...
     @property
     def step(self) -> int: ...
     @overload
-    def __new__(cls, __stop: SupportsIndex) -> Self: ...
+    def __new__(cls, stop: SupportsIndex, /) -> Self: ...
     @overload
-    def __new__(cls, __start: SupportsIndex, __stop: SupportsIndex, __step: SupportsIndex = ...) -> Self: ...
-    def count(self, __value: int) -> int: ...
-    def index(self, __value: int) -> int: ...  # type: ignore[override]
+    def __new__(cls, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ..., /) -> Self: ...
+    def count(self, value: int, /) -> int: ...
+    def index(self, value: int, /) -> int: ...  # type: ignore[override]
     def __len__(self) -> int: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
-    def __contains__(self, __key: object) -> bool: ...
+    def __contains__(self, key: object, /) -> bool: ...
     def __iter__(self) -> Iterator[int]: ...
     @overload
-    def __getitem__(self, __key: SupportsIndex) -> int: ...
+    def __getitem__(self, key: SupportsIndex, /) -> int: ...
     @overload
-    def __getitem__(self, __key: slice) -> range: ...
+    def __getitem__(self, key: slice, /) -> range: ...
     def __reversed__(self) -> Iterator[int]: ...
 
 class property:
     fget: Callable[[Any], Any] | None
     fset: Callable[[Any, Any], None] | None
     fdel: Callable[[Any], None] | None
     __isabstractmethod__: bool
     def __init__(
         self,
         fget: Callable[[Any], Any] | None = ...,
         fset: Callable[[Any, Any], None] | None = ...,
         fdel: Callable[[Any], None] | None = ...,
         doc: str | None = ...,
     ) -> None: ...
-    def getter(self, __fget: Callable[[Any], Any]) -> property: ...
-    def setter(self, __fset: Callable[[Any, Any], None]) -> property: ...
-    def deleter(self, __fdel: Callable[[Any], None]) -> property: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
-    def __set__(self, __instance: Any, __value: Any) -> None: ...
-    def __delete__(self, __instance: Any) -> None: ...
+    def getter(self, fget: Callable[[Any], Any], /) -> property: ...
+    def setter(self, fset: Callable[[Any, Any], None], /) -> property: ...
+    def deleter(self, fdel: Callable[[Any], None], /) -> property: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
+    def __set__(self, instance: Any, value: Any, /) -> None: ...
+    def __delete__(self, instance: Any, /) -> None: ...
 
 @final
 class _NotImplementedType(Any):
     # A little weird, but typing the __call__ as NotImplemented makes the error message
     # for NotImplemented() much better
-    __call__: NotImplemented  # type: ignore[valid-type]  # pyright: ignore[reportGeneralTypeIssues]
+    __call__: NotImplemented  # type: ignore[valid-type]  # pyright: ignore[reportInvalidTypeForm]
 
 NotImplemented: _NotImplementedType
 
-def abs(__x: SupportsAbs[_T]) -> _T: ...
-def all(__iterable: Iterable[object]) -> bool: ...
-def any(__iterable: Iterable[object]) -> bool: ...
-def ascii(__obj: object) -> str: ...
-def bin(__number: int | SupportsIndex) -> str: ...
+def abs(x: SupportsAbs[_T], /) -> _T: ...
+def all(iterable: Iterable[object], /) -> bool: ...
+def any(iterable: Iterable[object], /) -> bool: ...
+def ascii(obj: object, /) -> str: ...
+def bin(number: int | SupportsIndex, /) -> str: ...
 def breakpoint(*args: Any, **kws: Any) -> None: ...
-def callable(__obj: object) -> TypeGuard[Callable[..., object]]: ...
-def chr(__i: int) -> str: ...
+def callable(obj: object, /) -> TypeGuard[Callable[..., object]]: ...
+def chr(i: int, /) -> str: ...
 
 # We define this here instead of using os.PathLike to avoid import cycle issues.
 # See https://github.com/python/typeshed/pull/991#issuecomment-288160993
 class _PathLike(Protocol[AnyStr_co]):
     def __fspath__(self) -> AnyStr_co: ...
 
 if sys.version_info >= (3, 10):
-    def aiter(__async_iterable: SupportsAiter[_SupportsAnextT]) -> _SupportsAnextT: ...
+    def aiter(async_iterable: SupportsAiter[_SupportsAnextT], /) -> _SupportsAnextT: ...
 
     class _SupportsSynchronousAnext(Protocol[_AwaitableT_co]):
         def __anext__(self) -> _AwaitableT_co: ...
 
     @overload
     # `anext` is not, in fact, an async function. When default is not provided
     # `anext` is just a passthrough for `obj.__anext__`
     # See discussion in #7491 and pure-Python implementation of `anext` at https://github.com/python/cpython/blob/ea786a882b9ed4261eafabad6011bc7ef3b5bf94/Lib/test/test_asyncgen.py#L52-L80
-    def anext(__i: _SupportsSynchronousAnext[_AwaitableT]) -> _AwaitableT: ...
+    def anext(i: _SupportsSynchronousAnext[_AwaitableT], /) -> _AwaitableT: ...
     @overload
-    async def anext(__i: SupportsAnext[_T], __default: _VT) -> _T | _VT: ...
+    async def anext(i: SupportsAnext[_T], default: _VT, /) -> _T | _VT: ...
 
 # compile() returns a CodeType, unless the flags argument includes PyCF_ONLY_AST (=1024),
 # in which case it returns ast.AST. We have overloads for flag 0 (the default) and for
 # explicitly passing PyCF_ONLY_AST. We fall back to Any for other values of flags.
 @overload
 def compile(
     source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,
@@ -1206,183 +1209,186 @@
     dont_inherit: bool = False,
     optimize: int = -1,
     *,
     _feature_version: int = -1,
 ) -> Any: ...
 def copyright() -> None: ...
 def credits() -> None: ...
-def delattr(__obj: object, __name: str) -> None: ...
-def dir(__o: object = ...) -> list[str]: ...
+def delattr(obj: object, name: str, /) -> None: ...
+def dir(o: object = ..., /) -> list[str]: ...
 @overload
-def divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...
+def divmod(x: SupportsDivMod[_T_contra, _T_co], y: _T_contra, /) -> _T_co: ...
 @overload
-def divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...
+def divmod(x: _T_contra, y: SupportsRDivMod[_T_contra, _T_co], /) -> _T_co: ...
 
 # The `globals` argument to `eval` has to be `dict[str, Any]` rather than `dict[str, object]` due to invariance.
 # (The `globals` argument has to be a "real dict", rather than any old mapping, unlike the `locals` argument.)
 def eval(
-    __source: str | ReadableBuffer | CodeType,
-    __globals: dict[str, Any] | None = None,
-    __locals: Mapping[str, object] | None = None,
+    source: str | ReadableBuffer | CodeType, globals: dict[str, Any] | None = None, locals: Mapping[str, object] | None = None, /
 ) -> Any: ...
 
 # Comment above regarding `eval` applies to `exec` as well
 if sys.version_info >= (3, 11):
     def exec(
-        __source: str | ReadableBuffer | CodeType,
-        __globals: dict[str, Any] | None = None,
-        __locals: Mapping[str, object] | None = None,
+        source: str | ReadableBuffer | CodeType,
+        globals: dict[str, Any] | None = None,
+        locals: Mapping[str, object] | None = None,
+        /,
         *,
         closure: tuple[_Cell, ...] | None = None,
     ) -> None: ...
 
 else:
     def exec(
-        __source: str | ReadableBuffer | CodeType,
-        __globals: dict[str, Any] | None = None,
-        __locals: Mapping[str, object] | None = None,
+        source: str | ReadableBuffer | CodeType,
+        globals: dict[str, Any] | None = None,
+        locals: Mapping[str, object] | None = None,
+        /,
     ) -> None: ...
 
 def exit(code: sys._ExitCode = None) -> NoReturn: ...
 
 class filter(Iterator[_T]):
     @overload
-    def __new__(cls, __function: None, __iterable: Iterable[_T | None]) -> Self: ...
+    def __new__(cls, function: None, iterable: Iterable[_T | None], /) -> Self: ...
     @overload
-    def __new__(cls, __function: Callable[[_S], TypeGuard[_T]], __iterable: Iterable[_S]) -> Self: ...
+    def __new__(cls, function: Callable[[_S], TypeGuard[_T]], iterable: Iterable[_S], /) -> Self: ...
     @overload
-    def __new__(cls, __function: Callable[[_T], Any], __iterable: Iterable[_T]) -> Self: ...
+    def __new__(cls, function: Callable[[_T], Any], iterable: Iterable[_T], /) -> Self: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T: ...
 
-def format(__value: object, __format_spec: str = "") -> str: ...
+def format(value: object, format_spec: str = "", /) -> str: ...
 @overload
-def getattr(__o: object, __name: str) -> Any: ...
+def getattr(o: object, name: str, /) -> Any: ...
 
 # While technically covered by the last overload, spelling out the types for None, bool
 # and basic containers help mypy out in some tricky situations involving type context
 # (aka bidirectional inference)
 @overload
-def getattr(__o: object, __name: str, __default: None) -> Any | None: ...
+def getattr(o: object, name: str, default: None, /) -> Any | None: ...
 @overload
-def getattr(__o: object, __name: str, __default: bool) -> Any | bool: ...
+def getattr(o: object, name: str, default: bool, /) -> Any | bool: ...
 @overload
-def getattr(__o: object, __name: str, __default: list[Any]) -> Any | list[Any]: ...
+def getattr(o: object, name: str, default: list[Any], /) -> Any | list[Any]: ...
 @overload
-def getattr(__o: object, __name: str, __default: dict[Any, Any]) -> Any | dict[Any, Any]: ...
+def getattr(o: object, name: str, default: dict[Any, Any], /) -> Any | dict[Any, Any]: ...
 @overload
-def getattr(__o: object, __name: str, __default: _T) -> Any | _T: ...
+def getattr(o: object, name: str, default: _T, /) -> Any | _T: ...
 def globals() -> dict[str, Any]: ...
-def hasattr(__obj: object, __name: str) -> bool: ...
-def hash(__obj: object) -> int: ...
+def hasattr(obj: object, name: str, /) -> bool: ...
+def hash(obj: object, /) -> int: ...
 def help(request: object = ...) -> None: ...
-def hex(__number: int | SupportsIndex) -> str: ...
-def id(__obj: object) -> int: ...
-def input(__prompt: object = "") -> str: ...
+def hex(number: int | SupportsIndex, /) -> str: ...
+def id(obj: object, /) -> int: ...
+def input(prompt: object = "", /) -> str: ...
 
 class _GetItemIterable(Protocol[_T_co]):
-    def __getitem__(self, __i: int) -> _T_co: ...
+    def __getitem__(self, i: int, /) -> _T_co: ...
 
 @overload
-def iter(__object: SupportsIter[_SupportsNextT]) -> _SupportsNextT: ...
+def iter(object: SupportsIter[_SupportsNextT], /) -> _SupportsNextT: ...
 @overload
-def iter(__object: _GetItemIterable[_T]) -> Iterator[_T]: ...
+def iter(object: _GetItemIterable[_T], /) -> Iterator[_T]: ...
 @overload
-def iter(__object: Callable[[], _T | None], __sentinel: None) -> Iterator[_T]: ...
+def iter(object: Callable[[], _T | None], sentinel: None, /) -> Iterator[_T]: ...
 @overload
-def iter(__object: Callable[[], _T], __sentinel: object) -> Iterator[_T]: ...
+def iter(object: Callable[[], _T], sentinel: object, /) -> Iterator[_T]: ...
 
 # Keep this alias in sync with unittest.case._ClassInfo
 if sys.version_info >= (3, 10):
     _ClassInfo: TypeAlias = type | types.UnionType | tuple[_ClassInfo, ...]
 else:
     _ClassInfo: TypeAlias = type | tuple[_ClassInfo, ...]
 
-def isinstance(__obj: object, __class_or_tuple: _ClassInfo) -> bool: ...
-def issubclass(__cls: type, __class_or_tuple: _ClassInfo) -> bool: ...
-def len(__obj: Sized) -> int: ...
+def isinstance(obj: object, class_or_tuple: _ClassInfo, /) -> bool: ...
+def issubclass(cls: type, class_or_tuple: _ClassInfo, /) -> bool: ...
+def len(obj: Sized, /) -> int: ...
 def license() -> None: ...
 def locals() -> dict[str, Any]: ...
 
 class map(Iterator[_S]):
     @overload
-    def __new__(cls, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> Self: ...
+    def __new__(cls, func: Callable[[_T1], _S], iter1: Iterable[_T1], /) -> Self: ...
     @overload
-    def __new__(cls, __func: Callable[[_T1, _T2], _S], __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> Self: ...
+    def __new__(cls, func: Callable[[_T1, _T2], _S], iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> Self: ...
     @overload
     def __new__(
-        cls, __func: Callable[[_T1, _T2, _T3], _S], __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]
+        cls, func: Callable[[_T1, _T2, _T3], _S], iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /
     ) -> Self: ...
     @overload
     def __new__(
         cls,
-        __func: Callable[[_T1, _T2, _T3, _T4], _S],
-        __iter1: Iterable[_T1],
-        __iter2: Iterable[_T2],
-        __iter3: Iterable[_T3],
-        __iter4: Iterable[_T4],
+        func: Callable[[_T1, _T2, _T3, _T4], _S],
+        iter1: Iterable[_T1],
+        iter2: Iterable[_T2],
+        iter3: Iterable[_T3],
+        iter4: Iterable[_T4],
+        /,
     ) -> Self: ...
     @overload
     def __new__(
         cls,
-        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],
-        __iter1: Iterable[_T1],
-        __iter2: Iterable[_T2],
-        __iter3: Iterable[_T3],
-        __iter4: Iterable[_T4],
-        __iter5: Iterable[_T5],
+        func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],
+        iter1: Iterable[_T1],
+        iter2: Iterable[_T2],
+        iter3: Iterable[_T3],
+        iter4: Iterable[_T4],
+        iter5: Iterable[_T5],
+        /,
     ) -> Self: ...
     @overload
     def __new__(
         cls,
-        __func: Callable[..., _S],
-        __iter1: Iterable[Any],
-        __iter2: Iterable[Any],
-        __iter3: Iterable[Any],
-        __iter4: Iterable[Any],
-        __iter5: Iterable[Any],
-        __iter6: Iterable[Any],
+        func: Callable[..., _S],
+        iter1: Iterable[Any],
+        iter2: Iterable[Any],
+        iter3: Iterable[Any],
+        iter4: Iterable[Any],
+        iter5: Iterable[Any],
+        iter6: Iterable[Any],
+        /,
         *iterables: Iterable[Any],
     ) -> Self: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _S: ...
 
 @overload
 def max(
-    __arg1: SupportsRichComparisonT, __arg2: SupportsRichComparisonT, *_args: SupportsRichComparisonT, key: None = None
+    arg1: SupportsRichComparisonT, arg2: SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = None
 ) -> SupportsRichComparisonT: ...
 @overload
-def max(__arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
+def max(arg1: _T, arg2: _T, /, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
 @overload
-def max(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None) -> SupportsRichComparisonT: ...
+def max(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None) -> SupportsRichComparisonT: ...
 @overload
-def max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
+def max(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
 @overload
-def max(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...
+def max(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...
 @overload
-def max(__iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
+def max(iterable: Iterable[_T1], /, *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
 @overload
 def min(
-    __arg1: SupportsRichComparisonT, __arg2: SupportsRichComparisonT, *_args: SupportsRichComparisonT, key: None = None
+    arg1: SupportsRichComparisonT, arg2: SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = None
 ) -> SupportsRichComparisonT: ...
 @overload
-def min(__arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
+def min(arg1: _T, arg2: _T, /, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
 @overload
-def min(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None) -> SupportsRichComparisonT: ...
+def min(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None) -> SupportsRichComparisonT: ...
 @overload
-def min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
+def min(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
 @overload
-def min(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...
+def min(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...
 @overload
-def min(__iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
+def min(iterable: Iterable[_T1], /, *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
 @overload
-def next(__i: SupportsNext[_T]) -> _T: ...
+def next(i: SupportsNext[_T], /) -> _T: ...
 @overload
-def next(__i: SupportsNext[_T], __default: _VT) -> _T | _VT: ...
-def oct(__number: int | SupportsIndex) -> str: ...
+def next(i: SupportsNext[_T], default: _VT, /) -> _T | _VT: ...
+def oct(number: int | SupportsIndex, /) -> str: ...
 
 _Opener: TypeAlias = Callable[[str, int], int]
 
 # Text mode: always returns a TextIOWrapper
 @overload
 def open(
     file: FileDescriptorOrPath,
@@ -1464,15 +1470,15 @@
     buffering: int = -1,
     encoding: str | None = None,
     errors: str | None = None,
     newline: str | None = None,
     closefd: bool = True,
     opener: _Opener | None = None,
 ) -> IO[Any]: ...
-def ord(__c: str | bytes | bytearray) -> int: ...
+def ord(c: str | bytes | bytearray, /) -> int: ...
 
 class _SupportsWriteAndFlush(SupportsWrite[_T_contra], SupportsFlush, Protocol[_T_contra]): ...
 
 @overload
 def print(
     *values: object,
     sep: str | None = " ",
@@ -1485,21 +1491,21 @@
     *values: object, sep: str | None = " ", end: str | None = "\n", file: _SupportsWriteAndFlush[str] | None = None, flush: bool
 ) -> None: ...
 
 _E = TypeVar("_E", contravariant=True)
 _M = TypeVar("_M", contravariant=True)
 
 class _SupportsPow2(Protocol[_E, _T_co]):
-    def __pow__(self, __other: _E) -> _T_co: ...
+    def __pow__(self, other: _E, /) -> _T_co: ...
 
 class _SupportsPow3NoneOnly(Protocol[_E, _T_co]):
-    def __pow__(self, __other: _E, __modulo: None = None) -> _T_co: ...
+    def __pow__(self, other: _E, modulo: None = None, /) -> _T_co: ...
 
 class _SupportsPow3(Protocol[_E, _M, _T_co]):
-    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...
+    def __pow__(self, other: _E, modulo: _M, /) -> _T_co: ...
 
 _SupportsSomeKindOfPow = (  # noqa: Y026  # TODO: Use TypeAlias once mypy bugs are fixed
     _SupportsPow2[Any, Any] | _SupportsPow3NoneOnly[Any, Any] | _SupportsPow3[Any, Any, Any]
 )
 
 # TODO: `pow(int, int, Literal[0])` fails at runtime,
 # but adding a `NoReturn` overload isn't a good solution for expressing that (see #8566).
@@ -1540,150 +1546,142 @@
 def pow(base: _SupportsSomeKindOfPow, exp: float, mod: None = None) -> Any: ...
 @overload
 def pow(base: _SupportsSomeKindOfPow, exp: complex, mod: None = None) -> complex: ...
 def quit(code: sys._ExitCode = None) -> NoReturn: ...
 
 class reversed(Iterator[_T]):
     @overload
-    def __init__(self, __sequence: Reversible[_T]) -> None: ...
+    def __new__(cls, sequence: Reversible[_T], /) -> Iterator[_T]: ...  # type: ignore[misc]
     @overload
-    def __init__(self, __sequence: SupportsLenAndGetItem[_T]) -> None: ...
+    def __new__(cls, sequence: SupportsLenAndGetItem[_T], /) -> Iterator[_T]: ...  # type: ignore[misc]
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T: ...
     def __length_hint__(self) -> int: ...
 
-def repr(__obj: object) -> str: ...
+def repr(obj: object, /) -> str: ...
 
 # See https://github.com/python/typeshed/pull/9141
 # and https://github.com/python/typeshed/pull/9151
 # on why we don't use `SupportsRound` from `typing.pyi`
 
 class _SupportsRound1(Protocol[_T_co]):
     def __round__(self) -> _T_co: ...
 
 class _SupportsRound2(Protocol[_T_co]):
-    def __round__(self, __ndigits: int) -> _T_co: ...
+    def __round__(self, ndigits: int, /) -> _T_co: ...
 
 @overload
 def round(number: _SupportsRound1[_T], ndigits: None = None) -> _T: ...
 @overload
 def round(number: _SupportsRound2[_T], ndigits: SupportsIndex) -> _T: ...
 
 # See https://github.com/python/typeshed/pull/6292#discussion_r748875189
 # for why arg 3 of `setattr` should be annotated with `Any` and not `object`
-def setattr(__obj: object, __name: str, __value: Any) -> None: ...
+def setattr(obj: object, name: str, value: Any, /) -> None: ...
 @overload
 def sorted(
-    __iterable: Iterable[SupportsRichComparisonT], *, key: None = None, reverse: bool = False
+    iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, reverse: bool = False
 ) -> list[SupportsRichComparisonT]: ...
 @overload
-def sorted(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> list[_T]: ...
+def sorted(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> list[_T]: ...
 
 _AddableT1 = TypeVar("_AddableT1", bound=SupportsAdd[Any, Any])
 _AddableT2 = TypeVar("_AddableT2", bound=SupportsAdd[Any, Any])
 
 class _SupportsSumWithNoDefaultGiven(SupportsAdd[Any, Any], SupportsRAdd[int, Any], Protocol): ...
 
 _SupportsSumNoDefaultT = TypeVar("_SupportsSumNoDefaultT", bound=_SupportsSumWithNoDefaultGiven)
 
 # In general, the return type of `x + x` is *not* guaranteed to be the same type as x.
 # However, we can't express that in the stub for `sum()`
 # without creating many false-positive errors (see #7578).
 # Instead, we special-case the most common examples of this: bool and literal integers.
 @overload
-def sum(__iterable: Iterable[bool], start: int = 0) -> int: ...  # type: ignore[overload-overlap]
+def sum(iterable: Iterable[bool], /, start: int = 0) -> int: ...  # type: ignore[overload-overlap]
 @overload
-def sum(__iterable: Iterable[_SupportsSumNoDefaultT]) -> _SupportsSumNoDefaultT | Literal[0]: ...
+def sum(iterable: Iterable[_SupportsSumNoDefaultT], /) -> _SupportsSumNoDefaultT | Literal[0]: ...
 @overload
-def sum(__iterable: Iterable[_AddableT1], start: _AddableT2) -> _AddableT1 | _AddableT2: ...
+def sum(iterable: Iterable[_AddableT1], /, start: _AddableT2) -> _AddableT1 | _AddableT2: ...
 
 # The argument to `vars()` has to have a `__dict__` attribute, so the second overload can't be annotated with `object`
 # (A "SupportsDunderDict" protocol doesn't work)
 # Use a type: ignore to make complaints about overlapping overloads go away
 @overload
-def vars(__object: type) -> types.MappingProxyType[str, Any]: ...  # type: ignore[overload-overlap]
+def vars(object: type, /) -> types.MappingProxyType[str, Any]: ...  # type: ignore[overload-overlap]
 @overload
-def vars(__object: Any = ...) -> dict[str, Any]: ...
+def vars(object: Any = ..., /) -> dict[str, Any]: ...
 
 class zip(Iterator[_T_co]):
     if sys.version_info >= (3, 10):
         @overload
         def __new__(cls, *, strict: bool = ...) -> zip[Any]: ...
         @overload
-        def __new__(cls, __iter1: Iterable[_T1], *, strict: bool = ...) -> zip[tuple[_T1]]: ...
+        def __new__(cls, iter1: Iterable[_T1], /, *, strict: bool = ...) -> zip[tuple[_T1]]: ...
         @overload
-        def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], *, strict: bool = ...) -> zip[tuple[_T1, _T2]]: ...
+        def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /, *, strict: bool = ...) -> zip[tuple[_T1, _T2]]: ...
         @overload
         def __new__(
-            cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], *, strict: bool = ...
+            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /, *, strict: bool = ...
         ) -> zip[tuple[_T1, _T2, _T3]]: ...
         @overload
         def __new__(
-            cls,
-            __iter1: Iterable[_T1],
-            __iter2: Iterable[_T2],
-            __iter3: Iterable[_T3],
-            __iter4: Iterable[_T4],
-            *,
-            strict: bool = ...,
+            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /, *, strict: bool = ...
         ) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...
         @overload
         def __new__(
             cls,
-            __iter1: Iterable[_T1],
-            __iter2: Iterable[_T2],
-            __iter3: Iterable[_T3],
-            __iter4: Iterable[_T4],
-            __iter5: Iterable[_T5],
+            iter1: Iterable[_T1],
+            iter2: Iterable[_T2],
+            iter3: Iterable[_T3],
+            iter4: Iterable[_T4],
+            iter5: Iterable[_T5],
+            /,
             *,
             strict: bool = ...,
         ) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
         @overload
         def __new__(
             cls,
-            __iter1: Iterable[Any],
-            __iter2: Iterable[Any],
-            __iter3: Iterable[Any],
-            __iter4: Iterable[Any],
-            __iter5: Iterable[Any],
-            __iter6: Iterable[Any],
+            iter1: Iterable[Any],
+            iter2: Iterable[Any],
+            iter3: Iterable[Any],
+            iter4: Iterable[Any],
+            iter5: Iterable[Any],
+            iter6: Iterable[Any],
+            /,
             *iterables: Iterable[Any],
             strict: bool = ...,
         ) -> zip[tuple[Any, ...]]: ...
     else:
         @overload
         def __new__(cls) -> zip[Any]: ...
         @overload
-        def __new__(cls, __iter1: Iterable[_T1]) -> zip[tuple[_T1]]: ...
+        def __new__(cls, iter1: Iterable[_T1], /) -> zip[tuple[_T1]]: ...
         @overload
-        def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> zip[tuple[_T1, _T2]]: ...
+        def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> zip[tuple[_T1, _T2]]: ...
         @overload
-        def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]) -> zip[tuple[_T1, _T2, _T3]]: ...
+        def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /) -> zip[tuple[_T1, _T2, _T3]]: ...
         @overload
         def __new__(
-            cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], __iter4: Iterable[_T4]
+            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /
         ) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...
         @overload
         def __new__(
-            cls,
-            __iter1: Iterable[_T1],
-            __iter2: Iterable[_T2],
-            __iter3: Iterable[_T3],
-            __iter4: Iterable[_T4],
-            __iter5: Iterable[_T5],
+            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], iter5: Iterable[_T5], /
         ) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
         @overload
         def __new__(
             cls,
-            __iter1: Iterable[Any],
-            __iter2: Iterable[Any],
-            __iter3: Iterable[Any],
-            __iter4: Iterable[Any],
-            __iter5: Iterable[Any],
-            __iter6: Iterable[Any],
+            iter1: Iterable[Any],
+            iter2: Iterable[Any],
+            iter3: Iterable[Any],
+            iter4: Iterable[Any],
+            iter5: Iterable[Any],
+            iter6: Iterable[Any],
+            /,
             *iterables: Iterable[Any],
         ) -> zip[tuple[Any, ...]]: ...
 
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T_co: ...
 
 # Signature of `builtins.__import__` should be kept identical to `importlib.__import__`
@@ -1691,15 +1689,15 @@
 def __import__(
     name: str,
     globals: Mapping[str, object] | None = None,
     locals: Mapping[str, object] | None = None,
     fromlist: Sequence[str] = (),
     level: int = 0,
 ) -> types.ModuleType: ...
-def __build_class__(__func: Callable[[], _Cell | Any], __name: str, *bases: Any, metaclass: Any = ..., **kwds: Any) -> Any: ...
+def __build_class__(func: Callable[[], _Cell | Any], name: str, /, *bases: Any, metaclass: Any = ..., **kwds: Any) -> Any: ...
 
 if sys.version_info >= (3, 10):
     from types import EllipsisType
 
     # Backwards compatibility hack for folks who relied on the ellipsis type
     # existing in typeshed in Python 3.9 and earlier.
     ellipsis = EllipsisType
@@ -1718,20 +1716,20 @@
 class BaseException:
     args: tuple[Any, ...]
     __cause__: BaseException | None
     __context__: BaseException | None
     __suppress_context__: bool
     __traceback__: TracebackType | None
     def __init__(self, *args: object) -> None: ...
-    def __setstate__(self, __state: dict[str, Any] | None) -> None: ...
-    def with_traceback(self, __tb: TracebackType | None) -> Self: ...
+    def __setstate__(self, state: dict[str, Any] | None, /) -> None: ...
+    def with_traceback(self, tb: TracebackType | None, /) -> Self: ...
     if sys.version_info >= (3, 11):
         # only present after add_note() is called
         __notes__: list[str]
-        def add_note(self, __note: str) -> None: ...
+        def add_note(self, note: str, /) -> None: ...
 
 class GeneratorExit(BaseException): ...
 class KeyboardInterrupt(BaseException): ...
 
 class SystemExit(BaseException):
     code: sys._ExitCode
 
@@ -1775,14 +1773,15 @@
         name_from: str | None  # undocumented
 
 class LookupError(Exception): ...
 class MemoryError(Exception): ...
 
 class NameError(Exception):
     if sys.version_info >= (3, 10):
+        def __init__(self, *args: object, name: str | None = ...) -> None: ...
         name: str
 
 class ReferenceError(Exception): ...
 class RuntimeError(Exception): ...
 
 class StopAsyncIteration(Exception):
     value: Any
@@ -1833,31 +1832,31 @@
 
 class UnicodeDecodeError(UnicodeError):
     encoding: str
     object: bytes
     start: int
     end: int
     reason: str
-    def __init__(self, __encoding: str, __object: ReadableBuffer, __start: int, __end: int, __reason: str) -> None: ...
+    def __init__(self, encoding: str, object: ReadableBuffer, start: int, end: int, reason: str, /) -> None: ...
 
 class UnicodeEncodeError(UnicodeError):
     encoding: str
     object: str
     start: int
     end: int
     reason: str
-    def __init__(self, __encoding: str, __object: str, __start: int, __end: int, __reason: str) -> None: ...
+    def __init__(self, encoding: str, object: str, start: int, end: int, reason: str, /) -> None: ...
 
 class UnicodeTranslateError(UnicodeError):
     encoding: None
     object: str
     start: int
     end: int
     reason: str
-    def __init__(self, __object: str, __start: int, __end: int, __reason: str) -> None: ...
+    def __init__(self, object: str, start: int, end: int, reason: str, /) -> None: ...
 
 class Warning(Exception): ...
 class UserWarning(Warning): ...
 class DeprecationWarning(Warning): ...
 class SyntaxWarning(Warning): ...
 class RuntimeWarning(Warning): ...
 class FutureWarning(Warning): ...
@@ -1874,64 +1873,64 @@
     _BaseExceptionT_co = TypeVar("_BaseExceptionT_co", bound=BaseException, covariant=True)
     _BaseExceptionT = TypeVar("_BaseExceptionT", bound=BaseException)
     _ExceptionT_co = TypeVar("_ExceptionT_co", bound=Exception, covariant=True)
     _ExceptionT = TypeVar("_ExceptionT", bound=Exception)
 
     # See `check_exception_group.py` for use-cases and comments.
     class BaseExceptionGroup(BaseException, Generic[_BaseExceptionT_co]):
-        def __new__(cls, __message: str, __exceptions: Sequence[_BaseExceptionT_co]) -> Self: ...
-        def __init__(self, __message: str, __exceptions: Sequence[_BaseExceptionT_co]) -> None: ...
+        def __new__(cls, message: str, exceptions: Sequence[_BaseExceptionT_co], /) -> Self: ...
+        def __init__(self, message: str, exceptions: Sequence[_BaseExceptionT_co], /) -> None: ...
         @property
         def message(self) -> str: ...
         @property
         def exceptions(self) -> tuple[_BaseExceptionT_co | BaseExceptionGroup[_BaseExceptionT_co], ...]: ...
         @overload
         def subgroup(
-            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]
+            self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
         ) -> ExceptionGroup[_ExceptionT] | None: ...
         @overload
         def subgroup(
-            self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]
+            self, condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...], /
         ) -> BaseExceptionGroup[_BaseExceptionT] | None: ...
         @overload
         def subgroup(
-            self, __condition: Callable[[_BaseExceptionT_co | Self], bool]
+            self, condition: Callable[[_BaseExceptionT_co | Self], bool], /
         ) -> BaseExceptionGroup[_BaseExceptionT_co] | None: ...
         @overload
         def split(
-            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]
+            self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
         ) -> tuple[ExceptionGroup[_ExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
         @overload
         def split(
-            self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]
+            self, condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...], /
         ) -> tuple[BaseExceptionGroup[_BaseExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
         @overload
         def split(
-            self, __condition: Callable[[_BaseExceptionT_co | Self], bool]
+            self, condition: Callable[[_BaseExceptionT_co | Self], bool], /
         ) -> tuple[BaseExceptionGroup[_BaseExceptionT_co] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
         # In reality it is `NonEmptySequence`:
         @overload
-        def derive(self, __excs: Sequence[_ExceptionT]) -> ExceptionGroup[_ExceptionT]: ...
+        def derive(self, excs: Sequence[_ExceptionT], /) -> ExceptionGroup[_ExceptionT]: ...
         @overload
-        def derive(self, __excs: Sequence[_BaseExceptionT]) -> BaseExceptionGroup[_BaseExceptionT]: ...
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def derive(self, excs: Sequence[_BaseExceptionT], /) -> BaseExceptionGroup[_BaseExceptionT]: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
     class ExceptionGroup(BaseExceptionGroup[_ExceptionT_co], Exception):
-        def __new__(cls, __message: str, __exceptions: Sequence[_ExceptionT_co]) -> Self: ...
-        def __init__(self, __message: str, __exceptions: Sequence[_ExceptionT_co]) -> None: ...
+        def __new__(cls, message: str, exceptions: Sequence[_ExceptionT_co], /) -> Self: ...
+        def __init__(self, message: str, exceptions: Sequence[_ExceptionT_co], /) -> None: ...
         @property
         def exceptions(self) -> tuple[_ExceptionT_co | ExceptionGroup[_ExceptionT_co], ...]: ...
         # We accept a narrower type, but that's OK.
         @overload  # type: ignore[override]
         def subgroup(
-            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]
+            self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
         ) -> ExceptionGroup[_ExceptionT] | None: ...
         @overload
-        def subgroup(self, __condition: Callable[[_ExceptionT_co | Self], bool]) -> ExceptionGroup[_ExceptionT_co] | None: ...
+        def subgroup(self, condition: Callable[[_ExceptionT_co | Self], bool], /) -> ExceptionGroup[_ExceptionT_co] | None: ...
         @overload  # type: ignore[override]
         def split(
-            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]
+            self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
         ) -> tuple[ExceptionGroup[_ExceptionT] | None, ExceptionGroup[_ExceptionT_co] | None]: ...
         @overload
         def split(
-            self, __condition: Callable[[_ExceptionT_co | Self], bool]
+            self, condition: Callable[[_ExceptionT_co | Self], bool], /
         ) -> tuple[ExceptionGroup[_ExceptionT_co] | None, ExceptionGroup[_ExceptionT_co] | None]: ...
```

## puya/_typeshed/stdlib/sys/__init__.pyi

```diff
@@ -13,17 +13,15 @@
 
 # see https://github.com/python/typeshed/issues/8513#issue-1333671093 for the rationale behind this alias
 _ExitCode: TypeAlias = str | int | None
 _OptExcInfo: TypeAlias = OptExcInfo  # noqa: Y047  # TODO: obsolete, remove fall 2022 or later
 
 # Intentionally omits one deprecated and one optional method of `importlib.abc.MetaPathFinder`
 class _MetaPathFinder(Protocol):
-    def find_spec(
-        self, __fullname: str, __path: Sequence[str] | None, __target: ModuleType | None = ...
-    ) -> ModuleSpec | None: ...
+    def find_spec(self, fullname: str, path: Sequence[str] | None, target: ModuleType | None = ..., /) -> ModuleSpec | None: ...
 
 # ----- sys variables -----
 if sys.platform != "win32":
     abiflags: str
 argv: list[str]
 base_exec_prefix: str
 base_prefix: str
@@ -38,14 +36,16 @@
 exec_prefix: str
 executable: str
 float_repr_style: Literal["short", "legacy"]
 hexversion: int
 last_type: type[BaseException] | None
 last_value: BaseException | None
 last_traceback: TracebackType | None
+if sys.version_info >= (3, 12):
+    last_exc: BaseException  # or undefined.
 maxsize: int
 maxunicode: int
 meta_path: list[_MetaPathFinder]
 modules: dict[str, ModuleType]
 if sys.version_info >= (3, 10):
     orig_argv: list[str]
 path: list[str]
@@ -239,36 +239,36 @@
     @property
     def releaselevel(self) -> _ReleaseLevel: ...
     @property
     def serial(self) -> int: ...
 
 version_info: _version_info
 
-def call_tracing(__func: Callable[..., _T], __args: Any) -> _T: ...
+def call_tracing(func: Callable[..., _T], args: Any, /) -> _T: ...
 def _clear_type_cache() -> None: ...
 def _current_frames() -> dict[int, FrameType]: ...
-def _getframe(__depth: int = 0) -> FrameType: ...
+def _getframe(depth: int = 0, /) -> FrameType: ...
 def _debugmallocstats() -> None: ...
-def __displayhook__(__object: object) -> None: ...
-def __excepthook__(__exctype: type[BaseException], __value: BaseException, __traceback: TracebackType | None) -> None: ...
+def __displayhook__(object: object, /) -> None: ...
+def __excepthook__(exctype: type[BaseException], value: BaseException, traceback: TracebackType | None, /) -> None: ...
 def exc_info() -> OptExcInfo: ...
 
 if sys.version_info >= (3, 11):
     def exception() -> BaseException | None: ...
 
-def exit(__status: _ExitCode = None) -> NoReturn: ...
+def exit(status: _ExitCode = None, /) -> NoReturn: ...
 def getallocatedblocks() -> int: ...
 def getdefaultencoding() -> str: ...
 
 if sys.platform != "win32":
     def getdlopenflags() -> int: ...
 
 def getfilesystemencoding() -> str: ...
 def getfilesystemencodeerrors() -> str: ...
-def getrefcount(__object: Any) -> int: ...
+def getrefcount(object: Any, /) -> int: ...
 def getrecursionlimit() -> int: ...
 def getsizeof(obj: object, default: int = ...) -> int: ...
 def getswitchinterval() -> float: ...
 def getprofile() -> ProfileFunction | None: ...
 def setprofile(profilefunc: ProfileFunction | None) -> None: ...
 def gettrace() -> TraceFunction | None: ...
 def settrace(tracefunc: TraceFunction | None) -> None: ...
@@ -296,30 +296,30 @@
         @property
         def product_type(self) -> int: ...
         @property
         def platform_version(self) -> tuple[int, int, int]: ...
 
     def getwindowsversion() -> _WinVersion: ...
 
-def intern(__string: str) -> str: ...
+def intern(string: str, /) -> str: ...
 def is_finalizing() -> bool: ...
 def breakpointhook(*args: Any, **kwargs: Any) -> Any: ...
 
 __breakpointhook__ = breakpointhook  # Contains the original value of breakpointhook
 
 if sys.platform != "win32":
-    def setdlopenflags(__flags: int) -> None: ...
+    def setdlopenflags(flags: int, /) -> None: ...
 
-def setrecursionlimit(__limit: int) -> None: ...
-def setswitchinterval(__interval: float) -> None: ...
+def setrecursionlimit(limit: int, /) -> None: ...
+def setswitchinterval(interval: float, /) -> None: ...
 def gettotalrefcount() -> int: ...  # Debug builds only
 
 if sys.version_info < (3, 9):
     def getcheckinterval() -> int: ...  # deprecated
-    def setcheckinterval(__n: int) -> None: ...  # deprecated
+    def setcheckinterval(n: int, /) -> None: ...  # deprecated
 
 if sys.version_info < (3, 9):
     # An 11-tuple or None
     def callstats() -> tuple[int, int, int, int, int, int, int, int, int, int, int] | None: ...
 
 # Doesn't exist at runtime, but exported in the stubs so pytest etc. can annotate their code more easily.
 class UnraisableHookArgs(Protocol):
@@ -327,17 +327,17 @@
     exc_value: BaseException | None
     exc_traceback: TracebackType | None
     err_msg: str | None
     object: _object
 
 unraisablehook: Callable[[UnraisableHookArgs], Any]
 
-def __unraisablehook__(__unraisable: UnraisableHookArgs) -> Any: ...
+def __unraisablehook__(unraisable: UnraisableHookArgs, /) -> Any: ...
 def addaudithook(hook: Callable[[str, tuple[Any, ...]], Any]) -> None: ...
-def audit(__event: str, *args: Any) -> None: ...
+def audit(event: str, /, *args: Any) -> None: ...
 
 _AsyncgenHook: TypeAlias = Callable[[AsyncGenerator[Any, Any]], None] | None
 
 @final
 class _asyncgen_hooks(structseq[_AsyncgenHook], tuple[_AsyncgenHook, _AsyncgenHook]):
     @property
     def firstiter(self) -> _AsyncgenHook: ...
@@ -360,14 +360,14 @@
 
 if sys.version_info >= (3, 12):
     def getunicodeinternedsize() -> int: ...
     def deactivate_stack_trampoline() -> None: ...
     def is_stack_trampoline_active() -> bool: ...
     # It always exists, but raises on non-linux platforms:
     if sys.platform == "linux":
-        def activate_stack_trampoline(__backend: str) -> None: ...
+        def activate_stack_trampoline(backend: str, /) -> None: ...
     else:
-        def activate_stack_trampoline(__backend: str) -> NoReturn: ...
+        def activate_stack_trampoline(backend: str, /) -> NoReturn: ...
 
     from . import _monitoring
 
     monitoring = _monitoring
```

## puya/_typeshed/stdlib/types.pyi

```diff
@@ -13,15 +13,15 @@
     MutableSequence,
     ValuesView,
 )
 from importlib.machinery import ModuleSpec
 
 # pytype crashes if types.MappingProxyType inherits from collections.abc.Mapping instead of typing.Mapping
 from typing import Any, ClassVar, Literal, Mapping, Protocol, TypeVar, final, overload  # noqa: Y022
-from typing_extensions import ParamSpec, Self, TypeVarTuple
+from typing_extensions import ParamSpec, Self, TypeVarTuple, deprecated
 
 __all__ = [
     "FunctionType",
     "LambdaType",
     "CodeType",
     "MappingProxyType",
     "SimpleNamespace",
@@ -62,16 +62,16 @@
 _T1 = TypeVar("_T1")
 _T2 = TypeVar("_T2")
 _KT = TypeVar("_KT")
 _VT_co = TypeVar("_VT_co", covariant=True)
 
 @final
 class _Cell:
-    def __new__(cls, __contents: object = ...) -> Self: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __new__(cls, contents: object = ..., /) -> Self: ...
+    def __eq__(self, value: object, /) -> bool: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
     cell_contents: Any
 
 # Make sure this class definition stays roughly in line with `builtins.function`
 @final
 class FunctionType:
     @property
@@ -98,23 +98,23 @@
         globals: dict[str, Any],
         name: str | None = ...,
         argdefs: tuple[object, ...] | None = ...,
         closure: tuple[_Cell, ...] | None = ...,
     ) -> Self: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
     @overload
-    def __get__(self, __instance: None, __owner: type) -> FunctionType: ...
+    def __get__(self, instance: None, owner: type, /) -> FunctionType: ...
     @overload
-    def __get__(self, __instance: object, __owner: type | None = None) -> MethodType: ...
+    def __get__(self, instance: object, owner: type | None = None, /) -> MethodType: ...
 
 LambdaType = FunctionType
 
 @final
 class CodeType:
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     @property
     def co_argcount(self) -> int: ...
     @property
     def co_posonlyargcount(self) -> int: ...
     @property
     def co_kwonlyargcount(self) -> int: ...
@@ -134,16 +134,22 @@
     def co_varnames(self) -> tuple[str, ...]: ...
     @property
     def co_filename(self) -> str: ...
     @property
     def co_name(self) -> str: ...
     @property
     def co_firstlineno(self) -> int: ...
-    @property
-    def co_lnotab(self) -> bytes: ...
+    if sys.version_info >= (3, 10):
+        @property
+        @deprecated("Will be removed in Python 3.14. Use the co_lines() method instead.")
+        def co_lnotab(self) -> bytes: ...
+    else:
+        @property
+        def co_lnotab(self) -> bytes: ...
+
     @property
     def co_freevars(self) -> tuple[str, ...]: ...
     @property
     def co_cellvars(self) -> tuple[str, ...]: ...
     if sys.version_info >= (3, 10):
         @property
         def co_linetable(self) -> bytes: ...
@@ -154,72 +160,75 @@
         @property
         def co_qualname(self) -> str: ...
         def co_positions(self) -> Iterable[tuple[int | None, int | None, int | None, int | None]]: ...
 
     if sys.version_info >= (3, 11):
         def __new__(
             cls,
-            __argcount: int,
-            __posonlyargcount: int,
-            __kwonlyargcount: int,
-            __nlocals: int,
-            __stacksize: int,
-            __flags: int,
-            __codestring: bytes,
-            __constants: tuple[object, ...],
-            __names: tuple[str, ...],
-            __varnames: tuple[str, ...],
-            __filename: str,
-            __name: str,
-            __qualname: str,
-            __firstlineno: int,
-            __linetable: bytes,
-            __exceptiontable: bytes,
-            __freevars: tuple[str, ...] = ...,
-            __cellvars: tuple[str, ...] = ...,
+            argcount: int,
+            posonlyargcount: int,
+            kwonlyargcount: int,
+            nlocals: int,
+            stacksize: int,
+            flags: int,
+            codestring: bytes,
+            constants: tuple[object, ...],
+            names: tuple[str, ...],
+            varnames: tuple[str, ...],
+            filename: str,
+            name: str,
+            qualname: str,
+            firstlineno: int,
+            linetable: bytes,
+            exceptiontable: bytes,
+            freevars: tuple[str, ...] = ...,
+            cellvars: tuple[str, ...] = ...,
+            /,
         ) -> Self: ...
     elif sys.version_info >= (3, 10):
         def __new__(
             cls,
-            __argcount: int,
-            __posonlyargcount: int,
-            __kwonlyargcount: int,
-            __nlocals: int,
-            __stacksize: int,
-            __flags: int,
-            __codestring: bytes,
-            __constants: tuple[object, ...],
-            __names: tuple[str, ...],
-            __varnames: tuple[str, ...],
-            __filename: str,
-            __name: str,
-            __firstlineno: int,
-            __linetable: bytes,
-            __freevars: tuple[str, ...] = ...,
-            __cellvars: tuple[str, ...] = ...,
+            argcount: int,
+            posonlyargcount: int,
+            kwonlyargcount: int,
+            nlocals: int,
+            stacksize: int,
+            flags: int,
+            codestring: bytes,
+            constants: tuple[object, ...],
+            names: tuple[str, ...],
+            varnames: tuple[str, ...],
+            filename: str,
+            name: str,
+            firstlineno: int,
+            linetable: bytes,
+            freevars: tuple[str, ...] = ...,
+            cellvars: tuple[str, ...] = ...,
+            /,
         ) -> Self: ...
     else:
         def __new__(
             cls,
-            __argcount: int,
-            __posonlyargcount: int,
-            __kwonlyargcount: int,
-            __nlocals: int,
-            __stacksize: int,
-            __flags: int,
-            __codestring: bytes,
-            __constants: tuple[object, ...],
-            __names: tuple[str, ...],
-            __varnames: tuple[str, ...],
-            __filename: str,
-            __name: str,
-            __firstlineno: int,
-            __lnotab: bytes,
-            __freevars: tuple[str, ...] = ...,
-            __cellvars: tuple[str, ...] = ...,
+            argcount: int,
+            posonlyargcount: int,
+            kwonlyargcount: int,
+            nlocals: int,
+            stacksize: int,
+            flags: int,
+            codestring: bytes,
+            constants: tuple[object, ...],
+            names: tuple[str, ...],
+            varnames: tuple[str, ...],
+            filename: str,
+            name: str,
+            firstlineno: int,
+            lnotab: bytes,
+            freevars: tuple[str, ...] = ...,
+            cellvars: tuple[str, ...] = ...,
+            /,
         ) -> Self: ...
     if sys.version_info >= (3, 11):
         def replace(
             self,
             *,
             co_argcount: int = -1,
             co_posonlyargcount: int = -1,
@@ -283,38 +292,38 @@
             co_lnotab: bytes = ...,
         ) -> CodeType: ...
 
 @final
 class MappingProxyType(Mapping[_KT, _VT_co]):
     __hash__: ClassVar[None]  # type: ignore[assignment]
     def __new__(cls, mapping: SupportsKeysAndGetItem[_KT, _VT_co]) -> Self: ...
-    def __getitem__(self, __key: _KT) -> _VT_co: ...
+    def __getitem__(self, key: _KT, /) -> _VT_co: ...
     def __iter__(self) -> Iterator[_KT]: ...
     def __len__(self) -> int: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def copy(self) -> dict[_KT, _VT_co]: ...
     def keys(self) -> KeysView[_KT]: ...
     def values(self) -> ValuesView[_VT_co]: ...
     def items(self) -> ItemsView[_KT, _VT_co]: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
         def __reversed__(self) -> Iterator[_KT]: ...
-        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT_co | _T2]: ...
-        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT_co | _T2]: ...
+        def __or__(self, value: Mapping[_T1, _T2], /) -> dict[_KT | _T1, _VT_co | _T2]: ...
+        def __ror__(self, value: Mapping[_T1, _T2], /) -> dict[_KT | _T1, _VT_co | _T2]: ...
 
 class SimpleNamespace:
     __hash__: ClassVar[None]  # type: ignore[assignment]
     def __init__(self, **kwargs: Any) -> None: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __getattribute__(self, __name: str) -> Any: ...
-    def __setattr__(self, __name: str, __value: Any) -> None: ...
-    def __delattr__(self, __name: str) -> None: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __getattribute__(self, name: str, /) -> Any: ...
+    def __setattr__(self, name: str, value: Any, /) -> None: ...
+    def __delattr__(self, name: str, /) -> None: ...
 
 class _LoaderProtocol(Protocol):
-    def load_module(self, __fullname: str) -> ModuleType: ...
+    def load_module(self, fullname: str, /) -> ModuleType: ...
 
 class ModuleType:
     __name__: str
     __file__: str | None
     @property
     def __dict__(self) -> dict[str, Any]: ...  # type: ignore[override]
     __loader__: _LoaderProtocol | None
@@ -338,64 +347,64 @@
     if sys.version_info >= (3, 11):
         @property
         def gi_suspended(self) -> bool: ...
     __name__: str
     __qualname__: str
     def __iter__(self) -> Self: ...
     def __next__(self) -> _YieldT_co: ...
-    def send(self, __arg: _SendT_contra) -> _YieldT_co: ...
+    def send(self, arg: _SendT_contra, /) -> _YieldT_co: ...
     @overload
     def throw(
-        self, __typ: type[BaseException], __val: BaseException | object = ..., __tb: TracebackType | None = ...
+        self, typ: type[BaseException], val: BaseException | object = ..., tb: TracebackType | None = ..., /
     ) -> _YieldT_co: ...
     @overload
-    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = ...) -> _YieldT_co: ...
+    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = ..., /) -> _YieldT_co: ...
 
 @final
 class AsyncGeneratorType(AsyncGenerator[_YieldT_co, _SendT_contra]):
     @property
     def ag_await(self) -> Awaitable[Any] | None: ...
     __name__: str
     __qualname__: str
     if sys.version_info >= (3, 12):
         @property
         def ag_suspended(self) -> bool: ...
 
     def __aiter__(self) -> Self: ...
     def __anext__(self) -> Coroutine[Any, Any, _YieldT_co]: ...
-    def asend(self, __val: _SendT_contra) -> Coroutine[Any, Any, _YieldT_co]: ...
+    def asend(self, val: _SendT_contra, /) -> Coroutine[Any, Any, _YieldT_co]: ...
     @overload
     async def athrow(
-        self, __typ: type[BaseException], __val: BaseException | object = ..., __tb: TracebackType | None = ...
+        self, typ: type[BaseException], val: BaseException | object = ..., tb: TracebackType | None = ..., /
     ) -> _YieldT_co: ...
     @overload
-    async def athrow(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = ...) -> _YieldT_co: ...
+    async def athrow(self, typ: BaseException, val: None = None, tb: TracebackType | None = ..., /) -> _YieldT_co: ...
     def aclose(self) -> Coroutine[Any, Any, None]: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 @final
 class CoroutineType(Coroutine[_YieldT_co, _SendT_contra, _ReturnT_co]):
     __name__: str
     __qualname__: str
     @property
     def cr_origin(self) -> tuple[tuple[str, int, str], ...] | None: ...
     if sys.version_info >= (3, 11):
         @property
         def cr_suspended(self) -> bool: ...
 
     def close(self) -> None: ...
     def __await__(self) -> Generator[Any, None, _ReturnT_co]: ...
-    def send(self, __arg: _SendT_contra) -> _YieldT_co: ...
+    def send(self, arg: _SendT_contra, /) -> _YieldT_co: ...
     @overload
     def throw(
-        self, __typ: type[BaseException], __val: BaseException | object = ..., __tb: TracebackType | None = ...
+        self, typ: type[BaseException], val: BaseException | object = ..., tb: TracebackType | None = ..., /
     ) -> _YieldT_co: ...
     @overload
-    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = ...) -> _YieldT_co: ...
+    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = ..., /) -> _YieldT_co: ...
 
 @final
 class MethodType:
     @property
     def __closure__(self) -> tuple[_Cell, ...] | None: ...  # inherited from the added function
     @property
     def __defaults__(self) -> tuple[Any, ...] | None: ...  # inherited from the added function
@@ -403,80 +412,80 @@
     def __func__(self) -> Callable[..., Any]: ...
     @property
     def __self__(self) -> object: ...
     @property
     def __name__(self) -> str: ...  # inherited from the added function
     @property
     def __qualname__(self) -> str: ...  # inherited from the added function
-    def __new__(cls, __func: Callable[..., Any], __obj: object) -> Self: ...
+    def __new__(cls, func: Callable[..., Any], obj: object, /) -> Self: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
 
 @final
 class BuiltinFunctionType:
     @property
     def __self__(self) -> object | ModuleType: ...
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
 
 BuiltinMethodType = BuiltinFunctionType
 
 @final
 class WrapperDescriptorType:
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
 
 @final
 class MethodWrapperType:
     @property
     def __self__(self) -> object: ...
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
 
 @final
 class MethodDescriptorType:
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
 
 @final
 class ClassMethodDescriptorType:
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
 
 @final
 class TracebackType:
     def __new__(cls, tb_next: TracebackType | None, tb_frame: FrameType, tb_lasti: int, tb_lineno: int) -> Self: ...
     tb_next: TracebackType | None
     # the rest are read-only
     @property
@@ -514,43 +523,43 @@
 class GetSetDescriptorType:
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
-    def __set__(self, __instance: Any, __value: Any) -> None: ...
-    def __delete__(self, __instance: Any) -> None: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
+    def __set__(self, instance: Any, value: Any, /) -> None: ...
+    def __delete__(self, instance: Any, /) -> None: ...
 
 @final
 class MemberDescriptorType:
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
-    def __set__(self, __instance: Any, __value: Any) -> None: ...
-    def __delete__(self, __instance: Any) -> None: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
+    def __set__(self, instance: Any, value: Any, /) -> None: ...
+    def __delete__(self, instance: Any, /) -> None: ...
 
 def new_class(
     name: str,
     bases: Iterable[object] = (),
     kwds: dict[str, Any] | None = None,
     exec_body: Callable[[dict[str, Any]], object] | None = None,
 ) -> type: ...
 def resolve_bases(bases: Iterable[object]) -> tuple[Any, ...]: ...
 def prepare_class(
     name: str, bases: tuple[type, ...] = (), kwds: dict[str, Any] | None = None
 ) -> tuple[type, dict[str, Any], dict[str, Any]]: ...
 
 if sys.version_info >= (3, 12):
-    def get_original_bases(__cls: type) -> tuple[Any, ...]: ...
+    def get_original_bases(cls: type, /) -> tuple[Any, ...]: ...
 
 # Actually a different type, but `property` is special and we want that too.
 DynamicClassAttribute = property
 
 _Fn = TypeVar("_Fn", bound=Callable[..., object])
 _R = TypeVar("_R")
 _P = ParamSpec("_P")
@@ -568,16 +577,16 @@
         @property
         def __origin__(self) -> type: ...
         @property
         def __args__(self) -> tuple[Any, ...]: ...
         @property
         def __parameters__(self) -> tuple[Any, ...]: ...
         def __new__(cls, origin: type, args: Any) -> Self: ...
-        def __getitem__(self, __typeargs: Any) -> GenericAlias: ...
-        def __eq__(self, __value: object) -> bool: ...
+        def __getitem__(self, typeargs: Any, /) -> GenericAlias: ...
+        def __eq__(self, value: object, /) -> bool: ...
         def __hash__(self) -> int: ...
         if sys.version_info >= (3, 11):
             @property
             def __unpacked__(self) -> bool: ...
             @property
             def __typing_unpacked_tuple_args__(self) -> tuple[Any, ...] | None: ...
 
@@ -595,11 +604,11 @@
     from builtins import _NotImplementedType
 
     NotImplementedType = _NotImplementedType
     @final
     class UnionType:
         @property
         def __args__(self) -> tuple[Any, ...]: ...
-        def __or__(self, __value: Any) -> UnionType: ...
-        def __ror__(self, __value: Any) -> UnionType: ...
-        def __eq__(self, __value: object) -> bool: ...
+        def __or__(self, value: Any, /) -> UnionType: ...
+        def __ror__(self, value: Any, /) -> UnionType: ...
+        def __eq__(self, value: object, /) -> bool: ...
         def __hash__(self) -> int: ...
```

## puya/_typeshed/stdlib/typing.pyi

```diff
@@ -1,14 +1,16 @@
+# Since this module defines "overload" it is not recognized by Ruff as typing.overload
+# ruff: noqa: F811
 # TODO: The collections import is required, otherwise mypy crashes.
 # https://github.com/python/mypy/issues/16744
 import collections  # noqa: F401  # pyright: ignore
 import sys
 import typing_extensions
 from _collections_abc import dict_items, dict_keys, dict_values
-from _typeshed import IdentityFunction, Incomplete, ReadableBuffer, SupportsKeysAndGetItem
+from _typeshed import IdentityFunction, ReadableBuffer, SupportsKeysAndGetItem
 from abc import ABCMeta, abstractmethod
 from contextlib import AbstractAsyncContextManager, AbstractContextManager
 from re import Match as Match, Pattern as Pattern
 from types import (
     BuiltinFunctionType,
     CodeType,
     FrameType,
@@ -164,15 +166,15 @@
         def __init__(
             self, name: str, *constraints: Any, bound: Any | None = None, covariant: bool = False, contravariant: bool = False
         ) -> None: ...
     if sys.version_info >= (3, 10):
         def __or__(self, right: Any) -> _SpecialForm: ...
         def __ror__(self, left: Any) -> _SpecialForm: ...
     if sys.version_info >= (3, 11):
-        def __typing_subst__(self, arg: Incomplete) -> Incomplete: ...
+        def __typing_subst__(self, arg: Any) -> Any: ...
 
 # Used for an undocumented mypy feature. Does not exist at runtime.
 _promote = object()
 
 # N.B. Keep this definition in sync with typing_extensions._SpecialForm
 @final
 class _SpecialForm:
@@ -215,15 +217,15 @@
     @final
     class TypeVarTuple:
         @property
         def __name__(self) -> str: ...
         def __init__(self, name: str) -> None: ...
         def __iter__(self) -> Any: ...
         def __typing_subst__(self, arg: Never) -> Never: ...
-        def __typing_prepare_subst__(self, alias: Incomplete, args: Incomplete) -> Incomplete: ...
+        def __typing_prepare_subst__(self, alias: Any, args: Any) -> tuple[Any, ...]: ...
 
 if sys.version_info >= (3, 10):
     @final
     class ParamSpecArgs:
         @property
         def __origin__(self) -> ParamSpec: ...
         def __init__(self, origin: ParamSpec) -> None: ...
@@ -264,34 +266,35 @@
             ) -> None: ...
 
         @property
         def args(self) -> ParamSpecArgs: ...
         @property
         def kwargs(self) -> ParamSpecKwargs: ...
         if sys.version_info >= (3, 11):
-            def __typing_subst__(self, arg: Incomplete) -> Incomplete: ...
-            def __typing_prepare_subst__(self, alias: Incomplete, args: Incomplete) -> Incomplete: ...
+            def __typing_subst__(self, arg: Any) -> Any: ...
+            def __typing_prepare_subst__(self, alias: Any, args: Any) -> tuple[Any, ...]: ...
 
         def __or__(self, right: Any) -> _SpecialForm: ...
         def __ror__(self, left: Any) -> _SpecialForm: ...
+
     Concatenate: _SpecialForm
     TypeAlias: _SpecialForm
     TypeGuard: _SpecialForm
 
     class NewType:
         def __init__(self, name: str, tp: Any) -> None: ...
         if sys.version_info >= (3, 11):
             @staticmethod
-            def __call__(__x: _T) -> _T: ...
+            def __call__(x: _T, /) -> _T: ...
         else:
             def __call__(self, x: _T) -> _T: ...
 
         def __or__(self, other: Any) -> _SpecialForm: ...
         def __ror__(self, other: Any) -> _SpecialForm: ...
-        __supertype__: type
+        __supertype__: type | NewType
 
 else:
     def NewType(name: str, tp: Any) -> Any: ...
 
 # These type variables are used by the container types.
 _S = TypeVar("_S")
 _KT = TypeVar("_KT")  # Key type.
@@ -367,15 +370,15 @@
 @runtime_checkable
 class SupportsRound(Protocol[_T_co]):
     @overload
     @abstractmethod
     def __round__(self) -> int: ...
     @overload
     @abstractmethod
-    def __round__(self, __ndigits: int) -> _T_co: ...
+    def __round__(self, ndigits: int, /) -> _T_co: ...
 
 @runtime_checkable
 class Sized(Protocol, metaclass=ABCMeta):
     @abstractmethod
     def __len__(self) -> int: ...
 
 @runtime_checkable
@@ -405,23 +408,23 @@
 _YieldT_co = TypeVar("_YieldT_co", covariant=True)
 _SendT_contra = TypeVar("_SendT_contra", contravariant=True)
 _ReturnT_co = TypeVar("_ReturnT_co", covariant=True)
 
 class Generator(Iterator[_YieldT_co], Generic[_YieldT_co, _SendT_contra, _ReturnT_co]):
     def __next__(self) -> _YieldT_co: ...
     @abstractmethod
-    def send(self, __value: _SendT_contra) -> _YieldT_co: ...
+    def send(self, value: _SendT_contra, /) -> _YieldT_co: ...
     @overload
     @abstractmethod
     def throw(
-        self, __typ: type[BaseException], __val: BaseException | object = None, __tb: TracebackType | None = None
+        self, typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /
     ) -> _YieldT_co: ...
     @overload
     @abstractmethod
-    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = None) -> _YieldT_co: ...
+    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = None, /) -> _YieldT_co: ...
     def close(self) -> None: ...
     def __iter__(self) -> Generator[_YieldT_co, _SendT_contra, _ReturnT_co]: ...
     @property
     def gi_code(self) -> CodeType: ...
     @property
     def gi_frame(self) -> FrameType: ...
     @property
@@ -442,23 +445,23 @@
     @property
     def cr_code(self) -> CodeType: ...
     @property
     def cr_frame(self) -> FrameType: ...
     @property
     def cr_running(self) -> bool: ...
     @abstractmethod
-    def send(self, __value: _SendT_contra) -> _YieldT_co: ...
+    def send(self, value: _SendT_contra, /) -> _YieldT_co: ...
     @overload
     @abstractmethod
     def throw(
-        self, __typ: type[BaseException], __val: BaseException | object = None, __tb: TracebackType | None = None
+        self, typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /
     ) -> _YieldT_co: ...
     @overload
     @abstractmethod
-    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = None) -> _YieldT_co: ...
+    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = None, /) -> _YieldT_co: ...
     @abstractmethod
     def close(self) -> None: ...
 
 # NOTE: This type does not exist in typing.py or PEP 484 but mypy needs it to exist.
 # The parameters correspond to Generator, but the 4th is the original type.
 @type_check_only
 class AwaitableGenerator(
@@ -478,38 +481,38 @@
     @abstractmethod
     def __anext__(self) -> Awaitable[_T_co]: ...
     def __aiter__(self) -> AsyncIterator[_T_co]: ...
 
 class AsyncGenerator(AsyncIterator[_YieldT_co], Generic[_YieldT_co, _SendT_contra]):
     def __anext__(self) -> Awaitable[_YieldT_co]: ...
     @abstractmethod
-    def asend(self, __value: _SendT_contra) -> Awaitable[_YieldT_co]: ...
+    def asend(self, value: _SendT_contra, /) -> Awaitable[_YieldT_co]: ...
     @overload
     @abstractmethod
     def athrow(
-        self, __typ: type[BaseException], __val: BaseException | object = None, __tb: TracebackType | None = None
+        self, typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /
     ) -> Awaitable[_YieldT_co]: ...
     @overload
     @abstractmethod
-    def athrow(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = None) -> Awaitable[_YieldT_co]: ...
+    def athrow(self, typ: BaseException, val: None = None, tb: TracebackType | None = None, /) -> Awaitable[_YieldT_co]: ...
     def aclose(self) -> Awaitable[None]: ...
     @property
     def ag_await(self) -> Any: ...
     @property
     def ag_code(self) -> CodeType: ...
     @property
     def ag_frame(self) -> FrameType: ...
     @property
     def ag_running(self) -> bool: ...
 
 @runtime_checkable
 class Container(Protocol[_T_co]):
     # This is generic more on vibes than anything else
     @abstractmethod
-    def __contains__(self, __x: object) -> bool: ...
+    def __contains__(self, x: object, /) -> bool: ...
 
 @runtime_checkable
 class Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):
     # Implement Sized (but don't have it as a base class).
     @abstractmethod
     def __len__(self) -> int: ...
 
@@ -625,49 +628,49 @@
     def __iter__(self) -> Iterator[_VT_co]: ...
     def __reversed__(self) -> Iterator[_VT_co]: ...
 
 class Mapping(Collection[_KT], Generic[_KT, _VT_co]):
     # TODO: We wish the key type could also be covariant, but that doesn't work,
     # see discussion in https://github.com/python/typing/pull/273.
     @abstractmethod
-    def __getitem__(self, __key: _KT) -> _VT_co: ...
+    def __getitem__(self, key: _KT, /) -> _VT_co: ...
     # Mixin methods
     @overload
-    def get(self, __key: _KT) -> _VT_co | None: ...
+    def get(self, key: _KT, /) -> _VT_co | None: ...
     @overload
-    def get(self, __key: _KT, default: _VT_co | _T) -> _VT_co | _T: ...
+    def get(self, key: _KT, /, default: _VT_co | _T) -> _VT_co | _T: ...
     def items(self) -> ItemsView[_KT, _VT_co]: ...
     def keys(self) -> KeysView[_KT]: ...
     def values(self) -> ValuesView[_VT_co]: ...
-    def __contains__(self, __key: object) -> bool: ...
-    def __eq__(self, __other: object) -> bool: ...
+    def __contains__(self, key: object, /) -> bool: ...
+    def __eq__(self, other: object, /) -> bool: ...
 
 class MutableMapping(Mapping[_KT, _VT]):
     @abstractmethod
-    def __setitem__(self, __key: _KT, __value: _VT) -> None: ...
+    def __setitem__(self, key: _KT, value: _VT, /) -> None: ...
     @abstractmethod
-    def __delitem__(self, __key: _KT) -> None: ...
+    def __delitem__(self, key: _KT, /) -> None: ...
     def clear(self) -> None: ...
     @overload
-    def pop(self, __key: _KT) -> _VT: ...
+    def pop(self, key: _KT, /) -> _VT: ...
     @overload
-    def pop(self, __key: _KT, default: _VT) -> _VT: ...
+    def pop(self, key: _KT, /, default: _VT) -> _VT: ...
     @overload
-    def pop(self, __key: _KT, default: _T) -> _VT | _T: ...
+    def pop(self, key: _KT, /, default: _T) -> _VT | _T: ...
     def popitem(self) -> tuple[_KT, _VT]: ...
     # This overload should be allowed only if the value type is compatible with None.
     #
     # Keep the following methods in line with MutableMapping.setdefault, modulo positional-only differences:
     # -- collections.OrderedDict.setdefault
     # -- collections.ChainMap.setdefault
     # -- weakref.WeakKeyDictionary.setdefault
     @overload
-    def setdefault(self: MutableMapping[_KT, _T | None], __key: _KT, __default: None = None) -> _T | None: ...
+    def setdefault(self: MutableMapping[_KT, _T | None], key: _KT, default: None = None, /) -> _T | None: ...
     @overload
-    def setdefault(self, __key: _KT, __default: _VT) -> _VT: ...
+    def setdefault(self, key: _KT, default: _VT, /) -> _VT: ...
     # 'update' used to take a Union, but using overloading is better.
     # The second overloaded type here is a bit too general, because
     # Mapping[tuple[_KT, _VT], W] is a subclass of Iterable[tuple[_KT, _VT]],
     # but will always have the behavior of the first overloaded type
     # at runtime, leading to keys of a mix of types _KT and tuple[_KT, _VT].
     # We don't currently have any way of forcing all Mappings to use
     # the first overload, but by using overloading rather than a Union,
@@ -681,17 +684,17 @@
     # -- collections.UserDict.__ior__
     # -- collections.ChainMap.__ior__
     # -- peewee.attrdict.__add__
     # -- peewee.attrdict.__iadd__
     # -- weakref.WeakValueDictionary.__ior__
     # -- weakref.WeakKeyDictionary.__ior__
     @overload
-    def update(self, __m: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT) -> None: ...
+    def update(self, m: SupportsKeysAndGetItem[_KT, _VT], /, **kwargs: _VT) -> None: ...
     @overload
-    def update(self, __m: Iterable[tuple[_KT, _VT]], **kwargs: _VT) -> None: ...
+    def update(self, m: Iterable[tuple[_KT, _VT]], /, **kwargs: _VT) -> None: ...
     @overload
     def update(self, **kwargs: _VT) -> None: ...
 
 Text = str
 
 TYPE_CHECKING: bool
 
@@ -715,58 +718,58 @@
     @abstractmethod
     def fileno(self) -> int: ...
     @abstractmethod
     def flush(self) -> None: ...
     @abstractmethod
     def isatty(self) -> bool: ...
     @abstractmethod
-    def read(self, __n: int = -1) -> AnyStr: ...
+    def read(self, n: int = -1, /) -> AnyStr: ...
     @abstractmethod
     def readable(self) -> bool: ...
     @abstractmethod
-    def readline(self, __limit: int = -1) -> AnyStr: ...
+    def readline(self, limit: int = -1, /) -> AnyStr: ...
     @abstractmethod
-    def readlines(self, __hint: int = -1) -> list[AnyStr]: ...
+    def readlines(self, hint: int = -1, /) -> list[AnyStr]: ...
     @abstractmethod
-    def seek(self, __offset: int, __whence: int = 0) -> int: ...
+    def seek(self, offset: int, whence: int = 0, /) -> int: ...
     @abstractmethod
     def seekable(self) -> bool: ...
     @abstractmethod
     def tell(self) -> int: ...
     @abstractmethod
-    def truncate(self, __size: int | None = None) -> int: ...
+    def truncate(self, size: int | None = None, /) -> int: ...
     @abstractmethod
     def writable(self) -> bool: ...
     @abstractmethod
     @overload
-    def write(self: IO[str], __s: str) -> int: ...
+    def write(self: IO[str], s: str, /) -> int: ...
     @abstractmethod
     @overload
-    def write(self: IO[bytes], __s: ReadableBuffer) -> int: ...
+    def write(self: IO[bytes], s: ReadableBuffer, /) -> int: ...
     @abstractmethod
     @overload
-    def write(self, __s: AnyStr) -> int: ...
+    def write(self, s: AnyStr, /) -> int: ...
     @abstractmethod
     @overload
-    def writelines(self: IO[str], __lines: Iterable[str]) -> None: ...
+    def writelines(self: IO[str], lines: Iterable[str], /) -> None: ...
     @abstractmethod
     @overload
-    def writelines(self: IO[bytes], __lines: Iterable[ReadableBuffer]) -> None: ...
+    def writelines(self: IO[bytes], lines: Iterable[ReadableBuffer], /) -> None: ...
     @abstractmethod
     @overload
-    def writelines(self, __lines: Iterable[AnyStr]) -> None: ...
+    def writelines(self, lines: Iterable[AnyStr], /) -> None: ...
     @abstractmethod
     def __next__(self) -> AnyStr: ...
     @abstractmethod
     def __iter__(self) -> Iterator[AnyStr]: ...
     @abstractmethod
     def __enter__(self) -> IO[AnyStr]: ...
     @abstractmethod
     def __exit__(
-        self, __type: type[BaseException] | None, __value: BaseException | None, __traceback: TracebackType | None
+        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None, /
     ) -> None: ...
 
 class BinaryIO(IO[bytes]):
     @abstractmethod
     def __enter__(self) -> BinaryIO: ...
 
 class TextIO(IO[str]):
@@ -834,17 +837,17 @@
 def cast(typ: type[_T], val: Any) -> _T: ...
 @overload
 def cast(typ: str, val: Any) -> Any: ...
 @overload
 def cast(typ: object, val: Any) -> Any: ...
 
 if sys.version_info >= (3, 11):
-    def reveal_type(__obj: _T) -> _T: ...
-    def assert_never(__arg: Never) -> Never: ...
-    def assert_type(__val: _T, __typ: Any) -> _T: ...
+    def reveal_type(obj: _T, /) -> _T: ...
+    def assert_never(arg: Never, /) -> Never: ...
+    def assert_type(val: _T, typ: Any, /) -> _T: ...
     def clear_overloads() -> None: ...
     def get_overloads(func: Callable[..., object]) -> Sequence[Callable[..., object]]: ...
     def dataclass_transform(
         *,
         eq_default: bool = True,
         order_default: bool = False,
         kw_only_default: bool = False,
@@ -860,18 +863,22 @@
         _field_types: ClassVar[dict[str, type]]
     _field_defaults: ClassVar[dict[str, Any]]
     _fields: ClassVar[tuple[str, ...]]
     # __orig_bases__ sometimes exists on <3.12, but not consistently
     # So we only add it to the stub on 3.12+.
     if sys.version_info >= (3, 12):
         __orig_bases__: ClassVar[tuple[Any, ...]]
+
     @overload
-    def __init__(self, __typename: str, __fields: Iterable[tuple[str, Any]]) -> None: ...
+    def __init__(self, typename: str, fields: Iterable[tuple[str, Any]], /) -> None: ...
     @overload
-    def __init__(self, __typename: str, __fields: None = None, **kwargs: Any) -> None: ...
+    @typing_extensions.deprecated(
+        "Creating a typing.NamedTuple using keyword arguments is deprecated and support will be removed in Python 3.15"
+    )
+    def __init__(self, typename: str, fields: None = None, /, **kwargs: Any) -> None: ...
     @classmethod
     def _make(cls, iterable: Iterable[Any]) -> typing_extensions.Self: ...
     def _asdict(self) -> dict[str, Any]: ...
     def _replace(self, **kwargs: Any) -> typing_extensions.Self: ...
 
 # Internal mypy fallback type for all typed dicts (does not exist at runtime)
 # N.B. Keep this mostly in sync with typing_extensions._TypedDict/mypy_extensions._TypedDict
@@ -881,36 +888,37 @@
     if sys.version_info >= (3, 9):
         __required_keys__: ClassVar[frozenset[str]]
         __optional_keys__: ClassVar[frozenset[str]]
     # __orig_bases__ sometimes exists on <3.12, but not consistently,
     # so we only add it to the stub on 3.12+
     if sys.version_info >= (3, 12):
         __orig_bases__: ClassVar[tuple[Any, ...]]
+
     def copy(self) -> typing_extensions.Self: ...
     # Using Never so that only calls using mypy plugin hook that specialize the signature
     # can go through.
     def setdefault(self, k: _Never, default: object) -> object: ...
     # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.
     def pop(self, k: _Never, default: _T = ...) -> object: ...  # pyright: ignore[reportInvalidTypeVarUse]
-    def update(self: _T, __m: _T) -> None: ...
+    def update(self: _T, m: _T, /) -> None: ...
     def __delitem__(self, k: _Never) -> None: ...
     def items(self) -> dict_items[str, object]: ...
     def keys(self) -> dict_keys[str, object]: ...
     def values(self) -> dict_values[str, object]: ...
     if sys.version_info >= (3, 9):
         @overload
-        def __or__(self, __value: typing_extensions.Self) -> typing_extensions.Self: ...
+        def __or__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...
         @overload
-        def __or__(self, __value: dict[str, Any]) -> dict[str, object]: ...
+        def __or__(self, value: dict[str, Any], /) -> dict[str, object]: ...
         @overload
-        def __ror__(self, __value: typing_extensions.Self) -> typing_extensions.Self: ...
+        def __ror__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...
         @overload
-        def __ror__(self, __value: dict[str, Any]) -> dict[str, object]: ...
+        def __ror__(self, value: dict[str, Any], /) -> dict[str, object]: ...
         # supposedly incompatible definitions of __or__ and __ior__
-        def __ior__(self, __value: typing_extensions.Self) -> typing_extensions.Self: ...  # type: ignore[misc]
+        def __ior__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...  # type: ignore[misc]
 
 @final
 class ForwardRef:
     __forward_arg__: str
     __forward_code__: CodeType
     __forward_evaluated__: bool
     __forward_value__: Any | None
@@ -938,15 +946,15 @@
 
 if sys.version_info >= (3, 10):
     def is_typeddict(tp: object) -> bool: ...
 
 def _type_repr(obj: object) -> str: ...
 
 if sys.version_info >= (3, 12):
-    def override(__method: _F) -> _F: ...
+    def override(method: _F, /) -> _F: ...
     @final
     class TypeAliasType:
         def __init__(
             self, name: str, value: Any, *, type_params: tuple[TypeVar | ParamSpec | TypeVarTuple, ...] = ()
         ) -> None: ...
         @property
         def __value__(self) -> Any: ...
@@ -960,9 +968,9 @@
         @property
         def __module__(self) -> str | None: ...  # type: ignore[override]
         def __getitem__(self, parameters: Any) -> Any: ...
         def __or__(self, right: Any) -> _SpecialForm: ...
         def __ror__(self, left: Any) -> _SpecialForm: ...
 
 if sys.version_info >= (3, 13):
-    def is_protocol(__tp: type) -> bool: ...
-    def get_protocol_members(__tp: type) -> frozenset[str]: ...
+    def is_protocol(tp: type, /) -> bool: ...
+    def get_protocol_members(tp: type, /) -> frozenset[str]: ...
```

## puya/_typeshed/stdlib/typing_extensions.pyi

```diff
@@ -1,12 +1,12 @@
 import abc
 import sys
 import typing
 from _collections_abc import dict_items, dict_keys, dict_values
-from _typeshed import IdentityFunction, Incomplete
+from _typeshed import IdentityFunction
 from typing import (  # noqa: Y022,Y037,Y038,Y039
     IO as IO,
     TYPE_CHECKING as TYPE_CHECKING,
     AbstractSet as AbstractSet,
     Any as Any,
     AnyStr as AnyStr,
     AsyncContextManager as AsyncContextManager,
@@ -178,14 +178,15 @@
     "ValuesView",
     "cast",
     "get_protocol_members",
     "is_protocol",
     "no_type_check",
     "no_type_check_decorator",
     "ReadOnly",
+    "TypeIs",
 ]
 
 _T = typing.TypeVar("_T")
 _F = typing.TypeVar("_F", bound=Callable[..., Any])
 _TC = typing.TypeVar("_TC", bound=type[object])
 
 # unfortunately we have to duplicate this class definition from typing.pyi or we break pytype
@@ -216,40 +217,44 @@
 
 # Internal mypy fallback type for all typed dicts (does not exist at runtime)
 # N.B. Keep this mostly in sync with typing._TypedDict/mypy_extensions._TypedDict
 @type_check_only
 class _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):
     __required_keys__: ClassVar[frozenset[str]]
     __optional_keys__: ClassVar[frozenset[str]]
-    __readonly_keys__: ClassVar[frozenset[str]]
-    __mutable_keys__: ClassVar[frozenset[str]]
     __total__: ClassVar[bool]
     __orig_bases__: ClassVar[tuple[Any, ...]]
+    # PEP 705
+    __readonly_keys__: ClassVar[frozenset[str]]
+    __mutable_keys__: ClassVar[frozenset[str]]
+    # PEP 728
+    __closed__: ClassVar[bool]
+    __extra_items__: ClassVar[Any]
     def copy(self) -> Self: ...
     # Using Never so that only calls using mypy plugin hook that specialize the signature
     # can go through.
     def setdefault(self, k: Never, default: object) -> object: ...
     # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.
     def pop(self, k: Never, default: _T = ...) -> object: ...  # pyright: ignore[reportInvalidTypeVarUse]
-    def update(self: _T, __m: _T) -> None: ...
+    def update(self: _T, m: _T, /) -> None: ...
     def items(self) -> dict_items[str, object]: ...
     def keys(self) -> dict_keys[str, object]: ...
     def values(self) -> dict_values[str, object]: ...
     def __delitem__(self, k: Never) -> None: ...
     if sys.version_info >= (3, 9):
         @overload
-        def __or__(self, __value: Self) -> Self: ...
+        def __or__(self, value: Self, /) -> Self: ...
         @overload
-        def __or__(self, __value: dict[str, Any]) -> dict[str, object]: ...
+        def __or__(self, value: dict[str, Any], /) -> dict[str, object]: ...
         @overload
-        def __ror__(self, __value: Self) -> Self: ...
+        def __ror__(self, value: Self, /) -> Self: ...
         @overload
-        def __ror__(self, __value: dict[str, Any]) -> dict[str, object]: ...
+        def __ror__(self, value: dict[str, Any], /) -> dict[str, object]: ...
         # supposedly incompatible definitions of `__ior__` and `__or__`:
-        def __ior__(self, __value: Self) -> Self: ...  # type: ignore[misc]
+        def __ior__(self, value: Self, /) -> Self: ...  # type: ignore[misc]
 
 # TypedDict is a (non-subscriptable) special form.
 TypedDict: object
 
 OrderedDict = _Alias()
 
 def get_type_hints(
@@ -326,17 +331,17 @@
         dataclass_transform as dataclass_transform,
         get_overloads as get_overloads,
         reveal_type as reveal_type,
     )
 else:
     Self: _SpecialForm
     Never: _SpecialForm
-    def reveal_type(__obj: _T) -> _T: ...
-    def assert_never(__arg: Never) -> Never: ...
-    def assert_type(__val: _T, __typ: Any) -> _T: ...
+    def reveal_type(obj: _T, /) -> _T: ...
+    def assert_never(arg: Never, /) -> Never: ...
+    def assert_type(val: _T, typ: Any, /) -> _T: ...
     def clear_overloads() -> None: ...
     def get_overloads(func: Callable[..., object]) -> Sequence[Callable[..., object]]: ...
 
     Required: _SpecialForm
     NotRequired: _SpecialForm
     LiteralString: _SpecialForm
     Unpack: _SpecialForm
@@ -364,16 +369,16 @@
         @classmethod
         def _make(cls, iterable: Iterable[Any]) -> Self: ...
         def _asdict(self) -> dict[str, Any]: ...
         def _replace(self, **kwargs: Any) -> Self: ...
 
     class NewType:
         def __init__(self, name: str, tp: Any) -> None: ...
-        def __call__(self, __obj: _T) -> _T: ...
-        __supertype__: type
+        def __call__(self, obj: _T, /) -> _T: ...
+        __supertype__: type | NewType
         if sys.version_info >= (3, 10):
             def __or__(self, other: Any) -> _SpecialForm: ...
             def __ror__(self, other: Any) -> _SpecialForm: ...
 
 # New things in 3.xx
 # The `default` parameter was added to TypeVar, ParamSpec, and TypeVarTuple (PEP 696)
 # The `infer_variance` parameter was added to TypeVar in 3.12 (PEP 695)
@@ -404,15 +409,15 @@
         default: Any | None = None,
         infer_variance: bool = False,
     ) -> None: ...
     if sys.version_info >= (3, 10):
         def __or__(self, right: Any) -> _SpecialForm: ...
         def __ror__(self, left: Any) -> _SpecialForm: ...
     if sys.version_info >= (3, 11):
-        def __typing_subst__(self, arg: Incomplete) -> Incomplete: ...
+        def __typing_subst__(self, arg: Any) -> Any: ...
 
 @final
 class ParamSpec:
     @property
     def __name__(self) -> str: ...
     @property
     def __bound__(self) -> Any | None: ...
@@ -444,27 +449,27 @@
     def __name__(self) -> str: ...
     @property
     def __default__(self) -> Any | None: ...
     def __init__(self, name: str, *, default: Any | None = None) -> None: ...
     def __iter__(self) -> Any: ...  # Unpack[Self]
 
 class deprecated:
-    message: str
+    message: LiteralString
     category: type[Warning] | None
     stacklevel: int
-    def __init__(self, __message: str, *, category: type[Warning] | None = ..., stacklevel: int = 1) -> None: ...
-    def __call__(self, __arg: _T) -> _T: ...
+    def __init__(self, message: LiteralString, /, *, category: type[Warning] | None = ..., stacklevel: int = 1) -> None: ...
+    def __call__(self, arg: _T, /) -> _T: ...
 
 if sys.version_info >= (3, 12):
     from collections.abc import Buffer as Buffer
     from types import get_original_bases as get_original_bases
     from typing import TypeAliasType as TypeAliasType, override as override
 else:
-    def override(__arg: _F) -> _F: ...
-    def get_original_bases(__cls: type) -> tuple[Any, ...]: ...
+    def override(arg: _F, /) -> _F: ...
+    def get_original_bases(cls: type, /) -> tuple[Any, ...]: ...
     @final
     class TypeAliasType:
         def __init__(
             self, name: str, value: Any, *, type_params: tuple[TypeVar | ParamSpec | TypeVarTuple, ...] = ()
         ) -> None: ...
         @property
         def __value__(self) -> Any: ...
@@ -482,22 +487,23 @@
             def __or__(self, right: Any) -> _SpecialForm: ...
             def __ror__(self, left: Any) -> _SpecialForm: ...
 
     @runtime_checkable
     class Buffer(Protocol):
         # Not actually a Protocol at runtime; see
         # https://github.com/python/typeshed/issues/10224 for why we're defining it this way
-        def __buffer__(self, __flags: int) -> memoryview: ...
+        def __buffer__(self, flags: int, /) -> memoryview: ...
 
 if sys.version_info >= (3, 13):
     from typing import get_protocol_members as get_protocol_members, is_protocol as is_protocol
 else:
-    def is_protocol(__tp: type) -> bool: ...
-    def get_protocol_members(__tp: type) -> frozenset[str]: ...
+    def is_protocol(tp: type, /) -> bool: ...
+    def get_protocol_members(tp: type, /) -> frozenset[str]: ...
 
 class Doc:
     documentation: str
-    def __init__(self, __documentation: str) -> None: ...
+    def __init__(self, documentation: str, /) -> None: ...
     def __hash__(self) -> int: ...
     def __eq__(self, other: object) -> bool: ...
 
 ReadOnly: _SpecialForm
+TypeIs: _SpecialForm
```

## puya/_vendor/mypy/.version

```diff
@@ -1 +1 @@
-1.9.0: 5ff46f8b3706d005fabab2227ec84476d605bfd4
+v1.10.0: 3faf0fc4798ec3ee6b1cd123965193dc0a753fb0
```

## puya/_vendor/mypy/applytype.py

```diff
@@ -133,24 +133,40 @@
         assert isinstance(callable, CallableType)
         return callable.copy_modified(variables=[tv for tv in tvars if tv.id not in id_to_type])
     else:
         callable = callable.copy_modified(
             arg_types=[expand_type(at, id_to_type) for at in callable.arg_types]
         )
 
-    # Apply arguments to TypeGuard if any.
+    # Apply arguments to TypeGuard and TypeIs if any.
     if callable.type_guard is not None:
         type_guard = expand_type(callable.type_guard, id_to_type)
     else:
         type_guard = None
+    if callable.type_is is not None:
+        type_is = expand_type(callable.type_is, id_to_type)
+    else:
+        type_is = None
 
     # The callable may retain some type vars if only some were applied.
     # TODO: move apply_poly() logic from checkexpr.py here when new inference
     # becomes universally used (i.e. in all passes + in unification).
     # With this new logic we can actually *add* some new free variables.
-    remaining_tvars = [tv for tv in tvars if tv.id not in id_to_type]
+    remaining_tvars: list[TypeVarLikeType] = []
+    for tv in tvars:
+        if tv.id in id_to_type:
+            continue
+        if not tv.has_default():
+            remaining_tvars.append(tv)
+            continue
+        # TypeVarLike isn't in id_to_type mapping.
+        # Only expand the TypeVar default here.
+        typ = expand_type(tv, id_to_type)
+        assert isinstance(typ, TypeVarLikeType)
+        remaining_tvars.append(typ)
 
     return callable.copy_modified(
         ret_type=expand_type(callable.ret_type, id_to_type),
         variables=remaining_tvars,
         type_guard=type_guard,
+        type_is=type_is,
     )
```

## puya/_vendor/mypy/checker.py

```diff
@@ -1,14 +1,14 @@
 """Mypy type checker."""
 
 from __future__ import annotations
 
 import itertools
 from collections import defaultdict
-from contextlib import contextmanager, nullcontext
+from contextlib import ExitStack, contextmanager
 from typing import (
     AbstractSet,
     Callable,
     Dict,
     Final,
     Generic,
     Iterable,
@@ -522,25 +522,19 @@
                 for node, active_typeinfo in todo:
                     if node in done:
                         continue
                     # This is useful for debugging:
                     # print("XXX in pass %d, class %s, function %s" %
                     #       (self.pass_num, type_name, node.fullname or node.name))
                     done.add(node)
-                    with (
-                        self.tscope.class_scope(active_typeinfo)
-                        if active_typeinfo
-                        else nullcontext()
-                    ):
-                        with (
-                            self.scope.push_class(active_typeinfo)
-                            if active_typeinfo
-                            else nullcontext()
-                        ):
-                            self.check_partial(node)
+                    with ExitStack() as stack:
+                        if active_typeinfo:
+                            stack.enter_context(self.tscope.class_scope(active_typeinfo))
+                            stack.enter_context(self.scope.push_class(active_typeinfo))
+                        self.check_partial(node)
             return True
 
     def check_partial(self, node: DeferredNodeType | FineGrainedDeferredNodeType) -> None:
         if isinstance(node, MypyFile):
             self.check_top_level(node)
         else:
             self.recurse_into_functions = True
@@ -991,16 +985,17 @@
         elif (
             return_type.type.fullname in ("typing.Generator", "typing.AwaitableGenerator")
             and len(return_type.args) >= 3
         ):
             # AwaitableGenerator, Generator: tr is args[2].
             return return_type.args[2]
         else:
-            # Supertype of Generator (Iterator, Iterable, object): tr is any.
-            return AnyType(TypeOfAny.special_form)
+            # We have a supertype of Generator (Iterator, Iterable, object)
+            # Treat `Iterator[X]` as a shorthand for `Generator[X, Any, None]`.
+            return NoneType()
 
     def visit_func_def(self, defn: FuncDef) -> None:
         if not self.recurse_into_functions:
             return
         with self.tscope.function_scope(defn):
             self._visit_func_def(defn)
 
@@ -1205,14 +1200,30 @@
                 self.return_types.append(typ.ret_type)
 
                 with self.scope.push_function(defn):
                     # We temporary push the definition to get the self type as
                     # visible from *inside* of this function/method.
                     ref_type: Type | None = self.scope.active_self_type()
 
+                if typ.type_is:
+                    arg_index = 0
+                    # For methods and classmethods, we want the second parameter
+                    if ref_type is not None and (not defn.is_static or defn.name == "__new__"):
+                        arg_index = 1
+                    if arg_index < len(typ.arg_types) and not is_subtype(
+                        typ.type_is, typ.arg_types[arg_index]
+                    ):
+                        self.fail(
+                            message_registry.NARROWED_TYPE_NOT_SUBTYPE.format(
+                                format_type(typ.type_is, self.options),
+                                format_type(typ.arg_types[arg_index], self.options),
+                            ),
+                            item,
+                        )
+
                 # Store argument types.
                 for i in range(len(typ.arg_types)):
                     arg_type = typ.arg_types[i]
                     if (
                         isinstance(defn, FuncDef)
                         and ref_type is not None
                         and i == 0
@@ -2022,30 +2033,37 @@
                 original_class_or_static = False  # a variable can't be class or static
 
             if isinstance(original_type, FunctionLike):
                 original_type = self.bind_and_map_method(base_attr, original_type, defn.info, base)
                 if original_node and is_property(original_node):
                     original_type = get_property_type(original_type)
 
-            if isinstance(typ, FunctionLike) and is_property(defn):
-                typ = get_property_type(typ)
-                if (
-                    isinstance(original_node, Var)
-                    and not original_node.is_final
-                    and (not original_node.is_property or original_node.is_settable_property)
-                    and isinstance(defn, Decorator)
-                ):
-                    # We only give an error where no other similar errors will be given.
-                    if not isinstance(original_type, AnyType):
-                        self.msg.fail(
-                            "Cannot override writeable attribute with read-only property",
-                            # Give an error on function line to match old behaviour.
-                            defn.func,
-                            code=codes.OVERRIDE,
-                        )
+            if is_property(defn):
+                inner: FunctionLike | None
+                if isinstance(typ, FunctionLike):
+                    inner = typ
+                else:
+                    inner = self.extract_callable_type(typ, context)
+                if inner is not None:
+                    typ = inner
+                    typ = get_property_type(typ)
+                    if (
+                        isinstance(original_node, Var)
+                        and not original_node.is_final
+                        and (not original_node.is_property or original_node.is_settable_property)
+                        and isinstance(defn, Decorator)
+                    ):
+                        # We only give an error where no other similar errors will be given.
+                        if not isinstance(original_type, AnyType):
+                            self.msg.fail(
+                                "Cannot override writeable attribute with read-only property",
+                                # Give an error on function line to match old behaviour.
+                                defn.func,
+                                code=codes.OVERRIDE,
+                            )
 
             if isinstance(original_type, AnyType) or isinstance(typ, AnyType):
                 pass
             elif isinstance(original_type, FunctionLike) and isinstance(typ, FunctionLike):
                 # Check that the types are compatible.
                 self.check_override(
                     typ,
@@ -2144,19 +2162,26 @@
         original_class_or_static: bool,
         override_class_or_static: bool,
         node: Context,
     ) -> None:
         """Check a method override with given signatures.
 
         Arguments:
-          override:  The signature of the overriding method.
-          original:  The signature of the original supertype method.
-          name:      The name of the subtype. This and the next argument are
-                     only used for generating error messages.
-          supertype: The name of the supertype.
+          override:                 The signature of the overriding method.
+          original:                 The signature of the original supertype method.
+          name:                     The name of the overriding method.
+                                    Used primarily for generating error messages.
+          name_in_super:            The name of the overridden in the superclass.
+                                    Used for generating error messages only.
+          supertype:                The name of the supertype.
+          original_class_or_static: Indicates whether the original method (from the superclass)
+                                    is either a class method or a static method.
+          override_class_or_static: Indicates whether the overriding method (from the subclass)
+                                    is either a class method or a static method.
+          node:                     Context node.
         """
         # Use boolean variable to clarify code.
         fail = False
         op_method_wider_note = False
         if not is_subtype(override, original, ignore_pos_arg_names=True):
             fail = True
         elif isinstance(override, Overloaded) and self.is_forward_op_method(name):
@@ -2173,14 +2198,16 @@
                 op_method_wider_note = True
         if isinstance(override, FunctionLike):
             if original_class_or_static and not override_class_or_static:
                 fail = True
             elif isinstance(original, CallableType) and isinstance(override, CallableType):
                 if original.type_guard is not None and override.type_guard is None:
                     fail = True
+                if original.type_is is not None and override.type_is is None:
+                    fail = True
 
         if is_private(name):
             fail = False
 
         if fail:
             emitted_msg = False
 
@@ -5049,14 +5076,27 @@
         self.binder.handle_break()
 
     def visit_continue_stmt(self, s: ContinueStmt) -> None:
         self.binder.handle_continue()
         return
 
     def visit_match_stmt(self, s: MatchStmt) -> None:
+        named_subject: Expression
+        if isinstance(s.subject, CallExpr):
+            # Create a dummy subject expression to handle cases where a match statement's subject
+            # is not a literal value. This lets us correctly narrow types and check exhaustivity
+            # This is hack!
+            id = s.subject.callee.fullname if isinstance(s.subject.callee, RefExpr) else ""
+            name = "dummy-match-" + id
+            v = Var(name)
+            named_subject = NameExpr(name)
+            named_subject.node = v
+        else:
+            named_subject = s.subject
+
         with self.binder.frame_context(can_skip=False, fall_through=0):
             subject_type = get_proper_type(self.expr_checker.accept(s.subject))
 
             if isinstance(subject_type, DeletedType):
                 self.msg.deleted_as_rvalue(subject_type, s)
 
             # We infer types of patterns twice. The first pass is used
@@ -5067,29 +5107,32 @@
             pattern_types = [self.pattern_checker.accept(p, subject_type) for p in s.patterns]
             type_maps: list[TypeMap] = [t.captures for t in pattern_types]
             inferred_types = self.infer_variable_types_from_type_maps(type_maps)
 
             # The second pass narrows down the types and type checks bodies.
             for p, g, b in zip(s.patterns, s.guards, s.bodies):
                 current_subject_type = self.expr_checker.narrow_type_from_binder(
-                    s.subject, subject_type
+                    named_subject, subject_type
                 )
                 pattern_type = self.pattern_checker.accept(p, current_subject_type)
                 with self.binder.frame_context(can_skip=True, fall_through=2):
                     if b.is_unreachable or isinstance(
                         get_proper_type(pattern_type.type), UninhabitedType
                     ):
                         self.push_type_map(None)
                         else_map: TypeMap = {}
                     else:
                         pattern_map, else_map = conditional_types_to_typemaps(
-                            s.subject, pattern_type.type, pattern_type.rest_type
+                            named_subject, pattern_type.type, pattern_type.rest_type
                         )
                         self.remove_capture_conflicts(pattern_type.captures, inferred_types)
                         self.push_type_map(pattern_map)
+                        if pattern_map:
+                            for expr, typ in pattern_map.items():
+                                self.push_type_map(self._get_recursive_sub_patterns_map(expr, typ))
                         self.push_type_map(pattern_type.captures)
                     if g is not None:
                         with self.binder.frame_context(can_skip=False, fall_through=3):
                             gt = get_proper_type(self.expr_checker.accept(g))
 
                             if isinstance(gt, DeletedType):
                                 self.msg.deleted_as_rvalue(gt, s)
@@ -5106,27 +5149,41 @@
                                             continue
                                         for expr in list(type_map):
                                             if not (
                                                 isinstance(expr, NameExpr)
                                                 and expr.fullname == case_target.fullname
                                             ):
                                                 continue
-                                            type_map[s.subject] = type_map[expr]
+                                            type_map[named_subject] = type_map[expr]
 
                             self.push_type_map(guard_map)
                             self.accept(b)
                     else:
                         self.accept(b)
                 self.push_type_map(else_map)
 
             # This is needed due to a quirk in frame_context. Without it types will stay narrowed
             # after the match.
             with self.binder.frame_context(can_skip=False, fall_through=2):
                 pass
 
+    def _get_recursive_sub_patterns_map(
+        self, expr: Expression, typ: Type
+    ) -> dict[Expression, Type]:
+        sub_patterns_map: dict[Expression, Type] = {}
+        typ_ = get_proper_type(typ)
+        if isinstance(expr, TupleExpr) and isinstance(typ_, TupleType):
+            # When matching a tuple expression with a sequence pattern, narrow individual tuple items
+            assert len(expr.items) == len(typ_.items)
+            for item_expr, item_typ in zip(expr.items, typ_.items):
+                sub_patterns_map[item_expr] = item_typ
+                sub_patterns_map.update(self._get_recursive_sub_patterns_map(item_expr, item_typ))
+
+        return sub_patterns_map
+
     def infer_variable_types_from_type_maps(self, type_maps: list[TypeMap]) -> dict[Var, Type]:
         all_captures: dict[Var, list[tuple[NameExpr, Type]]] = defaultdict(list)
         for tm in type_maps:
             if tm is not None:
                 for expr, typ in tm.items():
                     if isinstance(expr, NameExpr):
                         node = expr.node
@@ -5625,15 +5682,15 @@
         else:
             else_map = {}
         return if_map, else_map
 
     def find_isinstance_check(self, node: Expression) -> tuple[TypeMap, TypeMap]:
         """Find any isinstance checks (within a chain of ands).  Includes
         implicit and explicit checks for None and calls to callable.
-        Also includes TypeGuard functions.
+        Also includes TypeGuard and TypeIs functions.
 
         Return value is a map of variables to their types if the condition
         is true and a map of variables to their types if the condition is false.
 
         If either of the values in the tuple is None, then that particular
         branch can never occur.
 
@@ -5677,15 +5734,15 @@
             elif refers_to_fullname(node.callee, "builtins.hasattr"):
                 if len(node.args) != 2:  # the error will be reported elsewhere
                     return {}, {}
                 attr = try_getting_str_literals(node.args[1], self.lookup_type(node.args[1]))
                 if literal(expr) == LITERAL_TYPE and attr and len(attr) == 1:
                     return self.hasattr_type_maps(expr, self.lookup_type(expr), attr[0])
             elif isinstance(node.callee, RefExpr):
-                if node.callee.type_guard is not None:
+                if node.callee.type_guard is not None or node.callee.type_is is not None:
                     # TODO: Follow *args, **kwargs
                     if node.arg_kinds[0] != nodes.ARG_POS:
                         # the first argument might be used as a kwarg
                         called_type = get_proper_type(self.lookup_type(node.callee))
 
                         # TODO: there are some more cases in check_call() to handle.
                         if isinstance(called_type, Instance):
@@ -5703,23 +5760,39 @@
                         if isinstance(called_type, (CallableType, Overloaded)):
                             name = called_type.items[0].arg_names[0]
                             if name in node.arg_names:
                                 idx = node.arg_names.index(name)
                                 # we want the idx-th variable to be narrowed
                                 expr = collapse_walrus(node.args[idx])
                             else:
-                                self.fail(message_registry.TYPE_GUARD_POS_ARG_REQUIRED, node)
+                                kind = (
+                                    "guard" if node.callee.type_guard is not None else "narrower"
+                                )
+                                self.fail(
+                                    message_registry.TYPE_GUARD_POS_ARG_REQUIRED.format(kind), node
+                                )
                                 return {}, {}
                     if literal(expr) == LITERAL_TYPE:
                         # Note: we wrap the target type, so that we can special case later.
                         # Namely, for isinstance() we use a normal meet, while TypeGuard is
                         # considered "always right" (i.e. even if the types are not overlapping).
                         # Also note that a care must be taken to unwrap this back at read places
                         # where we use this to narrow down declared type.
-                        return {expr: TypeGuardedType(node.callee.type_guard)}, {}
+                        if node.callee.type_guard is not None:
+                            return {expr: TypeGuardedType(node.callee.type_guard)}, {}
+                        else:
+                            assert node.callee.type_is is not None
+                            return conditional_types_to_typemaps(
+                                expr,
+                                *self.conditional_types_with_intersection(
+                                    self.lookup_type(expr),
+                                    [TypeRange(node.callee.type_is, is_upper_bound=False)],
+                                    expr,
+                                ),
+                            )
         elif isinstance(node, ComparisonExpr):
             # Step 1: Obtain the types of each operand and whether or not we can
             # narrow their types. (For example, we shouldn't try narrowing the
             # types of literal string or enum expressions).
 
             operands = [collapse_walrus(x) for x in node.operands]
             operand_types = []
```

## puya/_vendor/mypy/checkexpr.py

```diff
@@ -632,15 +632,25 @@
     def check_str_format_call(self, e: CallExpr) -> None:
         """More precise type checking for str.format() calls on literals."""
         assert isinstance(e.callee, MemberExpr)
         format_value = None
         if isinstance(e.callee.expr, StrExpr):
             format_value = e.callee.expr.value
         elif self.chk.has_type(e.callee.expr):
-            base_typ = try_getting_literal(self.chk.lookup_type(e.callee.expr))
+            typ = get_proper_type(self.chk.lookup_type(e.callee.expr))
+            if (
+                isinstance(typ, Instance)
+                and typ.type.is_enum
+                and isinstance(typ.last_known_value, LiteralType)
+                and isinstance(typ.last_known_value.value, str)
+            ):
+                value_type = typ.type.names[typ.last_known_value.value].type
+                if isinstance(value_type, Type):
+                    typ = get_proper_type(value_type)
+            base_typ = try_getting_literal(typ)
             if isinstance(base_typ, LiteralType) and isinstance(base_typ.value, str):
                 format_value = base_typ.value
         if format_value is not None:
             self.strfrm_checker.check_str_format_call(e, format_value)
 
     def method_fullname(self, object_type: Type, method_name: str) -> str | None:
         """Convert a method name to a fully qualified name, based on the type of the object that
@@ -945,15 +955,18 @@
             self.named_type("builtins.type"),
             variables=info.defn.type_vars,
         )
 
     def typeddict_callable_from_context(self, callee: TypedDictType) -> CallableType:
         return CallableType(
             list(callee.items.values()),
-            [ArgKind.ARG_NAMED] * len(callee.items),
+            [
+                ArgKind.ARG_NAMED if name in callee.required_keys else ArgKind.ARG_NAMED_OPT
+                for name in callee.items
+            ],
             list(callee.items.keys()),
             callee,
             self.named_type("builtins.type"),
         )
 
     def check_typeddict_call_with_kwargs(
         self,
@@ -1447,21 +1460,20 @@
             e,
             e.arg_names,
             callable_node=e.callee,
             callable_name=callable_name,
             object_type=object_type,
         )
         proper_callee = get_proper_type(callee_type)
-        if (
-            isinstance(e.callee, RefExpr)
-            and isinstance(proper_callee, CallableType)
-            and proper_callee.type_guard is not None
-        ):
+        if isinstance(e.callee, RefExpr) and isinstance(proper_callee, CallableType):
             # Cache it for find_isinstance_check()
-            e.callee.type_guard = proper_callee.type_guard
+            if proper_callee.type_guard is not None:
+                e.callee.type_guard = proper_callee.type_guard
+            if proper_callee.type_is is not None:
+                e.callee.type_is = proper_callee.type_is
         return ret_type
 
     def check_union_call_expr(self, e: CallExpr, object_type: UnionType, member: str) -> Type:
         """Type check calling a member expression where the base type is a union."""
         res: list[Type] = []
         for typ in object_type.relevant_items():
             # Member access errors are already reported when visiting the member expression.
@@ -1851,14 +1863,16 @@
                 callee = callee.copy_modified(ret_type=item)
             elif isinstance(callee, Overloaded):
                 callee = Overloaded([c.copy_modified(ret_type=item) for c in callee.items])
             return callee
         # We support Type of namedtuples but not of tuples in general
         if isinstance(item, TupleType) and tuple_fallback(item).type.fullname != "builtins.tuple":
             return self.analyze_type_type_callee(tuple_fallback(item), context)
+        if isinstance(item, TypedDictType):
+            return self.typeddict_callable_from_context(item)
 
         self.msg.unsupported_type_type(item, context)
         return AnyType(TypeOfAny.from_error)
 
     def infer_arg_types_in_empty_context(self, args: list[Expression]) -> list[Type]:
         """Infer argument expression types in an empty context.
 
@@ -4433,14 +4447,18 @@
         if isinstance(index, IntExpr):
             return [index.value]
         elif isinstance(index, UnaryExpr):
             if index.op == "-":
                 operand = index.expr
                 if isinstance(operand, IntExpr):
                     return [-1 * operand.value]
+            if index.op == "+":
+                operand = index.expr
+                if isinstance(operand, IntExpr):
+                    return [operand.value]
         typ = get_proper_type(self.accept(index))
         if isinstance(typ, Instance) and typ.last_known_value is not None:
             typ = typ.last_known_value
         if isinstance(typ, LiteralType) and isinstance(typ.value, int):
             return [typ.value]
         if isinstance(typ, UnionType):
             out = []
@@ -5273,15 +5291,15 @@
             assert isinstance(erased_ctx, ProperType) and isinstance(erased_ctx, CallableType)
             callable_ctx = erased_ctx
 
         # The callable_ctx may have a fallback of builtins.type if the context
         # is a constructor -- but this fallback doesn't make sense for lambdas.
         callable_ctx = callable_ctx.copy_modified(fallback=self.named_type("builtins.function"))
 
-        if callable_ctx.type_guard is not None:
+        if callable_ctx.type_guard is not None or callable_ctx.type_is is not None:
             # Lambda's return type cannot be treated as a `TypeGuard`,
             # because it is implicit. And `TypeGuard`s must be explicit.
             # See https://github.com/python/mypy/issues/9927
             return None, None
 
         arg_kinds = [arg.kind for arg in e.arguments]
 
@@ -5954,25 +5972,15 @@
             message_registry.INCOMPATIBLE_TYPES_IN_YIELD_FROM,
             "actual type",
             "expected type",
         )
 
         # Determine the type of the entire yield from expression.
         iter_type = get_proper_type(iter_type)
-        if isinstance(iter_type, Instance) and iter_type.type.fullname == "typing.Generator":
-            expr_type = self.chk.get_generator_return_type(iter_type, False)
-        else:
-            # Non-Generators don't return anything from `yield from` expressions.
-            # However special-case Any (which might be produced by an error).
-            actual_item_type = get_proper_type(actual_item_type)
-            if isinstance(actual_item_type, AnyType):
-                expr_type = AnyType(TypeOfAny.from_another_any, source_any=actual_item_type)
-            else:
-                # Treat `Iterator[X]` as a shorthand for `Generator[X, None, Any]`.
-                expr_type = NoneType()
+        expr_type = self.chk.get_generator_return_type(iter_type, is_coroutine=False)
 
         if not allow_none_return and isinstance(get_proper_type(expr_type), NoneType):
             self.chk.msg.does_not_return_value(None, e)
         return expr_type
 
     def visit_temp_node(self, e: TempNode) -> Type:
         return e.type
```

## puya/_vendor/mypy/checkmember.py

```diff
@@ -119,14 +119,15 @@
 
     def copy_modified(
         self,
         *,
         messages: MessageBuilder | None = None,
         self_type: Type | None = None,
         is_lvalue: bool | None = None,
+        original_type: Type | None = None,
     ) -> MemberContext:
         mx = MemberContext(
             self.is_lvalue,
             self.is_super,
             self.is_operator,
             self.original_type,
             self.context,
@@ -138,14 +139,16 @@
         )
         if messages is not None:
             mx.msg = messages
         if self_type is not None:
             mx.self_type = self_type
         if is_lvalue is not None:
             mx.is_lvalue = is_lvalue
+        if original_type is not None:
+            mx.original_type = original_type
         return mx
 
 
 def analyze_member_access(
     name: str,
     typ: Type,
     context: Context,
@@ -355,21 +358,15 @@
         unsafe_super = True
         impl = node
     elif isinstance(node, OverloadedFuncDef):
         if node.impl:
             impl = node.impl if isinstance(node.impl, FuncDef) else node.impl.func
             unsafe_super = impl.is_trivial_body
     if unsafe_super:
-        ret_type = (
-            impl.type.ret_type
-            if isinstance(impl.type, CallableType)
-            else AnyType(TypeOfAny.unannotated)
-        )
-        if not subtypes.is_subtype(NoneType(), ret_type):
-            mx.msg.unsafe_super(node.name, node.info.name, mx.context)
+        mx.msg.unsafe_super(node.name, node.info.name, mx.context)
 
 
 def analyze_type_callable_member_access(name: str, typ: FunctionLike, mx: MemberContext) -> Type:
     # Class attribute.
     # TODO super?
     ret_type = typ.items[0].ret_type
     assert isinstance(ret_type, ProperType)
@@ -646,14 +643,24 @@
     descriptor_type = get_proper_type(descriptor_type)
 
     if isinstance(descriptor_type, UnionType):
         # Map the access over union types
         return make_simplified_union(
             [analyze_descriptor_access(typ, mx) for typ in descriptor_type.items]
         )
+    elif isinstance(instance_type, UnionType):
+        # map over the instance types
+        return make_simplified_union(
+            [
+                analyze_descriptor_access(
+                    descriptor_type, mx.copy_modified(original_type=original_type)
+                )
+                for original_type in instance_type.items
+            ]
+        )
     elif not isinstance(descriptor_type, Instance):
         return orig_descriptor_type
 
     if not descriptor_type.type.has_readable_member("__get__"):
         return orig_descriptor_type
 
     dunder_get = descriptor_type.type.get_method("__get__")
```

## puya/_vendor/mypy/checkpattern.py

```diff
@@ -198,15 +198,15 @@
         return PatternType(union_type, current_type, captures)
 
     def visit_value_pattern(self, o: ValuePattern) -> PatternType:
         current_type = self.type_context[-1]
         typ = self.chk.expr_checker.accept(o.expr)
         typ = coerce_to_literal(typ)
         narrowed_type, rest_type = self.chk.conditional_types_with_intersection(
-            current_type, [get_type_range(typ)], o, default=current_type
+            current_type, [get_type_range(typ)], o, default=get_proper_type(typ)
         )
         if not isinstance(get_proper_type(narrowed_type), (LiteralType, UninhabitedType)):
             return PatternType(narrowed_type, UnionType.make_union([narrowed_type, rest_type]), {})
         return PatternType(narrowed_type, rest_type, {})
 
     def visit_singleton_pattern(self, o: SingletonPattern) -> PatternType:
         current_type = self.type_context[-1]
```

## puya/_vendor/mypy/constraints.py

```diff
@@ -1014,18 +1014,30 @@
         extra_tvars = False
         if isinstance(self.actual, CallableType):
             res: list[Constraint] = []
             cactual = self.actual.with_unpacked_kwargs()
             param_spec = template.param_spec()
 
             template_ret_type, cactual_ret_type = template.ret_type, cactual.ret_type
-            if template.type_guard is not None:
+            if template.type_guard is not None and cactual.type_guard is not None:
                 template_ret_type = template.type_guard
-            if cactual.type_guard is not None:
                 cactual_ret_type = cactual.type_guard
+            elif template.type_guard is not None:
+                template_ret_type = AnyType(TypeOfAny.special_form)
+            elif cactual.type_guard is not None:
+                cactual_ret_type = AnyType(TypeOfAny.special_form)
+
+            if template.type_is is not None and cactual.type_is is not None:
+                template_ret_type = template.type_is
+                cactual_ret_type = cactual.type_is
+            elif template.type_is is not None:
+                template_ret_type = AnyType(TypeOfAny.special_form)
+            elif cactual.type_is is not None:
+                cactual_ret_type = AnyType(TypeOfAny.special_form)
+
             res.extend(infer_constraints(template_ret_type, cactual_ret_type, self.direction))
 
             if param_spec is None:
                 # TODO: Erase template variables if it is generic?
                 if (
                     type_state.infer_polymorphic
                     and cactual.variables
```

## puya/_vendor/mypy/errorcodes.py

```diff
@@ -277,9 +277,15 @@
 OVERLOAD_OVERLAP: Final[ErrorCode] = ErrorCode(
     "overload-overlap",
     "Warn if multiple @overload variants overlap in unsafe ways",
     "General",
     sub_code_of=MISC,
 )
 
+NARROWED_TYPE_NOT_SUBTYPE: Final[ErrorCode] = ErrorCode(
+    "narrowed-type-not-subtype",
+    "Warn if a TypeIs function's narrowed type is not a subtype of the original type",
+    "General",
+)
+
 # This copy will not include any error codes defined later in the plugins.
 mypy_error_codes = error_codes.copy()
```

## puya/_vendor/mypy/expandtype.py

```diff
@@ -22,14 +22,15 @@
     PartialType,
     ProperType,
     TrivialSyntheticTypeTranslator,
     TupleType,
     Type,
     TypeAliasType,
     TypedDictType,
+    TypeOfAny,
     TypeType,
     TypeVarId,
     TypeVarLikeType,
     TypeVarTupleType,
     TypeVarType,
     UnboundType,
     UninhabitedType,
@@ -175,14 +176,15 @@
 class ExpandTypeVisitor(TrivialSyntheticTypeTranslator):
     """Visitor that substitutes type variables with values."""
 
     variables: Mapping[TypeVarId, Type]  # TypeVar id -> TypeVar value
 
     def __init__(self, variables: Mapping[TypeVarId, Type]) -> None:
         self.variables = variables
+        self.recursive_tvar_guard: dict[TypeVarId, Type | None] = {}
 
     def visit_unbound_type(self, t: UnboundType) -> Type:
         return t
 
     def visit_any(self, t: AnyType) -> Type:
         return t
 
@@ -222,14 +224,22 @@
         if t.id.raw_id == 0:
             t = t.copy_modified(upper_bound=t.upper_bound.accept(self))
         repl = self.variables.get(t.id, t)
         if isinstance(repl, ProperType) and isinstance(repl, Instance):
             # TODO: do we really need to do this?
             # If I try to remove this special-casing ~40 tests fail on reveal_type().
             return repl.copy_modified(last_known_value=None)
+        if isinstance(repl, TypeVarType) and repl.has_default():
+            if (tvar_id := repl.id) in self.recursive_tvar_guard:
+                return self.recursive_tvar_guard[tvar_id] or repl
+            self.recursive_tvar_guard[tvar_id] = None
+            repl = repl.accept(self)
+            if isinstance(repl, TypeVarType):
+                repl.default = repl.default.accept(self)
+            self.recursive_tvar_guard[tvar_id] = repl
         return repl
 
     def visit_param_spec(self, t: ParamSpecType) -> Type:
         # Set prefix to something empty, so we don't duplicate it below.
         repl = self.variables.get(t.id, t.copy_modified(prefix=Parameters([], [], [])))
         if isinstance(repl, ParamSpecType):
             return repl.copy_modified(
@@ -299,32 +309,34 @@
 
     def interpolate_args_for_unpack(self, t: CallableType, var_arg: UnpackType) -> list[Type]:
         star_index = t.arg_kinds.index(ARG_STAR)
         prefix = self.expand_types(t.arg_types[:star_index])
         suffix = self.expand_types(t.arg_types[star_index + 1 :])
 
         var_arg_type = get_proper_type(var_arg.type)
+        new_unpack: Type
         if isinstance(var_arg_type, Instance):
             # we have something like Unpack[Tuple[Any, ...]]
             new_unpack = var_arg
-        else:
-            if isinstance(var_arg_type, TupleType):
-                # We have something like Unpack[Tuple[Unpack[Ts], X1, X2]]
-                expanded_tuple = var_arg_type.accept(self)
-                assert isinstance(expanded_tuple, ProperType) and isinstance(
-                    expanded_tuple, TupleType
-                )
-                expanded_items = expanded_tuple.items
-                fallback = var_arg_type.partial_fallback
-            else:
-                # We have plain Unpack[Ts]
-                assert isinstance(var_arg_type, TypeVarTupleType), type(var_arg_type)
-                fallback = var_arg_type.tuple_fallback
-                expanded_items = self.expand_unpack(var_arg)
+        elif isinstance(var_arg_type, TupleType):
+            # We have something like Unpack[Tuple[Unpack[Ts], X1, X2]]
+            expanded_tuple = var_arg_type.accept(self)
+            assert isinstance(expanded_tuple, ProperType) and isinstance(expanded_tuple, TupleType)
+            expanded_items = expanded_tuple.items
+            fallback = var_arg_type.partial_fallback
             new_unpack = UnpackType(TupleType(expanded_items, fallback))
+        elif isinstance(var_arg_type, TypeVarTupleType):
+            # We have plain Unpack[Ts]
+            fallback = var_arg_type.tuple_fallback
+            expanded_items = self.expand_unpack(var_arg)
+            new_unpack = UnpackType(TupleType(expanded_items, fallback))
+        else:
+            # We have invalid type in Unpack. This can happen when expanding aliases
+            # to Callable[[*Invalid], Ret]
+            new_unpack = AnyType(TypeOfAny.from_error, line=var_arg.line, column=var_arg.column)
         return prefix + [new_unpack] + suffix
 
     def visit_callable_type(self, t: CallableType) -> CallableType:
         param_spec = t.param_spec()
         if param_spec is not None:
             repl = self.variables.get(param_spec.id)
             # If a ParamSpec in a callable type is substituted with a
@@ -338,14 +350,15 @@
                 # We need to expand both the types in the prefix and the ParamSpec itself
                 return t.copy_modified(
                     arg_types=self.expand_types(t.arg_types[:-2]) + repl.arg_types,
                     arg_kinds=t.arg_kinds[:-2] + repl.arg_kinds,
                     arg_names=t.arg_names[:-2] + repl.arg_names,
                     ret_type=t.ret_type.accept(self),
                     type_guard=(t.type_guard.accept(self) if t.type_guard is not None else None),
+                    type_is=(t.type_is.accept(self) if t.type_is is not None else None),
                     imprecise_arg_kinds=(t.imprecise_arg_kinds or repl.imprecise_arg_kinds),
                     variables=[*repl.variables, *t.variables],
                 )
             elif isinstance(repl, ParamSpecType):
                 # We're substituting one ParamSpec for another; this can mean that the prefix
                 # changes, e.g. substitute Concatenate[int, P] in place of Q.
                 prefix = repl.prefix
@@ -371,14 +384,15 @@
             arg_types = self.interpolate_args_for_unpack(t, var_arg.typ)
         else:
             arg_types = self.expand_types(t.arg_types)
         expanded = t.copy_modified(
             arg_types=arg_types,
             ret_type=t.ret_type.accept(self),
             type_guard=(t.type_guard.accept(self) if t.type_guard is not None else None),
+            type_is=(t.type_is.accept(self) if t.type_is is not None else None),
         )
         if needs_normalization:
             return expanded.with_normalized_var_args()
         return expanded
 
     def visit_overloaded(self, t: Overloaded) -> Type:
         items: list[CallableType] = []
```

## puya/_vendor/mypy/exprtotype.py

```diff
@@ -179,17 +179,20 @@
     elif isinstance(expr, StrExpr):
         return parse_type_string(expr.value, "builtins.str", expr.line, expr.column)
     elif isinstance(expr, BytesExpr):
         return parse_type_string(expr.value, "builtins.bytes", expr.line, expr.column)
     elif isinstance(expr, UnaryExpr):
         typ = expr_to_unanalyzed_type(expr.expr, options, allow_new_syntax)
         if isinstance(typ, RawExpressionType):
-            if isinstance(typ.literal_value, int) and expr.op == "-":
-                typ.literal_value *= -1
-                return typ
+            if isinstance(typ.literal_value, int):
+                if expr.op == "-":
+                    typ.literal_value *= -1
+                    return typ
+                elif expr.op == "+":
+                    return typ
         raise TypeTranslationError()
     elif isinstance(expr, IntExpr):
         return RawExpressionType(expr.value, "builtins.int", line=expr.line, column=expr.column)
     elif isinstance(expr, FloatExpr):
         # Floats are not valid parameters for RawExpressionType , so we just
         # pass in 'None' for now. We'll report the appropriate error at a later stage.
         return RawExpressionType(None, "builtins.float", line=expr.line, column=expr.column)
```

## puya/_vendor/mypy/fixup.py

```diff
@@ -266,14 +266,16 @@
         for v in ct.variables:
             v.accept(self)
         for arg in ct.bound_args:
             if arg:
                 arg.accept(self)
         if ct.type_guard is not None:
             ct.type_guard.accept(self)
+        if ct.type_is is not None:
+            ct.type_is.accept(self)
 
     def visit_overloaded(self, t: Overloaded) -> None:
         for ct in t.items:
             ct.accept(self)
 
     def visit_erased_type(self, o: Any) -> None:
         # This type should exist only temporarily during type inference
```

## puya/_vendor/mypy/join.py

```diff
@@ -104,20 +104,25 @@
                             return object_from_instance(t)
                         if not is_subtype(new_type, type_var.upper_bound):
                             self.seen_instances.pop()
                             return object_from_instance(t)
                     # TODO: contravariant case should use meet but pass seen instances as
                     # an argument to keep track of recursive checks.
                     elif type_var.variance in (INVARIANT, CONTRAVARIANT):
-                        if not is_equivalent(ta, sa):
+                        if isinstance(ta_proper, UninhabitedType) and not ta_proper.is_noreturn:
+                            new_type = sa
+                        elif isinstance(sa_proper, UninhabitedType) and not sa_proper.is_noreturn:
+                            new_type = ta
+                        elif not is_equivalent(ta, sa):
                             self.seen_instances.pop()
                             return object_from_instance(t)
-                        # If the types are different but equivalent, then an Any is involved
-                        # so using a join in the contravariant case is also OK.
-                        new_type = join_types(ta, sa, self)
+                        else:
+                            # If the types are different but equivalent, then an Any is involved
+                            # so using a join in the contravariant case is also OK.
+                            new_type = join_types(ta, sa, self)
                 elif isinstance(type_var, TypeVarTupleType):
                     new_type = get_proper_type(join_types(ta, sa, self))
                     # Put the joined arguments back into instance in the normal form:
                     #   a) Tuple[X, Y, Z] -> [X, Y, Z]
                     #   b) tuple[X, ...] -> [*tuple[X, ...]]
                     if isinstance(new_type, Instance):
                         assert new_type.type.fullname == "builtins.tuple"
```

## puya/_vendor/mypy/message_registry.py

```diff
@@ -258,15 +258,15 @@
 CANNOT_INSTANTIATE_PROTOCOL: Final = ErrorMessage('Cannot instantiate protocol class "{}"')
 TOO_MANY_UNION_COMBINATIONS: Final = ErrorMessage(
     "Not all union combinations were tried because there are too many unions"
 )
 
 CONTIGUOUS_ITERABLE_EXPECTED: Final = ErrorMessage("Contiguous iterable with same type expected")
 ITERABLE_TYPE_EXPECTED: Final = ErrorMessage("Invalid type '{}' for *expr (iterable expected)")
-TYPE_GUARD_POS_ARG_REQUIRED: Final = ErrorMessage("Type guard requires positional argument")
+TYPE_GUARD_POS_ARG_REQUIRED: Final = ErrorMessage("Type {} requires positional argument")
 
 # Match Statement
 MISSING_MATCH_ARGS: Final = 'Class "{}" doesn\'t define "__match_args__"'
 OR_PATTERN_ALTERNATIVE_NAMES: Final = "Alternative patterns bind different names"
 CLASS_PATTERN_GENERIC_TYPE_ALIAS: Final = (
     "Class pattern class must not be a type alias with type parameters"
 )
@@ -320,7 +320,10 @@
 )
 ARG_CONSTRUCTOR_UNEXPECTED_ARG: Final = ErrorMessage(
     'Unexpected argument "{}" for argument constructor', codes.SYNTAX
 )
 ARG_NAME_EXPECTED_STRING_LITERAL: Final = ErrorMessage(
     "Expected string literal for argument name, got {}", codes.SYNTAX
 )
+NARROWED_TYPE_NOT_SUBTYPE: Final = ErrorMessage(
+    "Narrowed type {} is not a subtype of input type {}", codes.NARROWED_TYPE_NOT_SUBTYPE
+)
```

## puya/_vendor/mypy/messages.py

```diff
@@ -1775,14 +1775,16 @@
                     recommended_type = f"Optional[{type_dec}]"
             elif node.type.type.fullname in reverse_builtin_aliases:
                 # partial types other than partial None
                 alias = reverse_builtin_aliases[node.type.type.fullname]
                 alias = alias.split(".")[-1]
                 if alias == "Dict":
                     type_dec = f"{type_dec}, {type_dec}"
+                if self.options.use_lowercase_names():
+                    alias = alias.lower()
                 recommended_type = f"{alias}[{type_dec}]"
         if recommended_type is not None:
             hint = f' (hint: "{node.name}: {recommended_type} = ...")'
 
         self.fail(
             f'Need type annotation for "{unmangle(node.name)}"{hint}',
             context,
@@ -2055,14 +2057,23 @@
         self, formatted_base_class_list: str, reason: str, context: Context
     ) -> None:
         template = "Subclass of {} cannot exist: {}"
         self.fail(
             template.format(formatted_base_class_list, reason), context, code=codes.UNREACHABLE
         )
 
+    def tvar_without_default_type(
+        self, tvar_name: str, last_tvar_name_with_default: str, context: Context
+    ) -> None:
+        self.fail(
+            f'"{tvar_name}" cannot appear after "{last_tvar_name_with_default}" '
+            "in type parameter list because it has no default type",
+            context,
+        )
+
     def report_protocol_problems(
         self,
         subtype: Instance | TupleType | TypedDictType | TypeType | CallableType,
         supertype: Instance,
         context: Context,
         *,
         code: ErrorCode | None,
@@ -2630,14 +2641,16 @@
         if func.is_type_obj():
             # The type of a type object type can be derived from the
             # return type (this always works).
             return format(TypeType.make_normalized(erase_type(func.items[0].ret_type)))
         elif isinstance(func, CallableType):
             if func.type_guard is not None:
                 return_type = f"TypeGuard[{format(func.type_guard)}]"
+            elif func.type_is is not None:
+                return_type = f"TypeIs[{format(func.type_is)}]"
             else:
                 return_type = format(func.ret_type)
             if func.is_ellipsis_args:
                 return f"Callable[..., {return_type}]"
             param_spec = func.param_spec()
             if param_spec is not None:
                 return f"Callable[{format(param_spec)}, {return_type}]"
@@ -2846,14 +2859,16 @@
         s = f"{tp.name.split()[0]}({s})"  # skip "of Class" part
     else:
         s = f"({s})"
 
     s += " -> "
     if tp.type_guard is not None:
         s += f"TypeGuard[{format_type_bare(tp.type_guard, options)}]"
+    elif tp.type_is is not None:
+        s += f"TypeIs[{format_type_bare(tp.type_is, options)}]"
     else:
         s += format_type_bare(tp.ret_type, options)
 
     if tp.variables:
         tvars = []
         for tvar in tp.variables:
             if isinstance(tvar, TypeVarType):
```

## puya/_vendor/mypy/modulefinder.py

```diff
@@ -866,10 +866,10 @@
 def parse_version(version: str) -> tuple[int, int]:
     major, minor = version.strip().split(".")
     return int(major), int(minor)
 
 
 def typeshed_py_version(options: Options) -> tuple[int, int]:
     """Return Python version used for checking whether module supports typeshed."""
-    # Typeshed no longer covers Python 3.x versions before 3.7, so 3.7 is
+    # Typeshed no longer covers Python 3.x versions before 3.8, so 3.8 is
     # the earliest we can support.
-    return max(options.python_version, (3, 7))
+    return max(options.python_version, (3, 8))
```

## puya/_vendor/mypy/nodes.py

```diff
@@ -1751,14 +1751,15 @@
         "kind",
         "node",
         "_fullname",
         "is_new_def",
         "is_inferred_def",
         "is_alias_rvalue",
         "type_guard",
+        "type_is",
     )
 
     def __init__(self) -> None:
         super().__init__()
         # LDEF/GDEF/MDEF/... (None if not available)
         self.kind: int | None = None
         # Var, FuncDef or TypeInfo that describes this
@@ -1772,14 +1773,16 @@
         # For members, after semantic analysis, this does not take base
         # classes into consideration at all; the type checker deals with these.
         self.is_inferred_def = False
         # Is this expression appears as an rvalue of a valid type alias definition?
         self.is_alias_rvalue = False
         # Cache type guard from callable_type.type_guard
         self.type_guard: mypy.types.Type | None = None
+        # And same for TypeIs
+        self.type_is: mypy.types.Type | None = None
 
     @property
     def fullname(self) -> str:
         return self._fullname
 
     @fullname.setter
     def fullname(self, v: str) -> None:
```

## puya/_vendor/mypy/plugins/attrs.py

```diff
@@ -321,17 +321,14 @@
     """
     info = ctx.cls.info
 
     init = _get_decorator_bool_argument(ctx, "init", True)
     frozen = _get_frozen(ctx, frozen_default)
     order = _determine_eq_order(ctx)
     slots = _get_decorator_bool_argument(ctx, "slots", slots_default)
-    hashable = _get_decorator_bool_argument(ctx, "hash", False) or _get_decorator_bool_argument(
-        ctx, "unsafe_hash", False
-    )
 
     auto_attribs = _get_decorator_optional_bool_argument(ctx, "auto_attribs", auto_attribs_default)
     kw_only = _get_decorator_bool_argument(ctx, "kw_only", False)
     match_args = _get_decorator_bool_argument(ctx, "match_args", True)
 
     for super_info in ctx.cls.info.mro[1:-1]:
         if "attrs_tag" in super_info.metadata and "attrs" not in super_info.metadata:
@@ -367,15 +364,32 @@
     # If  __init__ is not being generated, attrs still generates it as __attrs_init__ instead.
     _add_init(ctx, attributes, adder, "__init__" if init else ATTRS_INIT_NAME)
 
     if order:
         _add_order(ctx, adder)
     if frozen:
         _make_frozen(ctx, attributes)
-    elif not hashable:
+        # Frozen classes are hashable by default, even if inheriting from non-frozen ones.
+        hashable: bool | None = _get_decorator_bool_argument(
+            ctx, "hash", True
+        ) and _get_decorator_bool_argument(ctx, "unsafe_hash", True)
+    else:
+        hashable = _get_decorator_optional_bool_argument(ctx, "unsafe_hash")
+        if hashable is None:  # unspecified
+            hashable = _get_decorator_optional_bool_argument(ctx, "hash")
+
+    eq = _get_decorator_optional_bool_argument(ctx, "eq")
+    has_own_hash = "__hash__" in ctx.cls.info.names
+
+    if has_own_hash or (hashable is None and eq is False):
+        pass  # Do nothing.
+    elif hashable:
+        # We copy the `__hash__` signature from `object` to make them hashable.
+        ctx.cls.info.names["__hash__"] = ctx.cls.info.mro[-1].names["__hash__"]
+    else:
         _remove_hashability(ctx)
 
     return True
 
 
 def _get_frozen(ctx: mypy.plugin.ClassDefContext, frozen_default: bool) -> bool:
     """Return whether this class is frozen."""
```

## puya/_vendor/mypy/plugins/dataclasses.py

```diff
@@ -20,14 +20,15 @@
     AssignmentStmt,
     Block,
     CallExpr,
     ClassDef,
     Context,
     DataclassTransformSpec,
     Decorator,
+    EllipsisExpr,
     Expression,
     FuncDef,
     FuncItem,
     IfStmt,
     JsonDict,
     NameExpr,
     Node,
@@ -145,21 +146,21 @@
             # But, most people won't care about adding default values to `__post_init__`,
             # because it is not designed to be called directly, and duplicating default values
             # for the sake of type-checking is unpleasant.
             arg_kind = ARG_POS
         return Argument(
             variable=self.to_var(current_info),
             type_annotation=self.expand_type(current_info),
-            initializer=None,
+            initializer=EllipsisExpr() if self.has_default else None,  # Only used by stubgen
             kind=arg_kind,
         )
 
     def expand_type(self, current_info: TypeInfo) -> Type | None:
         if self.type is not None and self.info.self_type is not None:
-            # In general, it is not safe to call `expand_type()` during semantic analyzis,
+            # In general, it is not safe to call `expand_type()` during semantic analysis,
             # however this plugin is called very late, so all types should be fully ready.
             # Also, it is tricky to avoid eager expansion of Self types here (e.g. because
             # we serialize attributes).
             with state.strict_optional_set(self._api.options.strict_optional):
                 return expand_type(
                     self.type, {self.info.self_type.id: fill_typevars(current_info)}
                 )
@@ -265,19 +266,25 @@
                 # Make positional args optional since we don't know their order.
                 # This will at least allow us to typecheck them if they are called
                 # as kwargs
                 for arg in args:
                     if arg.kind == ARG_POS:
                         arg.kind = ARG_OPT
 
-                nameless_var = Var("")
+                existing_args_names = {arg.variable.name for arg in args}
+                gen_args_name = "generated_args"
+                while gen_args_name in existing_args_names:
+                    gen_args_name += "_"
+                gen_kwargs_name = "generated_kwargs"
+                while gen_kwargs_name in existing_args_names:
+                    gen_kwargs_name += "_"
                 args = [
-                    Argument(nameless_var, AnyType(TypeOfAny.explicit), None, ARG_STAR),
+                    Argument(Var(gen_args_name), AnyType(TypeOfAny.explicit), None, ARG_STAR),
                     *args,
-                    Argument(nameless_var, AnyType(TypeOfAny.explicit), None, ARG_STAR2),
+                    Argument(Var(gen_kwargs_name), AnyType(TypeOfAny.explicit), None, ARG_STAR2),
                 ]
 
             add_method_to_class(
                 self._api, self._cls, "__init__", args=args, return_type=NoneType()
             )
 
         if (
```

## puya/_vendor/mypy/plugins/default.py

```diff
@@ -96,14 +96,16 @@
 
         if fullname == "typing.Mapping.get":
             return typed_dict_get_callback
         elif fullname == "builtins.int.__pow__":
             return int_pow_callback
         elif fullname == "builtins.int.__neg__":
             return int_neg_callback
+        elif fullname == "builtins.int.__pos__":
+            return int_pos_callback
         elif fullname in ("builtins.tuple.__mul__", "builtins.tuple.__rmul__"):
             return tuple_mul_callback
         elif fullname in {n + ".setdefault" for n in TPDICT_FB_NAMES}:
             return typed_dict_setdefault_callback
         elif fullname in {n + ".pop" for n in TPDICT_FB_NAMES}:
             return typed_dict_pop_callback
         elif fullname in {n + ".__delitem__" for n in TPDICT_FB_NAMES}:
@@ -467,40 +469,51 @@
         if exponent >= 0:
             return ctx.api.named_generic_type("builtins.int", [])
         else:
             return ctx.api.named_generic_type("builtins.float", [])
     return ctx.default_return_type
 
 
-def int_neg_callback(ctx: MethodContext) -> Type:
-    """Infer a more precise return type for int.__neg__.
+def int_neg_callback(ctx: MethodContext, multiplier: int = -1) -> Type:
+    """Infer a more precise return type for int.__neg__ and int.__pos__.
 
     This is mainly used to infer the return type as LiteralType
-    if the original underlying object is a LiteralType object
+    if the original underlying object is a LiteralType object.
     """
     if isinstance(ctx.type, Instance) and ctx.type.last_known_value is not None:
         value = ctx.type.last_known_value.value
         fallback = ctx.type.last_known_value.fallback
         if isinstance(value, int):
             if is_literal_type_like(ctx.api.type_context[-1]):
-                return LiteralType(value=-value, fallback=fallback)
+                return LiteralType(value=multiplier * value, fallback=fallback)
             else:
                 return ctx.type.copy_modified(
                     last_known_value=LiteralType(
-                        value=-value, fallback=ctx.type, line=ctx.type.line, column=ctx.type.column
+                        value=multiplier * value,
+                        fallback=ctx.type,
+                        line=ctx.type.line,
+                        column=ctx.type.column,
                     )
                 )
     elif isinstance(ctx.type, LiteralType):
         value = ctx.type.value
         fallback = ctx.type.fallback
         if isinstance(value, int):
-            return LiteralType(value=-value, fallback=fallback)
+            return LiteralType(value=multiplier * value, fallback=fallback)
     return ctx.default_return_type
 
 
+def int_pos_callback(ctx: MethodContext) -> Type:
+    """Infer a more precise return type for int.__pos__.
+
+    This is identical to __neg__, except the value is not inverted.
+    """
+    return int_neg_callback(ctx, +1)
+
+
 def tuple_mul_callback(ctx: MethodContext) -> Type:
     """Infer a more precise return type for tuple.__mul__ and tuple.__rmul__.
 
     This is used to return a specific sized tuple if multiplied by Literal int
     """
     if not isinstance(ctx.type, TupleType):
         return ctx.default_return_type
```

## puya/_vendor/mypy/semanal.py

```diff
@@ -48,15 +48,15 @@
   reduce memory use).
 """
 
 from __future__ import annotations
 
 from contextlib import contextmanager
 from typing import Any, Callable, Collection, Final, Iterable, Iterator, List, TypeVar, cast
-from typing_extensions import TypeAlias as _TypeAlias
+from typing_extensions import TypeAlias as _TypeAlias, TypeGuard
 
 from mypy import errorcodes as codes, message_registry
 from mypy.constant_fold import constant_fold_expr
 from mypy.errorcodes import ErrorCode
 from mypy.errors import Errors, report_internal_error
 from mypy.exprtotype import TypeTranslationError, expr_to_unanalyzed_type
 from mypy.messages import (
@@ -222,14 +222,15 @@
 )
 from mypy.semanal_typeddict import TypedDictAnalyzer
 from mypy.tvar_scope import TypeVarLikeScope
 from mypy.typeanal import (
     SELF_TYPE_NAMES,
     FindTypeVarVisitor,
     TypeAnalyser,
+    TypeVarDefaultTranslator,
     TypeVarLikeList,
     analyze_type_alias,
     check_for_explicit_any,
     detect_diverging_alias,
     find_self_type,
     fix_instance,
     has_any_from_unimported_type,
@@ -248,14 +249,15 @@
     OVERLOAD_NAMES,
     OVERRIDE_DECORATOR_NAMES,
     PROTOCOL_NAMES,
     REVEAL_TYPE_NAMES,
     TPDICT_NAMES,
     TYPE_ALIAS_NAMES,
     TYPE_CHECK_ONLY_NAMES,
+    TYPE_VAR_LIKE_NAMES,
     TYPED_NAMEDTUPLE_NAMES,
     AnyType,
     CallableType,
     FunctionLike,
     Instance,
     LiteralType,
     NoneType,
@@ -875,14 +877,21 @@
                         self.fail(
                             "TypeGuard functions must have a positional argument",
                             result,
                             code=codes.VALID_TYPE,
                         )
                         # in this case, we just kind of just ... remove the type guard.
                         result = result.copy_modified(type_guard=None)
+                    if result.type_is and ARG_POS not in result.arg_kinds[skip_self:]:
+                        self.fail(
+                            '"TypeIs" functions must have a positional argument',
+                            result,
+                            code=codes.VALID_TYPE,
+                        )
+                        result = result.copy_modified(type_is=None)
 
                     result = self.remove_unpack_kwargs(defn, result)
                     if has_self_type and self.type is not None:
                         info = self.type
                         if info.self_type is not None:
                             result.variables = [info.self_type] + list(result.variables)
                 defn.type = result
@@ -1949,16 +1958,27 @@
         for i in reversed(removed):
             # We need to actually remove the base class expressions like Generic[T],
             # mostly because otherwise they will create spurious dependencies in fine
             # grained incremental mode.
             defn.removed_base_type_exprs.append(defn.base_type_exprs[i])
             del base_type_exprs[i]
         tvar_defs: list[TypeVarLikeType] = []
+        last_tvar_name_with_default: str | None = None
         for name, tvar_expr in declared_tvars:
+            tvar_expr.default = tvar_expr.default.accept(
+                TypeVarDefaultTranslator(self, tvar_expr.name, context)
+            )
             tvar_def = self.tvar_scope.bind_new(name, tvar_expr)
+            if last_tvar_name_with_default is not None and not tvar_def.has_default():
+                self.msg.tvar_without_default_type(
+                    tvar_def.name, last_tvar_name_with_default, context
+                )
+                tvar_def.default = AnyType(TypeOfAny.from_error)
+            elif tvar_def.has_default():
+                last_tvar_name_with_default = tvar_def.name
             tvar_defs.append(tvar_def)
         return base_type_exprs, tvar_defs, is_protocol
 
     def analyze_class_typevar_declaration(self, base: Type) -> tuple[TypeVarLikeList, bool] | None:
         """Analyze type variables declared using Generic[...] or Protocol[...].
 
         Args:
@@ -1994,42 +2014,43 @@
                 elif not self.found_incomplete_ref(tag):
                     self.fail("Free type variable expected in %s[...]" % sym.node.name, base)
             return tvars, is_proto
         return None
 
     def analyze_unbound_tvar(self, t: Type) -> tuple[str, TypeVarLikeExpr] | None:
         if isinstance(t, UnpackType) and isinstance(t.type, UnboundType):
-            return self.analyze_unbound_tvar_impl(t.type, allow_tvt=True)
+            return self.analyze_unbound_tvar_impl(t.type, is_unpacked=True)
         if isinstance(t, UnboundType):
             sym = self.lookup_qualified(t.name, t)
             if sym and sym.fullname in ("typing.Unpack", "typing_extensions.Unpack"):
                 inner_t = t.args[0]
                 if isinstance(inner_t, UnboundType):
-                    return self.analyze_unbound_tvar_impl(inner_t, allow_tvt=True)
+                    return self.analyze_unbound_tvar_impl(inner_t, is_unpacked=True)
                 return None
             return self.analyze_unbound_tvar_impl(t)
         return None
 
     def analyze_unbound_tvar_impl(
-        self, t: UnboundType, allow_tvt: bool = False
+        self, t: UnboundType, is_unpacked: bool = False, is_typealias_param: bool = False
     ) -> tuple[str, TypeVarLikeExpr] | None:
+        assert not is_unpacked or not is_typealias_param, "Mutually exclusive conditions"
         sym = self.lookup_qualified(t.name, t)
         if sym and isinstance(sym.node, PlaceholderNode):
             self.record_incomplete_ref()
-        if not allow_tvt and sym and isinstance(sym.node, ParamSpecExpr):
+        if not is_unpacked and sym and isinstance(sym.node, ParamSpecExpr):
             if sym.fullname and not self.tvar_scope.allow_binding(sym.fullname):
                 # It's bound by our type variable scope
                 return None
             return t.name, sym.node
-        if allow_tvt and sym and isinstance(sym.node, TypeVarTupleExpr):
+        if (is_unpacked or is_typealias_param) and sym and isinstance(sym.node, TypeVarTupleExpr):
             if sym.fullname and not self.tvar_scope.allow_binding(sym.fullname):
                 # It's bound by our type variable scope
                 return None
             return t.name, sym.node
-        if sym is None or not isinstance(sym.node, TypeVarExpr) or allow_tvt:
+        if sym is None or not isinstance(sym.node, TypeVarExpr) or is_unpacked:
             return None
         elif sym.fullname and not self.tvar_scope.allow_binding(sym.fullname):
             # It's bound by our type variable scope
             return None
         else:
             assert isinstance(sym.node, TypeVarExpr)
             return t.name, sym.node
@@ -2842,14 +2863,18 @@
         # To break the tie, we first analyse rvalue partially, if it can be a type alias.
         if self.can_possibly_be_type_form(s):
             old_basic_type_applications = self.basic_type_applications
             self.basic_type_applications = True
             with self.allow_unbound_tvars_set():
                 s.rvalue.accept(self)
             self.basic_type_applications = old_basic_type_applications
+        elif self.can_possibly_be_typevarlike_declaration(s):
+            # Allow unbound tvars inside TypeVarLike defaults to be evaluated later
+            with self.allow_unbound_tvars_set():
+                s.rvalue.accept(self)
         else:
             s.rvalue.accept(self)
 
         if self.found_incomplete_ref(tag) or self.should_wait_rhs(s.rvalue):
             # Initializer couldn't be fully analyzed. Defer the current node and give up.
             # Make sure that if we skip the definition of some local names, they can't be
             # added later in this scope, since an earlier definition should take precedence.
@@ -3018,14 +3043,24 @@
         if s.unanalyzed_type is not None and not self.is_pep_613(s):
             return False
         if not isinstance(s.rvalue, (IndexExpr, OpExpr)):
             return False
         # Something that looks like Foo = Bar[Baz, ...]
         return True
 
+    def can_possibly_be_typevarlike_declaration(self, s: AssignmentStmt) -> bool:
+        """Check if r.h.s. can be a TypeVarLike declaration."""
+        if len(s.lvalues) != 1 or not isinstance(s.lvalues[0], NameExpr):
+            return False
+        if not isinstance(s.rvalue, CallExpr) or not isinstance(s.rvalue.callee, NameExpr):
+            return False
+        ref = s.rvalue.callee
+        ref.accept(self)
+        return ref.fullname in TYPE_VAR_LIKE_NAMES
+
     def is_type_ref(self, rv: Expression, bare: bool = False) -> bool:
         """Does this expression refer to a type?
 
         This includes:
           * Special forms, like Any or Union
           * Classes (except subscripted enums)
           * Other type aliases
@@ -3477,15 +3512,20 @@
 
         typ = self.named_type_or_none(type_name)
         if typ and is_final:
             return typ.copy_modified(last_known_value=LiteralType(value=value, fallback=typ))
         return typ
 
     def analyze_alias(
-        self, name: str, rvalue: Expression, allow_placeholder: bool = False
+        self,
+        name: str,
+        rvalue: Expression,
+        allow_placeholder: bool = False,
+        declared_type_vars: TypeVarLikeList | None = None,
+        all_declared_type_params_names: list[str] | None = None,
     ) -> tuple[Type | None, list[TypeVarLikeType], set[str], list[str], bool]:
         """Check if 'rvalue' is a valid type allowed for aliasing (e.g. not a type variable).
 
         If yes, return the corresponding type, a list of
         qualified type variable names for generic aliases, a set of names the alias depends on,
         and a list of type variables if the alias is generic.
         A schematic example for the dependencies:
@@ -3502,43 +3542,56 @@
                 "Invalid type alias: expression is not a valid type", rvalue, code=codes.VALID_TYPE
             )
             return None, [], set(), [], False
 
         found_type_vars = self.find_type_var_likes(typ)
         tvar_defs: list[TypeVarLikeType] = []
         namespace = self.qualified_name(name)
+        alias_type_vars = found_type_vars if declared_type_vars is None else declared_type_vars
+        last_tvar_name_with_default: str | None = None
         with self.tvar_scope_frame(self.tvar_scope.class_frame(namespace)):
-            for name, tvar_expr in found_type_vars:
+            for name, tvar_expr in alias_type_vars:
+                tvar_expr.default = tvar_expr.default.accept(
+                    TypeVarDefaultTranslator(self, tvar_expr.name, typ)
+                )
                 tvar_def = self.tvar_scope.bind_new(name, tvar_expr)
+                if last_tvar_name_with_default is not None and not tvar_def.has_default():
+                    self.msg.tvar_without_default_type(
+                        tvar_def.name, last_tvar_name_with_default, typ
+                    )
+                    tvar_def.default = AnyType(TypeOfAny.from_error)
+                elif tvar_def.has_default():
+                    last_tvar_name_with_default = tvar_def.name
                 tvar_defs.append(tvar_def)
 
             analyzed, depends_on = analyze_type_alias(
                 typ,
                 self,
                 self.tvar_scope,
                 self.plugin,
                 self.options,
                 self.is_typeshed_stub_file,
                 allow_placeholder=allow_placeholder,
                 in_dynamic_func=dynamic,
                 global_scope=global_scope,
                 allowed_alias_tvars=tvar_defs,
+                alias_type_params_names=all_declared_type_params_names,
             )
 
         # There can be only one variadic variable at most, the error is reported elsewhere.
         new_tvar_defs = []
         variadic = False
         for td in tvar_defs:
             if isinstance(td, TypeVarTupleType):
                 if variadic:
                     continue
                 variadic = True
             new_tvar_defs.append(td)
 
-        qualified_tvars = [node.fullname for _name, node in found_type_vars]
+        qualified_tvars = [node.fullname for _name, node in alias_type_vars]
         empty_tuple_index = typ.empty_tuple_index if isinstance(typ, UnboundType) else False
         return analyzed, new_tvar_defs, depends_on, qualified_tvars, empty_tuple_index
 
     def is_pep_613(self, s: AssignmentStmt) -> bool:
         if s.unanalyzed_type is not None and isinstance(s.unanalyzed_type, UnboundType):
             lookup = self.lookup_qualified(s.unanalyzed_type.name, s, suppress_errors=True)
             if lookup and lookup.fullname in TYPE_ALIAS_NAMES:
@@ -3563,15 +3616,29 @@
 
         pep_613 = self.is_pep_613(s)
         if not pep_613 and s.unanalyzed_type is not None:
             # Second rule: Explicit type (cls: Type[A] = A) always creates variable, not alias.
             # unless using PEP 613 `cls: TypeAlias = A`
             return False
 
-        if isinstance(s.rvalue, CallExpr) and s.rvalue.analyzed:
+        # It can be `A = TypeAliasType('A', ...)` call, in this case,
+        # we just take the second argument and analyze it:
+        type_params: TypeVarLikeList | None
+        all_type_params_names: list[str] | None
+        if self.check_type_alias_type_call(s.rvalue, name=lvalue.name):
+            rvalue = s.rvalue.args[1]
+            pep_695 = True
+            type_params, all_type_params_names = self.analyze_type_alias_type_params(s.rvalue)
+        else:
+            rvalue = s.rvalue
+            pep_695 = False
+            type_params = None
+            all_type_params_names = None
+
+        if isinstance(rvalue, CallExpr) and rvalue.analyzed:
             return False
 
         existing = self.current_symbol_table().get(lvalue.name)
         # Third rule: type aliases can't be re-defined. For example:
         #     A: Type[float] = int
         #     A = float  # OK, but this doesn't define an alias
         #     B = int
@@ -3589,28 +3656,27 @@
                     'Cannot assign multiple types to name "{}"'
                     ' without an explicit "Type[...]" annotation'.format(lvalue.name),
                     lvalue,
                 )
             return False
 
         non_global_scope = self.type or self.is_func_scope()
-        if not pep_613 and isinstance(s.rvalue, RefExpr) and non_global_scope:
+        if not pep_613 and not pep_695 and isinstance(rvalue, RefExpr) and non_global_scope:
             # Fourth rule (special case): Non-subscripted right hand side creates a variable
             # at class and function scopes. For example:
             #
             #   class Model:
             #       ...
             #   class C:
             #       model = Model # this is automatically a variable with type 'Type[Model]'
             #
             # without this rule, this typical use case will require a lot of explicit
             # annotations (see the second rule).
             return False
-        rvalue = s.rvalue
-        if not pep_613 and not self.can_be_type_alias(rvalue):
+        if not pep_613 and not pep_695 and not self.can_be_type_alias(rvalue):
             return False
 
         if existing and not isinstance(existing.node, (PlaceholderNode, TypeAlias)):
             # Cannot redefine existing node as type alias.
             return False
 
         res: Type | None = None
@@ -3619,15 +3685,19 @@
             alias_tvars: list[TypeVarLikeType] = []
             depends_on: set[str] = set()
             qualified_tvars: list[str] = []
             empty_tuple_index = False
         else:
             tag = self.track_incomplete_refs()
             res, alias_tvars, depends_on, qualified_tvars, empty_tuple_index = self.analyze_alias(
-                lvalue.name, rvalue, allow_placeholder=True
+                lvalue.name,
+                rvalue,
+                allow_placeholder=True,
+                declared_type_vars=type_params,
+                all_declared_type_params_names=all_type_params_names,
             )
             if not res:
                 return False
             if not self.is_func_scope():
                 # Only marking incomplete for top-level placeholders makes recursive aliases like
                 # `A = Sequence[str | A]` valid here, similar to how we treat base classes in class
                 # definitions, allowing `class str(Sequence[str]): ...`
@@ -3649,21 +3719,23 @@
         # For subscripted aliases, type deps from expansion are added in deps.py
         # (because the type is stored).
         check_for_explicit_any(res, self.options, self.is_typeshed_stub_file, self.msg, context=s)
         # When this type alias gets "inlined", the Any is not explicit anymore,
         # so we need to replace it with non-explicit Anys.
         res = make_any_non_explicit(res)
         # Note: with the new (lazy) type alias representation we only need to set no_args to True
-        # if the expected number of arguments is non-zero, so that aliases like A = List work.
+        # if the expected number of arguments is non-zero, so that aliases like `A = List` work
+        # but not aliases like `A = TypeAliasType("A", List)` as these need explicit type params.
         # However, eagerly expanding aliases like Text = str is a nice performance optimization.
         no_args = (
             isinstance(res, ProperType)
             and isinstance(res, Instance)
             and not res.args
             and not empty_tuple_index
+            and not pep_695
         )
         if isinstance(res, ProperType) and isinstance(res, Instance):
             if not validate_instance(res, self.fail, empty_tuple_index):
                 fix_instance(res, self.fail, self.note, disallow_any=False, options=self.options)
         # Aliases defined within functions can't be accessed outside
         # the function, since the symbol table will no longer
         # exist. Work around by expanding them eagerly when used.
@@ -3722,14 +3794,100 @@
             assert self.type is not None
             if self.type.is_protocol:
                 self.fail("Type aliases are prohibited in protocol bodies", s)
                 if not lvalue.name[0].isupper():
                     self.note("Use variable annotation syntax to define protocol members", s)
         return True
 
+    def check_type_alias_type_call(self, rvalue: Expression, *, name: str) -> TypeGuard[CallExpr]:
+        if not isinstance(rvalue, CallExpr):
+            return False
+
+        names = ["typing_extensions.TypeAliasType"]
+        if self.options.python_version >= (3, 12):
+            names.append("typing.TypeAliasType")
+        if not refers_to_fullname(rvalue.callee, tuple(names)):
+            return False
+
+        return self.check_typevarlike_name(rvalue, name, rvalue)
+
+    def analyze_type_alias_type_params(
+        self, rvalue: CallExpr
+    ) -> tuple[TypeVarLikeList, list[str]]:
+        """Analyze type_params of TypeAliasType.
+
+        Returns declared unbound type variable expressions and a list of all decalred type
+        variable names for error reporting.
+        """
+        if "type_params" in rvalue.arg_names:
+            type_params_arg = rvalue.args[rvalue.arg_names.index("type_params")]
+            if not isinstance(type_params_arg, TupleExpr):
+                self.fail(
+                    "Tuple literal expected as the type_params argument to TypeAliasType",
+                    type_params_arg,
+                )
+                return [], []
+            type_params = type_params_arg.items
+        else:
+            return [], []
+
+        declared_tvars: TypeVarLikeList = []
+        all_declared_tvar_names: list[str] = []  # includes bound type variables
+        have_type_var_tuple = False
+        for tp_expr in type_params:
+            if isinstance(tp_expr, StarExpr):
+                tp_expr.valid = False
+            self.analyze_type_expr(tp_expr)
+            try:
+                base = self.expr_to_unanalyzed_type(tp_expr)
+            except TypeTranslationError:
+                continue
+            if not isinstance(base, UnboundType):
+                continue
+
+            tag = self.track_incomplete_refs()
+            tvar = self.analyze_unbound_tvar_impl(base, is_typealias_param=True)
+            if tvar:
+                if isinstance(tvar[1], TypeVarTupleExpr):
+                    if have_type_var_tuple:
+                        self.fail(
+                            "Can only use one TypeVarTuple in type_params argument to TypeAliasType",
+                            base,
+                            code=codes.TYPE_VAR,
+                        )
+                        have_type_var_tuple = True
+                        continue
+                    have_type_var_tuple = True
+            elif not self.found_incomplete_ref(tag):
+                sym = self.lookup_qualified(base.name, base)
+                if sym and isinstance(sym.node, TypeVarLikeExpr):
+                    all_declared_tvar_names.append(sym.node.name)  # Error will be reported later
+                else:
+                    self.fail(
+                        "Free type variable expected in type_params argument to TypeAliasType",
+                        base,
+                        code=codes.TYPE_VAR,
+                    )
+                    if sym and sym.fullname in ("typing.Unpack", "typing_extensions.Unpack"):
+                        self.note(
+                            "Don't Unpack type variables in type_params", base, code=codes.TYPE_VAR
+                        )
+                continue
+            if tvar in declared_tvars:
+                self.fail(
+                    f'Duplicate type variable "{tvar[0]}" in type_params argument to TypeAliasType',
+                    base,
+                    code=codes.TYPE_VAR,
+                )
+                continue
+            if tvar:
+                all_declared_tvar_names.append(tvar[0])
+                declared_tvars.append(tvar)
+        return declared_tvars, all_declared_tvar_names
+
     def disable_invalid_recursive_aliases(
         self, s: AssignmentStmt, current_node: TypeAlias
     ) -> None:
         """Prohibit and fix recursive type aliases that are invalid/unsupported."""
         messages = []
         if is_invalid_recursive_alias({current_node}, current_node.target):
             target = (
@@ -5138,14 +5296,20 @@
             expr.analyzed = self.translate_dict_call(expr)
         elif refers_to_fullname(expr.callee, "builtins.divmod"):
             if not self.check_fixed_args(expr, 2, "divmod"):
                 return
             expr.analyzed = OpExpr("divmod", expr.args[0], expr.args[1])
             expr.analyzed.line = expr.line
             expr.analyzed.accept(self)
+        elif refers_to_fullname(
+            expr.callee, ("typing.TypeAliasType", "typing_extensions.TypeAliasType")
+        ):
+            with self.allow_unbound_tvars_set():
+                for a in expr.args:
+                    a.accept(self)
         else:
             # Normal call expression.
             for a in expr.args:
                 a.accept(self)
 
             if (
                 isinstance(expr.callee, MemberExpr)
```

## puya/_vendor/mypy/stubgen.py

```diff
@@ -43,15 +43,15 @@
 
 import argparse
 import keyword
 import os
 import os.path
 import sys
 import traceback
-from typing import Final, Iterable
+from typing import Final, Iterable, Iterator
 
 import mypy.build
 import mypy.mixedtraverser
 import mypy.parse
 import mypy.traverser
 import mypy.util
 from mypy.build import build
@@ -106,17 +106,19 @@
     TempNode,
     TupleExpr,
     TypeInfo,
     UnaryExpr,
     Var,
 )
 from mypy.options import Options as MypyOptions
+from mypy.sharedparse import MAGIC_METHODS_POS_ARGS_ONLY
 from mypy.stubdoc import ArgSig, FunctionSig
 from mypy.stubgenc import InspectionStubGenerator, generate_stub_for_c_module
 from mypy.stubutil import (
+    TYPING_BUILTIN_REPLACEMENTS,
     BaseStubGenerator,
     CantImport,
     ClassInfo,
     FunctionContext,
     common_dir_prefix,
     fail_missing,
     find_module_path_and_all_py3,
@@ -284,28 +286,27 @@
                 args.append("**" + arg.accept(self))
             elif kind == ARG_NAMED:
                 args.append(f"{name}={arg.accept(self)}")
             else:
                 raise ValueError(f"Unknown argument kind {kind} in call")
         return f"{callee}({', '.join(args)})"
 
+    def _visit_ref_expr(self, node: NameExpr | MemberExpr) -> str:
+        fullname = self.stubgen.get_fullname(node)
+        if fullname in TYPING_BUILTIN_REPLACEMENTS:
+            return self.stubgen.add_name(TYPING_BUILTIN_REPLACEMENTS[fullname], require=False)
+        qualname = get_qualified_name(node)
+        self.stubgen.import_tracker.require_name(qualname)
+        return qualname
+
     def visit_name_expr(self, node: NameExpr) -> str:
-        self.stubgen.import_tracker.require_name(node.name)
-        return node.name
+        return self._visit_ref_expr(node)
 
     def visit_member_expr(self, o: MemberExpr) -> str:
-        node: Expression = o
-        trailer = ""
-        while isinstance(node, MemberExpr):
-            trailer = "." + node.name + trailer
-            node = node.expr
-        if not isinstance(node, NameExpr):
-            return ERROR_MARKER
-        self.stubgen.import_tracker.require_name(node.name)
-        return node.name + trailer
+        return self._visit_ref_expr(o)
 
     def visit_str_expr(self, node: StrExpr) -> str:
         return repr(node.value)
 
     def visit_index_expr(self, node: IndexExpr) -> str:
         base_fullname = self.stubgen.get_fullname(node.base)
         if base_fullname == "typing.Union":
@@ -346,31 +347,41 @@
 
 def find_defined_names(file: MypyFile) -> set[str]:
     finder = DefinitionFinder()
     file.accept(finder)
     return finder.names
 
 
+def get_assigned_names(lvalues: Iterable[Expression]) -> Iterator[str]:
+    for lvalue in lvalues:
+        if isinstance(lvalue, NameExpr):
+            yield lvalue.name
+        elif isinstance(lvalue, TupleExpr):
+            yield from get_assigned_names(lvalue.items)
+
+
 class DefinitionFinder(mypy.traverser.TraverserVisitor):
     """Find names of things defined at the top level of a module."""
 
-    # TODO: Assignment statements etc.
-
     def __init__(self) -> None:
         # Short names of things defined at the top level.
         self.names: set[str] = set()
 
     def visit_class_def(self, o: ClassDef) -> None:
         # Don't recurse into classes, as we only keep track of top-level definitions.
         self.names.add(o.name)
 
     def visit_func_def(self, o: FuncDef) -> None:
         # Don't recurse, as we only keep track of top-level definitions.
         self.names.add(o.name)
 
+    def visit_assignment_stmt(self, o: AssignmentStmt) -> None:
+        for name in get_assigned_names(o.lvalues):
+            self.names.add(name)
+
 
 def find_referenced_names(file: MypyFile) -> set[str]:
     finder = ReferenceFinder()
     file.accept(finder)
     return finder.refs
 
 
@@ -476,14 +487,17 @@
         args = self._get_func_args(func_def, ctx)
         retname = self._get_func_return(func_def, ctx)
         return FunctionSig(func_def.name, args, retname)
 
     def _get_func_args(self, o: FuncDef, ctx: FunctionContext) -> list[ArgSig]:
         args: list[ArgSig] = []
 
+        # Ignore pos-only status of magic methods whose args names are elided by mypy at parse
+        actually_pos_only_args = o.name not in MAGIC_METHODS_POS_ARGS_ONLY
+        pos_only_marker_position = 0  # Where to insert "/", if any
         for i, arg_ in enumerate(o.arguments):
             var = arg_.variable
             kind = arg_.kind
             name = var.name
             annotated_type = (
                 o.unanalyzed_type.arg_types[i]
                 if isinstance(o.unanalyzed_type, CallableType)
@@ -496,14 +510,17 @@
             typename: str | None = None
             if annotated_type and not is_self_arg and not is_cls_arg:
                 # Luckily, an argument explicitly annotated with "Any" has
                 # type "UnboundType" and will not match.
                 if not isinstance(get_proper_type(annotated_type), AnyType):
                     typename = self.print_annotation(annotated_type)
 
+            if actually_pos_only_args and arg_.pos_only:
+                pos_only_marker_position += 1
+
             if kind.is_named() and not any(arg.name.startswith("*") for arg in args):
                 args.append(ArgSig("*"))
 
             default = "..."
             if arg_.initializer:
                 if not typename:
                     typename = self.get_str_type_of_node(arg_.initializer, True, False)
@@ -514,35 +531,26 @@
                 name = f"*{name}"
             elif kind == ARG_STAR2:
                 name = f"**{name}"
 
             args.append(
                 ArgSig(name, typename, default=bool(arg_.initializer), default_value=default)
             )
+        if pos_only_marker_position:
+            args.insert(pos_only_marker_position, ArgSig("/"))
 
         if ctx.class_info is not None and all(
             arg.type is None and arg.default is False for arg in args
         ):
             new_args = infer_method_arg_types(
                 ctx.name, ctx.class_info.self_var, [arg.name for arg in args]
             )
             if new_args is not None:
                 args = new_args
 
-        is_dataclass_generated = (
-            self.analyzed and self.processing_dataclass and o.info.names[o.name].plugin_generated
-        )
-        if o.name == "__init__" and is_dataclass_generated and "**" in [a.name for a in args]:
-            # The dataclass plugin generates invalid nameless "*" and "**" arguments
-            new_name = "".join(a.name.strip("*") for a in args)
-            for arg in args:
-                if arg.name == "*":
-                    arg.name = f"*{new_name}_"  # this name is guaranteed to be unique
-                elif arg.name == "**":
-                    arg.name = f"**{new_name}__"  # same here
         return args
 
     def _get_func_return(self, o: FuncDef, ctx: FunctionContext) -> str | None:
         if o.name != "__init__" and isinstance(o.unanalyzed_type, CallableType):
             if isinstance(get_proper_type(o.unanalyzed_type.ret_type), AnyType):
                 # Luckily, a return type explicitly annotated with "Any" has
                 # type "UnboundType" and will enter the else branch.
@@ -1021,18 +1029,23 @@
         elif isinstance(expr, MemberExpr) and self.analyzed:
             # Also add function and module aliases.
             return (
                 top_level
                 and isinstance(expr.node, (FuncDef, Decorator, MypyFile))
                 or isinstance(expr.node, TypeInfo)
             ) and not self.is_private_member(expr.node.fullname)
-        elif (
-            isinstance(expr, IndexExpr)
-            and isinstance(expr.base, NameExpr)
-            and not self.is_private_name(expr.base.name)
+        elif isinstance(expr, IndexExpr) and (
+            (isinstance(expr.base, NameExpr) and not self.is_private_name(expr.base.name))
+            or (  # Also some known aliases that could be member expression
+                isinstance(expr.base, MemberExpr)
+                and not self.is_private_member(get_qualified_name(expr.base))
+                and self.get_fullname(expr.base).startswith(
+                    ("builtins.", "typing.", "typing_extensions.", "collections.abc.")
+                )
+            )
         ):
             if isinstance(expr.index, TupleExpr):
                 indices = expr.index.items
             else:
                 indices = [expr.index]
             if expr.base.name == "Callable" and len(indices) == 2:
                 args, ret = indices
```

## puya/_vendor/mypy/stubgenc.py

```diff
@@ -491,15 +491,15 @@
         """
         Given an instance, return a string representation of its type that is valid
         to use as a type annotation.
         """
         if obj is None or obj is type(None):
             return "None"
         elif inspect.isclass(obj):
-            return "type[{}]".format(self.get_type_fullname(obj))
+            return f"type[{self.get_type_fullname(obj)}]"
         elif isinstance(obj, FunctionType):
             return self.add_name("typing.Callable")
         elif isinstance(obj, ModuleType):
             return self.add_name("types.ModuleType", require=False)
         else:
             return self.get_type_fullname(type(obj))
```

## puya/_vendor/mypy/stubtest.py

```diff
@@ -1874,16 +1874,16 @@
     modules: list[str]
     concise: bool
     ignore_missing_stub: bool
     ignore_positional_only: bool
     allowlist: list[str]
     generate_allowlist: bool
     ignore_unused_allowlist: bool
-    mypy_config_file: str
-    custom_typeshed_dir: str
+    mypy_config_file: str | None
+    custom_typeshed_dir: str | None
     check_typeshed: bool
     version: str
 
 
 # typeshed added a stub for __main__, but that causes stubtest to check itself
 ANNOYING_STDLIB_MODULES: typing_extensions.Final = frozenset({"antigravity", "this", "__main__"})
 
@@ -1918,15 +1918,15 @@
         print(_style("error:", color="red", bold=True), "no modules to check")
         return 1
 
     options = Options()
     options.incremental = False
     options.custom_typeshed_dir = args.custom_typeshed_dir
     if options.custom_typeshed_dir:
-        options.abs_custom_typeshed_dir = os.path.abspath(args.custom_typeshed_dir)
+        options.abs_custom_typeshed_dir = os.path.abspath(options.custom_typeshed_dir)
     options.config_file = args.mypy_config_file
     options.use_builtins_fixtures = use_builtins_fixtures
 
     if options.config_file:
 
         def set_strict_flags() -> None:  # not needed yet
             return
```

## puya/_vendor/mypy/stubutil.py

```diff
@@ -18,14 +18,34 @@
 from mypy.moduleinspect import InspectError, ModuleInspect
 from mypy.stubdoc import ArgSig, FunctionSig
 from mypy.types import AnyType, NoneType, Type, TypeList, TypeStrVisitor, UnboundType, UnionType
 
 # Modules that may fail when imported, or that may have side effects (fully qualified).
 NOT_IMPORTABLE_MODULES = ()
 
+# Typing constructs to be replaced by their builtin equivalents.
+TYPING_BUILTIN_REPLACEMENTS: Final = {
+    # From typing
+    "typing.Text": "builtins.str",
+    "typing.Tuple": "builtins.tuple",
+    "typing.List": "builtins.list",
+    "typing.Dict": "builtins.dict",
+    "typing.Set": "builtins.set",
+    "typing.FrozenSet": "builtins.frozenset",
+    "typing.Type": "builtins.type",
+    # From typing_extensions
+    "typing_extensions.Text": "builtins.str",
+    "typing_extensions.Tuple": "builtins.tuple",
+    "typing_extensions.List": "builtins.list",
+    "typing_extensions.Dict": "builtins.dict",
+    "typing_extensions.Set": "builtins.set",
+    "typing_extensions.FrozenSet": "builtins.frozenset",
+    "typing_extensions.Type": "builtins.type",
+}
+
 
 class CantImport(Exception):
     def __init__(self, module: str, message: str) -> None:
         self.module = module
         self.message = message
 
 
@@ -225,14 +245,16 @@
     def visit_unbound_type(self, t: UnboundType) -> str:
         s = t.name
         fullname = self.stubgen.resolve_name(s)
         if fullname == "typing.Union":
             return " | ".join([item.accept(self) for item in t.args])
         if fullname == "typing.Optional":
             return f"{t.args[0].accept(self)} | None"
+        if fullname in TYPING_BUILTIN_REPLACEMENTS:
+            s = self.stubgen.add_name(TYPING_BUILTIN_REPLACEMENTS[fullname], require=True)
         if self.known_modules is not None and "." in s:
             # see if this object is from any of the modules that we're currently processing.
             # reverse sort so that subpackages come before parents: e.g. "foo.bar" before "foo".
             for module_name in self.local_modules + sorted(self.known_modules, reverse=True):
                 if s.startswith(module_name + "."):
                     if module_name in self.local_modules:
                         s = s[len(module_name) + 1 :]
@@ -246,14 +268,16 @@
             # when called without analysis all types are unbound, so this won't hit
             # visit_none_type().
             s = "None"
         else:
             self.stubgen.import_tracker.require_name(s)
         if t.args:
             s += f"[{self.args_str(t.args)}]"
+        elif t.empty_tuple_index:
+            s += "[()]"
         return s
 
     def visit_none_type(self, t: NoneType) -> str:
         return "None"
 
     def visit_type_list(self, t: TypeList) -> str:
         return f"[{self.list_str(t.items)}]"
@@ -470,15 +494,15 @@
         """
         self.require_name(name)
         self.reexports.add(name)
 
     def import_lines(self) -> list[str]:
         """The list of required import lines (as strings with python code).
 
-        In order for a module be included in this output, an indentifier must be both
+        In order for a module be included in this output, an identifier must be both
         'required' via require_name() and 'imported' via add_import_from()
         or add_import()
         """
         result = []
 
         # To summarize multiple names imported from a same module, we collect those
         # in the `module_map` dictionary, mapping a module path to the list of names that should
@@ -579,17 +603,17 @@
         self.sig_generators = self.get_sig_generators()
         # populated by visit_mypy_file
         self.module_name: str = ""
         # These are "soft" imports for objects which might appear in annotations but not have
         # a corresponding import statement.
         self.known_imports = {
             "_typeshed": ["Incomplete"],
-            "typing": ["Any", "TypeVar", "NamedTuple"],
+            "typing": ["Any", "TypeVar", "NamedTuple", "TypedDict"],
             "collections.abc": ["Generator"],
-            "typing_extensions": ["TypedDict", "ParamSpec", "TypeVarTuple"],
+            "typing_extensions": ["ParamSpec", "TypeVarTuple"],
         }
 
     def get_sig_generators(self) -> list[SignatureGenerator]:
         return []
 
     def resolve_name(self, name: str) -> str:
         """Return the full name resolving imports and import aliases."""
@@ -607,15 +631,18 @@
     def add_name(self, fullname: str, require: bool = True) -> str:
         """Add a name to be imported and return the name reference.
 
         The import will be internal to the stub (i.e don't reexport).
         """
         module, name = fullname.rsplit(".", 1)
         alias = "_" + name if name in self.defined_names else None
-        self.import_tracker.add_import_from(module, [(name, alias)], require=require)
+        while alias in self.defined_names:
+            alias = "_" + alias
+        if module != "builtins" or alias:  # don't import from builtins unless needed
+            self.import_tracker.add_import_from(module, [(name, alias)], require=require)
         return alias or name
 
     def add_import_line(self, line: str) -> None:
         """Add a line of text to the import section, unless it's already there."""
         if line not in self._import_lines:
             self._import_lines.append(line)
```

## puya/_vendor/mypy/subtypes.py

```diff
@@ -679,18 +679,31 @@
 
     def visit_callable_type(self, left: CallableType) -> bool:
         right = self.right
         if isinstance(right, CallableType):
             if left.type_guard is not None and right.type_guard is not None:
                 if not self._is_subtype(left.type_guard, right.type_guard):
                     return False
+            elif left.type_is is not None and right.type_is is not None:
+                # For TypeIs we have to check both ways; it is unsafe to pass
+                # a TypeIs[Child] when a TypeIs[Parent] is expected, because
+                # if the narrower returns False, we assume that the narrowed value is
+                # *not* a Parent.
+                if not self._is_subtype(left.type_is, right.type_is) or not self._is_subtype(
+                    right.type_is, left.type_is
+                ):
+                    return False
             elif right.type_guard is not None and left.type_guard is None:
                 # This means that one function has `TypeGuard` and other does not.
                 # They are not compatible. See https://github.com/python/mypy/issues/11307
                 return False
+            elif right.type_is is not None and left.type_is is None:
+                # Similarly, if one function has `TypeIs` and the other does not,
+                # they are not compatible.
+                return False
             return is_callable_compatible(
                 left,
                 right,
                 is_compat=self._is_subtype,
                 is_proper_subtype=self.proper_subtype,
                 ignore_pos_arg_names=self.subtype_context.ignore_pos_arg_names,
                 strict_concatenate=(
```

## puya/_vendor/mypy/test/data.py

```diff
@@ -636,17 +636,15 @@
     """
     if isinstance(obj, type):
         # Only classes derived from DataSuite contain test cases, not the DataSuite class itself
         if issubclass(obj, DataSuite) and obj is not DataSuite:
             # Non-None result means this obj is a test case.
             # The collect method of the returned DataSuiteCollector instance will be called later,
             # with self.obj being obj.
-            return DataSuiteCollector.from_parent(  # type: ignore[no-untyped-call]
-                parent=collector, name=name
-            )
+            return DataSuiteCollector.from_parent(parent=collector, name=name)
     return None
 
 
 _case_name_pattern = re.compile(
     r"(?P<name>[a-zA-Z_0-9]+)"
     r"(?P<writescache>-writescache)?"
     r"(?P<only_when>-only_when_cache|-only_when_nocache)?"
```

## puya/_vendor/mypy/test/helpers.py

```diff
@@ -37,15 +37,15 @@
     __tracebackhide__ = True
     # We must enable site packages even though they could cause problems,
     # since stubs for typing_extensions live there.
     outval, errval, status = api.run(args + ["--show-traceback", "--no-silence-site-packages"])
     if status != 0:
         sys.stdout.write(outval)
         sys.stderr.write(errval)
-        pytest.fail(msg="Sample check failed", pytrace=False)
+        pytest.fail(reason="Sample check failed", pytrace=False)
 
 
 def diff_ranges(
     left: list[str], right: list[str]
 ) -> tuple[list[tuple[int, int]], list[tuple[int, int]]]:
     seq = difflib.SequenceMatcher(None, left, right)
     # note last triple is a dummy, so don't need to worry
```

## puya/_vendor/mypy/tvar_scope.py

```diff
@@ -11,14 +11,34 @@
     ParamSpecFlavor,
     ParamSpecType,
     TypeVarId,
     TypeVarLikeType,
     TypeVarTupleType,
     TypeVarType,
 )
+from mypy.typetraverser import TypeTraverserVisitor
+
+
+class TypeVarLikeNamespaceSetter(TypeTraverserVisitor):
+    """Set namespace for all TypeVarLikeTypes types."""
+
+    def __init__(self, namespace: str) -> None:
+        self.namespace = namespace
+
+    def visit_type_var(self, t: TypeVarType) -> None:
+        t.id.namespace = self.namespace
+        super().visit_type_var(t)
+
+    def visit_param_spec(self, t: ParamSpecType) -> None:
+        t.id.namespace = self.namespace
+        return super().visit_param_spec(t)
+
+    def visit_type_var_tuple(self, t: TypeVarTupleType) -> None:
+        t.id.namespace = self.namespace
+        super().visit_type_var_tuple(t)
 
 
 class TypeVarLikeScope:
     """Scope that holds bindings for type variables and parameter specifications.
 
     Node fullname -> TypeVarLikeType.
     """
@@ -84,14 +104,16 @@
             i = self.class_id
             namespace = self.namespace
         else:
             self.func_id -= 1
             i = self.func_id
             # TODO: Consider also using namespaces for functions
             namespace = ""
+        tvar_expr.default.accept(TypeVarLikeNamespaceSetter(namespace))
+
         if isinstance(tvar_expr, TypeVarExpr):
             tvar_def: TypeVarLikeType = TypeVarType(
                 name=name,
                 fullname=tvar_expr.fullname,
                 id=TypeVarId(i, namespace=namespace),
                 values=tvar_expr.values,
                 upper_bound=tvar_expr.upper_bound,
```

## puya/_vendor/mypy/typeanal.py

```diff
@@ -34,15 +34,20 @@
     Var,
     check_arg_kinds,
     check_arg_names,
     get_nongen_builtins,
 )
 from mypy.options import Options
 from mypy.plugin import AnalyzeTypeContext, Plugin, TypeAnalyzerPluginInterface
-from mypy.semanal_shared import SemanticAnalyzerCoreInterface, paramspec_args, paramspec_kwargs
+from mypy.semanal_shared import (
+    SemanticAnalyzerCoreInterface,
+    SemanticAnalyzerInterface,
+    paramspec_args,
+    paramspec_kwargs,
+)
 from mypy.state import state
 from mypy.tvar_scope import TypeVarLikeScope
 from mypy.types import (
     ANNOTATED_TYPE_NAMES,
     ANY_STRATEGY,
     FINAL_TYPE_NAMES,
     LITERAL_TYPE_NAMES,
@@ -132,14 +137,15 @@
     plugin: Plugin,
     options: Options,
     is_typeshed_stub: bool,
     allow_placeholder: bool = False,
     in_dynamic_func: bool = False,
     global_scope: bool = True,
     allowed_alias_tvars: list[TypeVarLikeType] | None = None,
+    alias_type_params_names: list[str] | None = None,
 ) -> tuple[Type, set[str]]:
     """Analyze r.h.s. of a (potential) type alias definition.
 
     If `node` is valid as a type alias rvalue, return the resulting type and a set of
     full names of type aliases it depends on (directly or indirectly).
     'node' must have been semantically analyzed.
     """
@@ -149,14 +155,15 @@
         plugin,
         options,
         is_typeshed_stub,
         defining_alias=True,
         allow_placeholder=allow_placeholder,
         prohibit_self_type="type alias target",
         allowed_alias_tvars=allowed_alias_tvars,
+        alias_type_params_names=alias_type_params_names,
     )
     analyzer.in_dynamic_func = in_dynamic_func
     analyzer.global_scope = global_scope
     res = type.accept(analyzer)
     return res, analyzer.aliases_used
 
 
@@ -201,14 +208,15 @@
         allow_required: bool = False,
         allow_param_spec_literals: bool = False,
         allow_unpack: bool = False,
         report_invalid_types: bool = True,
         prohibit_self_type: str | None = None,
         allowed_alias_tvars: list[TypeVarLikeType] | None = None,
         allow_type_any: bool = False,
+        alias_type_params_names: list[str] | None = None,
     ) -> None:
         self.api = api
         self.fail_func = api.fail
         self.note_func = api.note
         self.tvar_scope = tvar_scope
         # Are we analysing a type alias definition rvalue?
         self.defining_alias = defining_alias
@@ -222,14 +230,15 @@
         )
         # Should we accept unbound type variables? This is currently used for class bases,
         # and alias right hand sides (before they are analyzed as type aliases).
         self.allow_unbound_tvars = allow_unbound_tvars
         if allowed_alias_tvars is None:
             allowed_alias_tvars = []
         self.allowed_alias_tvars = allowed_alias_tvars
+        self.alias_type_params_names = alias_type_params_names
         # If false, record incomplete ref if we generate PlaceholderType.
         self.allow_placeholder = allow_placeholder
         # Are we in a context where Required[] is allowed?
         self.allow_required = allow_required
         # Are we in a context where ParamSpec literals are allowed?
         self.allow_param_spec_literals = allow_param_spec_literals
         # Are we in context where literal "..." specifically is allowed?
@@ -262,14 +271,20 @@
         typ = self.visit_unbound_type_nonoptional(t, defining_literal)
         if t.optional:
             # We don't need to worry about double-wrapping Optionals or
             # wrapping Anys: Union simplification will take care of that.
             return make_optional_type(typ)
         return typ
 
+    def not_declared_in_type_params(self, tvar_name: str) -> bool:
+        return (
+            self.alias_type_params_names is not None
+            and tvar_name not in self.alias_type_params_names
+        )
+
     def visit_unbound_type_nonoptional(self, t: UnboundType, defining_literal: bool) -> Type:
         sym = self.lookup_qualified(t.name, t)
         if sym is not None:
             node = sym.node
             if isinstance(node, PlaceholderNode):
                 if node.becomes_typeinfo:
                     # Reference to placeholder type.
@@ -316,15 +331,19 @@
                     no_subscript_builtin_alias(fullname, propose_alt=not self.defining_alias), t
                 )
             tvar_def = self.tvar_scope.get_binding(sym)
             if isinstance(sym.node, ParamSpecExpr):
                 if tvar_def is None:
                     if self.allow_unbound_tvars:
                         return t
-                    self.fail(f'ParamSpec "{t.name}" is unbound', t, code=codes.VALID_TYPE)
+                    if self.defining_alias and self.not_declared_in_type_params(t.name):
+                        msg = f'ParamSpec "{t.name}" is not included in type_params'
+                    else:
+                        msg = f'ParamSpec "{t.name}" is unbound'
+                    self.fail(msg, t, code=codes.VALID_TYPE)
                     return AnyType(TypeOfAny.from_error)
                 assert isinstance(tvar_def, ParamSpecType)
                 if len(t.args) > 0:
                     self.fail(
                         f'ParamSpec "{t.name}" used with arguments', t, code=codes.VALID_TYPE
                     )
                 # Change the line number
@@ -340,44 +359,48 @@
                 )
             if (
                 isinstance(sym.node, TypeVarExpr)
                 and self.defining_alias
                 and not defining_literal
                 and (tvar_def is None or tvar_def not in self.allowed_alias_tvars)
             ):
-                self.fail(
-                    f'Can\'t use bound type variable "{t.name}" to define generic alias',
-                    t,
-                    code=codes.VALID_TYPE,
-                )
+                if self.not_declared_in_type_params(t.name):
+                    msg = f'Type variable "{t.name}" is not included in type_params'
+                else:
+                    msg = f'Can\'t use bound type variable "{t.name}" to define generic alias'
+                self.fail(msg, t, code=codes.VALID_TYPE)
                 return AnyType(TypeOfAny.from_error)
             if isinstance(sym.node, TypeVarExpr) and tvar_def is not None:
                 assert isinstance(tvar_def, TypeVarType)
                 if len(t.args) > 0:
                     self.fail(
                         f'Type variable "{t.name}" used with arguments', t, code=codes.VALID_TYPE
                     )
                 # Change the line number
                 return tvar_def.copy_modified(line=t.line, column=t.column)
             if isinstance(sym.node, TypeVarTupleExpr) and (
                 tvar_def is not None
                 and self.defining_alias
                 and tvar_def not in self.allowed_alias_tvars
             ):
-                self.fail(
-                    f'Can\'t use bound type variable "{t.name}" to define generic alias',
-                    t,
-                    code=codes.VALID_TYPE,
-                )
+                if self.not_declared_in_type_params(t.name):
+                    msg = f'Type variable "{t.name}" is not included in type_params'
+                else:
+                    msg = f'Can\'t use bound type variable "{t.name}" to define generic alias'
+                self.fail(msg, t, code=codes.VALID_TYPE)
                 return AnyType(TypeOfAny.from_error)
             if isinstance(sym.node, TypeVarTupleExpr):
                 if tvar_def is None:
                     if self.allow_unbound_tvars:
                         return t
-                    self.fail(f'TypeVarTuple "{t.name}" is unbound', t, code=codes.VALID_TYPE)
+                    if self.defining_alias and self.not_declared_in_type_params(t.name):
+                        msg = f'TypeVarTuple "{t.name}" is not included in type_params'
+                    else:
+                        msg = f'TypeVarTuple "{t.name}" is unbound'
+                    self.fail(msg, t, code=codes.VALID_TYPE)
                     return AnyType(TypeOfAny.from_error)
                 assert isinstance(tvar_def, TypeVarTupleType)
                 if not self.allow_type_var_tuple:
                     self.fail(
                         f'TypeVarTuple "{t.name}" is only valid with an unpack',
                         t,
                         code=codes.VALID_TYPE,
@@ -659,15 +682,18 @@
                 return AnyType(TypeOfAny.from_error)
             if len(t.args) != 1:
                 self.fail(
                     "NotRequired[] must have exactly one type argument", t, code=codes.VALID_TYPE
                 )
                 return AnyType(TypeOfAny.from_error)
             return RequiredType(self.anal_type(t.args[0]), required=False)
-        elif self.anal_type_guard_arg(t, fullname) is not None:
+        elif (
+            self.anal_type_guard_arg(t, fullname) is not None
+            or self.anal_type_is_arg(t, fullname) is not None
+        ):
             # In most contexts, TypeGuard[...] acts as an alias for bool (ignoring its args)
             return self.named_type("builtins.bool")
         elif fullname in ("typing.Unpack", "typing_extensions.Unpack"):
             if len(t.args) != 1:
                 self.fail("Unpack[...] requires exactly one type argument", t)
                 return AnyType(TypeOfAny.from_error)
             if not self.allow_unpack:
@@ -977,15 +1003,16 @@
         # Every Callable can bind its own type variables, if they're not in the outer scope
         with self.tvar_scope_frame():
             unpacked_kwargs = False
             if self.defining_alias:
                 variables = t.variables
             else:
                 variables, _ = self.bind_function_type_variables(t, t)
-            special = self.anal_type_guard(t.ret_type)
+            type_guard = self.anal_type_guard(t.ret_type)
+            type_is = self.anal_type_is(t.ret_type)
             arg_kinds = t.arg_kinds
             if len(arg_kinds) >= 2 and arg_kinds[-2] == ARG_STAR and arg_kinds[-1] == ARG_STAR2:
                 arg_types = self.anal_array(t.arg_types[:-2], nested=nested) + [
                     self.anal_star_arg_type(t.arg_types[-2], ARG_STAR, nested=nested),
                     self.anal_star_arg_type(t.arg_types[-1], ARG_STAR2, nested=nested),
                 ]
                 # If nested is True, it means we are analyzing a Callable[...] type, rather
@@ -1032,15 +1059,16 @@
                 arg_kinds=arg_kinds,
                 arg_names=arg_names,
                 ret_type=self.anal_type(t.ret_type, nested=nested),
                 # If the fallback isn't filled in yet,
                 # its type will be the falsey FakeInfo
                 fallback=(t.fallback if t.fallback.type else self.named_type("builtins.function")),
                 variables=self.anal_var_defs(variables),
-                type_guard=special,
+                type_guard=type_guard,
+                type_is=type_is,
                 unpack_kwargs=unpacked_kwargs,
             )
         return ret
 
     def anal_type_guard(self, t: Type) -> Type | None:
         if isinstance(t, UnboundType):
             sym = self.lookup_qualified(t.name, t)
@@ -1055,14 +1083,30 @@
                 self.fail(
                     "TypeGuard must have exactly one type argument", t, code=codes.VALID_TYPE
                 )
                 return AnyType(TypeOfAny.from_error)
             return self.anal_type(t.args[0])
         return None
 
+    def anal_type_is(self, t: Type) -> Type | None:
+        if isinstance(t, UnboundType):
+            sym = self.lookup_qualified(t.name, t)
+            if sym is not None and sym.node is not None:
+                return self.anal_type_is_arg(t, sym.node.fullname)
+        # TODO: What if it's an Instance? Then use t.type.fullname?
+        return None
+
+    def anal_type_is_arg(self, t: UnboundType, fullname: str) -> Type | None:
+        if fullname in ("typing_extensions.TypeIs", "typing.TypeIs"):
+            if len(t.args) != 1:
+                self.fail("TypeIs must have exactly one type argument", t, code=codes.VALID_TYPE)
+                return AnyType(TypeOfAny.from_error)
+            return self.anal_type(t.args[0])
+        return None
+
     def anal_star_arg_type(self, t: Type, kind: ArgKind, nested: bool) -> Type:
         """Analyze signature argument type for *args and **kwargs argument."""
         if isinstance(t, UnboundType) and t.name and "." in t.name and not t.args:
             components = t.name.split(".")
             tvar_name = ".".join(components[:-1])
             sym = self.lookup_qualified(tvar_name, t)
             if sym is not None and isinstance(sym.node, ParamSpecExpr):
@@ -1237,14 +1281,27 @@
             ):
                 # We are analyzing this type in runtime context (e.g. as type application).
                 # If it is not valid as a type in this position an error will be given later.
                 return callable_with_ellipsis(
                     AnyType(TypeOfAny.explicit), ret_type=ret_type, fallback=fallback
                 )
             return None
+        elif (
+            self.defining_alias
+            and self.not_declared_in_type_params(tvar_def.name)
+            and tvar_def not in self.allowed_alias_tvars
+        ):
+            self.fail(
+                f'ParamSpec "{tvar_def.name}" is not included in type_params',
+                callable_args,
+                code=codes.VALID_TYPE,
+            )
+            return callable_with_ellipsis(
+                AnyType(TypeOfAny.special_form), ret_type=ret_type, fallback=fallback
+            )
 
         return CallableType(
             [
                 paramspec_args(
                     tvar_def.name, tvar_def.fullname, tvar_def.id, named_type_func=self.named_type
                 ),
                 paramspec_kwargs(
@@ -2504,7 +2561,36 @@
         # Redundant type check helps mypyc.
         if isinstance(types, list):
             for t in types:
                 t.accept(self)
         else:
             for t in types:
                 t.accept(self)
+
+
+class TypeVarDefaultTranslator(TrivialSyntheticTypeTranslator):
+    """Type translate visitor that replaces UnboundTypes with in-scope TypeVars."""
+
+    def __init__(
+        self, api: SemanticAnalyzerInterface, tvar_expr_name: str, context: Context
+    ) -> None:
+        self.api = api
+        self.tvar_expr_name = tvar_expr_name
+        self.context = context
+
+    def visit_unbound_type(self, t: UnboundType) -> Type:
+        sym = self.api.lookup_qualified(t.name, t, suppress_errors=True)
+        if sym is not None:
+            if type_var := self.api.tvar_scope.get_binding(sym):
+                return type_var
+            if isinstance(sym.node, TypeVarLikeExpr):
+                self.api.fail(
+                    f'Type parameter "{self.tvar_expr_name}" has a default type '
+                    "that refers to one or more type variables that are out of scope",
+                    self.context,
+                )
+                return AnyType(TypeOfAny.from_error)
+        return super().visit_unbound_type(t)
+
+    def visit_type_alias_type(self, t: TypeAliasType) -> Type:
+        # TypeAliasTypes are analyzed separately already, just return it
+        return t
```

## puya/_vendor/mypy/types.py

```diff
@@ -81,14 +81,23 @@
 # semantic analyzer!
 if TYPE_CHECKING:
     from mypy.type_visitor import (
         SyntheticTypeVisitor as SyntheticTypeVisitor,
         TypeVisitor as TypeVisitor,
     )
 
+TYPE_VAR_LIKE_NAMES: Final = (
+    "typing.TypeVar",
+    "typing_extensions.TypeVar",
+    "typing.ParamSpec",
+    "typing_extensions.ParamSpec",
+    "typing.TypeVarTuple",
+    "typing_extensions.TypeVarTuple",
+)
+
 TYPED_NAMEDTUPLE_NAMES: Final = ("typing.NamedTuple", "typing_extensions.NamedTuple")
 
 # Supported names of TypedDict type constructors.
 TPDICT_NAMES: Final = (
     "typing.TypedDict",
     "typing_extensions.TypedDict",
     "mypy_extensions.TypedDict",
@@ -1511,15 +1520,15 @@
 
     def is_singleton_type(self) -> bool:
         # TODO:
         # Also make this return True if the type corresponds to NotImplemented?
         return (
             self.type.is_enum
             and len(self.get_enum_values()) == 1
-            or self.type.fullname == "builtins.ellipsis"
+            or self.type.fullname in {"builtins.ellipsis", "types.EllipsisType"}
         )
 
     def get_enum_values(self) -> list[str]:
         """Return the list of values for an Enum."""
         return [
             name for name, sym in self.type.names.items() if isinstance(sym.node, mypy.nodes.Var)
         ]
@@ -1787,14 +1796,15 @@
         "from_type_type",  # Was this callable generated by analyzing Type[...]
         # instantiation?
         "bound_args",  # Bound type args, mostly unused but may be useful for
         # tools that consume mypy ASTs
         "def_extras",  # Information about original definition we want to serialize.
         # This is used for more detailed error messages.
         "type_guard",  # T, if -> TypeGuard[T] (ret_type is bool in this case).
+        "type_is",  # T, if -> TypeIs[T] (ret_type is bool in this case).
         "from_concatenate",  # whether this callable is from a concatenate object
         # (this is used for error messages)
         "imprecise_arg_kinds",
         "unpack_kwargs",  # Was an Unpack[...] with **kwargs used to define this callable?
     )
 
     def __init__(
@@ -1813,14 +1823,15 @@
         is_ellipsis_args: bool = False,
         implicit: bool = False,
         special_sig: str | None = None,
         from_type_type: bool = False,
         bound_args: Sequence[Type | None] = (),
         def_extras: dict[str, Any] | None = None,
         type_guard: Type | None = None,
+        type_is: Type | None = None,
         from_concatenate: bool = False,
         imprecise_arg_kinds: bool = False,
         unpack_kwargs: bool = False,
     ) -> None:
         super().__init__(line, column)
         assert len(arg_types) == len(arg_kinds) == len(arg_names)
         for t, k in zip(arg_types, arg_kinds):
@@ -1862,14 +1873,15 @@
                     first_arg = definition.arguments[0].variable.name
                 else:
                     first_arg = definition.arg_names[0]
             self.def_extras = {"first_arg": first_arg}
         else:
             self.def_extras = {}
         self.type_guard = type_guard
+        self.type_is = type_is
         self.unpack_kwargs = unpack_kwargs
 
     def copy_modified(
         self: CT,
         arg_types: Bogus[Sequence[Type]] = _dummy,
         arg_kinds: Bogus[list[ArgKind]] = _dummy,
         arg_names: Bogus[Sequence[str | None]] = _dummy,
@@ -1883,14 +1895,15 @@
         is_ellipsis_args: Bogus[bool] = _dummy,
         implicit: Bogus[bool] = _dummy,
         special_sig: Bogus[str | None] = _dummy,
         from_type_type: Bogus[bool] = _dummy,
         bound_args: Bogus[list[Type | None]] = _dummy,
         def_extras: Bogus[dict[str, Any]] = _dummy,
         type_guard: Bogus[Type | None] = _dummy,
+        type_is: Bogus[Type | None] = _dummy,
         from_concatenate: Bogus[bool] = _dummy,
         imprecise_arg_kinds: Bogus[bool] = _dummy,
         unpack_kwargs: Bogus[bool] = _dummy,
     ) -> CT:
         modified = CallableType(
             arg_types=arg_types if arg_types is not _dummy else self.arg_types,
             arg_kinds=arg_kinds if arg_kinds is not _dummy else self.arg_kinds,
@@ -1907,14 +1920,15 @@
             ),
             implicit=implicit if implicit is not _dummy else self.implicit,
             special_sig=special_sig if special_sig is not _dummy else self.special_sig,
             from_type_type=from_type_type if from_type_type is not _dummy else self.from_type_type,
             bound_args=bound_args if bound_args is not _dummy else self.bound_args,
             def_extras=def_extras if def_extras is not _dummy else dict(self.def_extras),
             type_guard=type_guard if type_guard is not _dummy else self.type_guard,
+            type_is=type_is if type_is is not _dummy else self.type_is,
             from_concatenate=(
                 from_concatenate if from_concatenate is not _dummy else self.from_concatenate
             ),
             imprecise_arg_kinds=(
                 imprecise_arg_kinds
                 if imprecise_arg_kinds is not _dummy
                 else self.imprecise_arg_kinds
@@ -2220,14 +2234,15 @@
             # We don't serialize the definition (only used for error messages).
             "variables": [v.serialize() for v in self.variables],
             "is_ellipsis_args": self.is_ellipsis_args,
             "implicit": self.implicit,
             "bound_args": [(None if t is None else t.serialize()) for t in self.bound_args],
             "def_extras": dict(self.def_extras),
             "type_guard": self.type_guard.serialize() if self.type_guard is not None else None,
+            "type_is": (self.type_is.serialize() if self.type_is is not None else None),
             "from_concatenate": self.from_concatenate,
             "imprecise_arg_kinds": self.imprecise_arg_kinds,
             "unpack_kwargs": self.unpack_kwargs,
         }
 
     @classmethod
     def deserialize(cls, data: JsonDict) -> CallableType:
@@ -2244,14 +2259,15 @@
             is_ellipsis_args=data["is_ellipsis_args"],
             implicit=data["implicit"],
             bound_args=[(None if t is None else deserialize_type(t)) for t in data["bound_args"]],
             def_extras=data["def_extras"],
             type_guard=(
                 deserialize_type(data["type_guard"]) if data["type_guard"] is not None else None
             ),
+            type_is=(deserialize_type(data["type_is"]) if data["type_is"] is not None else None),
             from_concatenate=data["from_concatenate"],
             imprecise_arg_kinds=data["imprecise_arg_kinds"],
             unpack_kwargs=data["unpack_kwargs"],
         )
 
 
 # This is a little safety net to prevent reckless special-casing of callables
@@ -3302,14 +3318,16 @@
                 s += f" = {param_spec.default.accept(self)}"
 
         s = f"({s})"
 
         if not isinstance(get_proper_type(t.ret_type), NoneType):
             if t.type_guard is not None:
                 s += f" -> TypeGuard[{t.type_guard.accept(self)}]"
+            elif t.type_is is not None:
+                s += f" -> TypeIs[{t.type_is.accept(self)}]"
             else:
                 s += f" -> {t.ret_type.accept(self)}"
 
         if t.variables:
             vs = []
             for var in t.variables:
                 if isinstance(var, TypeVarType):
@@ -3383,15 +3401,19 @@
         else:
             return "<partial {}[{}]>".format(t.type.name, ", ".join(["?"] * len(t.type.type_vars)))
 
     def visit_ellipsis_type(self, t: EllipsisType) -> str:
         return "..."
 
     def visit_type_type(self, t: TypeType) -> str:
-        return f"Type[{t.item.accept(self)}]"
+        if self.options.use_lowercase_names():
+            type_name = "type"
+        else:
+            type_name = "Type"
+        return f"{type_name}[{t.item.accept(self)}]"
 
     def visit_placeholder_type(self, t: PlaceholderType) -> str:
         return f"<placeholder {t.fullname}>"
 
     def visit_type_alias_type(self, t: TypeAliasType) -> str:
         if t.alias is not None:
             unrolled, recursed = t._partial_expansion()
```

## puya/_vendor/mypy/typeshed/stdlib/VERSIONS

```diff
@@ -32,14 +32,15 @@
 _decimal: 3.3-
 _dummy_thread: 3.0-3.8
 _dummy_threading: 3.0-3.8
 _heapq: 3.0-
 _imp: 3.0-
 _json: 3.0-
 _locale: 3.0-
+_lsprof: 3.0-
 _markupbase: 3.0-
 _msi: 3.0-
 _operator: 3.4-
 _osx_support: 3.0-
 _posixsubprocess: 3.2-
 _py_abc: 3.7-
 _pydecimal: 3.5-
```

## puya/_vendor/mypy/typeshed/stdlib/_ast.pyi

```diff
@@ -2,14 +2,18 @@
 import typing_extensions
 from typing import Any, ClassVar, Literal
 
 PyCF_ONLY_AST: Literal[1024]
 PyCF_TYPE_COMMENTS: Literal[4096]
 PyCF_ALLOW_TOP_LEVEL_AWAIT: Literal[8192]
 
+# Alias used for fields that must always be valid identifiers
+# A string `x` counts as a valid identifier if both the following are True
+# (1) `x.isidentifier()` evaluates to `True`
+# (2) `keyword.iskeyword(x)` evaluates to `False`
 _Identifier: typing_extensions.TypeAlias = str
 
 class AST:
     if sys.version_info >= (3, 10):
         __match_args__ = ()
     _attributes: ClassVar[tuple[str, ...]]
     _fields: ClassVar[tuple[str, ...]]
@@ -495,15 +499,15 @@
         __match_args__ = ("arg", "value")
     arg: _Identifier | None
     value: expr
 
 class alias(AST):
     if sys.version_info >= (3, 10):
         __match_args__ = ("name", "asname")
-    name: _Identifier
+    name: str
     asname: _Identifier | None
 
 class withitem(AST):
     if sys.version_info >= (3, 10):
         __match_args__ = ("context_expr", "optional_vars")
     context_expr: expr
     optional_vars: expr | None
```

## puya/_vendor/mypy/typeshed/stdlib/_codecs.pyi

```diff
@@ -9,21 +9,21 @@
 class _EncodingMap:
     def size(self) -> int: ...
 
 _CharMap: TypeAlias = dict[int, int] | _EncodingMap
 _Handler: TypeAlias = Callable[[UnicodeError], tuple[str | bytes, int]]
 _SearchFunction: TypeAlias = Callable[[str], codecs.CodecInfo | None]
 
-def register(__search_function: _SearchFunction) -> None: ...
+def register(search_function: _SearchFunction, /) -> None: ...
 
 if sys.version_info >= (3, 10):
-    def unregister(__search_function: _SearchFunction) -> None: ...
+    def unregister(search_function: _SearchFunction, /) -> None: ...
 
-def register_error(__errors: str, __handler: _Handler) -> None: ...
-def lookup_error(__name: str) -> _Handler: ...
+def register_error(errors: str, handler: _Handler, /) -> None: ...
+def lookup_error(name: str, /) -> _Handler: ...
 
 # The type ignore on `encode` and `decode` is to avoid issues with overlapping overloads, for more details, see #300
 # https://docs.python.org/3/library/codecs.html#binary-transforms
 _BytesToBytesEncoding: TypeAlias = Literal[
     "base64",
     "base_64",
     "base64_codec",
@@ -64,70 +64,70 @@
 ) -> str: ...
 
 # hex is officially documented as a bytes to bytes encoding, but it appears to also work with str
 @overload
 def decode(obj: str, encoding: Literal["hex", "hex_codec"], errors: str = "strict") -> bytes: ...
 @overload
 def decode(obj: ReadableBuffer, encoding: str = "utf-8", errors: str = "strict") -> str: ...
-def lookup(__encoding: str) -> codecs.CodecInfo: ...
-def charmap_build(__map: str) -> _CharMap: ...
-def ascii_decode(__data: ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...
-def ascii_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
-def charmap_decode(__data: ReadableBuffer, __errors: str | None = None, __mapping: _CharMap | None = None) -> tuple[str, int]: ...
-def charmap_encode(__str: str, __errors: str | None = None, __mapping: _CharMap | None = None) -> tuple[bytes, int]: ...
-def escape_decode(__data: str | ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...
-def escape_encode(__data: bytes, __errors: str | None = None) -> tuple[bytes, int]: ...
-def latin_1_decode(__data: ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...
-def latin_1_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
+def lookup(encoding: str, /) -> codecs.CodecInfo: ...
+def charmap_build(map: str, /) -> _CharMap: ...
+def ascii_decode(data: ReadableBuffer, errors: str | None = None, /) -> tuple[str, int]: ...
+def ascii_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
+def charmap_decode(data: ReadableBuffer, errors: str | None = None, mapping: _CharMap | None = None, /) -> tuple[str, int]: ...
+def charmap_encode(str: str, errors: str | None = None, mapping: _CharMap | None = None, /) -> tuple[bytes, int]: ...
+def escape_decode(data: str | ReadableBuffer, errors: str | None = None, /) -> tuple[str, int]: ...
+def escape_encode(data: bytes, errors: str | None = None, /) -> tuple[bytes, int]: ...
+def latin_1_decode(data: ReadableBuffer, errors: str | None = None, /) -> tuple[str, int]: ...
+def latin_1_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
 
 if sys.version_info >= (3, 9):
     def raw_unicode_escape_decode(
-        __data: str | ReadableBuffer, __errors: str | None = None, __final: bool = True
+        data: str | ReadableBuffer, errors: str | None = None, final: bool = True, /
     ) -> tuple[str, int]: ...
 
 else:
-    def raw_unicode_escape_decode(__data: str | ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...
+    def raw_unicode_escape_decode(data: str | ReadableBuffer, errors: str | None = None, /) -> tuple[str, int]: ...
 
-def raw_unicode_escape_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
-def readbuffer_encode(__data: str | ReadableBuffer, __errors: str | None = None) -> tuple[bytes, int]: ...
+def raw_unicode_escape_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
+def readbuffer_encode(data: str | ReadableBuffer, errors: str | None = None, /) -> tuple[bytes, int]: ...
 
 if sys.version_info >= (3, 9):
     def unicode_escape_decode(
-        __data: str | ReadableBuffer, __errors: str | None = None, __final: bool = True
+        data: str | ReadableBuffer, errors: str | None = None, final: bool = True, /
     ) -> tuple[str, int]: ...
 
 else:
-    def unicode_escape_decode(__data: str | ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...
+    def unicode_escape_decode(data: str | ReadableBuffer, errors: str | None = None, /) -> tuple[str, int]: ...
 
-def unicode_escape_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
-def utf_16_be_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
-def utf_16_be_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
-def utf_16_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
-def utf_16_encode(__str: str, __errors: str | None = None, __byteorder: int = 0) -> tuple[bytes, int]: ...
+def unicode_escape_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
+def utf_16_be_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
+def utf_16_be_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
+def utf_16_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
+def utf_16_encode(str: str, errors: str | None = None, byteorder: int = 0, /) -> tuple[bytes, int]: ...
 def utf_16_ex_decode(
-    __data: ReadableBuffer, __errors: str | None = None, __byteorder: int = 0, __final: bool = False
+    data: ReadableBuffer, errors: str | None = None, byteorder: int = 0, final: bool = False, /
 ) -> tuple[str, int, int]: ...
-def utf_16_le_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
-def utf_16_le_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
-def utf_32_be_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
-def utf_32_be_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
-def utf_32_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
-def utf_32_encode(__str: str, __errors: str | None = None, __byteorder: int = 0) -> tuple[bytes, int]: ...
+def utf_16_le_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
+def utf_16_le_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
+def utf_32_be_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
+def utf_32_be_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
+def utf_32_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
+def utf_32_encode(str: str, errors: str | None = None, byteorder: int = 0, /) -> tuple[bytes, int]: ...
 def utf_32_ex_decode(
-    __data: ReadableBuffer, __errors: str | None = None, __byteorder: int = 0, __final: bool = False
+    data: ReadableBuffer, errors: str | None = None, byteorder: int = 0, final: bool = False, /
 ) -> tuple[str, int, int]: ...
-def utf_32_le_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
-def utf_32_le_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
-def utf_7_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
-def utf_7_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
-def utf_8_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
-def utf_8_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
+def utf_32_le_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
+def utf_32_le_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
+def utf_7_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
+def utf_7_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
+def utf_8_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
+def utf_8_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
 
 if sys.platform == "win32":
-    def mbcs_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
-    def mbcs_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
+    def mbcs_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
+    def mbcs_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
     def code_page_decode(
-        __codepage: int, __data: ReadableBuffer, __errors: str | None = None, __final: bool = False
+        codepage: int, data: ReadableBuffer, errors: str | None = None, final: bool = False, /
     ) -> tuple[str, int]: ...
-    def code_page_encode(__code_page: int, __str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
-    def oem_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
-    def oem_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
+    def code_page_encode(code_page: int, str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
+    def oem_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
+    def oem_encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_collections_abc.pyi

```diff
@@ -65,30 +65,30 @@
     __all__ += ["Buffer"]
 
 _KT_co = TypeVar("_KT_co", covariant=True)  # Key type covariant containers.
 _VT_co = TypeVar("_VT_co", covariant=True)  # Value type covariant containers.
 
 @final
 class dict_keys(KeysView[_KT_co], Generic[_KT_co, _VT_co]):  # undocumented
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     if sys.version_info >= (3, 10):
         @property
         def mapping(self) -> MappingProxyType[_KT_co, _VT_co]: ...
 
 @final
 class dict_values(ValuesView[_VT_co], Generic[_KT_co, _VT_co]):  # undocumented
     if sys.version_info >= (3, 10):
         @property
         def mapping(self) -> MappingProxyType[_KT_co, _VT_co]: ...
 
 @final
 class dict_items(ItemsView[_KT_co, _VT_co]):  # undocumented
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     if sys.version_info >= (3, 10):
         @property
         def mapping(self) -> MappingProxyType[_KT_co, _VT_co]: ...
 
 if sys.version_info >= (3, 12):
     @runtime_checkable
     class Buffer(Protocol):
         @abstractmethod
-        def __buffer__(self, __flags: int) -> memoryview: ...
+        def __buffer__(self, flags: int, /) -> memoryview: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_compression.pyi

```diff
@@ -2,17 +2,17 @@
 from collections.abc import Callable
 from io import DEFAULT_BUFFER_SIZE, BufferedIOBase, RawIOBase
 from typing import Any, Protocol
 
 BUFFER_SIZE = DEFAULT_BUFFER_SIZE
 
 class _Reader(Protocol):
-    def read(self, __n: int) -> bytes: ...
+    def read(self, n: int, /) -> bytes: ...
     def seekable(self) -> bool: ...
-    def seek(self, __n: int) -> Any: ...
+    def seek(self, n: int, /) -> Any: ...
 
 class BaseStream(BufferedIOBase): ...
 
 class DecompressReader(RawIOBase):
     def __init__(
         self,
         fp: _Reader,
```

## puya/_vendor/mypy/typeshed/stdlib/_ctypes.pyi

```diff
@@ -40,16 +40,16 @@
 
     FUNCFLAG_HRESULT: int
     FUNCFLAG_STDCALL: int
 
     def FormatError(code: int = ...) -> str: ...
     def get_last_error() -> int: ...
     def set_last_error(value: int) -> int: ...
-    def LoadLibrary(__name: str, __load_flags: int = 0) -> int: ...
-    def FreeLibrary(__handle: int) -> None: ...
+    def LoadLibrary(name: str, load_flags: int = 0, /) -> int: ...
+    def FreeLibrary(handle: int, /) -> None: ...
 
 class _CDataMeta(type):
     # By default mypy complains about the following two methods, because strictly speaking cls
     # might not be a Type[_CT]. However this can never actually happen, because the only class that
     # uses _CDataMeta as its metaclass is _CData. So it's safe to ignore the errors here.
     def __mul__(cls: type[_CT], other: int) -> type[Array[_CT]]: ...  # type: ignore[misc]
     def __rmul__(cls: type[_CT], other: int) -> type[Array[_CT]]: ...  # type: ignore[misc]
@@ -60,26 +60,27 @@
     _objects: Mapping[Any, int] | None
     # At runtime the following classmethods are available only on classes, not
     # on instances. This can't be reflected properly in the type system:
     #
     # Structure.from_buffer(...)  # valid at runtime
     # Structure(...).from_buffer(...)  # invalid at runtime
     #
+
     @classmethod
     def from_buffer(cls, source: WriteableBuffer, offset: int = ...) -> Self: ...
     @classmethod
     def from_buffer_copy(cls, source: ReadableBuffer, offset: int = ...) -> Self: ...
     @classmethod
     def from_address(cls, address: int) -> Self: ...
     @classmethod
     def from_param(cls, obj: Any) -> Self | _CArgObject: ...
     @classmethod
     def in_dll(cls, library: CDLL, name: str) -> Self: ...
-    def __buffer__(self, __flags: int) -> memoryview: ...
-    def __release_buffer__(self, __buffer: memoryview) -> None: ...
+    def __buffer__(self, flags: int, /) -> memoryview: ...
+    def __release_buffer__(self, buffer: memoryview, /) -> None: ...
 
 class _SimpleCData(_CData, Generic[_T]):
     value: _T
     # The TypeVar can be unsolved here,
     # but we can't use overloads without creating many, many mypy false-positive errors
     def __init__(self, value: _T = ...) -> None: ...  # pyright: ignore[reportInvalidTypeVarUse]
 
@@ -90,61 +91,62 @@
     _type_: type[_CT]
     contents: _CT
     @overload
     def __init__(self) -> None: ...
     @overload
     def __init__(self, arg: _CT) -> None: ...
     @overload
-    def __getitem__(self, __key: int) -> Any: ...
+    def __getitem__(self, key: int, /) -> Any: ...
     @overload
-    def __getitem__(self, __key: slice) -> list[Any]: ...
-    def __setitem__(self, __key: int, __value: Any) -> None: ...
+    def __getitem__(self, key: slice, /) -> list[Any]: ...
+    def __setitem__(self, key: int, value: Any, /) -> None: ...
 
 def POINTER(type: type[_CT]) -> type[_Pointer[_CT]]: ...
-def pointer(__arg: _CT) -> _Pointer[_CT]: ...
+def pointer(arg: _CT, /) -> _Pointer[_CT]: ...
 
 class _CArgObject: ...
 
 def byref(obj: _CData, offset: int = ...) -> _CArgObject: ...
 
-_ECT: TypeAlias = Callable[[type[_CData] | None, CFuncPtr, tuple[_CData, ...]], _CData]
+_ECT: TypeAlias = Callable[[_CData | None, CFuncPtr, tuple[_CData, ...]], _CData]
 _PF: TypeAlias = tuple[int] | tuple[int, str | None] | tuple[int, str | None, Any]
 
 class CFuncPtr(_PointerLike, _CData):
     restype: type[_CData] | Callable[[int], Any] | None
     argtypes: Sequence[type[_CData]]
     errcheck: _ECT
-    _flags_: ClassVar[int]  # Abstract attribute that must be defined on subclasses
+    # Abstract attribute that must be defined on subclasses
+    _flags_: ClassVar[int]
     @overload
     def __init__(self) -> None: ...
     @overload
-    def __init__(self, __address: int) -> None: ...
+    def __init__(self, address: int, /) -> None: ...
     @overload
-    def __init__(self, __callable: Callable[..., Any]) -> None: ...
+    def __init__(self, callable: Callable[..., Any], /) -> None: ...
     @overload
-    def __init__(self, __func_spec: tuple[str | int, CDLL], __paramflags: tuple[_PF, ...] | None = ...) -> None: ...
+    def __init__(self, func_spec: tuple[str | int, CDLL], paramflags: tuple[_PF, ...] | None = ..., /) -> None: ...
     if sys.platform == "win32":
         @overload
         def __init__(
-            self, __vtbl_index: int, __name: str, __paramflags: tuple[_PF, ...] | None = ..., __iid: _CData | None = ...
+            self, vtbl_index: int, name: str, paramflags: tuple[_PF, ...] | None = ..., iid: _CData | None = ..., /
         ) -> None: ...
 
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
 
 _GetT = TypeVar("_GetT")
 _SetT = TypeVar("_SetT")
 
 class _CField(Generic[_CT, _GetT, _SetT]):
     offset: int
     size: int
     @overload
-    def __get__(self, __instance: None, __owner: type[Any] | None) -> Self: ...
+    def __get__(self, instance: None, owner: type[Any] | None, /) -> Self: ...
     @overload
-    def __get__(self, __instance: Any, __owner: type[Any] | None) -> _GetT: ...
-    def __set__(self, __instance: Any, __value: _SetT) -> None: ...
+    def __get__(self, instance: Any, owner: type[Any] | None, /) -> _GetT: ...
+    def __set__(self, instance: Any, value: _SetT, /) -> None: ...
 
 class _StructUnionMeta(_CDataMeta):
     _fields_: Sequence[tuple[str, type[_CData]] | tuple[str, type[_CData], int]]
     _pack_: int
     _anonymous_: Sequence[str]
     def __getattr__(self, name: str) -> _CField[Any, Any, Any]: ...
 
@@ -179,21 +181,21 @@
     # This behavior does *not* apply to subclasses of "simple types".
     # If MyInt is a subclass of c_int, then accessing an element of an Array[MyInt] returns
     # a MyInt, not an int.
     # This special behavior is not easy to model in a stub, so for now all places where
     # the array element type would belong are annotated with Any instead.
     def __init__(self, *args: Any) -> None: ...
     @overload
-    def __getitem__(self, __key: int) -> Any: ...
+    def __getitem__(self, key: int, /) -> Any: ...
     @overload
-    def __getitem__(self, __key: slice) -> list[Any]: ...
+    def __getitem__(self, key: slice, /) -> list[Any]: ...
     @overload
-    def __setitem__(self, __key: int, __value: Any) -> None: ...
+    def __setitem__(self, key: int, value: Any, /) -> None: ...
     @overload
-    def __setitem__(self, __key: slice, __value: Iterable[Any]) -> None: ...
+    def __setitem__(self, key: slice, value: Iterable[Any], /) -> None: ...
     def __iter__(self) -> Iterator[Any]: ...
     # Can't inherit from Sized because the metaclass conflict between
     # Sized and _CData prevents using _CDataMeta.
     def __len__(self) -> int: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_curses.pyi

```diff
@@ -1,557 +1,566 @@
 import sys
 from _typeshed import ReadOnlyBuffer, SupportsRead
 from typing import IO, Any, NamedTuple, final, overload
 from typing_extensions import TypeAlias
 
-if sys.platform != "win32":
-    # Handled by PyCurses_ConvertToChtype in _cursesmodule.c.
-    _ChType: TypeAlias = str | bytes | int
-
-    # ACS codes are only initialized after initscr is called
-    ACS_BBSS: int
-    ACS_BLOCK: int
-    ACS_BOARD: int
-    ACS_BSBS: int
-    ACS_BSSB: int
-    ACS_BSSS: int
-    ACS_BTEE: int
-    ACS_BULLET: int
-    ACS_CKBOARD: int
-    ACS_DARROW: int
-    ACS_DEGREE: int
-    ACS_DIAMOND: int
-    ACS_GEQUAL: int
-    ACS_HLINE: int
-    ACS_LANTERN: int
-    ACS_LARROW: int
-    ACS_LEQUAL: int
-    ACS_LLCORNER: int
-    ACS_LRCORNER: int
-    ACS_LTEE: int
-    ACS_NEQUAL: int
-    ACS_PI: int
-    ACS_PLMINUS: int
-    ACS_PLUS: int
-    ACS_RARROW: int
-    ACS_RTEE: int
-    ACS_S1: int
-    ACS_S3: int
-    ACS_S7: int
-    ACS_S9: int
-    ACS_SBBS: int
-    ACS_SBSB: int
-    ACS_SBSS: int
-    ACS_SSBB: int
-    ACS_SSBS: int
-    ACS_SSSB: int
-    ACS_SSSS: int
-    ACS_STERLING: int
-    ACS_TTEE: int
-    ACS_UARROW: int
-    ACS_ULCORNER: int
-    ACS_URCORNER: int
-    ACS_VLINE: int
-    ALL_MOUSE_EVENTS: int
-    A_ALTCHARSET: int
-    A_ATTRIBUTES: int
-    A_BLINK: int
-    A_BOLD: int
-    A_CHARTEXT: int
-    A_COLOR: int
-    A_DIM: int
-    A_HORIZONTAL: int
-    A_INVIS: int
-    if sys.platform != "darwin":
-        A_ITALIC: int
-    A_LEFT: int
-    A_LOW: int
-    A_NORMAL: int
-    A_PROTECT: int
-    A_REVERSE: int
-    A_RIGHT: int
-    A_STANDOUT: int
-    A_TOP: int
-    A_UNDERLINE: int
-    A_VERTICAL: int
-    BUTTON1_CLICKED: int
-    BUTTON1_DOUBLE_CLICKED: int
-    BUTTON1_PRESSED: int
-    BUTTON1_RELEASED: int
-    BUTTON1_TRIPLE_CLICKED: int
-    BUTTON2_CLICKED: int
-    BUTTON2_DOUBLE_CLICKED: int
-    BUTTON2_PRESSED: int
-    BUTTON2_RELEASED: int
-    BUTTON2_TRIPLE_CLICKED: int
-    BUTTON3_CLICKED: int
-    BUTTON3_DOUBLE_CLICKED: int
-    BUTTON3_PRESSED: int
-    BUTTON3_RELEASED: int
-    BUTTON3_TRIPLE_CLICKED: int
-    BUTTON4_CLICKED: int
-    BUTTON4_DOUBLE_CLICKED: int
-    BUTTON4_PRESSED: int
-    BUTTON4_RELEASED: int
-    BUTTON4_TRIPLE_CLICKED: int
-    # Darwin ncurses doesn't provide BUTTON5_* constants
-    if sys.version_info >= (3, 10) and sys.platform != "darwin":
-        BUTTON5_PRESSED: int
-        BUTTON5_RELEASED: int
-        BUTTON5_CLICKED: int
-        BUTTON5_DOUBLE_CLICKED: int
-        BUTTON5_TRIPLE_CLICKED: int
-    BUTTON_ALT: int
-    BUTTON_CTRL: int
-    BUTTON_SHIFT: int
-    COLOR_BLACK: int
-    COLOR_BLUE: int
-    COLOR_CYAN: int
-    COLOR_GREEN: int
-    COLOR_MAGENTA: int
-    COLOR_RED: int
-    COLOR_WHITE: int
-    COLOR_YELLOW: int
-    ERR: int
-    KEY_A1: int
-    KEY_A3: int
-    KEY_B2: int
-    KEY_BACKSPACE: int
-    KEY_BEG: int
-    KEY_BREAK: int
-    KEY_BTAB: int
-    KEY_C1: int
-    KEY_C3: int
-    KEY_CANCEL: int
-    KEY_CATAB: int
-    KEY_CLEAR: int
-    KEY_CLOSE: int
-    KEY_COMMAND: int
-    KEY_COPY: int
-    KEY_CREATE: int
-    KEY_CTAB: int
-    KEY_DC: int
-    KEY_DL: int
-    KEY_DOWN: int
-    KEY_EIC: int
-    KEY_END: int
-    KEY_ENTER: int
-    KEY_EOL: int
-    KEY_EOS: int
-    KEY_EXIT: int
-    KEY_F0: int
-    KEY_F1: int
-    KEY_F10: int
-    KEY_F11: int
-    KEY_F12: int
-    KEY_F13: int
-    KEY_F14: int
-    KEY_F15: int
-    KEY_F16: int
-    KEY_F17: int
-    KEY_F18: int
-    KEY_F19: int
-    KEY_F2: int
-    KEY_F20: int
-    KEY_F21: int
-    KEY_F22: int
-    KEY_F23: int
-    KEY_F24: int
-    KEY_F25: int
-    KEY_F26: int
-    KEY_F27: int
-    KEY_F28: int
-    KEY_F29: int
-    KEY_F3: int
-    KEY_F30: int
-    KEY_F31: int
-    KEY_F32: int
-    KEY_F33: int
-    KEY_F34: int
-    KEY_F35: int
-    KEY_F36: int
-    KEY_F37: int
-    KEY_F38: int
-    KEY_F39: int
-    KEY_F4: int
-    KEY_F40: int
-    KEY_F41: int
-    KEY_F42: int
-    KEY_F43: int
-    KEY_F44: int
-    KEY_F45: int
-    KEY_F46: int
-    KEY_F47: int
-    KEY_F48: int
-    KEY_F49: int
-    KEY_F5: int
-    KEY_F50: int
-    KEY_F51: int
-    KEY_F52: int
-    KEY_F53: int
-    KEY_F54: int
-    KEY_F55: int
-    KEY_F56: int
-    KEY_F57: int
-    KEY_F58: int
-    KEY_F59: int
-    KEY_F6: int
-    KEY_F60: int
-    KEY_F61: int
-    KEY_F62: int
-    KEY_F63: int
-    KEY_F7: int
-    KEY_F8: int
-    KEY_F9: int
-    KEY_FIND: int
-    KEY_HELP: int
-    KEY_HOME: int
-    KEY_IC: int
-    KEY_IL: int
-    KEY_LEFT: int
-    KEY_LL: int
-    KEY_MARK: int
-    KEY_MAX: int
-    KEY_MESSAGE: int
-    KEY_MIN: int
-    KEY_MOUSE: int
-    KEY_MOVE: int
-    KEY_NEXT: int
-    KEY_NPAGE: int
-    KEY_OPEN: int
-    KEY_OPTIONS: int
-    KEY_PPAGE: int
-    KEY_PREVIOUS: int
-    KEY_PRINT: int
-    KEY_REDO: int
-    KEY_REFERENCE: int
-    KEY_REFRESH: int
-    KEY_REPLACE: int
-    KEY_RESET: int
-    KEY_RESIZE: int
-    KEY_RESTART: int
-    KEY_RESUME: int
-    KEY_RIGHT: int
-    KEY_SAVE: int
-    KEY_SBEG: int
-    KEY_SCANCEL: int
-    KEY_SCOMMAND: int
-    KEY_SCOPY: int
-    KEY_SCREATE: int
-    KEY_SDC: int
-    KEY_SDL: int
-    KEY_SELECT: int
-    KEY_SEND: int
-    KEY_SEOL: int
-    KEY_SEXIT: int
-    KEY_SF: int
-    KEY_SFIND: int
-    KEY_SHELP: int
-    KEY_SHOME: int
-    KEY_SIC: int
-    KEY_SLEFT: int
-    KEY_SMESSAGE: int
-    KEY_SMOVE: int
-    KEY_SNEXT: int
-    KEY_SOPTIONS: int
-    KEY_SPREVIOUS: int
-    KEY_SPRINT: int
-    KEY_SR: int
-    KEY_SREDO: int
-    KEY_SREPLACE: int
-    KEY_SRESET: int
-    KEY_SRIGHT: int
-    KEY_SRSUME: int
-    KEY_SSAVE: int
-    KEY_SSUSPEND: int
-    KEY_STAB: int
-    KEY_SUNDO: int
-    KEY_SUSPEND: int
-    KEY_UNDO: int
-    KEY_UP: int
-    OK: int
-    REPORT_MOUSE_POSITION: int
-    _C_API: Any
-    version: bytes
-    def baudrate() -> int: ...
-    def beep() -> None: ...
-    def can_change_color() -> bool: ...
-    def cbreak(__flag: bool = True) -> None: ...
-    def color_content(__color_number: int) -> tuple[int, int, int]: ...
-    def color_pair(__pair_number: int) -> int: ...
-    def curs_set(__visibility: int) -> int: ...
-    def def_prog_mode() -> None: ...
-    def def_shell_mode() -> None: ...
-    def delay_output(__ms: int) -> None: ...
-    def doupdate() -> None: ...
-    def echo(__flag: bool = True) -> None: ...
-    def endwin() -> None: ...
-    def erasechar() -> bytes: ...
-    def filter() -> None: ...
-    def flash() -> None: ...
-    def flushinp() -> None: ...
-    if sys.version_info >= (3, 9):
-        def get_escdelay() -> int: ...
-        def get_tabsize() -> int: ...
-
-    def getmouse() -> tuple[int, int, int, int, int]: ...
-    def getsyx() -> tuple[int, int]: ...
-    def getwin(__file: SupportsRead[bytes]) -> _CursesWindow: ...
-    def halfdelay(__tenths: int) -> None: ...
-    def has_colors() -> bool: ...
-    if sys.version_info >= (3, 10):
-        def has_extended_color_support() -> bool: ...
-
-    def has_ic() -> bool: ...
-    def has_il() -> bool: ...
-    def has_key(__key: int) -> bool: ...
-    def init_color(__color_number: int, __r: int, __g: int, __b: int) -> None: ...
-    def init_pair(__pair_number: int, __fg: int, __bg: int) -> None: ...
-    def initscr() -> _CursesWindow: ...
-    def intrflush(__flag: bool) -> None: ...
-    def is_term_resized(__nlines: int, __ncols: int) -> bool: ...
-    def isendwin() -> bool: ...
-    def keyname(__key: int) -> bytes: ...
-    def killchar() -> bytes: ...
-    def longname() -> bytes: ...
-    def meta(__yes: bool) -> None: ...
-    def mouseinterval(__interval: int) -> None: ...
-    def mousemask(__newmask: int) -> tuple[int, int]: ...
-    def napms(__ms: int) -> int: ...
-    def newpad(__nlines: int, __ncols: int) -> _CursesWindow: ...
-    def newwin(__nlines: int, __ncols: int, __begin_y: int = ..., __begin_x: int = ...) -> _CursesWindow: ...
-    def nl(__flag: bool = True) -> None: ...
-    def nocbreak() -> None: ...
-    def noecho() -> None: ...
-    def nonl() -> None: ...
-    def noqiflush() -> None: ...
-    def noraw() -> None: ...
-    def pair_content(__pair_number: int) -> tuple[int, int]: ...
-    def pair_number(__attr: int) -> int: ...
-    def putp(__string: ReadOnlyBuffer) -> None: ...
-    def qiflush(__flag: bool = True) -> None: ...
-    def raw(__flag: bool = True) -> None: ...
-    def reset_prog_mode() -> None: ...
-    def reset_shell_mode() -> None: ...
-    def resetty() -> None: ...
-    def resize_term(__nlines: int, __ncols: int) -> None: ...
-    def resizeterm(__nlines: int, __ncols: int) -> None: ...
-    def savetty() -> None: ...
-    if sys.version_info >= (3, 9):
-        def set_escdelay(__ms: int) -> None: ...
-        def set_tabsize(__size: int) -> None: ...
-
-    def setsyx(__y: int, __x: int) -> None: ...
-    def setupterm(term: str | None = None, fd: int = -1) -> None: ...
-    def start_color() -> None: ...
-    def termattrs() -> int: ...
-    def termname() -> bytes: ...
-    def tigetflag(__capname: str) -> int: ...
-    def tigetnum(__capname: str) -> int: ...
-    def tigetstr(__capname: str) -> bytes | None: ...
-    def tparm(
-        __str: ReadOnlyBuffer,
-        __i1: int = 0,
-        __i2: int = 0,
-        __i3: int = 0,
-        __i4: int = 0,
-        __i5: int = 0,
-        __i6: int = 0,
-        __i7: int = 0,
-        __i8: int = 0,
-        __i9: int = 0,
-    ) -> bytes: ...
-    def typeahead(__fd: int) -> None: ...
-    def unctrl(__ch: _ChType) -> bytes: ...
+# NOTE: This module is ordinarily only available on Unix, but the windows-curses
+# package makes it available on Windows as well with the same contents.
+
+# Handled by PyCurses_ConvertToChtype in _cursesmodule.c.
+_ChType: TypeAlias = str | bytes | int
+
+# ACS codes are only initialized after initscr is called
+ACS_BBSS: int
+ACS_BLOCK: int
+ACS_BOARD: int
+ACS_BSBS: int
+ACS_BSSB: int
+ACS_BSSS: int
+ACS_BTEE: int
+ACS_BULLET: int
+ACS_CKBOARD: int
+ACS_DARROW: int
+ACS_DEGREE: int
+ACS_DIAMOND: int
+ACS_GEQUAL: int
+ACS_HLINE: int
+ACS_LANTERN: int
+ACS_LARROW: int
+ACS_LEQUAL: int
+ACS_LLCORNER: int
+ACS_LRCORNER: int
+ACS_LTEE: int
+ACS_NEQUAL: int
+ACS_PI: int
+ACS_PLMINUS: int
+ACS_PLUS: int
+ACS_RARROW: int
+ACS_RTEE: int
+ACS_S1: int
+ACS_S3: int
+ACS_S7: int
+ACS_S9: int
+ACS_SBBS: int
+ACS_SBSB: int
+ACS_SBSS: int
+ACS_SSBB: int
+ACS_SSBS: int
+ACS_SSSB: int
+ACS_SSSS: int
+ACS_STERLING: int
+ACS_TTEE: int
+ACS_UARROW: int
+ACS_ULCORNER: int
+ACS_URCORNER: int
+ACS_VLINE: int
+ALL_MOUSE_EVENTS: int
+A_ALTCHARSET: int
+A_ATTRIBUTES: int
+A_BLINK: int
+A_BOLD: int
+A_CHARTEXT: int
+A_COLOR: int
+A_DIM: int
+A_HORIZONTAL: int
+A_INVIS: int
+if sys.platform != "darwin":
+    A_ITALIC: int
+A_LEFT: int
+A_LOW: int
+A_NORMAL: int
+A_PROTECT: int
+A_REVERSE: int
+A_RIGHT: int
+A_STANDOUT: int
+A_TOP: int
+A_UNDERLINE: int
+A_VERTICAL: int
+BUTTON1_CLICKED: int
+BUTTON1_DOUBLE_CLICKED: int
+BUTTON1_PRESSED: int
+BUTTON1_RELEASED: int
+BUTTON1_TRIPLE_CLICKED: int
+BUTTON2_CLICKED: int
+BUTTON2_DOUBLE_CLICKED: int
+BUTTON2_PRESSED: int
+BUTTON2_RELEASED: int
+BUTTON2_TRIPLE_CLICKED: int
+BUTTON3_CLICKED: int
+BUTTON3_DOUBLE_CLICKED: int
+BUTTON3_PRESSED: int
+BUTTON3_RELEASED: int
+BUTTON3_TRIPLE_CLICKED: int
+BUTTON4_CLICKED: int
+BUTTON4_DOUBLE_CLICKED: int
+BUTTON4_PRESSED: int
+BUTTON4_RELEASED: int
+BUTTON4_TRIPLE_CLICKED: int
+# Darwin ncurses doesn't provide BUTTON5_* constants
+if sys.version_info >= (3, 10) and sys.platform != "darwin":
+    BUTTON5_PRESSED: int
+    BUTTON5_RELEASED: int
+    BUTTON5_CLICKED: int
+    BUTTON5_DOUBLE_CLICKED: int
+    BUTTON5_TRIPLE_CLICKED: int
+BUTTON_ALT: int
+BUTTON_CTRL: int
+BUTTON_SHIFT: int
+COLOR_BLACK: int
+COLOR_BLUE: int
+COLOR_CYAN: int
+COLOR_GREEN: int
+COLOR_MAGENTA: int
+COLOR_RED: int
+COLOR_WHITE: int
+COLOR_YELLOW: int
+ERR: int
+KEY_A1: int
+KEY_A3: int
+KEY_B2: int
+KEY_BACKSPACE: int
+KEY_BEG: int
+KEY_BREAK: int
+KEY_BTAB: int
+KEY_C1: int
+KEY_C3: int
+KEY_CANCEL: int
+KEY_CATAB: int
+KEY_CLEAR: int
+KEY_CLOSE: int
+KEY_COMMAND: int
+KEY_COPY: int
+KEY_CREATE: int
+KEY_CTAB: int
+KEY_DC: int
+KEY_DL: int
+KEY_DOWN: int
+KEY_EIC: int
+KEY_END: int
+KEY_ENTER: int
+KEY_EOL: int
+KEY_EOS: int
+KEY_EXIT: int
+KEY_F0: int
+KEY_F1: int
+KEY_F10: int
+KEY_F11: int
+KEY_F12: int
+KEY_F13: int
+KEY_F14: int
+KEY_F15: int
+KEY_F16: int
+KEY_F17: int
+KEY_F18: int
+KEY_F19: int
+KEY_F2: int
+KEY_F20: int
+KEY_F21: int
+KEY_F22: int
+KEY_F23: int
+KEY_F24: int
+KEY_F25: int
+KEY_F26: int
+KEY_F27: int
+KEY_F28: int
+KEY_F29: int
+KEY_F3: int
+KEY_F30: int
+KEY_F31: int
+KEY_F32: int
+KEY_F33: int
+KEY_F34: int
+KEY_F35: int
+KEY_F36: int
+KEY_F37: int
+KEY_F38: int
+KEY_F39: int
+KEY_F4: int
+KEY_F40: int
+KEY_F41: int
+KEY_F42: int
+KEY_F43: int
+KEY_F44: int
+KEY_F45: int
+KEY_F46: int
+KEY_F47: int
+KEY_F48: int
+KEY_F49: int
+KEY_F5: int
+KEY_F50: int
+KEY_F51: int
+KEY_F52: int
+KEY_F53: int
+KEY_F54: int
+KEY_F55: int
+KEY_F56: int
+KEY_F57: int
+KEY_F58: int
+KEY_F59: int
+KEY_F6: int
+KEY_F60: int
+KEY_F61: int
+KEY_F62: int
+KEY_F63: int
+KEY_F7: int
+KEY_F8: int
+KEY_F9: int
+KEY_FIND: int
+KEY_HELP: int
+KEY_HOME: int
+KEY_IC: int
+KEY_IL: int
+KEY_LEFT: int
+KEY_LL: int
+KEY_MARK: int
+KEY_MAX: int
+KEY_MESSAGE: int
+KEY_MIN: int
+KEY_MOUSE: int
+KEY_MOVE: int
+KEY_NEXT: int
+KEY_NPAGE: int
+KEY_OPEN: int
+KEY_OPTIONS: int
+KEY_PPAGE: int
+KEY_PREVIOUS: int
+KEY_PRINT: int
+KEY_REDO: int
+KEY_REFERENCE: int
+KEY_REFRESH: int
+KEY_REPLACE: int
+KEY_RESET: int
+KEY_RESIZE: int
+KEY_RESTART: int
+KEY_RESUME: int
+KEY_RIGHT: int
+KEY_SAVE: int
+KEY_SBEG: int
+KEY_SCANCEL: int
+KEY_SCOMMAND: int
+KEY_SCOPY: int
+KEY_SCREATE: int
+KEY_SDC: int
+KEY_SDL: int
+KEY_SELECT: int
+KEY_SEND: int
+KEY_SEOL: int
+KEY_SEXIT: int
+KEY_SF: int
+KEY_SFIND: int
+KEY_SHELP: int
+KEY_SHOME: int
+KEY_SIC: int
+KEY_SLEFT: int
+KEY_SMESSAGE: int
+KEY_SMOVE: int
+KEY_SNEXT: int
+KEY_SOPTIONS: int
+KEY_SPREVIOUS: int
+KEY_SPRINT: int
+KEY_SR: int
+KEY_SREDO: int
+KEY_SREPLACE: int
+KEY_SRESET: int
+KEY_SRIGHT: int
+KEY_SRSUME: int
+KEY_SSAVE: int
+KEY_SSUSPEND: int
+KEY_STAB: int
+KEY_SUNDO: int
+KEY_SUSPEND: int
+KEY_UNDO: int
+KEY_UP: int
+OK: int
+REPORT_MOUSE_POSITION: int
+_C_API: Any
+version: bytes
+
+def baudrate() -> int: ...
+def beep() -> None: ...
+def can_change_color() -> bool: ...
+def cbreak(flag: bool = True, /) -> None: ...
+def color_content(color_number: int, /) -> tuple[int, int, int]: ...
+def color_pair(pair_number: int, /) -> int: ...
+def curs_set(visibility: int, /) -> int: ...
+def def_prog_mode() -> None: ...
+def def_shell_mode() -> None: ...
+def delay_output(ms: int, /) -> None: ...
+def doupdate() -> None: ...
+def echo(flag: bool = True, /) -> None: ...
+def endwin() -> None: ...
+def erasechar() -> bytes: ...
+def filter() -> None: ...
+def flash() -> None: ...
+def flushinp() -> None: ...
+
+if sys.version_info >= (3, 9):
+    def get_escdelay() -> int: ...
+    def get_tabsize() -> int: ...
+
+def getmouse() -> tuple[int, int, int, int, int]: ...
+def getsyx() -> tuple[int, int]: ...
+def getwin(file: SupportsRead[bytes], /) -> _CursesWindow: ...
+def halfdelay(tenths: int, /) -> None: ...
+def has_colors() -> bool: ...
+
+if sys.version_info >= (3, 10):
+    def has_extended_color_support() -> bool: ...
+
+def has_ic() -> bool: ...
+def has_il() -> bool: ...
+def has_key(key: int, /) -> bool: ...
+def init_color(color_number: int, r: int, g: int, b: int, /) -> None: ...
+def init_pair(pair_number: int, fg: int, bg: int, /) -> None: ...
+def initscr() -> _CursesWindow: ...
+def intrflush(flag: bool, /) -> None: ...
+def is_term_resized(nlines: int, ncols: int, /) -> bool: ...
+def isendwin() -> bool: ...
+def keyname(key: int, /) -> bytes: ...
+def killchar() -> bytes: ...
+def longname() -> bytes: ...
+def meta(yes: bool, /) -> None: ...
+def mouseinterval(interval: int, /) -> None: ...
+def mousemask(newmask: int, /) -> tuple[int, int]: ...
+def napms(ms: int, /) -> int: ...
+def newpad(nlines: int, ncols: int, /) -> _CursesWindow: ...
+def newwin(nlines: int, ncols: int, begin_y: int = ..., begin_x: int = ..., /) -> _CursesWindow: ...
+def nl(flag: bool = True, /) -> None: ...
+def nocbreak() -> None: ...
+def noecho() -> None: ...
+def nonl() -> None: ...
+def noqiflush() -> None: ...
+def noraw() -> None: ...
+def pair_content(pair_number: int, /) -> tuple[int, int]: ...
+def pair_number(attr: int, /) -> int: ...
+def putp(string: ReadOnlyBuffer, /) -> None: ...
+def qiflush(flag: bool = True, /) -> None: ...
+def raw(flag: bool = True, /) -> None: ...
+def reset_prog_mode() -> None: ...
+def reset_shell_mode() -> None: ...
+def resetty() -> None: ...
+def resize_term(nlines: int, ncols: int, /) -> None: ...
+def resizeterm(nlines: int, ncols: int, /) -> None: ...
+def savetty() -> None: ...
+
+if sys.version_info >= (3, 9):
+    def set_escdelay(ms: int, /) -> None: ...
+    def set_tabsize(size: int, /) -> None: ...
+
+def setsyx(y: int, x: int, /) -> None: ...
+def setupterm(term: str | None = None, fd: int = -1) -> None: ...
+def start_color() -> None: ...
+def termattrs() -> int: ...
+def termname() -> bytes: ...
+def tigetflag(capname: str, /) -> int: ...
+def tigetnum(capname: str, /) -> int: ...
+def tigetstr(capname: str, /) -> bytes | None: ...
+def tparm(
+    str: ReadOnlyBuffer,
+    i1: int = 0,
+    i2: int = 0,
+    i3: int = 0,
+    i4: int = 0,
+    i5: int = 0,
+    i6: int = 0,
+    i7: int = 0,
+    i8: int = 0,
+    i9: int = 0,
+    /,
+) -> bytes: ...
+def typeahead(fd: int, /) -> None: ...
+def unctrl(ch: _ChType, /) -> bytes: ...
+
+if sys.version_info < (3, 12) or sys.platform != "darwin":
+    # The support for macos was dropped in 3.12
+    def unget_wch(ch: int | str, /) -> None: ...
+
+def ungetch(ch: _ChType, /) -> None: ...
+def ungetmouse(id: int, x: int, y: int, z: int, bstate: int, /) -> None: ...
+def update_lines_cols() -> None: ...
+def use_default_colors() -> None: ...
+def use_env(flag: bool, /) -> None: ...
+
+class error(Exception): ...
+
+@final
+class _CursesWindow:
+    encoding: str
+    @overload
+    def addch(self, ch: _ChType, attr: int = ...) -> None: ...
+    @overload
+    def addch(self, y: int, x: int, ch: _ChType, attr: int = ...) -> None: ...
+    @overload
+    def addnstr(self, str: str, n: int, attr: int = ...) -> None: ...
+    @overload
+    def addnstr(self, y: int, x: int, str: str, n: int, attr: int = ...) -> None: ...
+    @overload
+    def addstr(self, str: str, attr: int = ...) -> None: ...
+    @overload
+    def addstr(self, y: int, x: int, str: str, attr: int = ...) -> None: ...
+    def attroff(self, attr: int, /) -> None: ...
+    def attron(self, attr: int, /) -> None: ...
+    def attrset(self, attr: int, /) -> None: ...
+    def bkgd(self, ch: _ChType, attr: int = ..., /) -> None: ...
+    def bkgdset(self, ch: _ChType, attr: int = ..., /) -> None: ...
+    def border(
+        self,
+        ls: _ChType = ...,
+        rs: _ChType = ...,
+        ts: _ChType = ...,
+        bs: _ChType = ...,
+        tl: _ChType = ...,
+        tr: _ChType = ...,
+        bl: _ChType = ...,
+        br: _ChType = ...,
+    ) -> None: ...
+    @overload
+    def box(self) -> None: ...
+    @overload
+    def box(self, vertch: _ChType = ..., horch: _ChType = ...) -> None: ...
+    @overload
+    def chgat(self, attr: int) -> None: ...
+    @overload
+    def chgat(self, num: int, attr: int) -> None: ...
+    @overload
+    def chgat(self, y: int, x: int, attr: int) -> None: ...
+    @overload
+    def chgat(self, y: int, x: int, num: int, attr: int) -> None: ...
+    def clear(self) -> None: ...
+    def clearok(self, yes: int) -> None: ...
+    def clrtobot(self) -> None: ...
+    def clrtoeol(self) -> None: ...
+    def cursyncup(self) -> None: ...
+    @overload
+    def delch(self) -> None: ...
+    @overload
+    def delch(self, y: int, x: int) -> None: ...
+    def deleteln(self) -> None: ...
+    @overload
+    def derwin(self, begin_y: int, begin_x: int) -> _CursesWindow: ...
+    @overload
+    def derwin(self, nlines: int, ncols: int, begin_y: int, begin_x: int) -> _CursesWindow: ...
+    def echochar(self, ch: _ChType, attr: int = ..., /) -> None: ...
+    def enclose(self, y: int, x: int, /) -> bool: ...
+    def erase(self) -> None: ...
+    def getbegyx(self) -> tuple[int, int]: ...
+    def getbkgd(self) -> tuple[int, int]: ...
+    @overload
+    def getch(self) -> int: ...
+    @overload
+    def getch(self, y: int, x: int) -> int: ...
     if sys.version_info < (3, 12) or sys.platform != "darwin":
         # The support for macos was dropped in 3.12
-        def unget_wch(__ch: int | str) -> None: ...
-
-    def ungetch(__ch: _ChType) -> None: ...
-    def ungetmouse(__id: int, __x: int, __y: int, __z: int, __bstate: int) -> None: ...
-    def update_lines_cols() -> None: ...
-    def use_default_colors() -> None: ...
-    def use_env(__flag: bool) -> None: ...
-
-    class error(Exception): ...
-
-    @final
-    class _CursesWindow:
-        encoding: str
-        @overload
-        def addch(self, ch: _ChType, attr: int = ...) -> None: ...
-        @overload
-        def addch(self, y: int, x: int, ch: _ChType, attr: int = ...) -> None: ...
         @overload
-        def addnstr(self, str: str, n: int, attr: int = ...) -> None: ...
+        def get_wch(self) -> int | str: ...
         @overload
-        def addnstr(self, y: int, x: int, str: str, n: int, attr: int = ...) -> None: ...
-        @overload
-        def addstr(self, str: str, attr: int = ...) -> None: ...
-        @overload
-        def addstr(self, y: int, x: int, str: str, attr: int = ...) -> None: ...
-        def attroff(self, __attr: int) -> None: ...
-        def attron(self, __attr: int) -> None: ...
-        def attrset(self, __attr: int) -> None: ...
-        def bkgd(self, __ch: _ChType, __attr: int = ...) -> None: ...
-        def bkgdset(self, __ch: _ChType, __attr: int = ...) -> None: ...
-        def border(
-            self,
-            ls: _ChType = ...,
-            rs: _ChType = ...,
-            ts: _ChType = ...,
-            bs: _ChType = ...,
-            tl: _ChType = ...,
-            tr: _ChType = ...,
-            bl: _ChType = ...,
-            br: _ChType = ...,
-        ) -> None: ...
-        @overload
-        def box(self) -> None: ...
-        @overload
-        def box(self, vertch: _ChType = ..., horch: _ChType = ...) -> None: ...
-        @overload
-        def chgat(self, attr: int) -> None: ...
-        @overload
-        def chgat(self, num: int, attr: int) -> None: ...
-        @overload
-        def chgat(self, y: int, x: int, attr: int) -> None: ...
-        @overload
-        def chgat(self, y: int, x: int, num: int, attr: int) -> None: ...
-        def clear(self) -> None: ...
-        def clearok(self, yes: int) -> None: ...
-        def clrtobot(self) -> None: ...
-        def clrtoeol(self) -> None: ...
-        def cursyncup(self) -> None: ...
-        @overload
-        def delch(self) -> None: ...
-        @overload
-        def delch(self, y: int, x: int) -> None: ...
-        def deleteln(self) -> None: ...
-        @overload
-        def derwin(self, begin_y: int, begin_x: int) -> _CursesWindow: ...
-        @overload
-        def derwin(self, nlines: int, ncols: int, begin_y: int, begin_x: int) -> _CursesWindow: ...
-        def echochar(self, __ch: _ChType, __attr: int = ...) -> None: ...
-        def enclose(self, __y: int, __x: int) -> bool: ...
-        def erase(self) -> None: ...
-        def getbegyx(self) -> tuple[int, int]: ...
-        def getbkgd(self) -> tuple[int, int]: ...
-        @overload
-        def getch(self) -> int: ...
-        @overload
-        def getch(self, y: int, x: int) -> int: ...
-        if sys.version_info < (3, 12) or sys.platform != "darwin":
-            # The support for macos was dropped in 3.12
-            @overload
-            def get_wch(self) -> int | str: ...
-            @overload
-            def get_wch(self, y: int, x: int) -> int | str: ...
+        def get_wch(self, y: int, x: int) -> int | str: ...
 
-        @overload
-        def getkey(self) -> str: ...
-        @overload
-        def getkey(self, y: int, x: int) -> str: ...
-        def getmaxyx(self) -> tuple[int, int]: ...
-        def getparyx(self) -> tuple[int, int]: ...
-        @overload
-        def getstr(self) -> bytes: ...
-        @overload
-        def getstr(self, n: int) -> bytes: ...
-        @overload
-        def getstr(self, y: int, x: int) -> bytes: ...
-        @overload
-        def getstr(self, y: int, x: int, n: int) -> bytes: ...
-        def getyx(self) -> tuple[int, int]: ...
-        @overload
-        def hline(self, ch: _ChType, n: int) -> None: ...
-        @overload
-        def hline(self, y: int, x: int, ch: _ChType, n: int) -> None: ...
-        def idcok(self, flag: bool) -> None: ...
-        def idlok(self, yes: bool) -> None: ...
-        def immedok(self, flag: bool) -> None: ...
-        @overload
-        def inch(self) -> int: ...
-        @overload
-        def inch(self, y: int, x: int) -> int: ...
-        @overload
-        def insch(self, ch: _ChType, attr: int = ...) -> None: ...
-        @overload
-        def insch(self, y: int, x: int, ch: _ChType, attr: int = ...) -> None: ...
-        def insdelln(self, nlines: int) -> None: ...
-        def insertln(self) -> None: ...
-        @overload
-        def insnstr(self, str: str, n: int, attr: int = ...) -> None: ...
-        @overload
-        def insnstr(self, y: int, x: int, str: str, n: int, attr: int = ...) -> None: ...
-        @overload
-        def insstr(self, str: str, attr: int = ...) -> None: ...
-        @overload
-        def insstr(self, y: int, x: int, str: str, attr: int = ...) -> None: ...
-        @overload
-        def instr(self, n: int = ...) -> bytes: ...
-        @overload
-        def instr(self, y: int, x: int, n: int = ...) -> bytes: ...
-        def is_linetouched(self, __line: int) -> bool: ...
-        def is_wintouched(self) -> bool: ...
-        def keypad(self, yes: bool) -> None: ...
-        def leaveok(self, yes: bool) -> None: ...
-        def move(self, new_y: int, new_x: int) -> None: ...
-        def mvderwin(self, y: int, x: int) -> None: ...
-        def mvwin(self, new_y: int, new_x: int) -> None: ...
-        def nodelay(self, yes: bool) -> None: ...
-        def notimeout(self, yes: bool) -> None: ...
-        @overload
-        def noutrefresh(self) -> None: ...
-        @overload
-        def noutrefresh(self, pminrow: int, pmincol: int, sminrow: int, smincol: int, smaxrow: int, smaxcol: int) -> None: ...
-        @overload
-        def overlay(self, destwin: _CursesWindow) -> None: ...
-        @overload
-        def overlay(
-            self, destwin: _CursesWindow, sminrow: int, smincol: int, dminrow: int, dmincol: int, dmaxrow: int, dmaxcol: int
-        ) -> None: ...
-        @overload
-        def overwrite(self, destwin: _CursesWindow) -> None: ...
-        @overload
-        def overwrite(
-            self, destwin: _CursesWindow, sminrow: int, smincol: int, dminrow: int, dmincol: int, dmaxrow: int, dmaxcol: int
-        ) -> None: ...
-        def putwin(self, __file: IO[Any]) -> None: ...
-        def redrawln(self, __beg: int, __num: int) -> None: ...
-        def redrawwin(self) -> None: ...
-        @overload
-        def refresh(self) -> None: ...
-        @overload
-        def refresh(self, pminrow: int, pmincol: int, sminrow: int, smincol: int, smaxrow: int, smaxcol: int) -> None: ...
-        def resize(self, nlines: int, ncols: int) -> None: ...
-        def scroll(self, lines: int = ...) -> None: ...
-        def scrollok(self, flag: bool) -> None: ...
-        def setscrreg(self, __top: int, __bottom: int) -> None: ...
-        def standend(self) -> None: ...
-        def standout(self) -> None: ...
-        @overload
-        def subpad(self, begin_y: int, begin_x: int) -> _CursesWindow: ...
-        @overload
-        def subpad(self, nlines: int, ncols: int, begin_y: int, begin_x: int) -> _CursesWindow: ...
-        @overload
-        def subwin(self, begin_y: int, begin_x: int) -> _CursesWindow: ...
-        @overload
-        def subwin(self, nlines: int, ncols: int, begin_y: int, begin_x: int) -> _CursesWindow: ...
-        def syncdown(self) -> None: ...
-        def syncok(self, flag: bool) -> None: ...
-        def syncup(self) -> None: ...
-        def timeout(self, delay: int) -> None: ...
-        def touchline(self, start: int, count: int, changed: bool = ...) -> None: ...
-        def touchwin(self) -> None: ...
-        def untouchwin(self) -> None: ...
-        @overload
-        def vline(self, ch: _ChType, n: int) -> None: ...
-        @overload
-        def vline(self, y: int, x: int, ch: _ChType, n: int) -> None: ...
+    @overload
+    def getkey(self) -> str: ...
+    @overload
+    def getkey(self, y: int, x: int) -> str: ...
+    def getmaxyx(self) -> tuple[int, int]: ...
+    def getparyx(self) -> tuple[int, int]: ...
+    @overload
+    def getstr(self) -> bytes: ...
+    @overload
+    def getstr(self, n: int) -> bytes: ...
+    @overload
+    def getstr(self, y: int, x: int) -> bytes: ...
+    @overload
+    def getstr(self, y: int, x: int, n: int) -> bytes: ...
+    def getyx(self) -> tuple[int, int]: ...
+    @overload
+    def hline(self, ch: _ChType, n: int) -> None: ...
+    @overload
+    def hline(self, y: int, x: int, ch: _ChType, n: int) -> None: ...
+    def idcok(self, flag: bool) -> None: ...
+    def idlok(self, yes: bool) -> None: ...
+    def immedok(self, flag: bool) -> None: ...
+    @overload
+    def inch(self) -> int: ...
+    @overload
+    def inch(self, y: int, x: int) -> int: ...
+    @overload
+    def insch(self, ch: _ChType, attr: int = ...) -> None: ...
+    @overload
+    def insch(self, y: int, x: int, ch: _ChType, attr: int = ...) -> None: ...
+    def insdelln(self, nlines: int) -> None: ...
+    def insertln(self) -> None: ...
+    @overload
+    def insnstr(self, str: str, n: int, attr: int = ...) -> None: ...
+    @overload
+    def insnstr(self, y: int, x: int, str: str, n: int, attr: int = ...) -> None: ...
+    @overload
+    def insstr(self, str: str, attr: int = ...) -> None: ...
+    @overload
+    def insstr(self, y: int, x: int, str: str, attr: int = ...) -> None: ...
+    @overload
+    def instr(self, n: int = ...) -> bytes: ...
+    @overload
+    def instr(self, y: int, x: int, n: int = ...) -> bytes: ...
+    def is_linetouched(self, line: int, /) -> bool: ...
+    def is_wintouched(self) -> bool: ...
+    def keypad(self, yes: bool) -> None: ...
+    def leaveok(self, yes: bool) -> None: ...
+    def move(self, new_y: int, new_x: int) -> None: ...
+    def mvderwin(self, y: int, x: int) -> None: ...
+    def mvwin(self, new_y: int, new_x: int) -> None: ...
+    def nodelay(self, yes: bool) -> None: ...
+    def notimeout(self, yes: bool) -> None: ...
+    @overload
+    def noutrefresh(self) -> None: ...
+    @overload
+    def noutrefresh(self, pminrow: int, pmincol: int, sminrow: int, smincol: int, smaxrow: int, smaxcol: int) -> None: ...
+    @overload
+    def overlay(self, destwin: _CursesWindow) -> None: ...
+    @overload
+    def overlay(
+        self, destwin: _CursesWindow, sminrow: int, smincol: int, dminrow: int, dmincol: int, dmaxrow: int, dmaxcol: int
+    ) -> None: ...
+    @overload
+    def overwrite(self, destwin: _CursesWindow) -> None: ...
+    @overload
+    def overwrite(
+        self, destwin: _CursesWindow, sminrow: int, smincol: int, dminrow: int, dmincol: int, dmaxrow: int, dmaxcol: int
+    ) -> None: ...
+    def putwin(self, file: IO[Any], /) -> None: ...
+    def redrawln(self, beg: int, num: int, /) -> None: ...
+    def redrawwin(self) -> None: ...
+    @overload
+    def refresh(self) -> None: ...
+    @overload
+    def refresh(self, pminrow: int, pmincol: int, sminrow: int, smincol: int, smaxrow: int, smaxcol: int) -> None: ...
+    def resize(self, nlines: int, ncols: int) -> None: ...
+    def scroll(self, lines: int = ...) -> None: ...
+    def scrollok(self, flag: bool) -> None: ...
+    def setscrreg(self, top: int, bottom: int, /) -> None: ...
+    def standend(self) -> None: ...
+    def standout(self) -> None: ...
+    @overload
+    def subpad(self, begin_y: int, begin_x: int) -> _CursesWindow: ...
+    @overload
+    def subpad(self, nlines: int, ncols: int, begin_y: int, begin_x: int) -> _CursesWindow: ...
+    @overload
+    def subwin(self, begin_y: int, begin_x: int) -> _CursesWindow: ...
+    @overload
+    def subwin(self, nlines: int, ncols: int, begin_y: int, begin_x: int) -> _CursesWindow: ...
+    def syncdown(self) -> None: ...
+    def syncok(self, flag: bool) -> None: ...
+    def syncup(self) -> None: ...
+    def timeout(self, delay: int) -> None: ...
+    def touchline(self, start: int, count: int, changed: bool = ...) -> None: ...
+    def touchwin(self) -> None: ...
+    def untouchwin(self) -> None: ...
+    @overload
+    def vline(self, ch: _ChType, n: int) -> None: ...
+    @overload
+    def vline(self, y: int, x: int, ch: _ChType, n: int) -> None: ...
+
+class _ncurses_version(NamedTuple):
+    major: int
+    minor: int
+    patch: int
 
-    class _ncurses_version(NamedTuple):
-        major: int
-        minor: int
-        patch: int
-    ncurses_version: _ncurses_version
-    window = _CursesWindow  # undocumented
+ncurses_version: _ncurses_version
+window = _CursesWindow  # undocumented
```

## puya/_vendor/mypy/typeshed/stdlib/_decimal.pyi

```diff
@@ -43,15 +43,15 @@
 class InvalidContext(InvalidOperation): ...
 class Rounded(DecimalException): ...
 class Subnormal(DecimalException): ...
 class Overflow(Inexact, Rounded): ...
 class Underflow(Inexact, Rounded, Subnormal): ...
 class FloatOperation(DecimalException, TypeError): ...
 
-def setcontext(__context: Context) -> None: ...
+def setcontext(context: Context, /) -> None: ...
 def getcontext() -> Context: ...
 
 if sys.version_info >= (3, 11):
     def localcontext(
         ctx: Context | None = None,
         *,
         prec: int | None = ...,
@@ -66,62 +66,62 @@
 
 else:
     def localcontext(ctx: Context | None = None) -> _ContextManager: ...
 
 class Decimal:
     def __new__(cls, value: _DecimalNew = ..., context: Context | None = ...) -> Self: ...
     @classmethod
-    def from_float(cls, __f: float) -> Self: ...
+    def from_float(cls, f: float, /) -> Self: ...
     def __bool__(self) -> bool: ...
     def compare(self, other: _Decimal, context: Context | None = None) -> Decimal: ...
     def __hash__(self) -> int: ...
     def as_tuple(self) -> DecimalTuple: ...
     def as_integer_ratio(self) -> tuple[int, int]: ...
     def to_eng_string(self, context: Context | None = None) -> str: ...
     def __abs__(self) -> Decimal: ...
-    def __add__(self, __value: _Decimal) -> Decimal: ...
-    def __divmod__(self, __value: _Decimal) -> tuple[Decimal, Decimal]: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __floordiv__(self, __value: _Decimal) -> Decimal: ...
-    def __ge__(self, __value: _ComparableNum) -> bool: ...
-    def __gt__(self, __value: _ComparableNum) -> bool: ...
-    def __le__(self, __value: _ComparableNum) -> bool: ...
-    def __lt__(self, __value: _ComparableNum) -> bool: ...
-    def __mod__(self, __value: _Decimal) -> Decimal: ...
-    def __mul__(self, __value: _Decimal) -> Decimal: ...
+    def __add__(self, value: _Decimal, /) -> Decimal: ...
+    def __divmod__(self, value: _Decimal, /) -> tuple[Decimal, Decimal]: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __floordiv__(self, value: _Decimal, /) -> Decimal: ...
+    def __ge__(self, value: _ComparableNum, /) -> bool: ...
+    def __gt__(self, value: _ComparableNum, /) -> bool: ...
+    def __le__(self, value: _ComparableNum, /) -> bool: ...
+    def __lt__(self, value: _ComparableNum, /) -> bool: ...
+    def __mod__(self, value: _Decimal, /) -> Decimal: ...
+    def __mul__(self, value: _Decimal, /) -> Decimal: ...
     def __neg__(self) -> Decimal: ...
     def __pos__(self) -> Decimal: ...
-    def __pow__(self, __value: _Decimal, __mod: _Decimal | None = None) -> Decimal: ...
-    def __radd__(self, __value: _Decimal) -> Decimal: ...
-    def __rdivmod__(self, __value: _Decimal) -> tuple[Decimal, Decimal]: ...
-    def __rfloordiv__(self, __value: _Decimal) -> Decimal: ...
-    def __rmod__(self, __value: _Decimal) -> Decimal: ...
-    def __rmul__(self, __value: _Decimal) -> Decimal: ...
-    def __rsub__(self, __value: _Decimal) -> Decimal: ...
-    def __rtruediv__(self, __value: _Decimal) -> Decimal: ...
-    def __sub__(self, __value: _Decimal) -> Decimal: ...
-    def __truediv__(self, __value: _Decimal) -> Decimal: ...
+    def __pow__(self, value: _Decimal, mod: _Decimal | None = None, /) -> Decimal: ...
+    def __radd__(self, value: _Decimal, /) -> Decimal: ...
+    def __rdivmod__(self, value: _Decimal, /) -> tuple[Decimal, Decimal]: ...
+    def __rfloordiv__(self, value: _Decimal, /) -> Decimal: ...
+    def __rmod__(self, value: _Decimal, /) -> Decimal: ...
+    def __rmul__(self, value: _Decimal, /) -> Decimal: ...
+    def __rsub__(self, value: _Decimal, /) -> Decimal: ...
+    def __rtruediv__(self, value: _Decimal, /) -> Decimal: ...
+    def __sub__(self, value: _Decimal, /) -> Decimal: ...
+    def __truediv__(self, value: _Decimal, /) -> Decimal: ...
     def remainder_near(self, other: _Decimal, context: Context | None = None) -> Decimal: ...
     def __float__(self) -> float: ...
     def __int__(self) -> int: ...
     def __trunc__(self) -> int: ...
     @property
     def real(self) -> Decimal: ...
     @property
     def imag(self) -> Decimal: ...
     def conjugate(self) -> Decimal: ...
     def __complex__(self) -> complex: ...
     @overload
     def __round__(self) -> int: ...
     @overload
-    def __round__(self, __ndigits: int) -> Decimal: ...
+    def __round__(self, ndigits: int, /) -> Decimal: ...
     def __floor__(self) -> int: ...
     def __ceil__(self) -> int: ...
     def fma(self, other: _Decimal, third: _Decimal, context: Context | None = None) -> Decimal: ...
-    def __rpow__(self, __value: _Decimal, __mod: Context | None = None) -> Decimal: ...
+    def __rpow__(self, value: _Decimal, mod: Context | None = None, /) -> Decimal: ...
     def normalize(self, context: Context | None = None) -> Decimal: ...
     def quantize(self, exp: _Decimal, rounding: str | None = None, context: Context | None = None) -> Decimal: ...
     def same_quantum(self, other: _Decimal, context: Context | None = None) -> bool: ...
     def to_integral_exact(self, rounding: str | None = None, context: Context | None = None) -> Decimal: ...
     def to_integral_value(self, rounding: str | None = None, context: Context | None = None) -> Decimal: ...
     def to_integral(self, rounding: str | None = None, context: Context | None = None) -> Decimal: ...
     def sqrt(self, context: Context | None = None) -> Decimal: ...
@@ -161,16 +161,16 @@
     def number_class(self, context: Context | None = None) -> str: ...
     def radix(self) -> Decimal: ...
     def rotate(self, other: _Decimal, context: Context | None = None) -> Decimal: ...
     def scaleb(self, other: _Decimal, context: Context | None = None) -> Decimal: ...
     def shift(self, other: _Decimal, context: Context | None = None) -> Decimal: ...
     def __reduce__(self) -> tuple[type[Self], tuple[str]]: ...
     def __copy__(self) -> Self: ...
-    def __deepcopy__(self, __memo: Any) -> Self: ...
-    def __format__(self, __specifier: str, __context: Context | None = ...) -> str: ...
+    def __deepcopy__(self, memo: Any, /) -> Self: ...
+    def __format__(self, specifier: str, context: Context | None = ..., /) -> str: ...
 
 class _ContextManager:
     new_context: Context
     saved_context: Context
     def __init__(self, new_context: Context) -> None: ...
     def __enter__(self) -> Context: ...
     def __exit__(self, t: type[BaseException] | None, v: BaseException | None, tb: TracebackType | None) -> None: ...
@@ -178,15 +178,15 @@
 _TrapType: TypeAlias = type[DecimalException]
 
 class Context:
     # TODO: Context doesn't allow you to delete *any* attributes from instances of the class at runtime,
     # even settable attributes like `prec` and `rounding`,
     # but that's inexpressable in the stub.
     # Type checkers either ignore it or misinterpret it
-    # if you add a `def __delattr__(self, __name: str) -> NoReturn` method to the stub
+    # if you add a `def __delattr__(self, name: str, /) -> NoReturn` method to the stub
     prec: int
     rounding: str
     Emin: int
     Emax: int
     capitals: int
     clamp: int
     traps: dict[_TrapType, bool]
@@ -208,74 +208,74 @@
     def clear_traps(self) -> None: ...
     def copy(self) -> Context: ...
     def __copy__(self) -> Context: ...
     # see https://github.com/python/cpython/issues/94107
     __hash__: ClassVar[None]  # type: ignore[assignment]
     def Etiny(self) -> int: ...
     def Etop(self) -> int: ...
-    def create_decimal(self, __num: _DecimalNew = "0") -> Decimal: ...
-    def create_decimal_from_float(self, __f: float) -> Decimal: ...
-    def abs(self, __x: _Decimal) -> Decimal: ...
-    def add(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def canonical(self, __x: Decimal) -> Decimal: ...
-    def compare(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def compare_signal(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def compare_total(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def compare_total_mag(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def copy_abs(self, __x: _Decimal) -> Decimal: ...
-    def copy_decimal(self, __x: _Decimal) -> Decimal: ...
-    def copy_negate(self, __x: _Decimal) -> Decimal: ...
-    def copy_sign(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def divide(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def divide_int(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def divmod(self, __x: _Decimal, __y: _Decimal) -> tuple[Decimal, Decimal]: ...
-    def exp(self, __x: _Decimal) -> Decimal: ...
-    def fma(self, __x: _Decimal, __y: _Decimal, __z: _Decimal) -> Decimal: ...
-    def is_canonical(self, __x: _Decimal) -> bool: ...
-    def is_finite(self, __x: _Decimal) -> bool: ...
-    def is_infinite(self, __x: _Decimal) -> bool: ...
-    def is_nan(self, __x: _Decimal) -> bool: ...
-    def is_normal(self, __x: _Decimal) -> bool: ...
-    def is_qnan(self, __x: _Decimal) -> bool: ...
-    def is_signed(self, __x: _Decimal) -> bool: ...
-    def is_snan(self, __x: _Decimal) -> bool: ...
-    def is_subnormal(self, __x: _Decimal) -> bool: ...
-    def is_zero(self, __x: _Decimal) -> bool: ...
-    def ln(self, __x: _Decimal) -> Decimal: ...
-    def log10(self, __x: _Decimal) -> Decimal: ...
-    def logb(self, __x: _Decimal) -> Decimal: ...
-    def logical_and(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def logical_invert(self, __x: _Decimal) -> Decimal: ...
-    def logical_or(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def logical_xor(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def max(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def max_mag(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def min(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def min_mag(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def minus(self, __x: _Decimal) -> Decimal: ...
-    def multiply(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def next_minus(self, __x: _Decimal) -> Decimal: ...
-    def next_plus(self, __x: _Decimal) -> Decimal: ...
-    def next_toward(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def normalize(self, __x: _Decimal) -> Decimal: ...
-    def number_class(self, __x: _Decimal) -> str: ...
-    def plus(self, __x: _Decimal) -> Decimal: ...
+    def create_decimal(self, num: _DecimalNew = "0", /) -> Decimal: ...
+    def create_decimal_from_float(self, f: float, /) -> Decimal: ...
+    def abs(self, x: _Decimal, /) -> Decimal: ...
+    def add(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def canonical(self, x: Decimal, /) -> Decimal: ...
+    def compare(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def compare_signal(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def compare_total(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def compare_total_mag(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def copy_abs(self, x: _Decimal, /) -> Decimal: ...
+    def copy_decimal(self, x: _Decimal, /) -> Decimal: ...
+    def copy_negate(self, x: _Decimal, /) -> Decimal: ...
+    def copy_sign(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def divide(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def divide_int(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def divmod(self, x: _Decimal, y: _Decimal, /) -> tuple[Decimal, Decimal]: ...
+    def exp(self, x: _Decimal, /) -> Decimal: ...
+    def fma(self, x: _Decimal, y: _Decimal, z: _Decimal, /) -> Decimal: ...
+    def is_canonical(self, x: _Decimal, /) -> bool: ...
+    def is_finite(self, x: _Decimal, /) -> bool: ...
+    def is_infinite(self, x: _Decimal, /) -> bool: ...
+    def is_nan(self, x: _Decimal, /) -> bool: ...
+    def is_normal(self, x: _Decimal, /) -> bool: ...
+    def is_qnan(self, x: _Decimal, /) -> bool: ...
+    def is_signed(self, x: _Decimal, /) -> bool: ...
+    def is_snan(self, x: _Decimal, /) -> bool: ...
+    def is_subnormal(self, x: _Decimal, /) -> bool: ...
+    def is_zero(self, x: _Decimal, /) -> bool: ...
+    def ln(self, x: _Decimal, /) -> Decimal: ...
+    def log10(self, x: _Decimal, /) -> Decimal: ...
+    def logb(self, x: _Decimal, /) -> Decimal: ...
+    def logical_and(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def logical_invert(self, x: _Decimal, /) -> Decimal: ...
+    def logical_or(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def logical_xor(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def max(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def max_mag(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def min(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def min_mag(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def minus(self, x: _Decimal, /) -> Decimal: ...
+    def multiply(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def next_minus(self, x: _Decimal, /) -> Decimal: ...
+    def next_plus(self, x: _Decimal, /) -> Decimal: ...
+    def next_toward(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def normalize(self, x: _Decimal, /) -> Decimal: ...
+    def number_class(self, x: _Decimal, /) -> str: ...
+    def plus(self, x: _Decimal, /) -> Decimal: ...
     def power(self, a: _Decimal, b: _Decimal, modulo: _Decimal | None = None) -> Decimal: ...
-    def quantize(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
+    def quantize(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
     def radix(self) -> Decimal: ...
-    def remainder(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def remainder_near(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def rotate(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def same_quantum(self, __x: _Decimal, __y: _Decimal) -> bool: ...
-    def scaleb(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def shift(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def sqrt(self, __x: _Decimal) -> Decimal: ...
-    def subtract(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...
-    def to_eng_string(self, __x: _Decimal) -> str: ...
-    def to_sci_string(self, __x: _Decimal) -> str: ...
-    def to_integral_exact(self, __x: _Decimal) -> Decimal: ...
-    def to_integral_value(self, __x: _Decimal) -> Decimal: ...
-    def to_integral(self, __x: _Decimal) -> Decimal: ...
+    def remainder(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def remainder_near(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def rotate(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def same_quantum(self, x: _Decimal, y: _Decimal, /) -> bool: ...
+    def scaleb(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def shift(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def sqrt(self, x: _Decimal, /) -> Decimal: ...
+    def subtract(self, x: _Decimal, y: _Decimal, /) -> Decimal: ...
+    def to_eng_string(self, x: _Decimal, /) -> str: ...
+    def to_sci_string(self, x: _Decimal, /) -> str: ...
+    def to_integral_exact(self, x: _Decimal, /) -> Decimal: ...
+    def to_integral_value(self, x: _Decimal, /) -> Decimal: ...
+    def to_integral(self, x: _Decimal, /) -> Decimal: ...
 
 DefaultContext: Context
 BasicContext: Context
 ExtendedContext: Context
```

## puya/_vendor/mypy/typeshed/stdlib/_dummy_thread.pyi

```diff
@@ -1,17 +1,23 @@
 from collections.abc import Callable
 from types import TracebackType
-from typing import Any, NoReturn
+from typing import Any, NoReturn, overload
+from typing_extensions import TypeVarTuple, Unpack
 
 __all__ = ["error", "start_new_thread", "exit", "get_ident", "allocate_lock", "interrupt_main", "LockType", "RLock"]
 
+_Ts = TypeVarTuple("_Ts")
+
 TIMEOUT_MAX: int
 error = RuntimeError
 
-def start_new_thread(function: Callable[..., object], args: tuple[Any, ...], kwargs: dict[str, Any] = {}) -> None: ...
+@overload
+def start_new_thread(function: Callable[[Unpack[_Ts]], object], args: tuple[Unpack[_Ts]]) -> None: ...
+@overload
+def start_new_thread(function: Callable[..., object], args: tuple[Any, ...], kwargs: dict[str, Any]) -> None: ...
 def exit() -> NoReturn: ...
 def get_ident() -> int: ...
 def allocate_lock() -> LockType: ...
 def stack_size(size: int | None = None) -> int: ...
 
 class LockType:
     locked_status: bool
```

## puya/_vendor/mypy/typeshed/stdlib/_heapq.pyi

```diff
@@ -1,11 +1,11 @@
 from typing import Any, Final, TypeVar
 
 _T = TypeVar("_T")
 
 __about__: Final[str]
 
-def heapify(__heap: list[Any]) -> None: ...
-def heappop(__heap: list[_T]) -> _T: ...
-def heappush(__heap: list[_T], __item: _T) -> None: ...
-def heappushpop(__heap: list[_T], __item: _T) -> _T: ...
-def heapreplace(__heap: list[_T], __item: _T) -> _T: ...
+def heapify(heap: list[Any], /) -> None: ...
+def heappop(heap: list[_T], /) -> _T: ...
+def heappush(heap: list[_T], item: _T, /) -> None: ...
+def heappushpop(heap: list[_T], item: _T, /) -> _T: ...
+def heapreplace(heap: list[_T], item: _T, /) -> _T: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_imp.pyi

```diff
@@ -3,26 +3,26 @@
 from _typeshed import ReadableBuffer
 from importlib.machinery import ModuleSpec
 from typing import Any
 
 check_hash_based_pycs: str
 
 def source_hash(key: int, source: ReadableBuffer) -> bytes: ...
-def create_builtin(__spec: ModuleSpec) -> types.ModuleType: ...
-def create_dynamic(__spec: ModuleSpec, __file: Any = None) -> types.ModuleType: ...
+def create_builtin(spec: ModuleSpec, /) -> types.ModuleType: ...
+def create_dynamic(spec: ModuleSpec, file: Any = None, /) -> types.ModuleType: ...
 def acquire_lock() -> None: ...
-def exec_builtin(__mod: types.ModuleType) -> int: ...
-def exec_dynamic(__mod: types.ModuleType) -> int: ...
+def exec_builtin(mod: types.ModuleType, /) -> int: ...
+def exec_dynamic(mod: types.ModuleType, /) -> int: ...
 def extension_suffixes() -> list[str]: ...
-def init_frozen(__name: str) -> types.ModuleType: ...
-def is_builtin(__name: str) -> int: ...
-def is_frozen(__name: str) -> bool: ...
-def is_frozen_package(__name: str) -> bool: ...
+def init_frozen(name: str, /) -> types.ModuleType: ...
+def is_builtin(name: str, /) -> int: ...
+def is_frozen(name: str, /) -> bool: ...
+def is_frozen_package(name: str, /) -> bool: ...
 def lock_held() -> bool: ...
 def release_lock() -> None: ...
 
 if sys.version_info >= (3, 11):
-    def find_frozen(__name: str, *, withdata: bool = False) -> tuple[memoryview | None, bool, str | None] | None: ...
-    def get_frozen_object(__name: str, __data: ReadableBuffer | None = None) -> types.CodeType: ...
+    def find_frozen(name: str, /, *, withdata: bool = False) -> tuple[memoryview | None, bool, str | None] | None: ...
+    def get_frozen_object(name: str, data: ReadableBuffer | None = None, /) -> types.CodeType: ...
 
 else:
-    def get_frozen_object(__name: str) -> types.CodeType: ...
+    def get_frozen_object(name: str, /) -> types.CodeType: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_locale.pyi

```diff
@@ -6,22 +6,22 @@
 LC_COLLATE: int
 LC_TIME: int
 LC_MONETARY: int
 LC_NUMERIC: int
 LC_ALL: int
 CHAR_MAX: int
 
-def setlocale(__category: int, __locale: str | None = None) -> str: ...
+def setlocale(category: int, locale: str | None = None, /) -> str: ...
 def localeconv() -> Mapping[str, int | str | list[int]]: ...
 
 if sys.version_info >= (3, 11):
     def getencoding() -> str: ...
 
-def strcoll(__os1: str, __os2: str) -> int: ...
-def strxfrm(__string: str) -> str: ...
+def strcoll(os1: str, os2: str, /) -> int: ...
+def strxfrm(string: str, /) -> str: ...
 
 # native gettext functions
 # https://docs.python.org/3/library/locale.html#access-to-message-catalogs
 # https://github.com/python/cpython/blob/f4c03484da59049eb62a9bf7777b963e2267d187/Modules/_localemodule.c#L626
 if sys.platform != "win32":
     LC_MESSAGES: int
 
@@ -83,18 +83,18 @@
     RADIXCHAR: int
     THOUSEP: int
     YESEXPR: int
     NOEXPR: int
     CRNCYSTR: int
     ALT_DIGITS: int
 
-    def nl_langinfo(__key: int) -> str: ...
+    def nl_langinfo(key: int, /) -> str: ...
 
     # This is dependent on `libintl.h` which is a part of `gettext`
     # system dependency. These functions might be missing.
     # But, we always say that they are present.
-    def gettext(__msg: str) -> str: ...
-    def dgettext(__domain: str | None, __msg: str) -> str: ...
-    def dcgettext(__domain: str | None, __msg: str, __category: int) -> str: ...
-    def textdomain(__domain: str | None) -> str: ...
-    def bindtextdomain(__domain: str, __dir: StrPath | None) -> str: ...
-    def bind_textdomain_codeset(__domain: str, __codeset: str | None) -> str | None: ...
+    def gettext(msg: str, /) -> str: ...
+    def dgettext(domain: str | None, msg: str, /) -> str: ...
+    def dcgettext(domain: str | None, msg: str, category: int, /) -> str: ...
+    def textdomain(domain: str | None, /) -> str: ...
+    def bindtextdomain(domain: str, dir: StrPath | None, /) -> str: ...
+    def bind_textdomain_codeset(domain: str, codeset: str | None, /) -> str | None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_msi.pyi

```diff
@@ -41,18 +41,19 @@
         def SetString(self, field: int, str: str) -> None: ...
         def SetStream(self, field: int, stream: str) -> None: ...
         def SetInteger(self, field: int, int: int) -> None: ...
         def ClearData(self) -> None: ...
         # Don't exist at runtime
         __new__: None  # type: ignore[assignment]
         __init__: None  # type: ignore[assignment]
+
     def UuidCreate() -> str: ...
-    def FCICreate(__cabname: str, __files: list[str]) -> None: ...
-    def OpenDatabase(__path: str, __persist: int) -> _Database: ...
-    def CreateRecord(__count: int) -> _Record: ...
+    def FCICreate(cabname: str, files: list[str], /) -> None: ...
+    def OpenDatabase(path: str, persist: int, /) -> _Database: ...
+    def CreateRecord(count: int, /) -> _Record: ...
 
     MSICOLINFO_NAMES: int
     MSICOLINFO_TYPES: int
     MSIDBOPEN_CREATE: int
     MSIDBOPEN_CREATEDIRECT: int
     MSIDBOPEN_DIRECT: int
     MSIDBOPEN_PATCHFILE: int
```

## puya/_vendor/mypy/typeshed/stdlib/_operator.pyi

```diff
@@ -15,133 +15,133 @@
 _Ts = TypeVarTuple("_Ts")
 
 # The following protocols return "Any" instead of bool, since the comparison
 # operators can be overloaded to return an arbitrary object. For example,
 # the numpy.array comparison dunders return another numpy.array.
 
 class _SupportsDunderLT(Protocol):
-    def __lt__(self, __other: Any) -> Any: ...
+    def __lt__(self, other: Any, /) -> Any: ...
 
 class _SupportsDunderGT(Protocol):
-    def __gt__(self, __other: Any) -> Any: ...
+    def __gt__(self, other: Any, /) -> Any: ...
 
 class _SupportsDunderLE(Protocol):
-    def __le__(self, __other: Any) -> Any: ...
+    def __le__(self, other: Any, /) -> Any: ...
 
 class _SupportsDunderGE(Protocol):
-    def __ge__(self, __other: Any) -> Any: ...
+    def __ge__(self, other: Any, /) -> Any: ...
 
 _SupportsComparison: TypeAlias = _SupportsDunderLE | _SupportsDunderGE | _SupportsDunderGT | _SupportsDunderLT
 
 class _SupportsInversion(Protocol[_T_co]):
     def __invert__(self) -> _T_co: ...
 
 class _SupportsNeg(Protocol[_T_co]):
     def __neg__(self) -> _T_co: ...
 
 class _SupportsPos(Protocol[_T_co]):
     def __pos__(self) -> _T_co: ...
 
 # All four comparison functions must have the same signature, or we get false-positive errors
-def lt(__a: _SupportsComparison, __b: _SupportsComparison) -> Any: ...
-def le(__a: _SupportsComparison, __b: _SupportsComparison) -> Any: ...
-def eq(__a: object, __b: object) -> Any: ...
-def ne(__a: object, __b: object) -> Any: ...
-def ge(__a: _SupportsComparison, __b: _SupportsComparison) -> Any: ...
-def gt(__a: _SupportsComparison, __b: _SupportsComparison) -> Any: ...
-def not_(__a: object) -> bool: ...
-def truth(__a: object) -> bool: ...
-def is_(__a: object, __b: object) -> bool: ...
-def is_not(__a: object, __b: object) -> bool: ...
-def abs(__a: SupportsAbs[_T]) -> _T: ...
-def add(__a: Any, __b: Any) -> Any: ...
-def and_(__a: Any, __b: Any) -> Any: ...
-def floordiv(__a: Any, __b: Any) -> Any: ...
-def index(__a: SupportsIndex) -> int: ...
-def inv(__a: _SupportsInversion[_T_co]) -> _T_co: ...
-def invert(__a: _SupportsInversion[_T_co]) -> _T_co: ...
-def lshift(__a: Any, __b: Any) -> Any: ...
-def mod(__a: Any, __b: Any) -> Any: ...
-def mul(__a: Any, __b: Any) -> Any: ...
-def matmul(__a: Any, __b: Any) -> Any: ...
-def neg(__a: _SupportsNeg[_T_co]) -> _T_co: ...
-def or_(__a: Any, __b: Any) -> Any: ...
-def pos(__a: _SupportsPos[_T_co]) -> _T_co: ...
-def pow(__a: Any, __b: Any) -> Any: ...
-def rshift(__a: Any, __b: Any) -> Any: ...
-def sub(__a: Any, __b: Any) -> Any: ...
-def truediv(__a: Any, __b: Any) -> Any: ...
-def xor(__a: Any, __b: Any) -> Any: ...
-def concat(__a: Sequence[_T], __b: Sequence[_T]) -> Sequence[_T]: ...
-def contains(__a: Container[object], __b: object) -> bool: ...
-def countOf(__a: Iterable[object], __b: object) -> int: ...
-@overload
-def delitem(__a: MutableSequence[Any], __b: SupportsIndex) -> None: ...
-@overload
-def delitem(__a: MutableSequence[Any], __b: slice) -> None: ...
-@overload
-def delitem(__a: MutableMapping[_K, Any], __b: _K) -> None: ...
-@overload
-def getitem(__a: Sequence[_T], __b: slice) -> Sequence[_T]: ...
-@overload
-def getitem(__a: SupportsGetItem[_K, _V], __b: _K) -> _V: ...
-def indexOf(__a: Iterable[_T], __b: _T) -> int: ...
+def lt(a: _SupportsComparison, b: _SupportsComparison, /) -> Any: ...
+def le(a: _SupportsComparison, b: _SupportsComparison, /) -> Any: ...
+def eq(a: object, b: object, /) -> Any: ...
+def ne(a: object, b: object, /) -> Any: ...
+def ge(a: _SupportsComparison, b: _SupportsComparison, /) -> Any: ...
+def gt(a: _SupportsComparison, b: _SupportsComparison, /) -> Any: ...
+def not_(a: object, /) -> bool: ...
+def truth(a: object, /) -> bool: ...
+def is_(a: object, b: object, /) -> bool: ...
+def is_not(a: object, b: object, /) -> bool: ...
+def abs(a: SupportsAbs[_T], /) -> _T: ...
+def add(a: Any, b: Any, /) -> Any: ...
+def and_(a: Any, b: Any, /) -> Any: ...
+def floordiv(a: Any, b: Any, /) -> Any: ...
+def index(a: SupportsIndex, /) -> int: ...
+def inv(a: _SupportsInversion[_T_co], /) -> _T_co: ...
+def invert(a: _SupportsInversion[_T_co], /) -> _T_co: ...
+def lshift(a: Any, b: Any, /) -> Any: ...
+def mod(a: Any, b: Any, /) -> Any: ...
+def mul(a: Any, b: Any, /) -> Any: ...
+def matmul(a: Any, b: Any, /) -> Any: ...
+def neg(a: _SupportsNeg[_T_co], /) -> _T_co: ...
+def or_(a: Any, b: Any, /) -> Any: ...
+def pos(a: _SupportsPos[_T_co], /) -> _T_co: ...
+def pow(a: Any, b: Any, /) -> Any: ...
+def rshift(a: Any, b: Any, /) -> Any: ...
+def sub(a: Any, b: Any, /) -> Any: ...
+def truediv(a: Any, b: Any, /) -> Any: ...
+def xor(a: Any, b: Any, /) -> Any: ...
+def concat(a: Sequence[_T], b: Sequence[_T], /) -> Sequence[_T]: ...
+def contains(a: Container[object], b: object, /) -> bool: ...
+def countOf(a: Iterable[object], b: object, /) -> int: ...
+@overload
+def delitem(a: MutableSequence[Any], b: SupportsIndex, /) -> None: ...
+@overload
+def delitem(a: MutableSequence[Any], b: slice, /) -> None: ...
+@overload
+def delitem(a: MutableMapping[_K, Any], b: _K, /) -> None: ...
+@overload
+def getitem(a: Sequence[_T], b: slice, /) -> Sequence[_T]: ...
+@overload
+def getitem(a: SupportsGetItem[_K, _V], b: _K, /) -> _V: ...
+def indexOf(a: Iterable[_T], b: _T, /) -> int: ...
 @overload
-def setitem(__a: MutableSequence[_T], __b: SupportsIndex, __c: _T) -> None: ...
+def setitem(a: MutableSequence[_T], b: SupportsIndex, c: _T, /) -> None: ...
 @overload
-def setitem(__a: MutableSequence[_T], __b: slice, __c: Sequence[_T]) -> None: ...
+def setitem(a: MutableSequence[_T], b: slice, c: Sequence[_T], /) -> None: ...
 @overload
-def setitem(__a: MutableMapping[_K, _V], __b: _K, __c: _V) -> None: ...
-def length_hint(__obj: object, __default: int = 0) -> int: ...
+def setitem(a: MutableMapping[_K, _V], b: _K, c: _V, /) -> None: ...
+def length_hint(obj: object, default: int = 0, /) -> int: ...
 @final
 class attrgetter(Generic[_T_co]):
     @overload
-    def __new__(cls, attr: str) -> attrgetter[Any]: ...
+    def __new__(cls, attr: str, /) -> attrgetter[Any]: ...
     @overload
-    def __new__(cls, attr: str, __attr2: str) -> attrgetter[tuple[Any, Any]]: ...
+    def __new__(cls, attr: str, attr2: str, /) -> attrgetter[tuple[Any, Any]]: ...
     @overload
-    def __new__(cls, attr: str, __attr2: str, __attr3: str) -> attrgetter[tuple[Any, Any, Any]]: ...
+    def __new__(cls, attr: str, attr2: str, attr3: str, /) -> attrgetter[tuple[Any, Any, Any]]: ...
     @overload
-    def __new__(cls, attr: str, __attr2: str, __attr3: str, __attr4: str) -> attrgetter[tuple[Any, Any, Any, Any]]: ...
+    def __new__(cls, attr: str, attr2: str, attr3: str, attr4: str, /) -> attrgetter[tuple[Any, Any, Any, Any]]: ...
     @overload
-    def __new__(cls, attr: str, *attrs: str) -> attrgetter[tuple[Any, ...]]: ...
-    def __call__(self, obj: Any) -> _T_co: ...
+    def __new__(cls, attr: str, /, *attrs: str) -> attrgetter[tuple[Any, ...]]: ...
+    def __call__(self, obj: Any, /) -> _T_co: ...
 
 @final
 class itemgetter(Generic[_T_co]):
     @overload
-    def __new__(cls, __item: _T) -> itemgetter[_T]: ...
+    def __new__(cls, item: _T, /) -> itemgetter[_T]: ...
     @overload
-    def __new__(cls, __item1: _T1, __item2: _T2, *items: Unpack[_Ts]) -> itemgetter[tuple[_T1, _T2, Unpack[_Ts]]]: ...
+    def __new__(cls, item1: _T1, item2: _T2, /, *items: Unpack[_Ts]) -> itemgetter[tuple[_T1, _T2, Unpack[_Ts]]]: ...
     # __key: _KT_contra in SupportsGetItem seems to be causing variance issues, ie:
     # TypeVar "_KT_contra@SupportsGetItem" is contravariant
     #   "tuple[int, int]" is incompatible with protocol "SupportsIndex"
     # preventing [_T_co, ...] instead of [Any, ...]
     #
     # A suspected mypy issue prevents using [..., _T] instead of [..., Any] here.
     # https://github.com/python/mypy/issues/14032
     def __call__(self, obj: SupportsGetItem[Any, Any]) -> Any: ...
 
 @final
 class methodcaller:
-    def __init__(self, __name: str, *args: Any, **kwargs: Any) -> None: ...
+    def __init__(self, name: str, /, *args: Any, **kwargs: Any) -> None: ...
     def __call__(self, obj: Any) -> Any: ...
 
-def iadd(__a: Any, __b: Any) -> Any: ...
-def iand(__a: Any, __b: Any) -> Any: ...
-def iconcat(__a: Any, __b: Any) -> Any: ...
-def ifloordiv(__a: Any, __b: Any) -> Any: ...
-def ilshift(__a: Any, __b: Any) -> Any: ...
-def imod(__a: Any, __b: Any) -> Any: ...
-def imul(__a: Any, __b: Any) -> Any: ...
-def imatmul(__a: Any, __b: Any) -> Any: ...
-def ior(__a: Any, __b: Any) -> Any: ...
-def ipow(__a: Any, __b: Any) -> Any: ...
-def irshift(__a: Any, __b: Any) -> Any: ...
-def isub(__a: Any, __b: Any) -> Any: ...
-def itruediv(__a: Any, __b: Any) -> Any: ...
-def ixor(__a: Any, __b: Any) -> Any: ...
+def iadd(a: Any, b: Any, /) -> Any: ...
+def iand(a: Any, b: Any, /) -> Any: ...
+def iconcat(a: Any, b: Any, /) -> Any: ...
+def ifloordiv(a: Any, b: Any, /) -> Any: ...
+def ilshift(a: Any, b: Any, /) -> Any: ...
+def imod(a: Any, b: Any, /) -> Any: ...
+def imul(a: Any, b: Any, /) -> Any: ...
+def imatmul(a: Any, b: Any, /) -> Any: ...
+def ior(a: Any, b: Any, /) -> Any: ...
+def ipow(a: Any, b: Any, /) -> Any: ...
+def irshift(a: Any, b: Any, /) -> Any: ...
+def isub(a: Any, b: Any, /) -> Any: ...
+def itruediv(a: Any, b: Any, /) -> Any: ...
+def ixor(a: Any, b: Any, /) -> Any: ...
 
 if sys.version_info >= (3, 11):
-    def call(__obj: Callable[_P, _R], *args: _P.args, **kwargs: _P.kwargs) -> _R: ...
+    def call(obj: Callable[_P, _R], /, *args: _P.args, **kwargs: _P.kwargs) -> _R: ...
 
-def _compare_digest(__a: AnyStr, __b: AnyStr) -> bool: ...
+def _compare_digest(a: AnyStr, b: AnyStr, /) -> bool: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_posixsubprocess.pyi

```diff
@@ -2,31 +2,32 @@
 from _typeshed import StrOrBytesPath
 from collections.abc import Callable, Sequence
 from typing import SupportsIndex
 
 if sys.platform != "win32":
     def cloexec_pipe() -> tuple[int, int]: ...
     def fork_exec(
-        __args: Sequence[StrOrBytesPath] | None,
-        __executable_list: Sequence[bytes],
-        __close_fds: bool,
-        __pass_fds: tuple[int, ...],
-        __cwd: str,
-        __env: Sequence[bytes] | None,
-        __p2cread: int,
-        __p2cwrite: int,
-        __c2pread: int,
-        __c2pwrite: int,
-        __errread: int,
-        __errwrite: int,
-        __errpipe_read: int,
-        __errpipe_write: int,
-        __restore_signals: int,
-        __call_setsid: int,
-        __pgid_to_set: int,
-        __gid: SupportsIndex | None,
-        __extra_groups: list[int] | None,
-        __uid: SupportsIndex | None,
-        __child_umask: int,
-        __preexec_fn: Callable[[], None],
-        __allow_vfork: bool,
+        args: Sequence[StrOrBytesPath] | None,
+        executable_list: Sequence[bytes],
+        close_fds: bool,
+        pass_fds: tuple[int, ...],
+        cwd: str,
+        env: Sequence[bytes] | None,
+        p2cread: int,
+        p2cwrite: int,
+        c2pread: int,
+        c2pwrite: int,
+        errread: int,
+        errwrite: int,
+        errpipe_read: int,
+        errpipe_write: int,
+        restore_signals: int,
+        call_setsid: int,
+        pgid_to_set: int,
+        gid: SupportsIndex | None,
+        extra_groups: list[int] | None,
+        uid: SupportsIndex | None,
+        child_umask: int,
+        preexec_fn: Callable[[], None],
+        allow_vfork: bool,
+        /,
     ) -> int: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_py_abc.pyi

```diff
@@ -5,10 +5,10 @@
 
 _CacheToken = NewType("_CacheToken", int)
 
 def get_cache_token() -> _CacheToken: ...
 
 class ABCMeta(type):
     def __new__(
-        __mcls: type[_typeshed.Self], __name: str, __bases: tuple[type[Any], ...], __namespace: dict[str, Any]
+        mcls: type[_typeshed.Self], name: str, bases: tuple[type[Any], ...], namespace: dict[str, Any], /
     ) -> _typeshed.Self: ...
     def register(cls, subclass: type[_T]) -> type[_T]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_random.pyi

```diff
@@ -1,12 +1,12 @@
 from typing_extensions import TypeAlias
 
 # Actually Tuple[(int,) * 625]
 _State: TypeAlias = tuple[int, ...]
 
 class Random:
     def __init__(self, seed: object = ...) -> None: ...
-    def seed(self, __n: object = None) -> None: ...
+    def seed(self, n: object = None, /) -> None: ...
     def getstate(self) -> _State: ...
-    def setstate(self, __state: _State) -> None: ...
+    def setstate(self, state: _State, /) -> None: ...
     def random(self) -> float: ...
-    def getrandbits(self, __k: int) -> int: ...
+    def getrandbits(self, k: int, /) -> int: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_socket.pyi

```diff
@@ -692,111 +692,112 @@
     if sys.platform == "win32":
         def __init__(
             self, family: int = ..., type: int = ..., proto: int = ..., fileno: SupportsIndex | bytes | None = ...
         ) -> None: ...
     else:
         def __init__(self, family: int = ..., type: int = ..., proto: int = ..., fileno: SupportsIndex | None = ...) -> None: ...
 
-    def bind(self, __address: _Address) -> None: ...
+    def bind(self, address: _Address, /) -> None: ...
     def close(self) -> None: ...
-    def connect(self, __address: _Address) -> None: ...
-    def connect_ex(self, __address: _Address) -> int: ...
+    def connect(self, address: _Address, /) -> None: ...
+    def connect_ex(self, address: _Address, /) -> int: ...
     def detach(self) -> int: ...
     def fileno(self) -> int: ...
     def getpeername(self) -> _RetAddress: ...
     def getsockname(self) -> _RetAddress: ...
     @overload
-    def getsockopt(self, __level: int, __optname: int) -> int: ...
+    def getsockopt(self, level: int, optname: int, /) -> int: ...
     @overload
-    def getsockopt(self, __level: int, __optname: int, __buflen: int) -> bytes: ...
+    def getsockopt(self, level: int, optname: int, buflen: int, /) -> bytes: ...
     def getblocking(self) -> bool: ...
     def gettimeout(self) -> float | None: ...
     if sys.platform == "win32":
-        def ioctl(self, __control: int, __option: int | tuple[int, int, int] | bool) -> None: ...
+        def ioctl(self, control: int, option: int | tuple[int, int, int] | bool, /) -> None: ...
 
-    def listen(self, __backlog: int = ...) -> None: ...
-    def recv(self, __bufsize: int, __flags: int = ...) -> bytes: ...
-    def recvfrom(self, __bufsize: int, __flags: int = ...) -> tuple[bytes, _RetAddress]: ...
+    def listen(self, backlog: int = ..., /) -> None: ...
+    def recv(self, bufsize: int, flags: int = ..., /) -> bytes: ...
+    def recvfrom(self, bufsize: int, flags: int = ..., /) -> tuple[bytes, _RetAddress]: ...
     if sys.platform != "win32":
-        def recvmsg(self, __bufsize: int, __ancbufsize: int = ..., __flags: int = ...) -> tuple[bytes, list[_CMSG], int, Any]: ...
+        def recvmsg(self, bufsize: int, ancbufsize: int = ..., flags: int = ..., /) -> tuple[bytes, list[_CMSG], int, Any]: ...
         def recvmsg_into(
-            self, __buffers: Iterable[WriteableBuffer], __ancbufsize: int = ..., __flags: int = ...
+            self, buffers: Iterable[WriteableBuffer], ancbufsize: int = ..., flags: int = ..., /
         ) -> tuple[int, list[_CMSG], int, Any]: ...
 
     def recvfrom_into(self, buffer: WriteableBuffer, nbytes: int = ..., flags: int = ...) -> tuple[int, _RetAddress]: ...
     def recv_into(self, buffer: WriteableBuffer, nbytes: int = ..., flags: int = ...) -> int: ...
-    def send(self, __data: ReadableBuffer, __flags: int = ...) -> int: ...
-    def sendall(self, __data: ReadableBuffer, __flags: int = ...) -> None: ...
+    def send(self, data: ReadableBuffer, flags: int = ..., /) -> int: ...
+    def sendall(self, data: ReadableBuffer, flags: int = ..., /) -> None: ...
     @overload
-    def sendto(self, __data: ReadableBuffer, __address: _Address) -> int: ...
+    def sendto(self, data: ReadableBuffer, address: _Address, /) -> int: ...
     @overload
-    def sendto(self, __data: ReadableBuffer, __flags: int, __address: _Address) -> int: ...
+    def sendto(self, data: ReadableBuffer, flags: int, address: _Address, /) -> int: ...
     if sys.platform != "win32":
         def sendmsg(
             self,
-            __buffers: Iterable[ReadableBuffer],
-            __ancdata: Iterable[_CMSGArg] = ...,
-            __flags: int = ...,
-            __address: _Address | None = ...,
+            buffers: Iterable[ReadableBuffer],
+            ancdata: Iterable[_CMSGArg] = ...,
+            flags: int = ...,
+            address: _Address | None = ...,
+            /,
         ) -> int: ...
     if sys.platform == "linux":
         def sendmsg_afalg(
             self, msg: Iterable[ReadableBuffer] = ..., *, op: int, iv: Any = ..., assoclen: int = ..., flags: int = ...
         ) -> int: ...
 
-    def setblocking(self, __flag: bool) -> None: ...
-    def settimeout(self, __value: float | None) -> None: ...
+    def setblocking(self, flag: bool, /) -> None: ...
+    def settimeout(self, value: float | None, /) -> None: ...
     @overload
-    def setsockopt(self, __level: int, __optname: int, __value: int | ReadableBuffer) -> None: ...
+    def setsockopt(self, level: int, optname: int, value: int | ReadableBuffer, /) -> None: ...
     @overload
-    def setsockopt(self, __level: int, __optname: int, __value: None, __optlen: int) -> None: ...
+    def setsockopt(self, level: int, optname: int, value: None, optlen: int, /) -> None: ...
     if sys.platform == "win32":
-        def share(self, __process_id: int) -> bytes: ...
+        def share(self, process_id: int, /) -> bytes: ...
 
-    def shutdown(self, __how: int) -> None: ...
+    def shutdown(self, how: int, /) -> None: ...
 
 SocketType = socket
 
 # ===== Functions =====
 
-def close(__fd: SupportsIndex) -> None: ...
-def dup(__fd: SupportsIndex) -> int: ...
+def close(fd: SupportsIndex, /) -> None: ...
+def dup(fd: SupportsIndex, /) -> int: ...
 
 # the 5th tuple item is an address
 def getaddrinfo(
     host: bytes | str | None,
     port: bytes | str | int | None,
     family: int = ...,
     type: int = ...,
     proto: int = ...,
     flags: int = ...,
 ) -> list[tuple[int, int, int, str, tuple[str, int] | tuple[str, int, int, int]]]: ...
-def gethostbyname(__hostname: str) -> str: ...
-def gethostbyname_ex(__hostname: str) -> tuple[str, list[str], list[str]]: ...
+def gethostbyname(hostname: str, /) -> str: ...
+def gethostbyname_ex(hostname: str, /) -> tuple[str, list[str], list[str]]: ...
 def gethostname() -> str: ...
-def gethostbyaddr(__ip_address: str) -> tuple[str, list[str], list[str]]: ...
-def getnameinfo(__sockaddr: tuple[str, int] | tuple[str, int, int, int], __flags: int) -> tuple[str, str]: ...
-def getprotobyname(__protocolname: str) -> int: ...
-def getservbyname(__servicename: str, __protocolname: str = ...) -> int: ...
-def getservbyport(__port: int, __protocolname: str = ...) -> str: ...
-def ntohl(__x: int) -> int: ...  # param & ret val are 32-bit ints
-def ntohs(__x: int) -> int: ...  # param & ret val are 16-bit ints
-def htonl(__x: int) -> int: ...  # param & ret val are 32-bit ints
-def htons(__x: int) -> int: ...  # param & ret val are 16-bit ints
-def inet_aton(__ip_string: str) -> bytes: ...  # ret val 4 bytes in length
-def inet_ntoa(__packed_ip: ReadableBuffer) -> str: ...
-def inet_pton(__address_family: int, __ip_string: str) -> bytes: ...
-def inet_ntop(__address_family: int, __packed_ip: ReadableBuffer) -> str: ...
+def gethostbyaddr(ip_address: str, /) -> tuple[str, list[str], list[str]]: ...
+def getnameinfo(sockaddr: tuple[str, int] | tuple[str, int, int, int], flags: int, /) -> tuple[str, str]: ...
+def getprotobyname(protocolname: str, /) -> int: ...
+def getservbyname(servicename: str, protocolname: str = ..., /) -> int: ...
+def getservbyport(port: int, protocolname: str = ..., /) -> str: ...
+def ntohl(x: int, /) -> int: ...  # param & ret val are 32-bit ints
+def ntohs(x: int, /) -> int: ...  # param & ret val are 16-bit ints
+def htonl(x: int, /) -> int: ...  # param & ret val are 32-bit ints
+def htons(x: int, /) -> int: ...  # param & ret val are 16-bit ints
+def inet_aton(ip_string: str, /) -> bytes: ...  # ret val 4 bytes in length
+def inet_ntoa(packed_ip: ReadableBuffer, /) -> str: ...
+def inet_pton(address_family: int, ip_string: str, /) -> bytes: ...
+def inet_ntop(address_family: int, packed_ip: ReadableBuffer, /) -> str: ...
 def getdefaulttimeout() -> float | None: ...
-def setdefaulttimeout(__timeout: float | None) -> None: ...
+def setdefaulttimeout(timeout: float | None, /) -> None: ...
 
 if sys.platform != "win32":
-    def sethostname(__name: str) -> None: ...
-    def CMSG_LEN(__length: int) -> int: ...
-    def CMSG_SPACE(__length: int) -> int: ...
-    def socketpair(__family: int = ..., __type: int = ..., __proto: int = ...) -> tuple[socket, socket]: ...
+    def sethostname(name: str, /) -> None: ...
+    def CMSG_LEN(length: int, /) -> int: ...
+    def CMSG_SPACE(length: int, /) -> int: ...
+    def socketpair(family: int = ..., type: int = ..., proto: int = ..., /) -> tuple[socket, socket]: ...
 
 def if_nameindex() -> list[tuple[int, str]]: ...
-def if_nametoindex(__name: str) -> int: ...
-def if_indextoname(__index: int) -> str: ...
+def if_nametoindex(name: str, /) -> int: ...
+def if_indextoname(index: int, /) -> str: ...
 
 CAPI: object
```

## puya/_vendor/mypy/typeshed/stdlib/_thread.pyi

```diff
@@ -1,41 +1,48 @@
 import sys
 from _typeshed import structseq
 from collections.abc import Callable
 from threading import Thread
 from types import TracebackType
-from typing import Any, Final, NoReturn, final
+from typing import Any, Final, NoReturn, final, overload
+from typing_extensions import TypeVarTuple, Unpack
+
+_Ts = TypeVarTuple("_Ts")
 
 error = RuntimeError
 
 def _count() -> int: ...
 @final
 class LockType:
     def acquire(self, blocking: bool = ..., timeout: float = ...) -> bool: ...
     def release(self) -> None: ...
     def locked(self) -> bool: ...
     def __enter__(self) -> bool: ...
     def __exit__(
         self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None
     ) -> None: ...
 
-def start_new_thread(function: Callable[..., object], args: tuple[Any, ...], kwargs: dict[str, Any] = ...) -> int: ...
+@overload
+def start_new_thread(function: Callable[[Unpack[_Ts]], object], args: tuple[Unpack[_Ts]]) -> int: ...
+@overload
+def start_new_thread(function: Callable[..., object], args: tuple[Any, ...], kwargs: dict[str, Any]) -> int: ...
 def interrupt_main() -> None: ...
 def exit() -> NoReturn: ...
 def allocate_lock() -> LockType: ...
 def get_ident() -> int: ...
 def stack_size(size: int = ...) -> int: ...
 
 TIMEOUT_MAX: float
 
 def get_native_id() -> int: ...  # only available on some platforms
 @final
 class _ExceptHookArgs(structseq[Any], tuple[type[BaseException], BaseException | None, TracebackType | None, Thread | None]):
     if sys.version_info >= (3, 10):
         __match_args__: Final = ("exc_type", "exc_value", "exc_traceback", "thread")
+
     @property
     def exc_type(self) -> type[BaseException]: ...
     @property
     def exc_value(self) -> BaseException | None: ...
     @property
     def exc_traceback(self) -> TracebackType | None: ...
     @property
@@ -43,10 +50,10 @@
 
 _excepthook: Callable[[_ExceptHookArgs], Any]
 
 if sys.version_info >= (3, 12):
     def daemon_threads_allowed() -> bool: ...
 
 class _local:
-    def __getattribute__(self, __name: str) -> Any: ...
-    def __setattr__(self, __name: str, __value: Any) -> None: ...
-    def __delattr__(self, __name: str) -> None: ...
+    def __getattribute__(self, name: str, /) -> Any: ...
+    def __setattr__(self, name: str, value: Any, /) -> None: ...
+    def __delattr__(self, name: str, /) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_tkinter.pyi

```diff
@@ -17,20 +17,20 @@
 @final
 class Tcl_Obj:
     @property
     def string(self) -> str: ...
     @property
     def typename(self) -> str: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
-    def __eq__(self, __value): ...
-    def __ge__(self, __value): ...
-    def __gt__(self, __value): ...
-    def __le__(self, __value): ...
-    def __lt__(self, __value): ...
-    def __ne__(self, __value): ...
+    def __eq__(self, value, /): ...
+    def __ge__(self, value, /): ...
+    def __gt__(self, value, /): ...
+    def __le__(self, value, /): ...
+    def __lt__(self, value, /): ...
+    def __ne__(self, value, /): ...
 
 class TclError(Exception): ...
 
 # This class allows running Tcl code. Tkinter uses it internally a lot, and
 # it's often handy to drop a piece of Tcl code into a tkinter program. Example:
 #
 #    >>> import tkinter, _tkinter
@@ -46,47 +46,47 @@
 # call args can be pretty much anything. Also, call(some_tuple) is same as call(*some_tuple).
 #
 # eval always returns str because _tkinter_tkapp_eval_impl in _tkinter.c calls
 # Tkapp_UnicodeResult, and it returns a string when it succeeds.
 @final
 class TkappType:
     # Please keep in sync with tkinter.Tk
-    def adderrorinfo(self, __msg): ...
-    def call(self, __command: Any, *args: Any) -> Any: ...
-    def createcommand(self, __name, __func): ...
+    def adderrorinfo(self, msg, /): ...
+    def call(self, command: Any, /, *args: Any) -> Any: ...
+    def createcommand(self, name, func, /): ...
     if sys.platform != "win32":
-        def createfilehandler(self, __file, __mask, __func): ...
-        def deletefilehandler(self, __file): ...
+        def createfilehandler(self, file, mask, func, /): ...
+        def deletefilehandler(self, file, /): ...
 
-    def createtimerhandler(self, __milliseconds, __func): ...
-    def deletecommand(self, __name): ...
-    def dooneevent(self, __flags: int = 0): ...
-    def eval(self, __script: str) -> str: ...
-    def evalfile(self, __fileName): ...
-    def exprboolean(self, __s): ...
-    def exprdouble(self, __s): ...
-    def exprlong(self, __s): ...
-    def exprstring(self, __s): ...
-    def getboolean(self, __arg): ...
-    def getdouble(self, __arg): ...
-    def getint(self, __arg): ...
+    def createtimerhandler(self, milliseconds, func, /): ...
+    def deletecommand(self, name, /): ...
+    def dooneevent(self, flags: int = 0, /): ...
+    def eval(self, script: str, /) -> str: ...
+    def evalfile(self, fileName, /): ...
+    def exprboolean(self, s, /): ...
+    def exprdouble(self, s, /): ...
+    def exprlong(self, s, /): ...
+    def exprstring(self, s, /): ...
+    def getboolean(self, arg, /): ...
+    def getdouble(self, arg, /): ...
+    def getint(self, arg, /): ...
     def getvar(self, *args, **kwargs): ...
     def globalgetvar(self, *args, **kwargs): ...
     def globalsetvar(self, *args, **kwargs): ...
     def globalunsetvar(self, *args, **kwargs): ...
     def interpaddr(self): ...
     def loadtk(self) -> None: ...
-    def mainloop(self, __threshold: int = 0): ...
+    def mainloop(self, threshold: int = 0, /): ...
     def quit(self): ...
-    def record(self, __script): ...
+    def record(self, script, /): ...
     def setvar(self, *ags, **kwargs): ...
     if sys.version_info < (3, 11):
-        def split(self, __arg): ...
+        def split(self, arg, /): ...
 
-    def splitlist(self, __arg): ...
+    def splitlist(self, arg, /): ...
     def unsetvar(self, *args, **kwargs): ...
     def wantobjects(self, *args, **kwargs): ...
     def willdispatch(self): ...
 
 # These should be kept in sync with tkinter.tix constants, except ALL_EVENTS which doesn't match TCL_ALL_EVENTS
 ALL_EVENTS: Literal[-3]
 FILE_EVENTS: Literal[8]
@@ -103,18 +103,19 @@
 TK_VERSION: str
 
 @final
 class TkttType:
     def deletetimerhandler(self): ...
 
 def create(
-    __screenName: str | None = None,
-    __baseName: str = "",
-    __className: str = "Tk",
-    __interactive: bool = False,
-    __wantobjects: bool = False,
-    __wantTk: bool = True,
-    __sync: bool = False,
-    __use: str | None = None,
+    screenName: str | None = None,
+    baseName: str = "",
+    className: str = "Tk",
+    interactive: bool = False,
+    wantobjects: bool = False,
+    wantTk: bool = True,
+    sync: bool = False,
+    use: str | None = None,
+    /,
 ): ...
 def getbusywaitinterval(): ...
-def setbusywaitinterval(__new_val): ...
+def setbusywaitinterval(new_val, /): ...
```

## puya/_vendor/mypy/typeshed/stdlib/_tracemalloc.pyi

```diff
@@ -1,17 +1,17 @@
 import sys
 from collections.abc import Sequence
 from tracemalloc import _FrameTuple, _TraceTuple
 
-def _get_object_traceback(__obj: object) -> Sequence[_FrameTuple] | None: ...
+def _get_object_traceback(obj: object, /) -> Sequence[_FrameTuple] | None: ...
 def _get_traces() -> Sequence[_TraceTuple]: ...
 def clear_traces() -> None: ...
 def get_traceback_limit() -> int: ...
 def get_traced_memory() -> tuple[int, int]: ...
 def get_tracemalloc_memory() -> int: ...
 def is_tracing() -> bool: ...
 
 if sys.version_info >= (3, 9):
     def reset_peak() -> None: ...
 
-def start(__nframe: int = 1) -> None: ...
+def start(nframe: int = 1, /) -> None: ...
 def stop() -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_typeshed/__init__.pyi

```diff
@@ -63,102 +63,102 @@
 # _SentinelType = NewType("_SentinelType", object)
 # sentinel: _SentinelType
 # def foo(x: int | None | _SentinelType = ...) -> None: ...
 sentinel: Any
 
 # stable
 class IdentityFunction(Protocol):
-    def __call__(self, __x: _T) -> _T: ...
+    def __call__(self, x: _T, /) -> _T: ...
 
 # stable
 class SupportsNext(Protocol[_T_co]):
     def __next__(self) -> _T_co: ...
 
 # stable
 class SupportsAnext(Protocol[_T_co]):
     def __anext__(self) -> Awaitable[_T_co]: ...
 
 # Comparison protocols
 
 class SupportsDunderLT(Protocol[_T_contra]):
-    def __lt__(self, __other: _T_contra) -> bool: ...
+    def __lt__(self, other: _T_contra, /) -> bool: ...
 
 class SupportsDunderGT(Protocol[_T_contra]):
-    def __gt__(self, __other: _T_contra) -> bool: ...
+    def __gt__(self, other: _T_contra, /) -> bool: ...
 
 class SupportsDunderLE(Protocol[_T_contra]):
-    def __le__(self, __other: _T_contra) -> bool: ...
+    def __le__(self, other: _T_contra, /) -> bool: ...
 
 class SupportsDunderGE(Protocol[_T_contra]):
-    def __ge__(self, __other: _T_contra) -> bool: ...
+    def __ge__(self, other: _T_contra, /) -> bool: ...
 
 class SupportsAllComparisons(
     SupportsDunderLT[Any], SupportsDunderGT[Any], SupportsDunderLE[Any], SupportsDunderGE[Any], Protocol
 ): ...
 
 SupportsRichComparison: TypeAlias = SupportsDunderLT[Any] | SupportsDunderGT[Any]
 SupportsRichComparisonT = TypeVar("SupportsRichComparisonT", bound=SupportsRichComparison)  # noqa: Y001
 
 # Dunder protocols
 
 class SupportsAdd(Protocol[_T_contra, _T_co]):
-    def __add__(self, __x: _T_contra) -> _T_co: ...
+    def __add__(self, x: _T_contra, /) -> _T_co: ...
 
 class SupportsRAdd(Protocol[_T_contra, _T_co]):
-    def __radd__(self, __x: _T_contra) -> _T_co: ...
+    def __radd__(self, x: _T_contra, /) -> _T_co: ...
 
 class SupportsSub(Protocol[_T_contra, _T_co]):
-    def __sub__(self, __x: _T_contra) -> _T_co: ...
+    def __sub__(self, x: _T_contra, /) -> _T_co: ...
 
 class SupportsRSub(Protocol[_T_contra, _T_co]):
-    def __rsub__(self, __x: _T_contra) -> _T_co: ...
+    def __rsub__(self, x: _T_contra, /) -> _T_co: ...
 
 class SupportsDivMod(Protocol[_T_contra, _T_co]):
-    def __divmod__(self, __other: _T_contra) -> _T_co: ...
+    def __divmod__(self, other: _T_contra, /) -> _T_co: ...
 
 class SupportsRDivMod(Protocol[_T_contra, _T_co]):
-    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...
+    def __rdivmod__(self, other: _T_contra, /) -> _T_co: ...
 
 # This protocol is generic over the iterator type, while Iterable is
 # generic over the type that is iterated over.
 class SupportsIter(Protocol[_T_co]):
     def __iter__(self) -> _T_co: ...
 
 # This protocol is generic over the iterator type, while AsyncIterable is
 # generic over the type that is iterated over.
 class SupportsAiter(Protocol[_T_co]):
     def __aiter__(self) -> _T_co: ...
 
 class SupportsLenAndGetItem(Protocol[_T_co]):
     def __len__(self) -> int: ...
-    def __getitem__(self, __k: int) -> _T_co: ...
+    def __getitem__(self, k: int, /) -> _T_co: ...
 
 class SupportsTrunc(Protocol):
     def __trunc__(self) -> int: ...
 
 # Mapping-like protocols
 
 # stable
 class SupportsItems(Protocol[_KT_co, _VT_co]):
     def items(self) -> AbstractSet[tuple[_KT_co, _VT_co]]: ...
 
 # stable
 class SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):
     def keys(self) -> Iterable[_KT]: ...
-    def __getitem__(self, __key: _KT) -> _VT_co: ...
+    def __getitem__(self, key: _KT, /) -> _VT_co: ...
 
 # stable
 class SupportsGetItem(Protocol[_KT_contra, _VT_co]):
-    def __contains__(self, __x: Any) -> bool: ...
-    def __getitem__(self, __key: _KT_contra) -> _VT_co: ...
+    def __contains__(self, x: Any, /) -> bool: ...
+    def __getitem__(self, key: _KT_contra, /) -> _VT_co: ...
 
 # stable
 class SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):
-    def __setitem__(self, __key: _KT_contra, __value: _VT) -> None: ...
-    def __delitem__(self, __key: _KT_contra) -> None: ...
+    def __setitem__(self, key: _KT_contra, value: _VT, /) -> None: ...
+    def __delitem__(self, key: _KT_contra, /) -> None: ...
 
 StrPath: TypeAlias = str | PathLike[str]  # stable
 BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable
 GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]
 StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  # stable
 
 OpenTextModeUpdating: TypeAlias = Literal[
@@ -234,27 +234,27 @@
 
 FileDescriptor: TypeAlias = int  # stable
 FileDescriptorLike: TypeAlias = int | HasFileno  # stable
 FileDescriptorOrPath: TypeAlias = int | StrOrBytesPath
 
 # stable
 class SupportsRead(Protocol[_T_co]):
-    def read(self, __length: int = ...) -> _T_co: ...
+    def read(self, length: int = ..., /) -> _T_co: ...
 
 # stable
 class SupportsReadline(Protocol[_T_co]):
-    def readline(self, __length: int = ...) -> _T_co: ...
+    def readline(self, length: int = ..., /) -> _T_co: ...
 
 # stable
 class SupportsNoArgReadline(Protocol[_T_co]):
     def readline(self) -> _T_co: ...
 
 # stable
 class SupportsWrite(Protocol[_T_contra]):
-    def write(self, __s: _T_contra) -> object: ...
+    def write(self, s: _T_contra, /) -> object: ...
 
 # stable
 class SupportsFlush(Protocol):
     def flush(self) -> object: ...
 
 # Unfortunately PEP 688 does not allow us to distinguish read-only
 # from writable buffers. We use these aliases for readability for now.
@@ -263,25 +263,25 @@
 ReadOnlyBuffer: TypeAlias = Buffer  # stable
 # Anything that implements the read-write buffer interface.
 WriteableBuffer: TypeAlias = Buffer
 # Same as WriteableBuffer, but also includes read-only buffer types (like bytes).
 ReadableBuffer: TypeAlias = Buffer  # stable
 
 class SliceableBuffer(Buffer, Protocol):
-    def __getitem__(self, __slice: slice) -> Sequence[int]: ...
+    def __getitem__(self, slice: slice, /) -> Sequence[int]: ...
 
 class IndexableBuffer(Buffer, Protocol):
-    def __getitem__(self, __i: int) -> int: ...
+    def __getitem__(self, i: int, /) -> int: ...
 
 class SupportsGetItemBuffer(SliceableBuffer, IndexableBuffer, Protocol):
-    def __contains__(self, __x: Any) -> bool: ...
+    def __contains__(self, x: Any, /) -> bool: ...
     @overload
-    def __getitem__(self, __slice: slice) -> Sequence[int]: ...
+    def __getitem__(self, slice: slice, /) -> Sequence[int]: ...
     @overload
-    def __getitem__(self, __i: int) -> int: ...
+    def __getitem__(self, i: int, /) -> int: ...
 
 class SizedBuffer(Sized, Buffer, Protocol): ...
 
 # for compatibility with third-party stubs that may use this
 _BufferWithLen: TypeAlias = SizedBuffer  # not stable  # noqa: Y047
 
 ExcInfo: TypeAlias = tuple[type[BaseException], BaseException, TracebackType]
```

## puya/_vendor/mypy/typeshed/stdlib/_typeshed/dbapi.pyi

```diff
@@ -19,19 +19,19 @@
 
 class DBAPICursor(Protocol):
     @property
     def description(self) -> Sequence[DBAPIColumnDescription] | None: ...
     @property
     def rowcount(self) -> int: ...
     # optional:
-    # def callproc(self, __procname: str, __parameters: Sequence[Any] = ...) -> Sequence[Any]: ...
+    # def callproc(self, procname: str, parameters: Sequence[Any] = ..., /) -> Sequence[Any]: ...
     def close(self) -> object: ...
-    def execute(self, __operation: str, __parameters: Sequence[Any] | Mapping[str, Any] = ...) -> object: ...
-    def executemany(self, __operation: str, __seq_of_parameters: Sequence[Sequence[Any]]) -> object: ...
+    def execute(self, operation: str, parameters: Sequence[Any] | Mapping[str, Any] = ..., /) -> object: ...
+    def executemany(self, operation: str, seq_of_parameters: Sequence[Sequence[Any]], /) -> object: ...
     def fetchone(self) -> Sequence[Any] | None: ...
-    def fetchmany(self, __size: int = ...) -> Sequence[Sequence[Any]]: ...
+    def fetchmany(self, size: int = ..., /) -> Sequence[Sequence[Any]]: ...
     def fetchall(self) -> Sequence[Sequence[Any]]: ...
     # optional:
     # def nextset(self) -> None | Literal[True]: ...
     arraysize: int
-    def setinputsizes(self, __sizes: Sequence[DBAPITypeCode | int | None]) -> object: ...
-    def setoutputsize(self, __size: int, __column: int = ...) -> object: ...
+    def setinputsizes(self, sizes: Sequence[DBAPITypeCode | int | None], /) -> object: ...
+    def setoutputsize(self, size: int, column: int = ..., /) -> object: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_typeshed/wsgi.pyi

```diff
@@ -7,38 +7,38 @@
 import sys
 from _typeshed import OptExcInfo
 from collections.abc import Callable, Iterable, Iterator
 from typing import Any, Protocol
 from typing_extensions import TypeAlias
 
 class _Readable(Protocol):
-    def read(self, __size: int = ...) -> bytes: ...
+    def read(self, size: int = ..., /) -> bytes: ...
     # Optional: def close(self) -> object: ...
 
 if sys.version_info >= (3, 11):
     from wsgiref.types import *
 else:
     # stable
     class StartResponse(Protocol):
         def __call__(
-            self, __status: str, __headers: list[tuple[str, str]], __exc_info: OptExcInfo | None = ...
+            self, status: str, headers: list[tuple[str, str]], exc_info: OptExcInfo | None = ..., /
         ) -> Callable[[bytes], object]: ...
 
     WSGIEnvironment: TypeAlias = dict[str, Any]  # stable
     WSGIApplication: TypeAlias = Callable[[WSGIEnvironment, StartResponse], Iterable[bytes]]  # stable
 
     # WSGI input streams per PEP 3333, stable
     class InputStream(Protocol):
-        def read(self, __size: int = ...) -> bytes: ...
-        def readline(self, __size: int = ...) -> bytes: ...
-        def readlines(self, __hint: int = ...) -> list[bytes]: ...
+        def read(self, size: int = ..., /) -> bytes: ...
+        def readline(self, size: int = ..., /) -> bytes: ...
+        def readlines(self, hint: int = ..., /) -> list[bytes]: ...
         def __iter__(self) -> Iterator[bytes]: ...
 
     # WSGI error streams per PEP 3333, stable
     class ErrorStream(Protocol):
         def flush(self) -> object: ...
-        def write(self, __s: str) -> object: ...
-        def writelines(self, __seq: list[str]) -> object: ...
+        def write(self, s: str, /) -> object: ...
+        def writelines(self, seq: list[str], /) -> object: ...
 
     # Optional file wrapper in wsgi.file_wrapper
     class FileWrapper(Protocol):
-        def __call__(self, __file: _Readable, __block_size: int = ...) -> Iterable[bytes]: ...
+        def __call__(self, file: _Readable, block_size: int = ..., /) -> Iterable[bytes]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_typeshed/xml.pyi

```diff
@@ -1,9 +1,9 @@
 # See the README.md file in this directory for more information.
 
 from typing import Any, Protocol
 
 # As defined https://docs.python.org/3/library/xml.dom.html#domimplementation-objects
 class DOMImplementation(Protocol):
-    def hasFeature(self, __feature: str, __version: str | None) -> bool: ...
-    def createDocument(self, __namespaceUri: str, __qualifiedName: str, __doctype: Any | None) -> Any: ...
-    def createDocumentType(self, __qualifiedName: str, __publicId: str, __systemId: str) -> Any: ...
+    def hasFeature(self, feature: str, version: str | None, /) -> bool: ...
+    def createDocument(self, namespaceUri: str, qualifiedName: str, doctype: Any | None, /) -> Any: ...
+    def createDocumentType(self, qualifiedName: str, publicId: str, systemId: str, /) -> Any: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_weakref.pyi

```diff
@@ -7,35 +7,35 @@
     from types import GenericAlias
 
 _C = TypeVar("_C", bound=Callable[..., Any])
 _T = TypeVar("_T")
 
 @final
 class CallableProxyType(Generic[_C]):  # "weakcallableproxy"
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __getattr__(self, attr: str) -> Any: ...
     __call__: _C
 
 @final
 class ProxyType(Generic[_T]):  # "weakproxy"
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __getattr__(self, attr: str) -> Any: ...
 
 class ReferenceType(Generic[_T]):
     __callback__: Callable[[ReferenceType[_T]], Any]
-    def __new__(cls, __o: _T, __callback: Callable[[ReferenceType[_T]], Any] | None = ...) -> Self: ...
+    def __new__(cls, o: _T, callback: Callable[[ReferenceType[_T]], Any] | None = ..., /) -> Self: ...
     def __call__(self) -> _T | None: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 ref = ReferenceType
 
-def getweakrefcount(__object: Any) -> int: ...
-def getweakrefs(__object: Any) -> list[Any]: ...
+def getweakrefcount(object: Any, /) -> int: ...
+def getweakrefs(object: Any, /) -> list[Any]: ...
 
 # Return CallableProxyType if object is callable, ProxyType otherwise
 @overload
-def proxy(__object: _C, __callback: Callable[[_C], Any] | None = None) -> CallableProxyType[_C]: ...
+def proxy(object: _C, callback: Callable[[_C], Any] | None = None, /) -> CallableProxyType[_C]: ...
 @overload
-def proxy(__object: _T, __callback: Callable[[_T], Any] | None = None) -> Any: ...
+def proxy(object: _T, callback: Callable[[_T], Any] | None = None, /) -> Any: ...
```

## puya/_vendor/mypy/typeshed/stdlib/_winapi.pyi

```diff
@@ -154,98 +154,102 @@
         COPY_FILE_RESUME_FROM_PAUSE: Literal[0x4000]
         COPY_FILE_NO_OFFLOAD: Literal[0x40000]
         COPY_FILE_REQUEST_COMPRESSED_TRAFFIC: Literal[0x10000000]
 
         ERROR_ACCESS_DENIED: Literal[5]
         ERROR_PRIVILEGE_NOT_HELD: Literal[1314]
 
-    def CloseHandle(__handle: int) -> None: ...
+    def CloseHandle(handle: int, /) -> None: ...
     @overload
     def ConnectNamedPipe(handle: int, overlapped: Literal[True]) -> Overlapped: ...
     @overload
     def ConnectNamedPipe(handle: int, overlapped: Literal[False] = False) -> None: ...
     @overload
     def ConnectNamedPipe(handle: int, overlapped: bool) -> Overlapped | None: ...
     def CreateFile(
-        __file_name: str,
-        __desired_access: int,
-        __share_mode: int,
-        __security_attributes: int,
-        __creation_disposition: int,
-        __flags_and_attributes: int,
-        __template_file: int,
+        file_name: str,
+        desired_access: int,
+        share_mode: int,
+        security_attributes: int,
+        creation_disposition: int,
+        flags_and_attributes: int,
+        template_file: int,
+        /,
     ) -> int: ...
-    def CreateJunction(__src_path: str, __dst_path: str) -> None: ...
+    def CreateJunction(src_path: str, dst_path: str, /) -> None: ...
     def CreateNamedPipe(
-        __name: str,
-        __open_mode: int,
-        __pipe_mode: int,
-        __max_instances: int,
-        __out_buffer_size: int,
-        __in_buffer_size: int,
-        __default_timeout: int,
-        __security_attributes: int,
+        name: str,
+        open_mode: int,
+        pipe_mode: int,
+        max_instances: int,
+        out_buffer_size: int,
+        in_buffer_size: int,
+        default_timeout: int,
+        security_attributes: int,
+        /,
     ) -> int: ...
-    def CreatePipe(__pipe_attrs: Any, __size: int) -> tuple[int, int]: ...
+    def CreatePipe(pipe_attrs: Any, size: int, /) -> tuple[int, int]: ...
     def CreateProcess(
-        __application_name: str | None,
-        __command_line: str | None,
-        __proc_attrs: Any,
-        __thread_attrs: Any,
-        __inherit_handles: bool,
-        __creation_flags: int,
-        __env_mapping: dict[str, str],
-        __current_directory: str | None,
-        __startup_info: Any,
+        application_name: str | None,
+        command_line: str | None,
+        proc_attrs: Any,
+        thread_attrs: Any,
+        inherit_handles: bool,
+        creation_flags: int,
+        env_mapping: dict[str, str],
+        current_directory: str | None,
+        startup_info: Any,
+        /,
     ) -> tuple[int, int, int, int]: ...
     def DuplicateHandle(
-        __source_process_handle: int,
-        __source_handle: int,
-        __target_process_handle: int,
-        __desired_access: int,
-        __inherit_handle: bool,
-        __options: int = 0,
+        source_process_handle: int,
+        source_handle: int,
+        target_process_handle: int,
+        desired_access: int,
+        inherit_handle: bool,
+        options: int = 0,
+        /,
     ) -> int: ...
-    def ExitProcess(__ExitCode: int) -> NoReturn: ...
+    def ExitProcess(ExitCode: int, /) -> NoReturn: ...
     def GetACP() -> int: ...
     def GetFileType(handle: int) -> int: ...
     def GetCurrentProcess() -> int: ...
-    def GetExitCodeProcess(__process: int) -> int: ...
+    def GetExitCodeProcess(process: int, /) -> int: ...
     def GetLastError() -> int: ...
-    def GetModuleFileName(__module_handle: int) -> str: ...
-    def GetStdHandle(__std_handle: int) -> int: ...
+    def GetModuleFileName(module_handle: int, /) -> str: ...
+    def GetStdHandle(std_handle: int, /) -> int: ...
     def GetVersion() -> int: ...
-    def OpenProcess(__desired_access: int, __inherit_handle: bool, __process_id: int) -> int: ...
-    def PeekNamedPipe(__handle: int, __size: int = 0) -> tuple[int, int] | tuple[bytes, int, int]: ...
+    def OpenProcess(desired_access: int, inherit_handle: bool, process_id: int, /) -> int: ...
+    def PeekNamedPipe(handle: int, size: int = 0, /) -> tuple[int, int] | tuple[bytes, int, int]: ...
     if sys.version_info >= (3, 10):
         def LCMapStringEx(locale: str, flags: int, src: str) -> str: ...
-        def UnmapViewOfFile(__address: int) -> None: ...
+        def UnmapViewOfFile(address: int, /) -> None: ...
 
     @overload
     def ReadFile(handle: int, size: int, overlapped: Literal[True]) -> tuple[Overlapped, int]: ...
     @overload
     def ReadFile(handle: int, size: int, overlapped: Literal[False] = False) -> tuple[bytes, int]: ...
     @overload
     def ReadFile(handle: int, size: int, overlapped: int | bool) -> tuple[Any, int]: ...
     def SetNamedPipeHandleState(
-        __named_pipe: int, __mode: int | None, __max_collection_count: int | None, __collect_data_timeout: int | None
+        named_pipe: int, mode: int | None, max_collection_count: int | None, collect_data_timeout: int | None, /
     ) -> None: ...
-    def TerminateProcess(__handle: int, __exit_code: int) -> None: ...
-    def WaitForMultipleObjects(__handle_seq: Sequence[int], __wait_flag: bool, __milliseconds: int = 0xFFFFFFFF) -> int: ...
-    def WaitForSingleObject(__handle: int, __milliseconds: int) -> int: ...
-    def WaitNamedPipe(__name: str, __timeout: int) -> None: ...
+    def TerminateProcess(handle: int, exit_code: int, /) -> None: ...
+    def WaitForMultipleObjects(handle_seq: Sequence[int], wait_flag: bool, milliseconds: int = 0xFFFFFFFF, /) -> int: ...
+    def WaitForSingleObject(handle: int, milliseconds: int, /) -> int: ...
+    def WaitNamedPipe(name: str, timeout: int, /) -> None: ...
     @overload
     def WriteFile(handle: int, buffer: ReadableBuffer, overlapped: Literal[True]) -> tuple[Overlapped, int]: ...
     @overload
     def WriteFile(handle: int, buffer: ReadableBuffer, overlapped: Literal[False] = False) -> tuple[int, int]: ...
     @overload
     def WriteFile(handle: int, buffer: ReadableBuffer, overlapped: int | bool) -> tuple[Any, int]: ...
     @final
     class Overlapped:
         event: int
-        def GetOverlappedResult(self, __wait: bool) -> tuple[int, int]: ...
+        def GetOverlappedResult(self, wait: bool, /) -> tuple[int, int]: ...
         def cancel(self) -> None: ...
         def getbuffer(self) -> bytes | None: ...
 
     if sys.version_info >= (3, 12):
         def CopyFile2(existing_file_name: str, new_file_name: str, flags: int, progress_routine: int | None = None) -> int: ...
-        def NeedCurrentDirectoryForExePath(__exe_name: str) -> bool: ...
+        def NeedCurrentDirectoryForExePath(exe_name: str, /) -> bool: ...
```

## puya/_vendor/mypy/typeshed/stdlib/abc.pyi

```diff
@@ -1,46 +1,48 @@
 import _typeshed
 import sys
 from _typeshed import SupportsWrite
 from collections.abc import Callable
 from typing import Any, Literal, TypeVar
-from typing_extensions import Concatenate, ParamSpec
+from typing_extensions import Concatenate, ParamSpec, deprecated
 
 _T = TypeVar("_T")
 _R_co = TypeVar("_R_co", covariant=True)
 _FuncT = TypeVar("_FuncT", bound=Callable[..., Any])
 _P = ParamSpec("_P")
 
 # These definitions have special processing in mypy
 class ABCMeta(type):
     __abstractmethods__: frozenset[str]
     if sys.version_info >= (3, 11):
         def __new__(
-            __mcls: type[_typeshed.Self], __name: str, __bases: tuple[type, ...], __namespace: dict[str, Any], **kwargs: Any
+            mcls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], /, **kwargs: Any
         ) -> _typeshed.Self: ...
     else:
         def __new__(
             mcls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], **kwargs: Any
         ) -> _typeshed.Self: ...
 
     def __instancecheck__(cls: ABCMeta, instance: Any) -> bool: ...
     def __subclasscheck__(cls: ABCMeta, subclass: type) -> bool: ...
     def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = None) -> None: ...
     def register(cls: ABCMeta, subclass: type[_T]) -> type[_T]: ...
 
 def abstractmethod(funcobj: _FuncT) -> _FuncT: ...
-
+@deprecated("Deprecated, use 'classmethod' with 'abstractmethod' instead")
 class abstractclassmethod(classmethod[_T, _P, _R_co]):
     __isabstractmethod__: Literal[True]
     def __init__(self, callable: Callable[Concatenate[type[_T], _P], _R_co]) -> None: ...
 
+@deprecated("Deprecated, use 'staticmethod' with 'abstractmethod' instead")
 class abstractstaticmethod(staticmethod[_P, _R_co]):
     __isabstractmethod__: Literal[True]
     def __init__(self, callable: Callable[_P, _R_co]) -> None: ...
 
+@deprecated("Deprecated, use 'property' with 'abstractmethod' instead")
 class abstractproperty(property):
     __isabstractmethod__: Literal[True]
 
 class ABC(metaclass=ABCMeta):
     __slots__ = ()
 
 def get_cache_token() -> object: ...
```

## puya/_vendor/mypy/typeshed/stdlib/argparse.pyi

```diff
@@ -1,13 +1,13 @@
 import sys
 from _typeshed import sentinel
 from collections.abc import Callable, Generator, Iterable, Sequence
 from re import Pattern
 from typing import IO, Any, Generic, Literal, NewType, NoReturn, Protocol, TypeVar, overload
-from typing_extensions import Self, TypeAlias
+from typing_extensions import Self, TypeAlias, deprecated
 
 __all__ = [
     "ArgumentParser",
     "ArgumentError",
     "ArgumentTypeError",
     "FileType",
     "HelpFormatter",
@@ -335,44 +335,68 @@
         self, parser: ArgumentParser, namespace: Namespace, values: str | Sequence[Any] | None, option_string: str | None = None
     ) -> None: ...
     if sys.version_info >= (3, 9):
         def format_usage(self) -> str: ...
 
 if sys.version_info >= (3, 12):
     class BooleanOptionalAction(Action):
+        @overload
         def __init__(
             self,
             option_strings: Sequence[str],
             dest: str,
-            default: _T | str | None = None,
+            default: bool | None = None,
+            *,
+            required: bool = False,
+            help: str | None = None,
+        ) -> None: ...
+        @overload
+        @deprecated("The `type`, `choices`, and `metavar` parameters are ignored and will be removed in Python 3.14.")
+        def __init__(
+            self,
+            option_strings: Sequence[str],
+            dest: str,
+            default: _T | bool | None = None,
             type: Callable[[str], _T] | FileType | None = sentinel,
             choices: Iterable[_T] | None = sentinel,
             required: bool = False,
             help: str | None = None,
             metavar: str | tuple[str, ...] | None = sentinel,
         ) -> None: ...
 
 elif sys.version_info >= (3, 9):
     class BooleanOptionalAction(Action):
+        @overload
+        def __init__(
+            self,
+            option_strings: Sequence[str],
+            dest: str,
+            default: bool | None = None,
+            *,
+            required: bool = False,
+            help: str | None = None,
+        ) -> None: ...
+        @overload
+        @deprecated("The `type`, `choices`, and `metavar` parameters are ignored and will be removed in Python 3.14.")
         def __init__(
             self,
             option_strings: Sequence[str],
             dest: str,
-            default: _T | str | None = None,
+            default: _T | bool | None = None,
             type: Callable[[str], _T] | FileType | None = None,
             choices: Iterable[_T] | None = None,
             required: bool = False,
             help: str | None = None,
             metavar: str | tuple[str, ...] | None = None,
         ) -> None: ...
 
 class Namespace(_AttributeHolder):
     def __init__(self, **kwargs: Any) -> None: ...
     def __getattr__(self, name: str) -> Any: ...
-    def __setattr__(self, __name: str, __value: Any) -> None: ...
+    def __setattr__(self, name: str, value: Any, /) -> None: ...
     def __contains__(self, key: str) -> bool: ...
     def __eq__(self, other: object) -> bool: ...
 
 class FileType:
     # undocumented
     _mode: str
     _bufsize: int
```

## puya/_vendor/mypy/typeshed/stdlib/array.pyi

```diff
@@ -20,73 +20,73 @@
 
 class array(MutableSequence[_T]):
     @property
     def typecode(self) -> _TypeCode: ...
     @property
     def itemsize(self) -> int: ...
     @overload
-    def __init__(self: array[int], __typecode: _IntTypeCode, __initializer: bytes | bytearray | Iterable[int] = ...) -> None: ...
+    def __init__(self: array[int], typecode: _IntTypeCode, initializer: bytes | bytearray | Iterable[int] = ..., /) -> None: ...
     @overload
     def __init__(
-        self: array[float], __typecode: _FloatTypeCode, __initializer: bytes | bytearray | Iterable[float] = ...
+        self: array[float], typecode: _FloatTypeCode, initializer: bytes | bytearray | Iterable[float] = ..., /
     ) -> None: ...
     @overload
     def __init__(
-        self: array[str], __typecode: _UnicodeTypeCode, __initializer: bytes | bytearray | Iterable[str] = ...
+        self: array[str], typecode: _UnicodeTypeCode, initializer: bytes | bytearray | Iterable[str] = ..., /
     ) -> None: ...
     @overload
-    def __init__(self, __typecode: str, __initializer: Iterable[_T]) -> None: ...
+    def __init__(self, typecode: str, initializer: Iterable[_T], /) -> None: ...
     @overload
-    def __init__(self, __typecode: str, __initializer: bytes | bytearray = ...) -> None: ...
-    def append(self, __v: _T) -> None: ...
+    def __init__(self, typecode: str, initializer: bytes | bytearray = ..., /) -> None: ...
+    def append(self, v: _T, /) -> None: ...
     def buffer_info(self) -> tuple[int, int]: ...
     def byteswap(self) -> None: ...
-    def count(self, __v: _T) -> int: ...
-    def extend(self, __bb: Iterable[_T]) -> None: ...
-    def frombytes(self, __buffer: ReadableBuffer) -> None: ...
-    def fromfile(self, __f: SupportsRead[bytes], __n: int) -> None: ...
-    def fromlist(self, __list: list[_T]) -> None: ...
-    def fromunicode(self, __ustr: str) -> None: ...
+    def count(self, v: _T, /) -> int: ...
+    def extend(self, bb: Iterable[_T], /) -> None: ...
+    def frombytes(self, buffer: ReadableBuffer, /) -> None: ...
+    def fromfile(self, f: SupportsRead[bytes], n: int, /) -> None: ...
+    def fromlist(self, list: list[_T], /) -> None: ...
+    def fromunicode(self, ustr: str, /) -> None: ...
     if sys.version_info >= (3, 10):
-        def index(self, __v: _T, __start: int = 0, __stop: int = sys.maxsize) -> int: ...
+        def index(self, v: _T, start: int = 0, stop: int = sys.maxsize, /) -> int: ...
     else:
-        def index(self, __v: _T) -> int: ...  # type: ignore[override]
+        def index(self, v: _T, /) -> int: ...  # type: ignore[override]
 
-    def insert(self, __i: int, __v: _T) -> None: ...
-    def pop(self, __i: int = -1) -> _T: ...
-    def remove(self, __v: _T) -> None: ...
+    def insert(self, i: int, v: _T, /) -> None: ...
+    def pop(self, i: int = -1, /) -> _T: ...
+    def remove(self, v: _T, /) -> None: ...
     def tobytes(self) -> bytes: ...
-    def tofile(self, __f: SupportsWrite[bytes]) -> None: ...
+    def tofile(self, f: SupportsWrite[bytes], /) -> None: ...
     def tolist(self) -> list[_T]: ...
     def tounicode(self) -> str: ...
     if sys.version_info < (3, 9):
-        def fromstring(self, __buffer: str | ReadableBuffer) -> None: ...
+        def fromstring(self, buffer: str | ReadableBuffer, /) -> None: ...
         def tostring(self) -> bytes: ...
 
     def __len__(self) -> int: ...
     @overload
-    def __getitem__(self, __key: SupportsIndex) -> _T: ...
+    def __getitem__(self, key: SupportsIndex, /) -> _T: ...
     @overload
-    def __getitem__(self, __key: slice) -> array[_T]: ...
+    def __getitem__(self, key: slice, /) -> array[_T]: ...
     @overload  # type: ignore[override]
-    def __setitem__(self, __key: SupportsIndex, __value: _T) -> None: ...
+    def __setitem__(self, key: SupportsIndex, value: _T, /) -> None: ...
     @overload
-    def __setitem__(self, __key: slice, __value: array[_T]) -> None: ...
-    def __delitem__(self, __key: SupportsIndex | slice) -> None: ...
-    def __add__(self, __value: array[_T]) -> array[_T]: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ge__(self, __value: array[_T]) -> bool: ...
-    def __gt__(self, __value: array[_T]) -> bool: ...
-    def __iadd__(self, __value: array[_T]) -> Self: ...  # type: ignore[override]
-    def __imul__(self, __value: int) -> Self: ...
-    def __le__(self, __value: array[_T]) -> bool: ...
-    def __lt__(self, __value: array[_T]) -> bool: ...
-    def __mul__(self, __value: int) -> array[_T]: ...
-    def __rmul__(self, __value: int) -> array[_T]: ...
+    def __setitem__(self, key: slice, value: array[_T], /) -> None: ...
+    def __delitem__(self, key: SupportsIndex | slice, /) -> None: ...
+    def __add__(self, value: array[_T], /) -> array[_T]: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ge__(self, value: array[_T], /) -> bool: ...
+    def __gt__(self, value: array[_T], /) -> bool: ...
+    def __iadd__(self, value: array[_T], /) -> Self: ...  # type: ignore[override]
+    def __imul__(self, value: int, /) -> Self: ...
+    def __le__(self, value: array[_T], /) -> bool: ...
+    def __lt__(self, value: array[_T], /) -> bool: ...
+    def __mul__(self, value: int, /) -> array[_T]: ...
+    def __rmul__(self, value: int, /) -> array[_T]: ...
     def __copy__(self) -> array[_T]: ...
-    def __deepcopy__(self, __unused: Any) -> array[_T]: ...
-    def __buffer__(self, __flags: int) -> memoryview: ...
-    def __release_buffer__(self, __buffer: memoryview) -> None: ...
+    def __deepcopy__(self, unused: Any, /) -> array[_T]: ...
+    def __buffer__(self, flags: int, /) -> memoryview: ...
+    def __release_buffer__(self, buffer: memoryview, /) -> None: ...
     if sys.version_info >= (3, 12):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 ArrayType = array
```

## puya/_vendor/mypy/typeshed/stdlib/asyncio/events.pyi

```diff
@@ -39,17 +39,15 @@
 _ProtocolT = TypeVar("_ProtocolT", bound=BaseProtocol)
 _Context: TypeAlias = dict[str, Any]
 _ExceptionHandler: TypeAlias = Callable[[AbstractEventLoop, _Context], object]
 _ProtocolFactory: TypeAlias = Callable[[], BaseProtocol]
 _SSLContext: TypeAlias = bool | None | ssl.SSLContext
 
 class _TaskFactory(Protocol):
-    def __call__(
-        self, __loop: AbstractEventLoop, __factory: Coroutine[Any, Any, _T] | Generator[Any, None, _T]
-    ) -> Future[_T]: ...
+    def __call__(self, loop: AbstractEventLoop, factory: Coroutine[Any, Any, _T] | Generator[Any, None, _T], /) -> Future[_T]: ...
 
 class Handle:
     _cancelled: bool
     _args: Sequence[Any]
     def __init__(
         self, callback: Callable[..., object], args: Sequence[Any], loop: AbstractEventLoop, context: Context | None = None
     ) -> None: ...
@@ -539,18 +537,26 @@
     @abstractmethod
     def get_event_loop(self) -> AbstractEventLoop: ...
     @abstractmethod
     def set_event_loop(self, loop: AbstractEventLoop | None) -> None: ...
     @abstractmethod
     def new_event_loop(self) -> AbstractEventLoop: ...
     # Child processes handling (Unix only).
-    @abstractmethod
-    def get_child_watcher(self) -> AbstractChildWatcher: ...
-    @abstractmethod
-    def set_child_watcher(self, watcher: AbstractChildWatcher) -> None: ...
+    if sys.version_info >= (3, 12):
+        @abstractmethod
+        @deprecated("Deprecated as of Python 3.12; will be removed in Python 3.14")
+        def get_child_watcher(self) -> AbstractChildWatcher: ...
+        @abstractmethod
+        @deprecated("Deprecated as of Python 3.12; will be removed in Python 3.14")
+        def set_child_watcher(self, watcher: AbstractChildWatcher) -> None: ...
+    else:
+        @abstractmethod
+        def get_child_watcher(self) -> AbstractChildWatcher: ...
+        @abstractmethod
+        def set_child_watcher(self, watcher: AbstractChildWatcher) -> None: ...
 
 class BaseDefaultEventLoopPolicy(AbstractEventLoopPolicy, metaclass=ABCMeta):
     def get_event_loop(self) -> AbstractEventLoop: ...
     def set_event_loop(self, loop: AbstractEventLoop | None) -> None: ...
     def new_event_loop(self) -> AbstractEventLoop: ...
 
 def get_event_loop_policy() -> AbstractEventLoopPolicy: ...
@@ -565,10 +571,10 @@
     @deprecated("Deprecated as of Python 3.12; will be removed in Python 3.14")
     def set_child_watcher(watcher: AbstractChildWatcher) -> None: ...
 
 else:
     def get_child_watcher() -> AbstractChildWatcher: ...
     def set_child_watcher(watcher: AbstractChildWatcher) -> None: ...
 
-def _set_running_loop(__loop: AbstractEventLoop | None) -> None: ...
+def _set_running_loop(loop: AbstractEventLoop | None, /) -> None: ...
 def _get_running_loop() -> AbstractEventLoop: ...
 def get_running_loop() -> AbstractEventLoop: ...
```

## puya/_vendor/mypy/typeshed/stdlib/asyncio/futures.pyi

```diff
@@ -30,27 +30,27 @@
     def _log_traceback(self, val: Literal[False]) -> None: ...
     _asyncio_future_blocking: bool  # is a part of duck-typing contract for `Future`
     def __init__(self, *, loop: AbstractEventLoop | None = ...) -> None: ...
     def __del__(self) -> None: ...
     def get_loop(self) -> AbstractEventLoop: ...
     @property
     def _callbacks(self) -> list[tuple[Callable[[Self], Any], Context]]: ...
-    def add_done_callback(self, __fn: Callable[[Self], object], *, context: Context | None = None) -> None: ...
+    def add_done_callback(self, fn: Callable[[Self], object], /, *, context: Context | None = None) -> None: ...
     if sys.version_info >= (3, 9):
         def cancel(self, msg: Any | None = None) -> bool: ...
     else:
         def cancel(self) -> bool: ...
 
     def cancelled(self) -> bool: ...
     def done(self) -> bool: ...
     def result(self) -> _T: ...
     def exception(self) -> BaseException | None: ...
-    def remove_done_callback(self, __fn: Callable[[Self], object]) -> int: ...
-    def set_result(self, __result: _T) -> None: ...
-    def set_exception(self, __exception: type | BaseException) -> None: ...
+    def remove_done_callback(self, fn: Callable[[Self], object], /) -> int: ...
+    def set_result(self, result: _T, /) -> None: ...
+    def set_exception(self, exception: type | BaseException, /) -> None: ...
     def __iter__(self) -> Generator[Any, None, _T]: ...
     def __await__(self) -> Generator[Any, None, _T]: ...
     @property
     def _loop(self) -> AbstractEventLoop: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
```

## puya/_vendor/mypy/typeshed/stdlib/asyncio/sslproto.pyi

```diff
@@ -21,14 +21,15 @@
         SHUTDOWN: str
 
     class AppProtocolState(Enum):
         STATE_INIT: str
         STATE_CON_MADE: str
         STATE_EOF: str
         STATE_CON_LOST: str
+
     def add_flowcontrol_defaults(high: int | None, low: int | None, kb: int) -> tuple[int, int]: ...
 
 else:
     _UNWRAPPED: Literal["UNWRAPPED"]
     _DO_HANDSHAKE: Literal["DO_HANDSHAKE"]
     _WRAPPED: Literal["WRAPPED"]
     _SHUTDOWN: Literal["SHUTDOWN"]
@@ -151,13 +152,14 @@
     else:
         def _write_appdata(self, data: bytes) -> None: ...
 
     def _start_handshake(self) -> None: ...
     def _check_handshake_timeout(self) -> None: ...
     def _on_handshake_complete(self, handshake_exc: BaseException | None) -> None: ...
     def _fatal_error(self, exc: BaseException, message: str = "Fatal error on transport") -> None: ...
-    def _abort(self) -> None: ...
     if sys.version_info >= (3, 11):
+        def _abort(self, exc: BaseException | None) -> None: ...
         def get_buffer(self, n: int) -> memoryview: ...
     else:
+        def _abort(self) -> None: ...
         def _finalize(self) -> None: ...
         def _process_write_backlog(self) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/asyncio/streams.pyi

```diff
@@ -1,12 +1,12 @@
 import ssl
 import sys
-from _typeshed import StrPath
-from collections.abc import AsyncIterator, Awaitable, Callable, Iterable, Sequence
-from typing import Any, SupportsIndex
+from _typeshed import ReadableBuffer, StrPath
+from collections.abc import AsyncIterator, Awaitable, Callable, Iterable, Sequence, Sized
+from typing import Any, Protocol, SupportsIndex
 from typing_extensions import Self, TypeAlias
 
 from . import events, protocols, transports
 from .base_events import Server
 
 if sys.platform == "win32":
     __all__ = ("StreamReader", "StreamWriter", "StreamReaderProtocol", "open_connection", "start_server")
@@ -19,14 +19,16 @@
         "start_server",
         "open_unix_connection",
         "start_unix_server",
     )
 
 _ClientConnectedCallback: TypeAlias = Callable[[StreamReader, StreamWriter], Awaitable[None] | None]
 
+class _ReaduntilBuffer(ReadableBuffer, Sized, Protocol): ...
+
 if sys.version_info >= (3, 10):
     async def open_connection(
         host: str | None = None,
         port: int | str | None = None,
         *,
         limit: int = 65536,
         ssl_handshake_timeout: float | None = ...,
@@ -136,13 +138,16 @@
     def exception(self) -> Exception: ...
     def set_exception(self, exc: Exception) -> None: ...
     def set_transport(self, transport: transports.BaseTransport) -> None: ...
     def feed_eof(self) -> None: ...
     def at_eof(self) -> bool: ...
     def feed_data(self, data: Iterable[SupportsIndex]) -> None: ...
     async def readline(self) -> bytes: ...
-    # Can be any buffer that supports len(); consider changing to a Protocol if PEP 688 is accepted
-    async def readuntil(self, separator: bytes | bytearray | memoryview = b"\n") -> bytes: ...
+    if sys.version_info >= (3, 13):
+        async def readuntil(self, separator: _ReaduntilBuffer | tuple[_ReaduntilBuffer, ...] = b"\n") -> bytes: ...
+    else:
+        async def readuntil(self, separator: _ReaduntilBuffer = b"\n") -> bytes: ...
+
     async def read(self, n: int = -1) -> bytes: ...
     async def readexactly(self, n: int) -> bytes: ...
     def __aiter__(self) -> Self: ...
     async def __anext__(self) -> bytes: ...
```

## puya/_vendor/mypy/typeshed/stdlib/asyncio/tasks.pyi

```diff
@@ -94,102 +94,110 @@
 # of tasks passed; however, Tuple is used similar to the annotation for
 # zip() because typing does not support variadic type variables.  See
 # typing PR #1550 for discussion.
 #
 # N.B. Having overlapping overloads is the only way to get acceptable type inference in all edge cases.
 if sys.version_info >= (3, 10):
     @overload
-    def gather(__coro_or_future1: _FutureLike[_T1], *, return_exceptions: Literal[False] = False) -> Future[tuple[_T1]]: ...  # type: ignore[overload-overlap]
+    def gather(coro_or_future1: _FutureLike[_T1], /, *, return_exceptions: Literal[False] = False) -> Future[tuple[_T1]]: ...  # type: ignore[overload-overlap]
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1], __coro_or_future2: _FutureLike[_T2], *, return_exceptions: Literal[False] = False
+        coro_or_future1: _FutureLike[_T1], coro_or_future2: _FutureLike[_T2], /, *, return_exceptions: Literal[False] = False
     ) -> Future[tuple[_T1, _T2]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        /,
         *,
         return_exceptions: Literal[False] = False,
     ) -> Future[tuple[_T1, _T2, _T3]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        /,
         *,
         return_exceptions: Literal[False] = False,
     ) -> Future[tuple[_T1, _T2, _T3, _T4]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
-        __coro_or_future5: _FutureLike[_T5],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        coro_or_future5: _FutureLike[_T5],
+        /,
         *,
         return_exceptions: Literal[False] = False,
     ) -> Future[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
-        __coro_or_future5: _FutureLike[_T5],
-        __coro_or_future6: _FutureLike[_T6],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        coro_or_future5: _FutureLike[_T5],
+        coro_or_future6: _FutureLike[_T6],
+        /,
         *,
         return_exceptions: Literal[False] = False,
     ) -> Future[tuple[_T1, _T2, _T3, _T4, _T5, _T6]]: ...
     @overload
     def gather(*coros_or_futures: _FutureLike[_T], return_exceptions: Literal[False] = False) -> Future[list[_T]]: ...  # type: ignore[overload-overlap]
     @overload
-    def gather(__coro_or_future1: _FutureLike[_T1], *, return_exceptions: bool) -> Future[tuple[_T1 | BaseException]]: ...  # type: ignore[overload-overlap]
+    def gather(coro_or_future1: _FutureLike[_T1], /, *, return_exceptions: bool) -> Future[tuple[_T1 | BaseException]]: ...  # type: ignore[overload-overlap]
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1], __coro_or_future2: _FutureLike[_T2], *, return_exceptions: bool
+        coro_or_future1: _FutureLike[_T1], coro_or_future2: _FutureLike[_T2], /, *, return_exceptions: bool
     ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        /,
         *,
         return_exceptions: bool,
     ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        /,
         *,
         return_exceptions: bool,
     ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException, _T4 | BaseException]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
-        __coro_or_future5: _FutureLike[_T5],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        coro_or_future5: _FutureLike[_T5],
+        /,
         *,
         return_exceptions: bool,
     ) -> Future[
         tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException, _T4 | BaseException, _T5 | BaseException]
     ]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
-        __coro_or_future5: _FutureLike[_T5],
-        __coro_or_future6: _FutureLike[_T6],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        coro_or_future5: _FutureLike[_T5],
+        coro_or_future6: _FutureLike[_T6],
+        /,
         *,
         return_exceptions: bool,
     ) -> Future[
         tuple[
             _T1 | BaseException,
             _T2 | BaseException,
             _T3 | BaseException,
@@ -200,109 +208,118 @@
     ]: ...
     @overload
     def gather(*coros_or_futures: _FutureLike[_T], return_exceptions: bool) -> Future[list[_T | BaseException]]: ...
 
 else:
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1], *, loop: AbstractEventLoop | None = None, return_exceptions: Literal[False] = False
+        coro_or_future1: _FutureLike[_T1], /, *, loop: AbstractEventLoop | None = None, return_exceptions: Literal[False] = False
     ) -> Future[tuple[_T1]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        /,
         *,
         loop: AbstractEventLoop | None = None,
         return_exceptions: Literal[False] = False,
     ) -> Future[tuple[_T1, _T2]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        /,
         *,
         loop: AbstractEventLoop | None = None,
         return_exceptions: Literal[False] = False,
     ) -> Future[tuple[_T1, _T2, _T3]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        /,
         *,
         loop: AbstractEventLoop | None = None,
         return_exceptions: Literal[False] = False,
     ) -> Future[tuple[_T1, _T2, _T3, _T4]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
-        __coro_or_future5: _FutureLike[_T5],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        coro_or_future5: _FutureLike[_T5],
+        /,
         *,
         loop: AbstractEventLoop | None = None,
         return_exceptions: Literal[False] = False,
     ) -> Future[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
-        __coro_or_future5: _FutureLike[_T5],
-        __coro_or_future6: _FutureLike[_T6],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        coro_or_future5: _FutureLike[_T5],
+        coro_or_future6: _FutureLike[_T6],
+        /,
         *,
         loop: AbstractEventLoop | None = None,
         return_exceptions: Literal[False] = False,
     ) -> Future[tuple[_T1, _T2, _T3, _T4, _T5, _T6]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
         *coros_or_futures: _FutureLike[_T], loop: AbstractEventLoop | None = None, return_exceptions: Literal[False] = False
     ) -> Future[list[_T]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1], *, loop: AbstractEventLoop | None = None, return_exceptions: bool
+        coro_or_future1: _FutureLike[_T1], /, *, loop: AbstractEventLoop | None = None, return_exceptions: bool
     ) -> Future[tuple[_T1 | BaseException]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        /,
         *,
         loop: AbstractEventLoop | None = None,
         return_exceptions: bool,
     ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        /,
         *,
         loop: AbstractEventLoop | None = None,
         return_exceptions: bool,
     ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        /,
         *,
         loop: AbstractEventLoop | None = None,
         return_exceptions: bool,
     ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException, _T4 | BaseException]]: ...
     @overload
     def gather(  # type: ignore[overload-overlap]
-        __coro_or_future1: _FutureLike[_T1],
-        __coro_or_future2: _FutureLike[_T2],
-        __coro_or_future3: _FutureLike[_T3],
-        __coro_or_future4: _FutureLike[_T4],
-        __coro_or_future5: _FutureLike[_T5],
-        __coro_or_future6: _FutureLike[_T6],
+        coro_or_future1: _FutureLike[_T1],
+        coro_or_future2: _FutureLike[_T2],
+        coro_or_future3: _FutureLike[_T3],
+        coro_or_future4: _FutureLike[_T4],
+        coro_or_future5: _FutureLike[_T5],
+        coro_or_future6: _FutureLike[_T6],
+        /,
         *,
         loop: AbstractEventLoop | None = None,
         return_exceptions: bool,
     ) -> Future[
         tuple[
             _T1 | BaseException,
             _T2 | BaseException,
@@ -371,22 +388,24 @@
         loop: AbstractEventLoop | None = None,
         timeout: float | None = None,
         return_when: str = "ALL_COMPLETED",
     ) -> tuple[set[Task[_T]], set[Task[_T]]]: ...
 
 if sys.version_info >= (3, 12):
     _TaskCompatibleCoro: TypeAlias = Coroutine[Any, Any, _T_co]
+elif sys.version_info >= (3, 9):
+    _TaskCompatibleCoro: TypeAlias = Generator[_TaskYieldType, None, _T_co] | Coroutine[Any, Any, _T_co]
 else:
     _TaskCompatibleCoro: TypeAlias = Generator[_TaskYieldType, None, _T_co] | Awaitable[_T_co]
 
 # mypy and pyright complain that a subclass of an invariant class shouldn't be covariant.
 # While this is true in general, here it's sort-of okay to have a covariant subclass,
 # since the only reason why `asyncio.Future` is invariant is the `set_result()` method,
 # and `asyncio.Task.set_result()` always raises.
-class Task(Future[_T_co]):  # type: ignore[type-var]  # pyright: ignore[reportGeneralTypeIssues]
+class Task(Future[_T_co]):  # type: ignore[type-var]  # pyright: ignore[reportInvalidTypeArguments]
     if sys.version_info >= (3, 12):
         def __init__(
             self,
             coro: _TaskCompatibleCoro[_T_co],
             *,
             loop: AbstractEventLoop = ...,
             name: str | None = ...,
@@ -405,15 +424,15 @@
     else:
         def __init__(
             self, coro: _TaskCompatibleCoro[_T_co], *, loop: AbstractEventLoop = ..., name: str | None = ...
         ) -> None: ...
 
     def get_coro(self) -> _TaskCompatibleCoro[_T_co]: ...
     def get_name(self) -> str: ...
-    def set_name(self, __value: object) -> None: ...
+    def set_name(self, value: object, /) -> None: ...
     if sys.version_info >= (3, 12):
         def get_context(self) -> Context: ...
 
     def get_stack(self, *, limit: int | None = None) -> list[FrameType]: ...
     def print_stack(self, *, limit: int | None = None, file: TextIO | None = None) -> None: ...
     if sys.version_info >= (3, 11):
         def cancelling(self) -> int: ...
@@ -440,15 +459,16 @@
 
 if sys.version_info >= (3, 12):
     _TaskT_co = TypeVar("_TaskT_co", bound=Task[Any], covariant=True)
 
     class _CustomTaskConstructor(Protocol[_TaskT_co]):
         def __call__(
             self,
-            __coro: _TaskCompatibleCoro[Any],
+            coro: _TaskCompatibleCoro[Any],
+            /,
             *,
             loop: AbstractEventLoop,
             name: str | None,
             context: Context | None,
             eager_start: bool,
         ) -> _TaskT_co: ...
```

## puya/_vendor/mypy/typeshed/stdlib/asyncio/threads.pyi

```diff
@@ -2,8 +2,8 @@
 from typing import TypeVar
 from typing_extensions import ParamSpec
 
 __all__ = ("to_thread",)
 _P = ParamSpec("_P")
 _R = TypeVar("_R")
 
-async def to_thread(__func: Callable[_P, _R], *args: _P.args, **kwargs: _P.kwargs) -> _R: ...
+async def to_thread(func: Callable[_P, _R], /, *args: _P.args, **kwargs: _P.kwargs) -> _R: ...
```

## puya/_vendor/mypy/typeshed/stdlib/asyncio/trsock.pyi

```diff
@@ -47,34 +47,30 @@
         def connect_ex(self, address: _Address) -> int: ...
         def bind(self, address: _Address) -> None: ...
         if sys.platform == "win32":
             def ioctl(self, control: int, option: int | tuple[int, int, int] | bool) -> None: ...
         else:
             def ioctl(self, control: int, option: int | tuple[int, int, int] | bool) -> NoReturn: ...
 
-        def listen(self, __backlog: int = ...) -> None: ...
+        def listen(self, backlog: int = ..., /) -> None: ...
         def makefile(self) -> BinaryIO: ...
         def sendfile(self, file: BinaryIO, offset: int = ..., count: int | None = ...) -> int: ...
         def close(self) -> None: ...
         def detach(self) -> int: ...
         if sys.platform == "linux":
             def sendmsg_afalg(
                 self, msg: Iterable[ReadableBuffer] = ..., *, op: int, iv: Any = ..., assoclen: int = ..., flags: int = ...
             ) -> int: ...
         else:
             def sendmsg_afalg(
                 self, msg: Iterable[ReadableBuffer] = ..., *, op: int, iv: Any = ..., assoclen: int = ..., flags: int = ...
             ) -> NoReturn: ...
 
         def sendmsg(
-            self,
-            __buffers: Iterable[ReadableBuffer],
-            __ancdata: Iterable[_CMSG] = ...,
-            __flags: int = ...,
-            __address: _Address = ...,
+            self, buffers: Iterable[ReadableBuffer], ancdata: Iterable[_CMSG] = ..., flags: int = ..., address: _Address = ..., /
         ) -> int: ...
         @overload
         def sendto(self, data: ReadableBuffer, address: _Address) -> int: ...
         @overload
         def sendto(self, data: ReadableBuffer, flags: int, address: _Address) -> int: ...
         def send(self, data: ReadableBuffer, flags: int = ...) -> int: ...
         def sendall(self, data: ReadableBuffer, flags: int = ...) -> None: ...
@@ -83,16 +79,16 @@
             def share(self, process_id: int) -> bytes: ...
         else:
             def share(self, process_id: int) -> NoReturn: ...
 
         def recv_into(self, buffer: _WriteBuffer, nbytes: int = ..., flags: int = ...) -> int: ...
         def recvfrom_into(self, buffer: _WriteBuffer, nbytes: int = ..., flags: int = ...) -> tuple[int, _RetAddress]: ...
         def recvmsg_into(
-            self, __buffers: Iterable[_WriteBuffer], __ancbufsize: int = ..., __flags: int = ...
+            self, buffers: Iterable[_WriteBuffer], ancbufsize: int = ..., flags: int = ..., /
         ) -> tuple[int, list[_CMSG], int, Any]: ...
-        def recvmsg(self, __bufsize: int, __ancbufsize: int = ..., __flags: int = ...) -> tuple[bytes, list[_CMSG], int, Any]: ...
+        def recvmsg(self, bufsize: int, ancbufsize: int = ..., flags: int = ..., /) -> tuple[bytes, list[_CMSG], int, Any]: ...
         def recvfrom(self, bufsize: int, flags: int = ...) -> tuple[bytes, _RetAddress]: ...
         def recv(self, bufsize: int, flags: int = ...) -> bytes: ...
         def __enter__(self) -> socket.socket: ...
         def __exit__(
             self, exc_type: Type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
         ) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/asyncio/unix_events.pyi

```diff
@@ -13,15 +13,17 @@
 # This is also technically not available on Win,
 # but other parts of typeshed need this definition.
 # So, it is special cased.
 if sys.version_info >= (3, 12):
     @deprecated("Deprecated as of Python 3.12; will be removed in Python 3.14")
     class AbstractChildWatcher:
         @abstractmethod
-        def add_child_handler(self, pid: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]) -> None: ...
+        def add_child_handler(
+            self, pid: int, callback: Callable[[int, int, Unpack[_Ts]], object], *args: Unpack[_Ts]
+        ) -> None: ...
         @abstractmethod
         def remove_child_handler(self, pid: int) -> bool: ...
         @abstractmethod
         def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...
         @abstractmethod
         def close(self) -> None: ...
         @abstractmethod
@@ -32,15 +34,17 @@
         ) -> None: ...
         @abstractmethod
         def is_active(self) -> bool: ...
 
 else:
     class AbstractChildWatcher:
         @abstractmethod
-        def add_child_handler(self, pid: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]) -> None: ...
+        def add_child_handler(
+            self, pid: int, callback: Callable[[int, int, Unpack[_Ts]], object], *args: Unpack[_Ts]
+        ) -> None: ...
         @abstractmethod
         def remove_child_handler(self, pid: int) -> bool: ...
         @abstractmethod
         def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...
         @abstractmethod
         def close(self) -> None: ...
         @abstractmethod
@@ -83,91 +87,110 @@
         def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...
 
     if sys.version_info >= (3, 12):
         @deprecated("Deprecated as of Python 3.12; will be removed in Python 3.14")
         class SafeChildWatcher(BaseChildWatcher):
             def __enter__(self) -> Self: ...
             def __exit__(self, a: type[BaseException] | None, b: BaseException | None, c: types.TracebackType | None) -> None: ...
-            def add_child_handler(self, pid: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]) -> None: ...
+            def add_child_handler(
+                self, pid: int, callback: Callable[[int, int, Unpack[_Ts]], object], *args: Unpack[_Ts]
+            ) -> None: ...
             def remove_child_handler(self, pid: int) -> bool: ...
 
         @deprecated("Deprecated as of Python 3.12; will be removed in Python 3.14")
         class FastChildWatcher(BaseChildWatcher):
             def __enter__(self) -> Self: ...
             def __exit__(self, a: type[BaseException] | None, b: BaseException | None, c: types.TracebackType | None) -> None: ...
-            def add_child_handler(self, pid: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]) -> None: ...
+            def add_child_handler(
+                self, pid: int, callback: Callable[[int, int, Unpack[_Ts]], object], *args: Unpack[_Ts]
+            ) -> None: ...
             def remove_child_handler(self, pid: int) -> bool: ...
+
     else:
         class SafeChildWatcher(BaseChildWatcher):
             def __enter__(self) -> Self: ...
             def __exit__(self, a: type[BaseException] | None, b: BaseException | None, c: types.TracebackType | None) -> None: ...
-            def add_child_handler(self, pid: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]) -> None: ...
+            def add_child_handler(
+                self, pid: int, callback: Callable[[int, int, Unpack[_Ts]], object], *args: Unpack[_Ts]
+            ) -> None: ...
             def remove_child_handler(self, pid: int) -> bool: ...
 
         class FastChildWatcher(BaseChildWatcher):
             def __enter__(self) -> Self: ...
             def __exit__(self, a: type[BaseException] | None, b: BaseException | None, c: types.TracebackType | None) -> None: ...
-            def add_child_handler(self, pid: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]) -> None: ...
+            def add_child_handler(
+                self, pid: int, callback: Callable[[int, int, Unpack[_Ts]], object], *args: Unpack[_Ts]
+            ) -> None: ...
             def remove_child_handler(self, pid: int) -> bool: ...
 
     class _UnixSelectorEventLoop(BaseSelectorEventLoop): ...
 
     class _UnixDefaultEventLoopPolicy(BaseDefaultEventLoopPolicy):
         if sys.version_info >= (3, 12):
             @deprecated("Deprecated as of Python 3.12; will be removed in Python 3.14")
             def get_child_watcher(self) -> AbstractChildWatcher: ...
             @deprecated("Deprecated as of Python 3.12; will be removed in Python 3.14")
             def set_child_watcher(self, watcher: AbstractChildWatcher | None) -> None: ...
         else:
             def get_child_watcher(self) -> AbstractChildWatcher: ...
             def set_child_watcher(self, watcher: AbstractChildWatcher | None) -> None: ...
+
     SelectorEventLoop = _UnixSelectorEventLoop
 
     DefaultEventLoopPolicy = _UnixDefaultEventLoopPolicy
 
     if sys.version_info >= (3, 12):
         @deprecated("Deprecated as of Python 3.12; will be removed in Python 3.14")
         class MultiLoopChildWatcher(AbstractChildWatcher):
             def is_active(self) -> bool: ...
             def close(self) -> None: ...
             def __enter__(self) -> Self: ...
             def __exit__(
                 self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None
             ) -> None: ...
-            def add_child_handler(self, pid: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]) -> None: ...
+            def add_child_handler(
+                self, pid: int, callback: Callable[[int, int, Unpack[_Ts]], object], *args: Unpack[_Ts]
+            ) -> None: ...
             def remove_child_handler(self, pid: int) -> bool: ...
             def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...
+
     else:
         class MultiLoopChildWatcher(AbstractChildWatcher):
             def is_active(self) -> bool: ...
             def close(self) -> None: ...
             def __enter__(self) -> Self: ...
             def __exit__(
                 self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None
             ) -> None: ...
-            def add_child_handler(self, pid: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]) -> None: ...
+            def add_child_handler(
+                self, pid: int, callback: Callable[[int, int, Unpack[_Ts]], object], *args: Unpack[_Ts]
+            ) -> None: ...
             def remove_child_handler(self, pid: int) -> bool: ...
             def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...
 
     class ThreadedChildWatcher(AbstractChildWatcher):
         def is_active(self) -> Literal[True]: ...
         def close(self) -> None: ...
         def __enter__(self) -> Self: ...
         def __exit__(
             self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None
         ) -> None: ...
         def __del__(self) -> None: ...
-        def add_child_handler(self, pid: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]) -> None: ...
+        def add_child_handler(
+            self, pid: int, callback: Callable[[int, int, Unpack[_Ts]], object], *args: Unpack[_Ts]
+        ) -> None: ...
         def remove_child_handler(self, pid: int) -> bool: ...
         def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...
 
     if sys.version_info >= (3, 9):
         class PidfdChildWatcher(AbstractChildWatcher):
             def __enter__(self) -> Self: ...
             def __exit__(
                 self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None
             ) -> None: ...
             def is_active(self) -> bool: ...
             def close(self) -> None: ...
             def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...
-            def add_child_handler(self, pid: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]) -> None: ...
+            def add_child_handler(
+                self, pid: int, callback: Callable[[int, int, Unpack[_Ts]], object], *args: Unpack[_Ts]
+            ) -> None: ...
             def remove_child_handler(self, pid: int) -> bool: ...
```

## puya/_vendor/mypy/typeshed/stdlib/asyncio/windows_events.pyi

```diff
@@ -65,19 +65,21 @@
         async def connect_pipe(self, address: str) -> windows_utils.PipeHandle: ...
         def wait_for_handle(self, handle: windows_utils.PipeHandle, timeout: int | None = None) -> bool: ...
         def close(self) -> None: ...
         if sys.version_info >= (3, 11):
             def recvfrom_into(
                 self, conn: socket.socket, buf: WriteableBuffer, flags: int = 0
             ) -> futures.Future[tuple[int, socket._RetAddress]]: ...
+
     SelectorEventLoop = _WindowsSelectorEventLoop
 
     class WindowsSelectorEventLoopPolicy(events.BaseDefaultEventLoopPolicy):
         _loop_factory: ClassVar[type[SelectorEventLoop]]
         def get_child_watcher(self) -> NoReturn: ...
         def set_child_watcher(self, watcher: Any) -> NoReturn: ...
 
     class WindowsProactorEventLoopPolicy(events.BaseDefaultEventLoopPolicy):
         _loop_factory: ClassVar[type[ProactorEventLoop]]
         def get_child_watcher(self) -> NoReturn: ...
         def set_child_watcher(self, watcher: Any) -> NoReturn: ...
+
     DefaultEventLoopPolicy = WindowsSelectorEventLoopPolicy
```

## puya/_vendor/mypy/typeshed/stdlib/audioop.pyi

```diff
@@ -1,42 +1,43 @@
 from typing_extensions import TypeAlias
 
 _AdpcmState: TypeAlias = tuple[int, int]
 _RatecvState: TypeAlias = tuple[int, tuple[tuple[int, int], ...]]
 
 class error(Exception): ...
 
-def add(__fragment1: bytes, __fragment2: bytes, __width: int) -> bytes: ...
-def adpcm2lin(__fragment: bytes, __width: int, __state: _AdpcmState | None) -> tuple[bytes, _AdpcmState]: ...
-def alaw2lin(__fragment: bytes, __width: int) -> bytes: ...
-def avg(__fragment: bytes, __width: int) -> int: ...
-def avgpp(__fragment: bytes, __width: int) -> int: ...
-def bias(__fragment: bytes, __width: int, __bias: int) -> bytes: ...
-def byteswap(__fragment: bytes, __width: int) -> bytes: ...
-def cross(__fragment: bytes, __width: int) -> int: ...
-def findfactor(__fragment: bytes, __reference: bytes) -> float: ...
-def findfit(__fragment: bytes, __reference: bytes) -> tuple[int, float]: ...
-def findmax(__fragment: bytes, __length: int) -> int: ...
-def getsample(__fragment: bytes, __width: int, __index: int) -> int: ...
-def lin2adpcm(__fragment: bytes, __width: int, __state: _AdpcmState | None) -> tuple[bytes, _AdpcmState]: ...
-def lin2alaw(__fragment: bytes, __width: int) -> bytes: ...
-def lin2lin(__fragment: bytes, __width: int, __newwidth: int) -> bytes: ...
-def lin2ulaw(__fragment: bytes, __width: int) -> bytes: ...
-def max(__fragment: bytes, __width: int) -> int: ...
-def maxpp(__fragment: bytes, __width: int) -> int: ...
-def minmax(__fragment: bytes, __width: int) -> tuple[int, int]: ...
-def mul(__fragment: bytes, __width: int, __factor: float) -> bytes: ...
+def add(fragment1: bytes, fragment2: bytes, width: int, /) -> bytes: ...
+def adpcm2lin(fragment: bytes, width: int, state: _AdpcmState | None, /) -> tuple[bytes, _AdpcmState]: ...
+def alaw2lin(fragment: bytes, width: int, /) -> bytes: ...
+def avg(fragment: bytes, width: int, /) -> int: ...
+def avgpp(fragment: bytes, width: int, /) -> int: ...
+def bias(fragment: bytes, width: int, bias: int, /) -> bytes: ...
+def byteswap(fragment: bytes, width: int, /) -> bytes: ...
+def cross(fragment: bytes, width: int, /) -> int: ...
+def findfactor(fragment: bytes, reference: bytes, /) -> float: ...
+def findfit(fragment: bytes, reference: bytes, /) -> tuple[int, float]: ...
+def findmax(fragment: bytes, length: int, /) -> int: ...
+def getsample(fragment: bytes, width: int, index: int, /) -> int: ...
+def lin2adpcm(fragment: bytes, width: int, state: _AdpcmState | None, /) -> tuple[bytes, _AdpcmState]: ...
+def lin2alaw(fragment: bytes, width: int, /) -> bytes: ...
+def lin2lin(fragment: bytes, width: int, newwidth: int, /) -> bytes: ...
+def lin2ulaw(fragment: bytes, width: int, /) -> bytes: ...
+def max(fragment: bytes, width: int, /) -> int: ...
+def maxpp(fragment: bytes, width: int, /) -> int: ...
+def minmax(fragment: bytes, width: int, /) -> tuple[int, int]: ...
+def mul(fragment: bytes, width: int, factor: float, /) -> bytes: ...
 def ratecv(
-    __fragment: bytes,
-    __width: int,
-    __nchannels: int,
-    __inrate: int,
-    __outrate: int,
-    __state: _RatecvState | None,
-    __weightA: int = 1,
-    __weightB: int = 0,
+    fragment: bytes,
+    width: int,
+    nchannels: int,
+    inrate: int,
+    outrate: int,
+    state: _RatecvState | None,
+    weightA: int = 1,
+    weightB: int = 0,
+    /,
 ) -> tuple[bytes, _RatecvState]: ...
-def reverse(__fragment: bytes, __width: int) -> bytes: ...
-def rms(__fragment: bytes, __width: int) -> int: ...
-def tomono(__fragment: bytes, __width: int, __lfactor: float, __rfactor: float) -> bytes: ...
-def tostereo(__fragment: bytes, __width: int, __lfactor: float, __rfactor: float) -> bytes: ...
-def ulaw2lin(__fragment: bytes, __width: int) -> bytes: ...
+def reverse(fragment: bytes, width: int, /) -> bytes: ...
+def rms(fragment: bytes, width: int, /) -> int: ...
+def tomono(fragment: bytes, width: int, lfactor: float, rfactor: float, /) -> bytes: ...
+def tostereo(fragment: bytes, width: int, lfactor: float, rfactor: float, /) -> bytes: ...
+def ulaw2lin(fragment: bytes, width: int, /) -> bytes: ...
```

## puya/_vendor/mypy/typeshed/stdlib/bdb.pyi

```diff
@@ -63,15 +63,15 @@
     def get_stack(self, f: FrameType | None, t: TracebackType | None) -> tuple[list[tuple[FrameType, int]], int]: ...
     def format_stack_entry(self, frame_lineno: int, lprefix: str = ": ") -> str: ...
     def run(
         self, cmd: str | CodeType, globals: dict[str, Any] | None = None, locals: Mapping[str, Any] | None = None
     ) -> None: ...
     def runeval(self, expr: str, globals: dict[str, Any] | None = None, locals: Mapping[str, Any] | None = None) -> None: ...
     def runctx(self, cmd: str | CodeType, globals: dict[str, Any] | None, locals: Mapping[str, Any] | None) -> None: ...
-    def runcall(self, __func: Callable[_P, _T], *args: _P.args, **kwds: _P.kwargs) -> _T | None: ...
+    def runcall(self, func: Callable[_P, _T], /, *args: _P.args, **kwds: _P.kwargs) -> _T | None: ...
 
 class Breakpoint:
     next: int
     bplist: dict[tuple[str, int], list[Breakpoint]]
     bpbynumber: list[Breakpoint | None]
 
     funcname: str | None
```

## puya/_vendor/mypy/typeshed/stdlib/binascii.pyi

```diff
@@ -2,35 +2,35 @@
 from _typeshed import ReadableBuffer
 from typing_extensions import TypeAlias
 
 # Many functions in binascii accept buffer objects
 # or ASCII-only strings.
 _AsciiBuffer: TypeAlias = str | ReadableBuffer
 
-def a2b_uu(__data: _AsciiBuffer) -> bytes: ...
-def b2a_uu(__data: ReadableBuffer, *, backtick: bool = False) -> bytes: ...
+def a2b_uu(data: _AsciiBuffer, /) -> bytes: ...
+def b2a_uu(data: ReadableBuffer, /, *, backtick: bool = False) -> bytes: ...
 
 if sys.version_info >= (3, 11):
-    def a2b_base64(__data: _AsciiBuffer, *, strict_mode: bool = False) -> bytes: ...
+    def a2b_base64(data: _AsciiBuffer, /, *, strict_mode: bool = False) -> bytes: ...
 
 else:
-    def a2b_base64(__data: _AsciiBuffer) -> bytes: ...
+    def a2b_base64(data: _AsciiBuffer, /) -> bytes: ...
 
-def b2a_base64(__data: ReadableBuffer, *, newline: bool = True) -> bytes: ...
+def b2a_base64(data: ReadableBuffer, /, *, newline: bool = True) -> bytes: ...
 def a2b_qp(data: _AsciiBuffer, header: bool = False) -> bytes: ...
 def b2a_qp(data: ReadableBuffer, quotetabs: bool = False, istext: bool = True, header: bool = False) -> bytes: ...
 
 if sys.version_info < (3, 11):
-    def a2b_hqx(__data: _AsciiBuffer) -> bytes: ...
-    def rledecode_hqx(__data: ReadableBuffer) -> bytes: ...
-    def rlecode_hqx(__data: ReadableBuffer) -> bytes: ...
-    def b2a_hqx(__data: ReadableBuffer) -> bytes: ...
+    def a2b_hqx(data: _AsciiBuffer, /) -> bytes: ...
+    def rledecode_hqx(data: ReadableBuffer, /) -> bytes: ...
+    def rlecode_hqx(data: ReadableBuffer, /) -> bytes: ...
+    def b2a_hqx(data: ReadableBuffer, /) -> bytes: ...
 
-def crc_hqx(__data: ReadableBuffer, __crc: int) -> int: ...
-def crc32(__data: ReadableBuffer, __crc: int = 0) -> int: ...
+def crc_hqx(data: ReadableBuffer, crc: int, /) -> int: ...
+def crc32(data: ReadableBuffer, crc: int = 0, /) -> int: ...
 def b2a_hex(data: ReadableBuffer, sep: str | bytes = ..., bytes_per_sep: int = ...) -> bytes: ...
 def hexlify(data: ReadableBuffer, sep: str | bytes = ..., bytes_per_sep: int = ...) -> bytes: ...
-def a2b_hex(__hexstr: _AsciiBuffer) -> bytes: ...
-def unhexlify(__hexstr: _AsciiBuffer) -> bytes: ...
+def a2b_hex(hexstr: _AsciiBuffer, /) -> bytes: ...
+def unhexlify(hexstr: _AsciiBuffer, /) -> bytes: ...
 
 class Error(ValueError): ...
 class Incomplete(Exception): ...
```

## puya/_vendor/mypy/typeshed/stdlib/builtins.pyi

```diff
@@ -93,70 +93,69 @@
 class object:
     __doc__: str | None
     __dict__: dict[str, Any]
     __module__: str
     __annotations__: dict[str, Any]
     @property
     def __class__(self) -> type[Self]: ...
-    # Ignore errors about type mismatch between property getter and setter
     @__class__.setter
-    def __class__(self, __type: type[object]) -> None: ...  # noqa: F811
+    def __class__(self, type: type[object], /) -> None: ...
     def __init__(self) -> None: ...
     def __new__(cls) -> Self: ...
     # N.B. `object.__setattr__` and `object.__delattr__` are heavily special-cased by type checkers.
     # Overriding them in subclasses has different semantics, even if the override has an identical signature.
-    def __setattr__(self, __name: str, __value: Any) -> None: ...
-    def __delattr__(self, __name: str) -> None: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
+    def __setattr__(self, name: str, value: Any, /) -> None: ...
+    def __delattr__(self, name: str, /) -> None: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
     def __str__(self) -> str: ...  # noqa: Y029
     def __repr__(self) -> str: ...  # noqa: Y029
     def __hash__(self) -> int: ...
-    def __format__(self, __format_spec: str) -> str: ...
-    def __getattribute__(self, __name: str) -> Any: ...
+    def __format__(self, format_spec: str, /) -> str: ...
+    def __getattribute__(self, name: str, /) -> Any: ...
     def __sizeof__(self) -> int: ...
     # return type of pickle methods is rather hard to express in the current type system
     # see #6661 and https://docs.python.org/3/library/pickle.html#object.__reduce__
     def __reduce__(self) -> str | tuple[Any, ...]: ...
-    def __reduce_ex__(self, __protocol: SupportsIndex) -> str | tuple[Any, ...]: ...
+    def __reduce_ex__(self, protocol: SupportsIndex, /) -> str | tuple[Any, ...]: ...
     if sys.version_info >= (3, 11):
         def __getstate__(self) -> object: ...
 
     def __dir__(self) -> Iterable[str]: ...
     def __init_subclass__(cls) -> None: ...
     @classmethod
-    def __subclasshook__(cls, __subclass: type) -> bool: ...
+    def __subclasshook__(cls, subclass: type, /) -> bool: ...
 
 class staticmethod(Generic[_P, _R_co]):
     @property
     def __func__(self) -> Callable[_P, _R_co]: ...
     @property
     def __isabstractmethod__(self) -> bool: ...
-    def __init__(self, __f: Callable[_P, _R_co]) -> None: ...
+    def __init__(self, f: Callable[_P, _R_co], /) -> None: ...
     @overload
-    def __get__(self, __instance: None, __owner: type) -> Callable[_P, _R_co]: ...
+    def __get__(self, instance: None, owner: type, /) -> Callable[_P, _R_co]: ...
     @overload
-    def __get__(self, __instance: _T, __owner: type[_T] | None = None) -> Callable[_P, _R_co]: ...
+    def __get__(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...
     if sys.version_info >= (3, 10):
         __name__: str
         __qualname__: str
         @property
         def __wrapped__(self) -> Callable[_P, _R_co]: ...
         def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R_co: ...
 
 class classmethod(Generic[_T, _P, _R_co]):
     @property
     def __func__(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...
     @property
     def __isabstractmethod__(self) -> bool: ...
-    def __init__(self, __f: Callable[Concatenate[type[_T], _P], _R_co]) -> None: ...
+    def __init__(self, f: Callable[Concatenate[type[_T], _P], _R_co], /) -> None: ...
     @overload
-    def __get__(self, __instance: _T, __owner: type[_T] | None = None) -> Callable[_P, _R_co]: ...
+    def __get__(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...
     @overload
-    def __get__(self, __instance: None, __owner: type[_T]) -> Callable[_P, _R_co]: ...
+    def __get__(self, instance: None, owner: type[_T], /) -> Callable[_P, _R_co]: ...
     if sys.version_info >= (3, 10):
         __name__: str
         __qualname__: str
         @property
         def __wrapped__(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...
 
 class type:
@@ -180,55 +179,55 @@
     __name__: str
     __qualname__: str
     @property
     def __text_signature__(self) -> str | None: ...
     @property
     def __weakrefoffset__(self) -> int: ...
     @overload
-    def __init__(self, __o: object) -> None: ...
+    def __init__(self, o: object, /) -> None: ...
     @overload
-    def __init__(self, __name: str, __bases: tuple[type, ...], __dict: dict[str, Any], **kwds: Any) -> None: ...
+    def __init__(self, name: str, bases: tuple[type, ...], dict: dict[str, Any], /, **kwds: Any) -> None: ...
     @overload
-    def __new__(cls, __o: object) -> type: ...
+    def __new__(cls, o: object, /) -> type: ...
     @overload
     def __new__(
-        cls: type[_typeshed.Self], __name: str, __bases: tuple[type, ...], __namespace: dict[str, Any], **kwds: Any
+        cls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], /, **kwds: Any
     ) -> _typeshed.Self: ...
     def __call__(self, *args: Any, **kwds: Any) -> Any: ...
     def __subclasses__(self: _typeshed.Self) -> list[_typeshed.Self]: ...
     # Note: the documentation doesn't specify what the return type is, the standard
     # implementation seems to be returning a list.
     def mro(self) -> list[type]: ...
-    def __instancecheck__(self, __instance: Any) -> bool: ...
-    def __subclasscheck__(self, __subclass: type) -> bool: ...
+    def __instancecheck__(self, instance: Any, /) -> bool: ...
+    def __subclasscheck__(self, subclass: type, /) -> bool: ...
     @classmethod
-    def __prepare__(metacls, __name: str, __bases: tuple[type, ...], **kwds: Any) -> MutableMapping[str, object]: ...
+    def __prepare__(metacls, name: str, bases: tuple[type, ...], /, **kwds: Any) -> MutableMapping[str, object]: ...
     if sys.version_info >= (3, 10):
-        def __or__(self, __value: Any) -> types.UnionType: ...
-        def __ror__(self, __value: Any) -> types.UnionType: ...
+        def __or__(self, value: Any, /) -> types.UnionType: ...
+        def __ror__(self, value: Any, /) -> types.UnionType: ...
     if sys.version_info >= (3, 12):
         __type_params__: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]
 
 class super:
     @overload
-    def __init__(self, __t: Any, __obj: Any) -> None: ...
+    def __init__(self, t: Any, obj: Any, /) -> None: ...
     @overload
-    def __init__(self, __t: Any) -> None: ...
+    def __init__(self, t: Any, /) -> None: ...
     @overload
     def __init__(self) -> None: ...
 
 _PositiveInteger: TypeAlias = Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
 _NegativeInteger: TypeAlias = Literal[-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20]
 _LiteralInteger = _PositiveInteger | _NegativeInteger | Literal[0]  # noqa: Y026  # TODO: Use TypeAlias once mypy bugs are fixed
 
 class int:
     @overload
-    def __new__(cls, __x: ConvertibleToInt = ...) -> Self: ...
+    def __new__(cls, x: ConvertibleToInt = ..., /) -> Self: ...
     @overload
-    def __new__(cls, __x: str | bytes | bytearray, base: SupportsIndex) -> Self: ...
+    def __new__(cls, x: str | bytes | bytearray, /, base: SupportsIndex) -> Self: ...
     def as_integer_ratio(self) -> tuple[int, Literal[1]]: ...
     @property
     def real(self) -> int: ...
     @property
     def imag(self) -> Literal[0]: ...
     @property
     def numerator(self) -> int: ...
@@ -261,129 +260,129 @@
             *,
             signed: bool = False,
         ) -> Self: ...
 
     if sys.version_info >= (3, 12):
         def is_integer(self) -> Literal[True]: ...
 
-    def __add__(self, __value: int) -> int: ...
-    def __sub__(self, __value: int) -> int: ...
-    def __mul__(self, __value: int) -> int: ...
-    def __floordiv__(self, __value: int) -> int: ...
-    def __truediv__(self, __value: int) -> float: ...
-    def __mod__(self, __value: int) -> int: ...
-    def __divmod__(self, __value: int) -> tuple[int, int]: ...
-    def __radd__(self, __value: int) -> int: ...
-    def __rsub__(self, __value: int) -> int: ...
-    def __rmul__(self, __value: int) -> int: ...
-    def __rfloordiv__(self, __value: int) -> int: ...
-    def __rtruediv__(self, __value: int) -> float: ...
-    def __rmod__(self, __value: int) -> int: ...
-    def __rdivmod__(self, __value: int) -> tuple[int, int]: ...
+    def __add__(self, value: int, /) -> int: ...
+    def __sub__(self, value: int, /) -> int: ...
+    def __mul__(self, value: int, /) -> int: ...
+    def __floordiv__(self, value: int, /) -> int: ...
+    def __truediv__(self, value: int, /) -> float: ...
+    def __mod__(self, value: int, /) -> int: ...
+    def __divmod__(self, value: int, /) -> tuple[int, int]: ...
+    def __radd__(self, value: int, /) -> int: ...
+    def __rsub__(self, value: int, /) -> int: ...
+    def __rmul__(self, value: int, /) -> int: ...
+    def __rfloordiv__(self, value: int, /) -> int: ...
+    def __rtruediv__(self, value: int, /) -> float: ...
+    def __rmod__(self, value: int, /) -> int: ...
+    def __rdivmod__(self, value: int, /) -> tuple[int, int]: ...
     @overload
-    def __pow__(self, __x: Literal[0]) -> Literal[1]: ...
+    def __pow__(self, x: Literal[0], /) -> Literal[1]: ...
     @overload
-    def __pow__(self, __value: Literal[0], __mod: None) -> Literal[1]: ...
+    def __pow__(self, value: Literal[0], mod: None, /) -> Literal[1]: ...
     @overload
-    def __pow__(self, __value: _PositiveInteger, __mod: None = None) -> int: ...
+    def __pow__(self, value: _PositiveInteger, mod: None = None, /) -> int: ...
     @overload
-    def __pow__(self, __value: _NegativeInteger, __mod: None = None) -> float: ...
+    def __pow__(self, value: _NegativeInteger, mod: None = None, /) -> float: ...
     # positive __value -> int; negative __value -> float
     # return type must be Any as `int | float` causes too many false-positive errors
     @overload
-    def __pow__(self, __value: int, __mod: None = None) -> Any: ...
+    def __pow__(self, value: int, mod: None = None, /) -> Any: ...
     @overload
-    def __pow__(self, __value: int, __mod: int) -> int: ...
-    def __rpow__(self, __value: int, __mod: int | None = None) -> Any: ...
-    def __and__(self, __value: int) -> int: ...
-    def __or__(self, __value: int) -> int: ...
-    def __xor__(self, __value: int) -> int: ...
-    def __lshift__(self, __value: int) -> int: ...
-    def __rshift__(self, __value: int) -> int: ...
-    def __rand__(self, __value: int) -> int: ...
-    def __ror__(self, __value: int) -> int: ...
-    def __rxor__(self, __value: int) -> int: ...
-    def __rlshift__(self, __value: int) -> int: ...
-    def __rrshift__(self, __value: int) -> int: ...
+    def __pow__(self, value: int, mod: int, /) -> int: ...
+    def __rpow__(self, value: int, mod: int | None = None, /) -> Any: ...
+    def __and__(self, value: int, /) -> int: ...
+    def __or__(self, value: int, /) -> int: ...
+    def __xor__(self, value: int, /) -> int: ...
+    def __lshift__(self, value: int, /) -> int: ...
+    def __rshift__(self, value: int, /) -> int: ...
+    def __rand__(self, value: int, /) -> int: ...
+    def __ror__(self, value: int, /) -> int: ...
+    def __rxor__(self, value: int, /) -> int: ...
+    def __rlshift__(self, value: int, /) -> int: ...
+    def __rrshift__(self, value: int, /) -> int: ...
     def __neg__(self) -> int: ...
     def __pos__(self) -> int: ...
     def __invert__(self) -> int: ...
     def __trunc__(self) -> int: ...
     def __ceil__(self) -> int: ...
     def __floor__(self) -> int: ...
-    def __round__(self, __ndigits: SupportsIndex = ...) -> int: ...
+    def __round__(self, ndigits: SupportsIndex = ..., /) -> int: ...
     def __getnewargs__(self) -> tuple[int]: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
-    def __lt__(self, __value: int) -> bool: ...
-    def __le__(self, __value: int) -> bool: ...
-    def __gt__(self, __value: int) -> bool: ...
-    def __ge__(self, __value: int) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
+    def __lt__(self, value: int, /) -> bool: ...
+    def __le__(self, value: int, /) -> bool: ...
+    def __gt__(self, value: int, /) -> bool: ...
+    def __ge__(self, value: int, /) -> bool: ...
     def __float__(self) -> float: ...
     def __int__(self) -> int: ...
     def __abs__(self) -> int: ...
     def __hash__(self) -> int: ...
     def __bool__(self) -> bool: ...
     def __index__(self) -> int: ...
 
 class float:
-    def __new__(cls, __x: ConvertibleToFloat = ...) -> Self: ...
+    def __new__(cls, x: ConvertibleToFloat = ..., /) -> Self: ...
     def as_integer_ratio(self) -> tuple[int, int]: ...
     def hex(self) -> str: ...
     def is_integer(self) -> bool: ...
     @classmethod
-    def fromhex(cls, __string: str) -> Self: ...
+    def fromhex(cls, string: str, /) -> Self: ...
     @property
     def real(self) -> float: ...
     @property
     def imag(self) -> float: ...
     def conjugate(self) -> float: ...
-    def __add__(self, __value: float) -> float: ...
-    def __sub__(self, __value: float) -> float: ...
-    def __mul__(self, __value: float) -> float: ...
-    def __floordiv__(self, __value: float) -> float: ...
-    def __truediv__(self, __value: float) -> float: ...
-    def __mod__(self, __value: float) -> float: ...
-    def __divmod__(self, __value: float) -> tuple[float, float]: ...
+    def __add__(self, value: float, /) -> float: ...
+    def __sub__(self, value: float, /) -> float: ...
+    def __mul__(self, value: float, /) -> float: ...
+    def __floordiv__(self, value: float, /) -> float: ...
+    def __truediv__(self, value: float, /) -> float: ...
+    def __mod__(self, value: float, /) -> float: ...
+    def __divmod__(self, value: float, /) -> tuple[float, float]: ...
     @overload
-    def __pow__(self, __value: int, __mod: None = None) -> float: ...
+    def __pow__(self, value: int, mod: None = None, /) -> float: ...
     # positive __value -> float; negative __value -> complex
     # return type must be Any as `float | complex` causes too many false-positive errors
     @overload
-    def __pow__(self, __value: float, __mod: None = None) -> Any: ...
-    def __radd__(self, __value: float) -> float: ...
-    def __rsub__(self, __value: float) -> float: ...
-    def __rmul__(self, __value: float) -> float: ...
-    def __rfloordiv__(self, __value: float) -> float: ...
-    def __rtruediv__(self, __value: float) -> float: ...
-    def __rmod__(self, __value: float) -> float: ...
-    def __rdivmod__(self, __value: float) -> tuple[float, float]: ...
+    def __pow__(self, value: float, mod: None = None, /) -> Any: ...
+    def __radd__(self, value: float, /) -> float: ...
+    def __rsub__(self, value: float, /) -> float: ...
+    def __rmul__(self, value: float, /) -> float: ...
+    def __rfloordiv__(self, value: float, /) -> float: ...
+    def __rtruediv__(self, value: float, /) -> float: ...
+    def __rmod__(self, value: float, /) -> float: ...
+    def __rdivmod__(self, value: float, /) -> tuple[float, float]: ...
     @overload
-    def __rpow__(self, __value: _PositiveInteger, __mod: None = None) -> float: ...
+    def __rpow__(self, value: _PositiveInteger, mod: None = None, /) -> float: ...
     @overload
-    def __rpow__(self, __value: _NegativeInteger, __mod: None = None) -> complex: ...
+    def __rpow__(self, value: _NegativeInteger, mod: None = None, /) -> complex: ...
     # Returning `complex` for the general case gives too many false-positive errors.
     @overload
-    def __rpow__(self, __value: float, __mod: None = None) -> Any: ...
+    def __rpow__(self, value: float, mod: None = None, /) -> Any: ...
     def __getnewargs__(self) -> tuple[float]: ...
     def __trunc__(self) -> int: ...
     if sys.version_info >= (3, 9):
         def __ceil__(self) -> int: ...
         def __floor__(self) -> int: ...
 
     @overload
-    def __round__(self, __ndigits: None = None) -> int: ...
+    def __round__(self, ndigits: None = None, /) -> int: ...
     @overload
-    def __round__(self, __ndigits: SupportsIndex) -> float: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
-    def __lt__(self, __value: float) -> bool: ...
-    def __le__(self, __value: float) -> bool: ...
-    def __gt__(self, __value: float) -> bool: ...
-    def __ge__(self, __value: float) -> bool: ...
+    def __round__(self, ndigits: SupportsIndex, /) -> float: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
+    def __lt__(self, value: float, /) -> bool: ...
+    def __le__(self, value: float, /) -> bool: ...
+    def __gt__(self, value: float, /) -> bool: ...
+    def __ge__(self, value: float, /) -> bool: ...
     def __neg__(self) -> float: ...
     def __pos__(self) -> float: ...
     def __int__(self) -> int: ...
     def __float__(self) -> float: ...
     def __abs__(self) -> float: ...
     def __hash__(self) -> int: ...
     def __bool__(self) -> bool: ...
@@ -399,331 +398,335 @@
     @overload
     def __new__(cls, real: str | SupportsComplex | SupportsFloat | SupportsIndex | complex) -> Self: ...
     @property
     def real(self) -> float: ...
     @property
     def imag(self) -> float: ...
     def conjugate(self) -> complex: ...
-    def __add__(self, __value: complex) -> complex: ...
-    def __sub__(self, __value: complex) -> complex: ...
-    def __mul__(self, __value: complex) -> complex: ...
-    def __pow__(self, __value: complex, __mod: None = None) -> complex: ...
-    def __truediv__(self, __value: complex) -> complex: ...
-    def __radd__(self, __value: complex) -> complex: ...
-    def __rsub__(self, __value: complex) -> complex: ...
-    def __rmul__(self, __value: complex) -> complex: ...
-    def __rpow__(self, __value: complex, __mod: None = None) -> complex: ...
-    def __rtruediv__(self, __value: complex) -> complex: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
+    def __add__(self, value: complex, /) -> complex: ...
+    def __sub__(self, value: complex, /) -> complex: ...
+    def __mul__(self, value: complex, /) -> complex: ...
+    def __pow__(self, value: complex, mod: None = None, /) -> complex: ...
+    def __truediv__(self, value: complex, /) -> complex: ...
+    def __radd__(self, value: complex, /) -> complex: ...
+    def __rsub__(self, value: complex, /) -> complex: ...
+    def __rmul__(self, value: complex, /) -> complex: ...
+    def __rpow__(self, value: complex, mod: None = None, /) -> complex: ...
+    def __rtruediv__(self, value: complex, /) -> complex: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
     def __neg__(self) -> complex: ...
     def __pos__(self) -> complex: ...
     def __abs__(self) -> float: ...
     def __hash__(self) -> int: ...
     def __bool__(self) -> bool: ...
     if sys.version_info >= (3, 11):
         def __complex__(self) -> complex: ...
 
 class _FormatMapMapping(Protocol):
-    def __getitem__(self, __key: str) -> Any: ...
+    def __getitem__(self, key: str, /) -> Any: ...
 
 class _TranslateTable(Protocol):
-    def __getitem__(self, __key: int) -> str | int | None: ...
+    def __getitem__(self, key: int, /) -> str | int | None: ...
 
 class str(Sequence[str]):
     @overload
     def __new__(cls, object: object = ...) -> Self: ...
     @overload
     def __new__(cls, object: ReadableBuffer, encoding: str = ..., errors: str = ...) -> Self: ...
     def capitalize(self) -> str: ...  # type: ignore[misc]
     def casefold(self) -> str: ...  # type: ignore[misc]
-    def center(self, __width: SupportsIndex, __fillchar: str = " ") -> str: ...  # type: ignore[misc]
-    def count(self, x: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...
+    def center(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ...  # type: ignore[misc]
+    def count(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
     def encode(self, encoding: str = "utf-8", errors: str = "strict") -> bytes: ...
     def endswith(
-        self, __suffix: str | tuple[str, ...], __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, suffix: str | tuple[str, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> bool: ...
     def expandtabs(self, tabsize: SupportsIndex = 8) -> str: ...  # type: ignore[misc]
-    def find(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...
+    def find(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
     def format(self, *args: object, **kwargs: object) -> str: ...
     def format_map(self, map: _FormatMapMapping) -> str: ...
-    def index(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...
+    def index(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
     def isalnum(self) -> bool: ...
     def isalpha(self) -> bool: ...
     def isascii(self) -> bool: ...
     def isdecimal(self) -> bool: ...
     def isdigit(self) -> bool: ...
     def isidentifier(self) -> bool: ...
     def islower(self) -> bool: ...
     def isnumeric(self) -> bool: ...
     def isprintable(self) -> bool: ...
     def isspace(self) -> bool: ...
     def istitle(self) -> bool: ...
     def isupper(self) -> bool: ...
-    def join(self, __iterable: Iterable[str]) -> str: ...  # type: ignore[misc]
-    def ljust(self, __width: SupportsIndex, __fillchar: str = " ") -> str: ...  # type: ignore[misc]
+    def join(self, iterable: Iterable[str], /) -> str: ...  # type: ignore[misc]
+    def ljust(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ...  # type: ignore[misc]
     def lower(self) -> str: ...  # type: ignore[misc]
-    def lstrip(self, __chars: str | None = None) -> str: ...  # type: ignore[misc]
-    def partition(self, __sep: str) -> tuple[str, str, str]: ...  # type: ignore[misc]
-    def replace(self, __old: str, __new: str, __count: SupportsIndex = -1) -> str: ...  # type: ignore[misc]
+    def lstrip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]
+    def partition(self, sep: str, /) -> tuple[str, str, str]: ...  # type: ignore[misc]
+    def replace(self, old: str, new: str, count: SupportsIndex = -1, /) -> str: ...  # type: ignore[misc]
     if sys.version_info >= (3, 9):
-        def removeprefix(self, __prefix: str) -> str: ...  # type: ignore[misc]
-        def removesuffix(self, __suffix: str) -> str: ...  # type: ignore[misc]
+        def removeprefix(self, prefix: str, /) -> str: ...  # type: ignore[misc]
+        def removesuffix(self, suffix: str, /) -> str: ...  # type: ignore[misc]
 
-    def rfind(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...
-    def rindex(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...
-    def rjust(self, __width: SupportsIndex, __fillchar: str = " ") -> str: ...  # type: ignore[misc]
-    def rpartition(self, __sep: str) -> tuple[str, str, str]: ...  # type: ignore[misc]
+    def rfind(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
+    def rindex(self, sub: str, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /) -> int: ...
+    def rjust(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ...  # type: ignore[misc]
+    def rpartition(self, sep: str, /) -> tuple[str, str, str]: ...  # type: ignore[misc]
     def rsplit(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]
-    def rstrip(self, __chars: str | None = None) -> str: ...  # type: ignore[misc]
+    def rstrip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]
     def split(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]
     def splitlines(self, keepends: bool = False) -> list[str]: ...  # type: ignore[misc]
     def startswith(
-        self, __prefix: str | tuple[str, ...], __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, prefix: str | tuple[str, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> bool: ...
-    def strip(self, __chars: str | None = None) -> str: ...  # type: ignore[misc]
+    def strip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]
     def swapcase(self) -> str: ...  # type: ignore[misc]
     def title(self) -> str: ...  # type: ignore[misc]
-    def translate(self, __table: _TranslateTable) -> str: ...
+    def translate(self, table: _TranslateTable, /) -> str: ...
     def upper(self) -> str: ...  # type: ignore[misc]
-    def zfill(self, __width: SupportsIndex) -> str: ...  # type: ignore[misc]
+    def zfill(self, width: SupportsIndex, /) -> str: ...  # type: ignore[misc]
     @staticmethod
     @overload
-    def maketrans(__x: dict[int, _T] | dict[str, _T] | dict[str | int, _T]) -> dict[int, _T]: ...
+    def maketrans(x: dict[int, _T] | dict[str, _T] | dict[str | int, _T], /) -> dict[int, _T]: ...
     @staticmethod
     @overload
-    def maketrans(__x: str, __y: str) -> dict[int, int]: ...
+    def maketrans(x: str, y: str, /) -> dict[int, int]: ...
     @staticmethod
     @overload
-    def maketrans(__x: str, __y: str, __z: str) -> dict[int, int | None]: ...
-    def __add__(self, __value: str) -> str: ...  # type: ignore[misc]
+    def maketrans(x: str, y: str, z: str, /) -> dict[int, int | None]: ...
+    def __add__(self, value: str, /) -> str: ...  # type: ignore[misc]
     # Incompatible with Sequence.__contains__
-    def __contains__(self, __key: str) -> bool: ...  # type: ignore[override]
-    def __eq__(self, __value: object) -> bool: ...
-    def __ge__(self, __value: str) -> bool: ...
-    def __getitem__(self, __key: SupportsIndex | slice) -> str: ...
-    def __gt__(self, __value: str) -> bool: ...
+    def __contains__(self, key: str, /) -> bool: ...  # type: ignore[override]
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ge__(self, value: str, /) -> bool: ...
+    def __getitem__(self, key: SupportsIndex | slice, /) -> str: ...
+    def __gt__(self, value: str, /) -> bool: ...
     def __hash__(self) -> int: ...
     def __iter__(self) -> Iterator[str]: ...  # type: ignore[misc]
-    def __le__(self, __value: str) -> bool: ...
+    def __le__(self, value: str, /) -> bool: ...
     def __len__(self) -> int: ...
-    def __lt__(self, __value: str) -> bool: ...
-    def __mod__(self, __value: Any) -> str: ...
-    def __mul__(self, __value: SupportsIndex) -> str: ...  # type: ignore[misc]
-    def __ne__(self, __value: object) -> bool: ...
-    def __rmul__(self, __value: SupportsIndex) -> str: ...  # type: ignore[misc]
+    def __lt__(self, value: str, /) -> bool: ...
+    def __mod__(self, value: Any, /) -> str: ...
+    def __mul__(self, value: SupportsIndex, /) -> str: ...  # type: ignore[misc]
+    def __ne__(self, value: object, /) -> bool: ...
+    def __rmul__(self, value: SupportsIndex, /) -> str: ...  # type: ignore[misc]
     def __getnewargs__(self) -> tuple[str]: ...
 
 class bytes(Sequence[int]):
     @overload
-    def __new__(cls, __o: Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | ReadableBuffer) -> Self: ...
+    def __new__(cls, o: Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | ReadableBuffer, /) -> Self: ...
     @overload
-    def __new__(cls, __string: str, encoding: str, errors: str = ...) -> Self: ...
+    def __new__(cls, string: str, /, encoding: str, errors: str = ...) -> Self: ...
     @overload
     def __new__(cls) -> Self: ...
     def capitalize(self) -> bytes: ...
-    def center(self, __width: SupportsIndex, __fillchar: bytes = b" ") -> bytes: ...
+    def center(self, width: SupportsIndex, fillchar: bytes = b" ", /) -> bytes: ...
     def count(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def decode(self, encoding: str = "utf-8", errors: str = "strict") -> str: ...
     def endswith(
         self,
-        __suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
-        __start: SupportsIndex | None = ...,
-        __end: SupportsIndex | None = ...,
+        suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
+        start: SupportsIndex | None = ...,
+        end: SupportsIndex | None = ...,
+        /,
     ) -> bool: ...
     def expandtabs(self, tabsize: SupportsIndex = 8) -> bytes: ...
     def find(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
     def index(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def isalnum(self) -> bool: ...
     def isalpha(self) -> bool: ...
     def isascii(self) -> bool: ...
     def isdigit(self) -> bool: ...
     def islower(self) -> bool: ...
     def isspace(self) -> bool: ...
     def istitle(self) -> bool: ...
     def isupper(self) -> bool: ...
-    def join(self, __iterable_of_bytes: Iterable[ReadableBuffer]) -> bytes: ...
-    def ljust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b" ") -> bytes: ...
+    def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytes: ...
+    def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytes: ...
     def lower(self) -> bytes: ...
-    def lstrip(self, __bytes: ReadableBuffer | None = None) -> bytes: ...
-    def partition(self, __sep: ReadableBuffer) -> tuple[bytes, bytes, bytes]: ...
-    def replace(self, __old: ReadableBuffer, __new: ReadableBuffer, __count: SupportsIndex = -1) -> bytes: ...
+    def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
+    def partition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...
+    def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytes: ...
     if sys.version_info >= (3, 9):
-        def removeprefix(self, __prefix: ReadableBuffer) -> bytes: ...
-        def removesuffix(self, __suffix: ReadableBuffer) -> bytes: ...
+        def removeprefix(self, prefix: ReadableBuffer, /) -> bytes: ...
+        def removesuffix(self, suffix: ReadableBuffer, /) -> bytes: ...
 
     def rfind(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def rindex(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
-    def rjust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b" ") -> bytes: ...
-    def rpartition(self, __sep: ReadableBuffer) -> tuple[bytes, bytes, bytes]: ...
+    def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytes: ...
+    def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...
     def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...
-    def rstrip(self, __bytes: ReadableBuffer | None = None) -> bytes: ...
+    def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
     def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...
     def splitlines(self, keepends: bool = False) -> list[bytes]: ...
     def startswith(
         self,
-        __prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
-        __start: SupportsIndex | None = ...,
-        __end: SupportsIndex | None = ...,
+        prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
+        start: SupportsIndex | None = ...,
+        end: SupportsIndex | None = ...,
+        /,
     ) -> bool: ...
-    def strip(self, __bytes: ReadableBuffer | None = None) -> bytes: ...
+    def strip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
     def swapcase(self) -> bytes: ...
     def title(self) -> bytes: ...
-    def translate(self, __table: ReadableBuffer | None, delete: bytes = b"") -> bytes: ...
+    def translate(self, table: ReadableBuffer | None, /, delete: bytes = b"") -> bytes: ...
     def upper(self) -> bytes: ...
-    def zfill(self, __width: SupportsIndex) -> bytes: ...
+    def zfill(self, width: SupportsIndex, /) -> bytes: ...
     @classmethod
-    def fromhex(cls, __string: str) -> Self: ...
+    def fromhex(cls, string: str, /) -> Self: ...
     @staticmethod
-    def maketrans(__frm: ReadableBuffer, __to: ReadableBuffer) -> bytes: ...
+    def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...
     def __len__(self) -> int: ...
     def __iter__(self) -> Iterator[int]: ...
     def __hash__(self) -> int: ...
     @overload
-    def __getitem__(self, __key: SupportsIndex) -> int: ...
+    def __getitem__(self, key: SupportsIndex, /) -> int: ...
     @overload
-    def __getitem__(self, __key: slice) -> bytes: ...
-    def __add__(self, __value: ReadableBuffer) -> bytes: ...
-    def __mul__(self, __value: SupportsIndex) -> bytes: ...
-    def __rmul__(self, __value: SupportsIndex) -> bytes: ...
-    def __mod__(self, __value: Any) -> bytes: ...
+    def __getitem__(self, key: slice, /) -> bytes: ...
+    def __add__(self, value: ReadableBuffer, /) -> bytes: ...
+    def __mul__(self, value: SupportsIndex, /) -> bytes: ...
+    def __rmul__(self, value: SupportsIndex, /) -> bytes: ...
+    def __mod__(self, value: Any, /) -> bytes: ...
     # Incompatible with Sequence.__contains__
-    def __contains__(self, __key: SupportsIndex | ReadableBuffer) -> bool: ...  # type: ignore[override]
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
-    def __lt__(self, __value: bytes) -> bool: ...
-    def __le__(self, __value: bytes) -> bool: ...
-    def __gt__(self, __value: bytes) -> bool: ...
-    def __ge__(self, __value: bytes) -> bool: ...
+    def __contains__(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ...  # type: ignore[override]
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
+    def __lt__(self, value: bytes, /) -> bool: ...
+    def __le__(self, value: bytes, /) -> bool: ...
+    def __gt__(self, value: bytes, /) -> bool: ...
+    def __ge__(self, value: bytes, /) -> bool: ...
     def __getnewargs__(self) -> tuple[bytes]: ...
     if sys.version_info >= (3, 11):
         def __bytes__(self) -> bytes: ...
 
-    def __buffer__(self, __flags: int) -> memoryview: ...
+    def __buffer__(self, flags: int, /) -> memoryview: ...
 
 class bytearray(MutableSequence[int]):
     @overload
     def __init__(self) -> None: ...
     @overload
-    def __init__(self, __ints: Iterable[SupportsIndex] | SupportsIndex | ReadableBuffer) -> None: ...
+    def __init__(self, ints: Iterable[SupportsIndex] | SupportsIndex | ReadableBuffer, /) -> None: ...
     @overload
-    def __init__(self, __string: str, encoding: str, errors: str = ...) -> None: ...
-    def append(self, __item: SupportsIndex) -> None: ...
+    def __init__(self, string: str, /, encoding: str, errors: str = ...) -> None: ...
+    def append(self, item: SupportsIndex, /) -> None: ...
     def capitalize(self) -> bytearray: ...
-    def center(self, __width: SupportsIndex, __fillchar: bytes = b" ") -> bytearray: ...
+    def center(self, width: SupportsIndex, fillchar: bytes = b" ", /) -> bytearray: ...
     def count(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def copy(self) -> bytearray: ...
     def decode(self, encoding: str = "utf-8", errors: str = "strict") -> str: ...
     def endswith(
         self,
-        __suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
-        __start: SupportsIndex | None = ...,
-        __end: SupportsIndex | None = ...,
+        suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
+        start: SupportsIndex | None = ...,
+        end: SupportsIndex | None = ...,
+        /,
     ) -> bool: ...
     def expandtabs(self, tabsize: SupportsIndex = 8) -> bytearray: ...
-    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...
+    def extend(self, iterable_of_ints: Iterable[SupportsIndex], /) -> None: ...
     def find(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
     def index(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
-    def insert(self, __index: SupportsIndex, __item: SupportsIndex) -> None: ...
+    def insert(self, index: SupportsIndex, item: SupportsIndex, /) -> None: ...
     def isalnum(self) -> bool: ...
     def isalpha(self) -> bool: ...
     def isascii(self) -> bool: ...
     def isdigit(self) -> bool: ...
     def islower(self) -> bool: ...
     def isspace(self) -> bool: ...
     def istitle(self) -> bool: ...
     def isupper(self) -> bool: ...
-    def join(self, __iterable_of_bytes: Iterable[ReadableBuffer]) -> bytearray: ...
-    def ljust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b" ") -> bytearray: ...
+    def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytearray: ...
+    def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytearray: ...
     def lower(self) -> bytearray: ...
-    def lstrip(self, __bytes: ReadableBuffer | None = None) -> bytearray: ...
-    def partition(self, __sep: ReadableBuffer) -> tuple[bytearray, bytearray, bytearray]: ...
-    def pop(self, __index: int = -1) -> int: ...
-    def remove(self, __value: int) -> None: ...
+    def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...
+    def partition(self, sep: ReadableBuffer, /) -> tuple[bytearray, bytearray, bytearray]: ...
+    def pop(self, index: int = -1, /) -> int: ...
+    def remove(self, value: int, /) -> None: ...
     if sys.version_info >= (3, 9):
-        def removeprefix(self, __prefix: ReadableBuffer) -> bytearray: ...
-        def removesuffix(self, __suffix: ReadableBuffer) -> bytearray: ...
+        def removeprefix(self, prefix: ReadableBuffer, /) -> bytearray: ...
+        def removesuffix(self, suffix: ReadableBuffer, /) -> bytearray: ...
 
-    def replace(self, __old: ReadableBuffer, __new: ReadableBuffer, __count: SupportsIndex = -1) -> bytearray: ...
+    def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytearray: ...
     def rfind(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
     def rindex(
-        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...
+        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., /
     ) -> int: ...
-    def rjust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b" ") -> bytearray: ...
-    def rpartition(self, __sep: ReadableBuffer) -> tuple[bytearray, bytearray, bytearray]: ...
+    def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytearray: ...
+    def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytearray, bytearray, bytearray]: ...
     def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...
-    def rstrip(self, __bytes: ReadableBuffer | None = None) -> bytearray: ...
+    def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...
     def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...
     def splitlines(self, keepends: bool = False) -> list[bytearray]: ...
     def startswith(
         self,
-        __prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
-        __start: SupportsIndex | None = ...,
-        __end: SupportsIndex | None = ...,
+        prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
+        start: SupportsIndex | None = ...,
+        end: SupportsIndex | None = ...,
+        /,
     ) -> bool: ...
-    def strip(self, __bytes: ReadableBuffer | None = None) -> bytearray: ...
+    def strip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...
     def swapcase(self) -> bytearray: ...
     def title(self) -> bytearray: ...
-    def translate(self, __table: ReadableBuffer | None, delete: bytes = b"") -> bytearray: ...
+    def translate(self, table: ReadableBuffer | None, /, delete: bytes = b"") -> bytearray: ...
     def upper(self) -> bytearray: ...
-    def zfill(self, __width: SupportsIndex) -> bytearray: ...
+    def zfill(self, width: SupportsIndex, /) -> bytearray: ...
     @classmethod
-    def fromhex(cls, __string: str) -> Self: ...
+    def fromhex(cls, string: str, /) -> Self: ...
     @staticmethod
-    def maketrans(__frm: ReadableBuffer, __to: ReadableBuffer) -> bytes: ...
+    def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...
     def __len__(self) -> int: ...
     def __iter__(self) -> Iterator[int]: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
     @overload
-    def __getitem__(self, __key: SupportsIndex) -> int: ...
+    def __getitem__(self, key: SupportsIndex, /) -> int: ...
     @overload
-    def __getitem__(self, __key: slice) -> bytearray: ...
+    def __getitem__(self, key: slice, /) -> bytearray: ...
     @overload
-    def __setitem__(self, __key: SupportsIndex, __value: SupportsIndex) -> None: ...
+    def __setitem__(self, key: SupportsIndex, value: SupportsIndex, /) -> None: ...
     @overload
-    def __setitem__(self, __key: slice, __value: Iterable[SupportsIndex] | bytes) -> None: ...
-    def __delitem__(self, __key: SupportsIndex | slice) -> None: ...
-    def __add__(self, __value: ReadableBuffer) -> bytearray: ...
+    def __setitem__(self, key: slice, value: Iterable[SupportsIndex] | bytes, /) -> None: ...
+    def __delitem__(self, key: SupportsIndex | slice, /) -> None: ...
+    def __add__(self, value: ReadableBuffer, /) -> bytearray: ...
     # The superclass wants us to accept Iterable[int], but that fails at runtime.
-    def __iadd__(self, __value: ReadableBuffer) -> Self: ...  # type: ignore[override]
-    def __mul__(self, __value: SupportsIndex) -> bytearray: ...
-    def __rmul__(self, __value: SupportsIndex) -> bytearray: ...
-    def __imul__(self, __value: SupportsIndex) -> Self: ...
-    def __mod__(self, __value: Any) -> bytes: ...
+    def __iadd__(self, value: ReadableBuffer, /) -> Self: ...  # type: ignore[override]
+    def __mul__(self, value: SupportsIndex, /) -> bytearray: ...
+    def __rmul__(self, value: SupportsIndex, /) -> bytearray: ...
+    def __imul__(self, value: SupportsIndex, /) -> Self: ...
+    def __mod__(self, value: Any, /) -> bytes: ...
     # Incompatible with Sequence.__contains__
-    def __contains__(self, __key: SupportsIndex | ReadableBuffer) -> bool: ...  # type: ignore[override]
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
-    def __lt__(self, __value: ReadableBuffer) -> bool: ...
-    def __le__(self, __value: ReadableBuffer) -> bool: ...
-    def __gt__(self, __value: ReadableBuffer) -> bool: ...
-    def __ge__(self, __value: ReadableBuffer) -> bool: ...
+    def __contains__(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ...  # type: ignore[override]
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
+    def __lt__(self, value: ReadableBuffer, /) -> bool: ...
+    def __le__(self, value: ReadableBuffer, /) -> bool: ...
+    def __gt__(self, value: ReadableBuffer, /) -> bool: ...
+    def __ge__(self, value: ReadableBuffer, /) -> bool: ...
     def __alloc__(self) -> int: ...
-    def __buffer__(self, __flags: int) -> memoryview: ...
-    def __release_buffer__(self, __buffer: memoryview) -> None: ...
+    def __buffer__(self, flags: int, /) -> memoryview: ...
+    def __release_buffer__(self, buffer: memoryview, /) -> None: ...
 
 @final
 class memoryview(Sequence[int]):
     @property
     def format(self) -> str: ...
     @property
     def itemsize(self) -> int: ...
@@ -746,116 +749,116 @@
     @property
     def contiguous(self) -> bool: ...
     @property
     def nbytes(self) -> int: ...
     def __new__(cls, obj: ReadableBuffer) -> Self: ...
     def __enter__(self) -> Self: ...
     def __exit__(
-        self, __exc_type: type[BaseException] | None, __exc_val: BaseException | None, __exc_tb: TracebackType | None
+        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None, /
     ) -> None: ...
     def cast(self, format: str, shape: list[int] | tuple[int, ...] = ...) -> memoryview: ...
     @overload
-    def __getitem__(self, __key: SupportsIndex | tuple[SupportsIndex, ...]) -> int: ...
+    def __getitem__(self, key: SupportsIndex | tuple[SupportsIndex, ...], /) -> int: ...
     @overload
-    def __getitem__(self, __key: slice) -> memoryview: ...
-    def __contains__(self, __x: object) -> bool: ...
+    def __getitem__(self, key: slice, /) -> memoryview: ...
+    def __contains__(self, x: object, /) -> bool: ...
     def __iter__(self) -> Iterator[int]: ...
     def __len__(self) -> int: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     @overload
-    def __setitem__(self, __key: slice, __value: ReadableBuffer) -> None: ...
+    def __setitem__(self, key: slice, value: ReadableBuffer, /) -> None: ...
     @overload
-    def __setitem__(self, __key: SupportsIndex | tuple[SupportsIndex, ...], __value: SupportsIndex) -> None: ...
+    def __setitem__(self, key: SupportsIndex | tuple[SupportsIndex, ...], value: SupportsIndex, /) -> None: ...
     if sys.version_info >= (3, 10):
         def tobytes(self, order: Literal["C", "F", "A"] | None = "C") -> bytes: ...
     else:
         def tobytes(self, order: Literal["C", "F", "A"] | None = None) -> bytes: ...
 
     def tolist(self) -> list[int]: ...
     def toreadonly(self) -> memoryview: ...
     def release(self) -> None: ...
     def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
-    def __buffer__(self, __flags: int) -> memoryview: ...
-    def __release_buffer__(self, __buffer: memoryview) -> None: ...
+    def __buffer__(self, flags: int, /) -> memoryview: ...
+    def __release_buffer__(self, buffer: memoryview, /) -> None: ...
 
 @final
 class bool(int):
-    def __new__(cls, __o: object = ...) -> Self: ...
+    def __new__(cls, o: object = ..., /) -> Self: ...
     # The following overloads could be represented more elegantly with a TypeVar("_B", bool, int),
     # however mypy has a bug regarding TypeVar constraints (https://github.com/python/mypy/issues/11880).
     @overload
-    def __and__(self, __value: bool) -> bool: ...
+    def __and__(self, value: bool, /) -> bool: ...
     @overload
-    def __and__(self, __value: int) -> int: ...
+    def __and__(self, value: int, /) -> int: ...
     @overload
-    def __or__(self, __value: bool) -> bool: ...
+    def __or__(self, value: bool, /) -> bool: ...
     @overload
-    def __or__(self, __value: int) -> int: ...
+    def __or__(self, value: int, /) -> int: ...
     @overload
-    def __xor__(self, __value: bool) -> bool: ...
+    def __xor__(self, value: bool, /) -> bool: ...
     @overload
-    def __xor__(self, __value: int) -> int: ...
+    def __xor__(self, value: int, /) -> int: ...
     @overload
-    def __rand__(self, __value: bool) -> bool: ...
+    def __rand__(self, value: bool, /) -> bool: ...
     @overload
-    def __rand__(self, __value: int) -> int: ...
+    def __rand__(self, value: int, /) -> int: ...
     @overload
-    def __ror__(self, __value: bool) -> bool: ...
+    def __ror__(self, value: bool, /) -> bool: ...
     @overload
-    def __ror__(self, __value: int) -> int: ...
+    def __ror__(self, value: int, /) -> int: ...
     @overload
-    def __rxor__(self, __value: bool) -> bool: ...
+    def __rxor__(self, value: bool, /) -> bool: ...
     @overload
-    def __rxor__(self, __value: int) -> int: ...
+    def __rxor__(self, value: int, /) -> int: ...
     def __getnewargs__(self) -> tuple[int]: ...
     @deprecated("Will throw an error in Python 3.14. Use `not` for logical negation of bools instead.")
     def __invert__(self) -> int: ...
 
 @final
 class slice:
     @property
     def start(self) -> Any: ...
     @property
     def step(self) -> Any: ...
     @property
     def stop(self) -> Any: ...
     @overload
-    def __new__(cls, __stop: Any) -> Self: ...
+    def __new__(cls, stop: Any, /) -> Self: ...
     @overload
-    def __new__(cls, __start: Any, __stop: Any, __step: Any = ...) -> Self: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __new__(cls, start: Any, stop: Any, step: Any = ..., /) -> Self: ...
+    def __eq__(self, value: object, /) -> bool: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
-    def indices(self, __len: SupportsIndex) -> tuple[int, int, int]: ...
+    def indices(self, len: SupportsIndex, /) -> tuple[int, int, int]: ...
 
 class tuple(Sequence[_T_co]):
-    def __new__(cls, __iterable: Iterable[_T_co] = ...) -> Self: ...
+    def __new__(cls, iterable: Iterable[_T_co] = ..., /) -> Self: ...
     def __len__(self) -> int: ...
-    def __contains__(self, __key: object) -> bool: ...
+    def __contains__(self, key: object, /) -> bool: ...
     @overload
-    def __getitem__(self, __key: SupportsIndex) -> _T_co: ...
+    def __getitem__(self, key: SupportsIndex, /) -> _T_co: ...
     @overload
-    def __getitem__(self, __key: slice) -> tuple[_T_co, ...]: ...
+    def __getitem__(self, key: slice, /) -> tuple[_T_co, ...]: ...
     def __iter__(self) -> Iterator[_T_co]: ...
-    def __lt__(self, __value: tuple[_T_co, ...]) -> bool: ...
-    def __le__(self, __value: tuple[_T_co, ...]) -> bool: ...
-    def __gt__(self, __value: tuple[_T_co, ...]) -> bool: ...
-    def __ge__(self, __value: tuple[_T_co, ...]) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __lt__(self, value: tuple[_T_co, ...], /) -> bool: ...
+    def __le__(self, value: tuple[_T_co, ...], /) -> bool: ...
+    def __gt__(self, value: tuple[_T_co, ...], /) -> bool: ...
+    def __ge__(self, value: tuple[_T_co, ...], /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     @overload
-    def __add__(self, __value: tuple[_T_co, ...]) -> tuple[_T_co, ...]: ...
+    def __add__(self, value: tuple[_T_co, ...], /) -> tuple[_T_co, ...]: ...
     @overload
-    def __add__(self, __value: tuple[_T, ...]) -> tuple[_T_co | _T, ...]: ...
-    def __mul__(self, __value: SupportsIndex) -> tuple[_T_co, ...]: ...
-    def __rmul__(self, __value: SupportsIndex) -> tuple[_T_co, ...]: ...
-    def count(self, __value: Any) -> int: ...
-    def index(self, __value: Any, __start: SupportsIndex = 0, __stop: SupportsIndex = sys.maxsize) -> int: ...
+    def __add__(self, value: tuple[_T, ...], /) -> tuple[_T_co | _T, ...]: ...
+    def __mul__(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...
+    def __rmul__(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...
+    def count(self, value: Any, /) -> int: ...
+    def index(self, value: Any, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 # Doesn't exist at runtime, but deleting this breaks mypy. See #2999
 @final
 @type_check_only
 class function:
     # Make sure this class definition stays roughly in line with `types.FunctionType`
     @property
@@ -873,298 +876,298 @@
         @property
         def __builtins__(self) -> dict[str, Any]: ...
     if sys.version_info >= (3, 12):
         __type_params__: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]
 
     __module__: str
     # mypy uses `builtins.function.__get__` to represent methods, properties, and getset_descriptors so we type the return as Any.
-    def __get__(self, __instance: object, __owner: type | None = None) -> Any: ...
+    def __get__(self, instance: object, owner: type | None = None, /) -> Any: ...
 
 class list(MutableSequence[_T]):
     @overload
     def __init__(self) -> None: ...
     @overload
-    def __init__(self, __iterable: Iterable[_T]) -> None: ...
+    def __init__(self, iterable: Iterable[_T], /) -> None: ...
     def copy(self) -> list[_T]: ...
-    def append(self, __object: _T) -> None: ...
-    def extend(self, __iterable: Iterable[_T]) -> None: ...
-    def pop(self, __index: SupportsIndex = -1) -> _T: ...
+    def append(self, object: _T, /) -> None: ...
+    def extend(self, iterable: Iterable[_T], /) -> None: ...
+    def pop(self, index: SupportsIndex = -1, /) -> _T: ...
     # Signature of `list.index` should be kept in line with `collections.UserList.index()`
     # and multiprocessing.managers.ListProxy.index()
-    def index(self, __value: _T, __start: SupportsIndex = 0, __stop: SupportsIndex = sys.maxsize) -> int: ...
-    def count(self, __value: _T) -> int: ...
-    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...
-    def remove(self, __value: _T) -> None: ...
+    def index(self, value: _T, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...
+    def count(self, value: _T, /) -> int: ...
+    def insert(self, index: SupportsIndex, object: _T, /) -> None: ...
+    def remove(self, value: _T, /) -> None: ...
     # Signature of `list.sort` should be kept inline with `collections.UserList.sort()`
     # and multiprocessing.managers.ListProxy.sort()
     #
     # Use list[SupportsRichComparisonT] for the first overload rather than [SupportsRichComparison]
     # to work around invariance
     @overload
     def sort(self: list[SupportsRichComparisonT], *, key: None = None, reverse: bool = False) -> None: ...
     @overload
     def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> None: ...
     def __len__(self) -> int: ...
     def __iter__(self) -> Iterator[_T]: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
     @overload
-    def __getitem__(self, __i: SupportsIndex) -> _T: ...
+    def __getitem__(self, i: SupportsIndex, /) -> _T: ...
     @overload
-    def __getitem__(self, __s: slice) -> list[_T]: ...
+    def __getitem__(self, s: slice, /) -> list[_T]: ...
     @overload
-    def __setitem__(self, __key: SupportsIndex, __value: _T) -> None: ...
+    def __setitem__(self, key: SupportsIndex, value: _T, /) -> None: ...
     @overload
-    def __setitem__(self, __key: slice, __value: Iterable[_T]) -> None: ...
-    def __delitem__(self, __key: SupportsIndex | slice) -> None: ...
+    def __setitem__(self, key: slice, value: Iterable[_T], /) -> None: ...
+    def __delitem__(self, key: SupportsIndex | slice, /) -> None: ...
     # Overloading looks unnecessary, but is needed to work around complex mypy problems
     @overload
-    def __add__(self, __value: list[_T]) -> list[_T]: ...
+    def __add__(self, value: list[_T], /) -> list[_T]: ...
     @overload
-    def __add__(self, __value: list[_S]) -> list[_S | _T]: ...
-    def __iadd__(self, __value: Iterable[_T]) -> Self: ...  # type: ignore[misc]
-    def __mul__(self, __value: SupportsIndex) -> list[_T]: ...
-    def __rmul__(self, __value: SupportsIndex) -> list[_T]: ...
-    def __imul__(self, __value: SupportsIndex) -> Self: ...
-    def __contains__(self, __key: object) -> bool: ...
+    def __add__(self, value: list[_S], /) -> list[_S | _T]: ...
+    def __iadd__(self, value: Iterable[_T], /) -> Self: ...  # type: ignore[misc]
+    def __mul__(self, value: SupportsIndex, /) -> list[_T]: ...
+    def __rmul__(self, value: SupportsIndex, /) -> list[_T]: ...
+    def __imul__(self, value: SupportsIndex, /) -> Self: ...
+    def __contains__(self, key: object, /) -> bool: ...
     def __reversed__(self) -> Iterator[_T]: ...
-    def __gt__(self, __value: list[_T]) -> bool: ...
-    def __ge__(self, __value: list[_T]) -> bool: ...
-    def __lt__(self, __value: list[_T]) -> bool: ...
-    def __le__(self, __value: list[_T]) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __gt__(self, value: list[_T], /) -> bool: ...
+    def __ge__(self, value: list[_T], /) -> bool: ...
+    def __lt__(self, value: list[_T], /) -> bool: ...
+    def __le__(self, value: list[_T], /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 class dict(MutableMapping[_KT, _VT]):
     # __init__ should be kept roughly in line with `collections.UserDict.__init__`, which has similar semantics
     # Also multiprocessing.managers.SyncManager.dict()
     @overload
     def __init__(self) -> None: ...
     @overload
     def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...
     @overload
-    def __init__(self, __map: SupportsKeysAndGetItem[_KT, _VT]) -> None: ...
+    def __init__(self, map: SupportsKeysAndGetItem[_KT, _VT], /) -> None: ...
     @overload
-    def __init__(self: dict[str, _VT], __map: SupportsKeysAndGetItem[str, _VT], **kwargs: _VT) -> None: ...
+    def __init__(self: dict[str, _VT], map: SupportsKeysAndGetItem[str, _VT], /, **kwargs: _VT) -> None: ...
     @overload
-    def __init__(self, __iterable: Iterable[tuple[_KT, _VT]]) -> None: ...
+    def __init__(self, iterable: Iterable[tuple[_KT, _VT]], /) -> None: ...
     @overload
-    def __init__(self: dict[str, _VT], __iterable: Iterable[tuple[str, _VT]], **kwargs: _VT) -> None: ...
+    def __init__(self: dict[str, _VT], iterable: Iterable[tuple[str, _VT]], /, **kwargs: _VT) -> None: ...
     # Next two overloads are for dict(string.split(sep) for string in iterable)
     # Cannot be Iterable[Sequence[_T]] or otherwise dict(["foo", "bar", "baz"]) is not an error
     @overload
-    def __init__(self: dict[str, str], __iterable: Iterable[list[str]]) -> None: ...
+    def __init__(self: dict[str, str], iterable: Iterable[list[str]], /) -> None: ...
     @overload
-    def __init__(self: dict[bytes, bytes], __iterable: Iterable[list[bytes]]) -> None: ...
+    def __init__(self: dict[bytes, bytes], iterable: Iterable[list[bytes]], /) -> None: ...
     def __new__(cls, *args: Any, **kwargs: Any) -> Self: ...
     def copy(self) -> dict[_KT, _VT]: ...
     def keys(self) -> dict_keys[_KT, _VT]: ...
     def values(self) -> dict_values[_KT, _VT]: ...
     def items(self) -> dict_items[_KT, _VT]: ...
     # Signature of `dict.fromkeys` should be kept identical to `fromkeys` methods of `OrderedDict`/`ChainMap`/`UserDict` in `collections`
     # TODO: the true signature of `dict.fromkeys` is not expressible in the current type system.
     # See #3800 & https://github.com/python/typing/issues/548#issuecomment-683336963.
     @classmethod
     @overload
-    def fromkeys(cls, __iterable: Iterable[_T], __value: None = None) -> dict[_T, Any | None]: ...
+    def fromkeys(cls, iterable: Iterable[_T], value: None = None, /) -> dict[_T, Any | None]: ...
     @classmethod
     @overload
-    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...
+    def fromkeys(cls, iterable: Iterable[_T], value: _S, /) -> dict[_T, _S]: ...
     # Positional-only in dict, but not in MutableMapping
     @overload  # type: ignore[override]
-    def get(self, __key: _KT) -> _VT | None: ...
+    def get(self, key: _KT, /) -> _VT | None: ...
     @overload
-    def get(self, __key: _KT, __default: _VT) -> _VT: ...
+    def get(self, key: _KT, default: _VT, /) -> _VT: ...
     @overload
-    def get(self, __key: _KT, __default: _T) -> _VT | _T: ...
+    def get(self, key: _KT, default: _T, /) -> _VT | _T: ...
     @overload
-    def pop(self, __key: _KT) -> _VT: ...
+    def pop(self, key: _KT, /) -> _VT: ...
     @overload
-    def pop(self, __key: _KT, __default: _VT) -> _VT: ...
+    def pop(self, key: _KT, default: _VT, /) -> _VT: ...
     @overload
-    def pop(self, __key: _KT, __default: _T) -> _VT | _T: ...
+    def pop(self, key: _KT, default: _T, /) -> _VT | _T: ...
     def __len__(self) -> int: ...
-    def __getitem__(self, __key: _KT) -> _VT: ...
-    def __setitem__(self, __key: _KT, __value: _VT) -> None: ...
-    def __delitem__(self, __key: _KT) -> None: ...
+    def __getitem__(self, key: _KT, /) -> _VT: ...
+    def __setitem__(self, key: _KT, value: _VT, /) -> None: ...
+    def __delitem__(self, key: _KT, /) -> None: ...
     def __iter__(self) -> Iterator[_KT]: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __reversed__(self) -> Iterator[_KT]: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
         @overload
-        def __or__(self, __value: dict[_KT, _VT]) -> dict[_KT, _VT]: ...
+        def __or__(self, value: dict[_KT, _VT], /) -> dict[_KT, _VT]: ...
         @overload
-        def __or__(self, __value: dict[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...
+        def __or__(self, value: dict[_T1, _T2], /) -> dict[_KT | _T1, _VT | _T2]: ...
         @overload
-        def __ror__(self, __value: dict[_KT, _VT]) -> dict[_KT, _VT]: ...
+        def __ror__(self, value: dict[_KT, _VT], /) -> dict[_KT, _VT]: ...
         @overload
-        def __ror__(self, __value: dict[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...
+        def __ror__(self, value: dict[_T1, _T2], /) -> dict[_KT | _T1, _VT | _T2]: ...
         # dict.__ior__ should be kept roughly in line with MutableMapping.update()
         @overload  # type: ignore[misc]
-        def __ior__(self, __value: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...
+        def __ior__(self, value: SupportsKeysAndGetItem[_KT, _VT], /) -> Self: ...
         @overload
-        def __ior__(self, __value: Iterable[tuple[_KT, _VT]]) -> Self: ...
+        def __ior__(self, value: Iterable[tuple[_KT, _VT]], /) -> Self: ...
 
 class set(MutableSet[_T]):
     @overload
     def __init__(self) -> None: ...
     @overload
-    def __init__(self, __iterable: Iterable[_T]) -> None: ...
-    def add(self, __element: _T) -> None: ...
+    def __init__(self, iterable: Iterable[_T], /) -> None: ...
+    def add(self, element: _T, /) -> None: ...
     def copy(self) -> set[_T]: ...
     def difference(self, *s: Iterable[Any]) -> set[_T]: ...
     def difference_update(self, *s: Iterable[Any]) -> None: ...
-    def discard(self, __element: _T) -> None: ...
+    def discard(self, element: _T, /) -> None: ...
     def intersection(self, *s: Iterable[Any]) -> set[_T]: ...
     def intersection_update(self, *s: Iterable[Any]) -> None: ...
-    def isdisjoint(self, __s: Iterable[Any]) -> bool: ...
-    def issubset(self, __s: Iterable[Any]) -> bool: ...
-    def issuperset(self, __s: Iterable[Any]) -> bool: ...
-    def remove(self, __element: _T) -> None: ...
-    def symmetric_difference(self, __s: Iterable[_T]) -> set[_T]: ...
-    def symmetric_difference_update(self, __s: Iterable[_T]) -> None: ...
+    def isdisjoint(self, s: Iterable[Any], /) -> bool: ...
+    def issubset(self, s: Iterable[Any], /) -> bool: ...
+    def issuperset(self, s: Iterable[Any], /) -> bool: ...
+    def remove(self, element: _T, /) -> None: ...
+    def symmetric_difference(self, s: Iterable[_T], /) -> set[_T]: ...
+    def symmetric_difference_update(self, s: Iterable[_T], /) -> None: ...
     def union(self, *s: Iterable[_S]) -> set[_T | _S]: ...
     def update(self, *s: Iterable[_T]) -> None: ...
     def __len__(self) -> int: ...
-    def __contains__(self, __o: object) -> bool: ...
+    def __contains__(self, o: object, /) -> bool: ...
     def __iter__(self) -> Iterator[_T]: ...
-    def __and__(self, __value: AbstractSet[object]) -> set[_T]: ...
-    def __iand__(self, __value: AbstractSet[object]) -> Self: ...
-    def __or__(self, __value: AbstractSet[_S]) -> set[_T | _S]: ...
-    def __ior__(self, __value: AbstractSet[_T]) -> Self: ...  # type: ignore[override,misc]
-    def __sub__(self, __value: AbstractSet[_T | None]) -> set[_T]: ...
-    def __isub__(self, __value: AbstractSet[object]) -> Self: ...
-    def __xor__(self, __value: AbstractSet[_S]) -> set[_T | _S]: ...
-    def __ixor__(self, __value: AbstractSet[_T]) -> Self: ...  # type: ignore[override,misc]
-    def __le__(self, __value: AbstractSet[object]) -> bool: ...
-    def __lt__(self, __value: AbstractSet[object]) -> bool: ...
-    def __ge__(self, __value: AbstractSet[object]) -> bool: ...
-    def __gt__(self, __value: AbstractSet[object]) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __and__(self, value: AbstractSet[object], /) -> set[_T]: ...
+    def __iand__(self, value: AbstractSet[object], /) -> Self: ...
+    def __or__(self, value: AbstractSet[_S], /) -> set[_T | _S]: ...
+    def __ior__(self, value: AbstractSet[_T], /) -> Self: ...  # type: ignore[override,misc]
+    def __sub__(self, value: AbstractSet[_T | None], /) -> set[_T]: ...
+    def __isub__(self, value: AbstractSet[object], /) -> Self: ...
+    def __xor__(self, value: AbstractSet[_S], /) -> set[_T | _S]: ...
+    def __ixor__(self, value: AbstractSet[_T], /) -> Self: ...  # type: ignore[override,misc]
+    def __le__(self, value: AbstractSet[object], /) -> bool: ...
+    def __lt__(self, value: AbstractSet[object], /) -> bool: ...
+    def __ge__(self, value: AbstractSet[object], /) -> bool: ...
+    def __gt__(self, value: AbstractSet[object], /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 class frozenset(AbstractSet[_T_co]):
     @overload
     def __new__(cls) -> Self: ...
     @overload
-    def __new__(cls, __iterable: Iterable[_T_co]) -> Self: ...
+    def __new__(cls, iterable: Iterable[_T_co], /) -> Self: ...
     def copy(self) -> frozenset[_T_co]: ...
     def difference(self, *s: Iterable[object]) -> frozenset[_T_co]: ...
     def intersection(self, *s: Iterable[object]) -> frozenset[_T_co]: ...
-    def isdisjoint(self, __s: Iterable[_T_co]) -> bool: ...
-    def issubset(self, __s: Iterable[object]) -> bool: ...
-    def issuperset(self, __s: Iterable[object]) -> bool: ...
-    def symmetric_difference(self, __s: Iterable[_T_co]) -> frozenset[_T_co]: ...
+    def isdisjoint(self, s: Iterable[_T_co], /) -> bool: ...
+    def issubset(self, s: Iterable[object], /) -> bool: ...
+    def issuperset(self, s: Iterable[object], /) -> bool: ...
+    def symmetric_difference(self, s: Iterable[_T_co], /) -> frozenset[_T_co]: ...
     def union(self, *s: Iterable[_S]) -> frozenset[_T_co | _S]: ...
     def __len__(self) -> int: ...
-    def __contains__(self, __o: object) -> bool: ...
+    def __contains__(self, o: object, /) -> bool: ...
     def __iter__(self) -> Iterator[_T_co]: ...
-    def __and__(self, __value: AbstractSet[_T_co]) -> frozenset[_T_co]: ...
-    def __or__(self, __value: AbstractSet[_S]) -> frozenset[_T_co | _S]: ...
-    def __sub__(self, __value: AbstractSet[_T_co]) -> frozenset[_T_co]: ...
-    def __xor__(self, __value: AbstractSet[_S]) -> frozenset[_T_co | _S]: ...
-    def __le__(self, __value: AbstractSet[object]) -> bool: ...
-    def __lt__(self, __value: AbstractSet[object]) -> bool: ...
-    def __ge__(self, __value: AbstractSet[object]) -> bool: ...
-    def __gt__(self, __value: AbstractSet[object]) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __and__(self, value: AbstractSet[_T_co], /) -> frozenset[_T_co]: ...
+    def __or__(self, value: AbstractSet[_S], /) -> frozenset[_T_co | _S]: ...
+    def __sub__(self, value: AbstractSet[_T_co], /) -> frozenset[_T_co]: ...
+    def __xor__(self, value: AbstractSet[_S], /) -> frozenset[_T_co | _S]: ...
+    def __le__(self, value: AbstractSet[object], /) -> bool: ...
+    def __lt__(self, value: AbstractSet[object], /) -> bool: ...
+    def __ge__(self, value: AbstractSet[object], /) -> bool: ...
+    def __gt__(self, value: AbstractSet[object], /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 class enumerate(Iterator[tuple[int, _T]]):
     def __new__(cls, iterable: Iterable[_T], start: int = ...) -> Self: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> tuple[int, _T]: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 @final
 class range(Sequence[int]):
     @property
     def start(self) -> int: ...
     @property
     def stop(self) -> int: ...
     @property
     def step(self) -> int: ...
     @overload
-    def __new__(cls, __stop: SupportsIndex) -> Self: ...
+    def __new__(cls, stop: SupportsIndex, /) -> Self: ...
     @overload
-    def __new__(cls, __start: SupportsIndex, __stop: SupportsIndex, __step: SupportsIndex = ...) -> Self: ...
-    def count(self, __value: int) -> int: ...
-    def index(self, __value: int) -> int: ...  # type: ignore[override]
+    def __new__(cls, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ..., /) -> Self: ...
+    def count(self, value: int, /) -> int: ...
+    def index(self, value: int, /) -> int: ...  # type: ignore[override]
     def __len__(self) -> int: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
-    def __contains__(self, __key: object) -> bool: ...
+    def __contains__(self, key: object, /) -> bool: ...
     def __iter__(self) -> Iterator[int]: ...
     @overload
-    def __getitem__(self, __key: SupportsIndex) -> int: ...
+    def __getitem__(self, key: SupportsIndex, /) -> int: ...
     @overload
-    def __getitem__(self, __key: slice) -> range: ...
+    def __getitem__(self, key: slice, /) -> range: ...
     def __reversed__(self) -> Iterator[int]: ...
 
 class property:
     fget: Callable[[Any], Any] | None
     fset: Callable[[Any, Any], None] | None
     fdel: Callable[[Any], None] | None
     __isabstractmethod__: bool
     def __init__(
         self,
         fget: Callable[[Any], Any] | None = ...,
         fset: Callable[[Any, Any], None] | None = ...,
         fdel: Callable[[Any], None] | None = ...,
         doc: str | None = ...,
     ) -> None: ...
-    def getter(self, __fget: Callable[[Any], Any]) -> property: ...
-    def setter(self, __fset: Callable[[Any, Any], None]) -> property: ...
-    def deleter(self, __fdel: Callable[[Any], None]) -> property: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
-    def __set__(self, __instance: Any, __value: Any) -> None: ...
-    def __delete__(self, __instance: Any) -> None: ...
+    def getter(self, fget: Callable[[Any], Any], /) -> property: ...
+    def setter(self, fset: Callable[[Any, Any], None], /) -> property: ...
+    def deleter(self, fdel: Callable[[Any], None], /) -> property: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
+    def __set__(self, instance: Any, value: Any, /) -> None: ...
+    def __delete__(self, instance: Any, /) -> None: ...
 
 @final
 class _NotImplementedType(Any):
     # A little weird, but typing the __call__ as NotImplemented makes the error message
     # for NotImplemented() much better
-    __call__: NotImplemented  # type: ignore[valid-type]  # pyright: ignore[reportGeneralTypeIssues]
+    __call__: NotImplemented  # type: ignore[valid-type]  # pyright: ignore[reportInvalidTypeForm]
 
 NotImplemented: _NotImplementedType
 
-def abs(__x: SupportsAbs[_T]) -> _T: ...
-def all(__iterable: Iterable[object]) -> bool: ...
-def any(__iterable: Iterable[object]) -> bool: ...
-def ascii(__obj: object) -> str: ...
-def bin(__number: int | SupportsIndex) -> str: ...
+def abs(x: SupportsAbs[_T], /) -> _T: ...
+def all(iterable: Iterable[object], /) -> bool: ...
+def any(iterable: Iterable[object], /) -> bool: ...
+def ascii(obj: object, /) -> str: ...
+def bin(number: int | SupportsIndex, /) -> str: ...
 def breakpoint(*args: Any, **kws: Any) -> None: ...
-def callable(__obj: object) -> TypeGuard[Callable[..., object]]: ...
-def chr(__i: int) -> str: ...
+def callable(obj: object, /) -> TypeGuard[Callable[..., object]]: ...
+def chr(i: int, /) -> str: ...
 
 # We define this here instead of using os.PathLike to avoid import cycle issues.
 # See https://github.com/python/typeshed/pull/991#issuecomment-288160993
 class _PathLike(Protocol[AnyStr_co]):
     def __fspath__(self) -> AnyStr_co: ...
 
 if sys.version_info >= (3, 10):
-    def aiter(__async_iterable: SupportsAiter[_SupportsAnextT]) -> _SupportsAnextT: ...
+    def aiter(async_iterable: SupportsAiter[_SupportsAnextT], /) -> _SupportsAnextT: ...
 
     class _SupportsSynchronousAnext(Protocol[_AwaitableT_co]):
         def __anext__(self) -> _AwaitableT_co: ...
 
     @overload
     # `anext` is not, in fact, an async function. When default is not provided
     # `anext` is just a passthrough for `obj.__anext__`
     # See discussion in #7491 and pure-Python implementation of `anext` at https://github.com/python/cpython/blob/ea786a882b9ed4261eafabad6011bc7ef3b5bf94/Lib/test/test_asyncgen.py#L52-L80
-    def anext(__i: _SupportsSynchronousAnext[_AwaitableT]) -> _AwaitableT: ...
+    def anext(i: _SupportsSynchronousAnext[_AwaitableT], /) -> _AwaitableT: ...
     @overload
-    async def anext(__i: SupportsAnext[_T], __default: _VT) -> _T | _VT: ...
+    async def anext(i: SupportsAnext[_T], default: _VT, /) -> _T | _VT: ...
 
 # compile() returns a CodeType, unless the flags argument includes PyCF_ONLY_AST (=1024),
 # in which case it returns ast.AST. We have overloads for flag 0 (the default) and for
 # explicitly passing PyCF_ONLY_AST. We fall back to Any for other values of flags.
 @overload
 def compile(
     source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,
@@ -1206,183 +1209,186 @@
     dont_inherit: bool = False,
     optimize: int = -1,
     *,
     _feature_version: int = -1,
 ) -> Any: ...
 def copyright() -> None: ...
 def credits() -> None: ...
-def delattr(__obj: object, __name: str) -> None: ...
-def dir(__o: object = ...) -> list[str]: ...
+def delattr(obj: object, name: str, /) -> None: ...
+def dir(o: object = ..., /) -> list[str]: ...
 @overload
-def divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...
+def divmod(x: SupportsDivMod[_T_contra, _T_co], y: _T_contra, /) -> _T_co: ...
 @overload
-def divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...
+def divmod(x: _T_contra, y: SupportsRDivMod[_T_contra, _T_co], /) -> _T_co: ...
 
 # The `globals` argument to `eval` has to be `dict[str, Any]` rather than `dict[str, object]` due to invariance.
 # (The `globals` argument has to be a "real dict", rather than any old mapping, unlike the `locals` argument.)
 def eval(
-    __source: str | ReadableBuffer | CodeType,
-    __globals: dict[str, Any] | None = None,
-    __locals: Mapping[str, object] | None = None,
+    source: str | ReadableBuffer | CodeType, globals: dict[str, Any] | None = None, locals: Mapping[str, object] | None = None, /
 ) -> Any: ...
 
 # Comment above regarding `eval` applies to `exec` as well
 if sys.version_info >= (3, 11):
     def exec(
-        __source: str | ReadableBuffer | CodeType,
-        __globals: dict[str, Any] | None = None,
-        __locals: Mapping[str, object] | None = None,
+        source: str | ReadableBuffer | CodeType,
+        globals: dict[str, Any] | None = None,
+        locals: Mapping[str, object] | None = None,
+        /,
         *,
         closure: tuple[_Cell, ...] | None = None,
     ) -> None: ...
 
 else:
     def exec(
-        __source: str | ReadableBuffer | CodeType,
-        __globals: dict[str, Any] | None = None,
-        __locals: Mapping[str, object] | None = None,
+        source: str | ReadableBuffer | CodeType,
+        globals: dict[str, Any] | None = None,
+        locals: Mapping[str, object] | None = None,
+        /,
     ) -> None: ...
 
 def exit(code: sys._ExitCode = None) -> NoReturn: ...
 
 class filter(Iterator[_T]):
     @overload
-    def __new__(cls, __function: None, __iterable: Iterable[_T | None]) -> Self: ...
+    def __new__(cls, function: None, iterable: Iterable[_T | None], /) -> Self: ...
     @overload
-    def __new__(cls, __function: Callable[[_S], TypeGuard[_T]], __iterable: Iterable[_S]) -> Self: ...
+    def __new__(cls, function: Callable[[_S], TypeGuard[_T]], iterable: Iterable[_S], /) -> Self: ...
     @overload
-    def __new__(cls, __function: Callable[[_T], Any], __iterable: Iterable[_T]) -> Self: ...
+    def __new__(cls, function: Callable[[_T], Any], iterable: Iterable[_T], /) -> Self: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T: ...
 
-def format(__value: object, __format_spec: str = "") -> str: ...
+def format(value: object, format_spec: str = "", /) -> str: ...
 @overload
-def getattr(__o: object, __name: str) -> Any: ...
+def getattr(o: object, name: str, /) -> Any: ...
 
 # While technically covered by the last overload, spelling out the types for None, bool
 # and basic containers help mypy out in some tricky situations involving type context
 # (aka bidirectional inference)
 @overload
-def getattr(__o: object, __name: str, __default: None) -> Any | None: ...
+def getattr(o: object, name: str, default: None, /) -> Any | None: ...
 @overload
-def getattr(__o: object, __name: str, __default: bool) -> Any | bool: ...
+def getattr(o: object, name: str, default: bool, /) -> Any | bool: ...
 @overload
-def getattr(__o: object, __name: str, __default: list[Any]) -> Any | list[Any]: ...
+def getattr(o: object, name: str, default: list[Any], /) -> Any | list[Any]: ...
 @overload
-def getattr(__o: object, __name: str, __default: dict[Any, Any]) -> Any | dict[Any, Any]: ...
+def getattr(o: object, name: str, default: dict[Any, Any], /) -> Any | dict[Any, Any]: ...
 @overload
-def getattr(__o: object, __name: str, __default: _T) -> Any | _T: ...
+def getattr(o: object, name: str, default: _T, /) -> Any | _T: ...
 def globals() -> dict[str, Any]: ...
-def hasattr(__obj: object, __name: str) -> bool: ...
-def hash(__obj: object) -> int: ...
+def hasattr(obj: object, name: str, /) -> bool: ...
+def hash(obj: object, /) -> int: ...
 def help(request: object = ...) -> None: ...
-def hex(__number: int | SupportsIndex) -> str: ...
-def id(__obj: object) -> int: ...
-def input(__prompt: object = "") -> str: ...
+def hex(number: int | SupportsIndex, /) -> str: ...
+def id(obj: object, /) -> int: ...
+def input(prompt: object = "", /) -> str: ...
 
 class _GetItemIterable(Protocol[_T_co]):
-    def __getitem__(self, __i: int) -> _T_co: ...
+    def __getitem__(self, i: int, /) -> _T_co: ...
 
 @overload
-def iter(__object: SupportsIter[_SupportsNextT]) -> _SupportsNextT: ...
+def iter(object: SupportsIter[_SupportsNextT], /) -> _SupportsNextT: ...
 @overload
-def iter(__object: _GetItemIterable[_T]) -> Iterator[_T]: ...
+def iter(object: _GetItemIterable[_T], /) -> Iterator[_T]: ...
 @overload
-def iter(__object: Callable[[], _T | None], __sentinel: None) -> Iterator[_T]: ...
+def iter(object: Callable[[], _T | None], sentinel: None, /) -> Iterator[_T]: ...
 @overload
-def iter(__object: Callable[[], _T], __sentinel: object) -> Iterator[_T]: ...
+def iter(object: Callable[[], _T], sentinel: object, /) -> Iterator[_T]: ...
 
 # Keep this alias in sync with unittest.case._ClassInfo
 if sys.version_info >= (3, 10):
     _ClassInfo: TypeAlias = type | types.UnionType | tuple[_ClassInfo, ...]
 else:
     _ClassInfo: TypeAlias = type | tuple[_ClassInfo, ...]
 
-def isinstance(__obj: object, __class_or_tuple: _ClassInfo) -> bool: ...
-def issubclass(__cls: type, __class_or_tuple: _ClassInfo) -> bool: ...
-def len(__obj: Sized) -> int: ...
+def isinstance(obj: object, class_or_tuple: _ClassInfo, /) -> bool: ...
+def issubclass(cls: type, class_or_tuple: _ClassInfo, /) -> bool: ...
+def len(obj: Sized, /) -> int: ...
 def license() -> None: ...
 def locals() -> dict[str, Any]: ...
 
 class map(Iterator[_S]):
     @overload
-    def __new__(cls, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> Self: ...
+    def __new__(cls, func: Callable[[_T1], _S], iter1: Iterable[_T1], /) -> Self: ...
     @overload
-    def __new__(cls, __func: Callable[[_T1, _T2], _S], __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> Self: ...
+    def __new__(cls, func: Callable[[_T1, _T2], _S], iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> Self: ...
     @overload
     def __new__(
-        cls, __func: Callable[[_T1, _T2, _T3], _S], __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]
+        cls, func: Callable[[_T1, _T2, _T3], _S], iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /
     ) -> Self: ...
     @overload
     def __new__(
         cls,
-        __func: Callable[[_T1, _T2, _T3, _T4], _S],
-        __iter1: Iterable[_T1],
-        __iter2: Iterable[_T2],
-        __iter3: Iterable[_T3],
-        __iter4: Iterable[_T4],
+        func: Callable[[_T1, _T2, _T3, _T4], _S],
+        iter1: Iterable[_T1],
+        iter2: Iterable[_T2],
+        iter3: Iterable[_T3],
+        iter4: Iterable[_T4],
+        /,
     ) -> Self: ...
     @overload
     def __new__(
         cls,
-        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],
-        __iter1: Iterable[_T1],
-        __iter2: Iterable[_T2],
-        __iter3: Iterable[_T3],
-        __iter4: Iterable[_T4],
-        __iter5: Iterable[_T5],
+        func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],
+        iter1: Iterable[_T1],
+        iter2: Iterable[_T2],
+        iter3: Iterable[_T3],
+        iter4: Iterable[_T4],
+        iter5: Iterable[_T5],
+        /,
     ) -> Self: ...
     @overload
     def __new__(
         cls,
-        __func: Callable[..., _S],
-        __iter1: Iterable[Any],
-        __iter2: Iterable[Any],
-        __iter3: Iterable[Any],
-        __iter4: Iterable[Any],
-        __iter5: Iterable[Any],
-        __iter6: Iterable[Any],
+        func: Callable[..., _S],
+        iter1: Iterable[Any],
+        iter2: Iterable[Any],
+        iter3: Iterable[Any],
+        iter4: Iterable[Any],
+        iter5: Iterable[Any],
+        iter6: Iterable[Any],
+        /,
         *iterables: Iterable[Any],
     ) -> Self: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _S: ...
 
 @overload
 def max(
-    __arg1: SupportsRichComparisonT, __arg2: SupportsRichComparisonT, *_args: SupportsRichComparisonT, key: None = None
+    arg1: SupportsRichComparisonT, arg2: SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = None
 ) -> SupportsRichComparisonT: ...
 @overload
-def max(__arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
+def max(arg1: _T, arg2: _T, /, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
 @overload
-def max(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None) -> SupportsRichComparisonT: ...
+def max(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None) -> SupportsRichComparisonT: ...
 @overload
-def max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
+def max(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
 @overload
-def max(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...
+def max(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...
 @overload
-def max(__iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
+def max(iterable: Iterable[_T1], /, *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
 @overload
 def min(
-    __arg1: SupportsRichComparisonT, __arg2: SupportsRichComparisonT, *_args: SupportsRichComparisonT, key: None = None
+    arg1: SupportsRichComparisonT, arg2: SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = None
 ) -> SupportsRichComparisonT: ...
 @overload
-def min(__arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
+def min(arg1: _T, arg2: _T, /, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
 @overload
-def min(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None) -> SupportsRichComparisonT: ...
+def min(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None) -> SupportsRichComparisonT: ...
 @overload
-def min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
+def min(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
 @overload
-def min(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...
+def min(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...
 @overload
-def min(__iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
+def min(iterable: Iterable[_T1], /, *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
 @overload
-def next(__i: SupportsNext[_T]) -> _T: ...
+def next(i: SupportsNext[_T], /) -> _T: ...
 @overload
-def next(__i: SupportsNext[_T], __default: _VT) -> _T | _VT: ...
-def oct(__number: int | SupportsIndex) -> str: ...
+def next(i: SupportsNext[_T], default: _VT, /) -> _T | _VT: ...
+def oct(number: int | SupportsIndex, /) -> str: ...
 
 _Opener: TypeAlias = Callable[[str, int], int]
 
 # Text mode: always returns a TextIOWrapper
 @overload
 def open(
     file: FileDescriptorOrPath,
@@ -1464,15 +1470,15 @@
     buffering: int = -1,
     encoding: str | None = None,
     errors: str | None = None,
     newline: str | None = None,
     closefd: bool = True,
     opener: _Opener | None = None,
 ) -> IO[Any]: ...
-def ord(__c: str | bytes | bytearray) -> int: ...
+def ord(c: str | bytes | bytearray, /) -> int: ...
 
 class _SupportsWriteAndFlush(SupportsWrite[_T_contra], SupportsFlush, Protocol[_T_contra]): ...
 
 @overload
 def print(
     *values: object,
     sep: str | None = " ",
@@ -1485,21 +1491,21 @@
     *values: object, sep: str | None = " ", end: str | None = "\n", file: _SupportsWriteAndFlush[str] | None = None, flush: bool
 ) -> None: ...
 
 _E = TypeVar("_E", contravariant=True)
 _M = TypeVar("_M", contravariant=True)
 
 class _SupportsPow2(Protocol[_E, _T_co]):
-    def __pow__(self, __other: _E) -> _T_co: ...
+    def __pow__(self, other: _E, /) -> _T_co: ...
 
 class _SupportsPow3NoneOnly(Protocol[_E, _T_co]):
-    def __pow__(self, __other: _E, __modulo: None = None) -> _T_co: ...
+    def __pow__(self, other: _E, modulo: None = None, /) -> _T_co: ...
 
 class _SupportsPow3(Protocol[_E, _M, _T_co]):
-    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...
+    def __pow__(self, other: _E, modulo: _M, /) -> _T_co: ...
 
 _SupportsSomeKindOfPow = (  # noqa: Y026  # TODO: Use TypeAlias once mypy bugs are fixed
     _SupportsPow2[Any, Any] | _SupportsPow3NoneOnly[Any, Any] | _SupportsPow3[Any, Any, Any]
 )
 
 # TODO: `pow(int, int, Literal[0])` fails at runtime,
 # but adding a `NoReturn` overload isn't a good solution for expressing that (see #8566).
@@ -1540,150 +1546,142 @@
 def pow(base: _SupportsSomeKindOfPow, exp: float, mod: None = None) -> Any: ...
 @overload
 def pow(base: _SupportsSomeKindOfPow, exp: complex, mod: None = None) -> complex: ...
 def quit(code: sys._ExitCode = None) -> NoReturn: ...
 
 class reversed(Iterator[_T]):
     @overload
-    def __init__(self, __sequence: Reversible[_T]) -> None: ...
+    def __new__(cls, sequence: Reversible[_T], /) -> Iterator[_T]: ...  # type: ignore[misc]
     @overload
-    def __init__(self, __sequence: SupportsLenAndGetItem[_T]) -> None: ...
+    def __new__(cls, sequence: SupportsLenAndGetItem[_T], /) -> Iterator[_T]: ...  # type: ignore[misc]
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T: ...
     def __length_hint__(self) -> int: ...
 
-def repr(__obj: object) -> str: ...
+def repr(obj: object, /) -> str: ...
 
 # See https://github.com/python/typeshed/pull/9141
 # and https://github.com/python/typeshed/pull/9151
 # on why we don't use `SupportsRound` from `typing.pyi`
 
 class _SupportsRound1(Protocol[_T_co]):
     def __round__(self) -> _T_co: ...
 
 class _SupportsRound2(Protocol[_T_co]):
-    def __round__(self, __ndigits: int) -> _T_co: ...
+    def __round__(self, ndigits: int, /) -> _T_co: ...
 
 @overload
 def round(number: _SupportsRound1[_T], ndigits: None = None) -> _T: ...
 @overload
 def round(number: _SupportsRound2[_T], ndigits: SupportsIndex) -> _T: ...
 
 # See https://github.com/python/typeshed/pull/6292#discussion_r748875189
 # for why arg 3 of `setattr` should be annotated with `Any` and not `object`
-def setattr(__obj: object, __name: str, __value: Any) -> None: ...
+def setattr(obj: object, name: str, value: Any, /) -> None: ...
 @overload
 def sorted(
-    __iterable: Iterable[SupportsRichComparisonT], *, key: None = None, reverse: bool = False
+    iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, reverse: bool = False
 ) -> list[SupportsRichComparisonT]: ...
 @overload
-def sorted(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> list[_T]: ...
+def sorted(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> list[_T]: ...
 
 _AddableT1 = TypeVar("_AddableT1", bound=SupportsAdd[Any, Any])
 _AddableT2 = TypeVar("_AddableT2", bound=SupportsAdd[Any, Any])
 
 class _SupportsSumWithNoDefaultGiven(SupportsAdd[Any, Any], SupportsRAdd[int, Any], Protocol): ...
 
 _SupportsSumNoDefaultT = TypeVar("_SupportsSumNoDefaultT", bound=_SupportsSumWithNoDefaultGiven)
 
 # In general, the return type of `x + x` is *not* guaranteed to be the same type as x.
 # However, we can't express that in the stub for `sum()`
 # without creating many false-positive errors (see #7578).
 # Instead, we special-case the most common examples of this: bool and literal integers.
 @overload
-def sum(__iterable: Iterable[bool], start: int = 0) -> int: ...  # type: ignore[overload-overlap]
+def sum(iterable: Iterable[bool], /, start: int = 0) -> int: ...  # type: ignore[overload-overlap]
 @overload
-def sum(__iterable: Iterable[_SupportsSumNoDefaultT]) -> _SupportsSumNoDefaultT | Literal[0]: ...
+def sum(iterable: Iterable[_SupportsSumNoDefaultT], /) -> _SupportsSumNoDefaultT | Literal[0]: ...
 @overload
-def sum(__iterable: Iterable[_AddableT1], start: _AddableT2) -> _AddableT1 | _AddableT2: ...
+def sum(iterable: Iterable[_AddableT1], /, start: _AddableT2) -> _AddableT1 | _AddableT2: ...
 
 # The argument to `vars()` has to have a `__dict__` attribute, so the second overload can't be annotated with `object`
 # (A "SupportsDunderDict" protocol doesn't work)
 # Use a type: ignore to make complaints about overlapping overloads go away
 @overload
-def vars(__object: type) -> types.MappingProxyType[str, Any]: ...  # type: ignore[overload-overlap]
+def vars(object: type, /) -> types.MappingProxyType[str, Any]: ...  # type: ignore[overload-overlap]
 @overload
-def vars(__object: Any = ...) -> dict[str, Any]: ...
+def vars(object: Any = ..., /) -> dict[str, Any]: ...
 
 class zip(Iterator[_T_co]):
     if sys.version_info >= (3, 10):
         @overload
         def __new__(cls, *, strict: bool = ...) -> zip[Any]: ...
         @overload
-        def __new__(cls, __iter1: Iterable[_T1], *, strict: bool = ...) -> zip[tuple[_T1]]: ...
+        def __new__(cls, iter1: Iterable[_T1], /, *, strict: bool = ...) -> zip[tuple[_T1]]: ...
         @overload
-        def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], *, strict: bool = ...) -> zip[tuple[_T1, _T2]]: ...
+        def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /, *, strict: bool = ...) -> zip[tuple[_T1, _T2]]: ...
         @overload
         def __new__(
-            cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], *, strict: bool = ...
+            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /, *, strict: bool = ...
         ) -> zip[tuple[_T1, _T2, _T3]]: ...
         @overload
         def __new__(
-            cls,
-            __iter1: Iterable[_T1],
-            __iter2: Iterable[_T2],
-            __iter3: Iterable[_T3],
-            __iter4: Iterable[_T4],
-            *,
-            strict: bool = ...,
+            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /, *, strict: bool = ...
         ) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...
         @overload
         def __new__(
             cls,
-            __iter1: Iterable[_T1],
-            __iter2: Iterable[_T2],
-            __iter3: Iterable[_T3],
-            __iter4: Iterable[_T4],
-            __iter5: Iterable[_T5],
+            iter1: Iterable[_T1],
+            iter2: Iterable[_T2],
+            iter3: Iterable[_T3],
+            iter4: Iterable[_T4],
+            iter5: Iterable[_T5],
+            /,
             *,
             strict: bool = ...,
         ) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
         @overload
         def __new__(
             cls,
-            __iter1: Iterable[Any],
-            __iter2: Iterable[Any],
-            __iter3: Iterable[Any],
-            __iter4: Iterable[Any],
-            __iter5: Iterable[Any],
-            __iter6: Iterable[Any],
+            iter1: Iterable[Any],
+            iter2: Iterable[Any],
+            iter3: Iterable[Any],
+            iter4: Iterable[Any],
+            iter5: Iterable[Any],
+            iter6: Iterable[Any],
+            /,
             *iterables: Iterable[Any],
             strict: bool = ...,
         ) -> zip[tuple[Any, ...]]: ...
     else:
         @overload
         def __new__(cls) -> zip[Any]: ...
         @overload
-        def __new__(cls, __iter1: Iterable[_T1]) -> zip[tuple[_T1]]: ...
+        def __new__(cls, iter1: Iterable[_T1], /) -> zip[tuple[_T1]]: ...
         @overload
-        def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> zip[tuple[_T1, _T2]]: ...
+        def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> zip[tuple[_T1, _T2]]: ...
         @overload
-        def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]) -> zip[tuple[_T1, _T2, _T3]]: ...
+        def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /) -> zip[tuple[_T1, _T2, _T3]]: ...
         @overload
         def __new__(
-            cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], __iter4: Iterable[_T4]
+            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /
         ) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...
         @overload
         def __new__(
-            cls,
-            __iter1: Iterable[_T1],
-            __iter2: Iterable[_T2],
-            __iter3: Iterable[_T3],
-            __iter4: Iterable[_T4],
-            __iter5: Iterable[_T5],
+            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], iter5: Iterable[_T5], /
         ) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
         @overload
         def __new__(
             cls,
-            __iter1: Iterable[Any],
-            __iter2: Iterable[Any],
-            __iter3: Iterable[Any],
-            __iter4: Iterable[Any],
-            __iter5: Iterable[Any],
-            __iter6: Iterable[Any],
+            iter1: Iterable[Any],
+            iter2: Iterable[Any],
+            iter3: Iterable[Any],
+            iter4: Iterable[Any],
+            iter5: Iterable[Any],
+            iter6: Iterable[Any],
+            /,
             *iterables: Iterable[Any],
         ) -> zip[tuple[Any, ...]]: ...
 
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T_co: ...
 
 # Signature of `builtins.__import__` should be kept identical to `importlib.__import__`
@@ -1691,15 +1689,15 @@
 def __import__(
     name: str,
     globals: Mapping[str, object] | None = None,
     locals: Mapping[str, object] | None = None,
     fromlist: Sequence[str] = (),
     level: int = 0,
 ) -> types.ModuleType: ...
-def __build_class__(__func: Callable[[], _Cell | Any], __name: str, *bases: Any, metaclass: Any = ..., **kwds: Any) -> Any: ...
+def __build_class__(func: Callable[[], _Cell | Any], name: str, /, *bases: Any, metaclass: Any = ..., **kwds: Any) -> Any: ...
 
 if sys.version_info >= (3, 10):
     from types import EllipsisType
 
     # Backwards compatibility hack for folks who relied on the ellipsis type
     # existing in typeshed in Python 3.9 and earlier.
     ellipsis = EllipsisType
@@ -1718,20 +1716,20 @@
 class BaseException:
     args: tuple[Any, ...]
     __cause__: BaseException | None
     __context__: BaseException | None
     __suppress_context__: bool
     __traceback__: TracebackType | None
     def __init__(self, *args: object) -> None: ...
-    def __setstate__(self, __state: dict[str, Any] | None) -> None: ...
-    def with_traceback(self, __tb: TracebackType | None) -> Self: ...
+    def __setstate__(self, state: dict[str, Any] | None, /) -> None: ...
+    def with_traceback(self, tb: TracebackType | None, /) -> Self: ...
     if sys.version_info >= (3, 11):
         # only present after add_note() is called
         __notes__: list[str]
-        def add_note(self, __note: str) -> None: ...
+        def add_note(self, note: str, /) -> None: ...
 
 class GeneratorExit(BaseException): ...
 class KeyboardInterrupt(BaseException): ...
 
 class SystemExit(BaseException):
     code: sys._ExitCode
 
@@ -1775,14 +1773,15 @@
         name_from: str | None  # undocumented
 
 class LookupError(Exception): ...
 class MemoryError(Exception): ...
 
 class NameError(Exception):
     if sys.version_info >= (3, 10):
+        def __init__(self, *args: object, name: str | None = ...) -> None: ...
         name: str
 
 class ReferenceError(Exception): ...
 class RuntimeError(Exception): ...
 
 class StopAsyncIteration(Exception):
     value: Any
@@ -1833,31 +1832,31 @@
 
 class UnicodeDecodeError(UnicodeError):
     encoding: str
     object: bytes
     start: int
     end: int
     reason: str
-    def __init__(self, __encoding: str, __object: ReadableBuffer, __start: int, __end: int, __reason: str) -> None: ...
+    def __init__(self, encoding: str, object: ReadableBuffer, start: int, end: int, reason: str, /) -> None: ...
 
 class UnicodeEncodeError(UnicodeError):
     encoding: str
     object: str
     start: int
     end: int
     reason: str
-    def __init__(self, __encoding: str, __object: str, __start: int, __end: int, __reason: str) -> None: ...
+    def __init__(self, encoding: str, object: str, start: int, end: int, reason: str, /) -> None: ...
 
 class UnicodeTranslateError(UnicodeError):
     encoding: None
     object: str
     start: int
     end: int
     reason: str
-    def __init__(self, __object: str, __start: int, __end: int, __reason: str) -> None: ...
+    def __init__(self, object: str, start: int, end: int, reason: str, /) -> None: ...
 
 class Warning(Exception): ...
 class UserWarning(Warning): ...
 class DeprecationWarning(Warning): ...
 class SyntaxWarning(Warning): ...
 class RuntimeWarning(Warning): ...
 class FutureWarning(Warning): ...
@@ -1874,64 +1873,64 @@
     _BaseExceptionT_co = TypeVar("_BaseExceptionT_co", bound=BaseException, covariant=True)
     _BaseExceptionT = TypeVar("_BaseExceptionT", bound=BaseException)
     _ExceptionT_co = TypeVar("_ExceptionT_co", bound=Exception, covariant=True)
     _ExceptionT = TypeVar("_ExceptionT", bound=Exception)
 
     # See `check_exception_group.py` for use-cases and comments.
     class BaseExceptionGroup(BaseException, Generic[_BaseExceptionT_co]):
-        def __new__(cls, __message: str, __exceptions: Sequence[_BaseExceptionT_co]) -> Self: ...
-        def __init__(self, __message: str, __exceptions: Sequence[_BaseExceptionT_co]) -> None: ...
+        def __new__(cls, message: str, exceptions: Sequence[_BaseExceptionT_co], /) -> Self: ...
+        def __init__(self, message: str, exceptions: Sequence[_BaseExceptionT_co], /) -> None: ...
         @property
         def message(self) -> str: ...
         @property
         def exceptions(self) -> tuple[_BaseExceptionT_co | BaseExceptionGroup[_BaseExceptionT_co], ...]: ...
         @overload
         def subgroup(
-            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]
+            self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
         ) -> ExceptionGroup[_ExceptionT] | None: ...
         @overload
         def subgroup(
-            self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]
+            self, condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...], /
         ) -> BaseExceptionGroup[_BaseExceptionT] | None: ...
         @overload
         def subgroup(
-            self, __condition: Callable[[_BaseExceptionT_co | Self], bool]
+            self, condition: Callable[[_BaseExceptionT_co | Self], bool], /
         ) -> BaseExceptionGroup[_BaseExceptionT_co] | None: ...
         @overload
         def split(
-            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]
+            self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
         ) -> tuple[ExceptionGroup[_ExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
         @overload
         def split(
-            self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]
+            self, condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...], /
         ) -> tuple[BaseExceptionGroup[_BaseExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
         @overload
         def split(
-            self, __condition: Callable[[_BaseExceptionT_co | Self], bool]
+            self, condition: Callable[[_BaseExceptionT_co | Self], bool], /
         ) -> tuple[BaseExceptionGroup[_BaseExceptionT_co] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
         # In reality it is `NonEmptySequence`:
         @overload
-        def derive(self, __excs: Sequence[_ExceptionT]) -> ExceptionGroup[_ExceptionT]: ...
+        def derive(self, excs: Sequence[_ExceptionT], /) -> ExceptionGroup[_ExceptionT]: ...
         @overload
-        def derive(self, __excs: Sequence[_BaseExceptionT]) -> BaseExceptionGroup[_BaseExceptionT]: ...
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def derive(self, excs: Sequence[_BaseExceptionT], /) -> BaseExceptionGroup[_BaseExceptionT]: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
     class ExceptionGroup(BaseExceptionGroup[_ExceptionT_co], Exception):
-        def __new__(cls, __message: str, __exceptions: Sequence[_ExceptionT_co]) -> Self: ...
-        def __init__(self, __message: str, __exceptions: Sequence[_ExceptionT_co]) -> None: ...
+        def __new__(cls, message: str, exceptions: Sequence[_ExceptionT_co], /) -> Self: ...
+        def __init__(self, message: str, exceptions: Sequence[_ExceptionT_co], /) -> None: ...
         @property
         def exceptions(self) -> tuple[_ExceptionT_co | ExceptionGroup[_ExceptionT_co], ...]: ...
         # We accept a narrower type, but that's OK.
         @overload  # type: ignore[override]
         def subgroup(
-            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]
+            self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
         ) -> ExceptionGroup[_ExceptionT] | None: ...
         @overload
-        def subgroup(self, __condition: Callable[[_ExceptionT_co | Self], bool]) -> ExceptionGroup[_ExceptionT_co] | None: ...
+        def subgroup(self, condition: Callable[[_ExceptionT_co | Self], bool], /) -> ExceptionGroup[_ExceptionT_co] | None: ...
         @overload  # type: ignore[override]
         def split(
-            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]
+            self, condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /
         ) -> tuple[ExceptionGroup[_ExceptionT] | None, ExceptionGroup[_ExceptionT_co] | None]: ...
         @overload
         def split(
-            self, __condition: Callable[[_ExceptionT_co | Self], bool]
+            self, condition: Callable[[_ExceptionT_co | Self], bool], /
         ) -> tuple[ExceptionGroup[_ExceptionT_co] | None, ExceptionGroup[_ExceptionT_co] | None]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/bz2.pyi

```diff
@@ -10,15 +10,15 @@
 
 # The following attributes and methods are optional:
 # def fileno(self) -> int: ...
 # def close(self) -> object: ...
 class _ReadableFileobj(_compression._Reader, Protocol): ...
 
 class _WritableFileobj(Protocol):
-    def write(self, __b: bytes) -> object: ...
+    def write(self, b: bytes, /) -> object: ...
     # The following attributes and methods are optional:
     # def fileno(self) -> int: ...
     # def close(self) -> object: ...
 
 def compress(data: ReadableBuffer, compresslevel: int = 9) -> bytes: ...
 def decompress(data: ReadableBuffer) -> bytes: ...
 
@@ -128,15 +128,15 @@
     def seek(self, offset: int, whence: int = 0) -> int: ...
     def write(self, data: ReadableBuffer) -> int: ...
     def writelines(self, seq: Iterable[ReadableBuffer]) -> None: ...
 
 @final
 class BZ2Compressor:
     def __init__(self, compresslevel: int = ...) -> None: ...
-    def compress(self, __data: ReadableBuffer) -> bytes: ...
+    def compress(self, data: ReadableBuffer, /) -> bytes: ...
     def flush(self) -> bytes: ...
 
 @final
 class BZ2Decompressor:
     def decompress(self, data: ReadableBuffer, max_length: int = -1) -> bytes: ...
     @property
     def eof(self) -> bool: ...
```

## puya/_vendor/mypy/typeshed/stdlib/cProfile.pyi

```diff
@@ -1,7 +1,8 @@
+import _lsprof
 from _typeshed import StrOrBytesPath, Unused
 from collections.abc import Callable
 from types import CodeType
 from typing import Any, TypeVar
 from typing_extensions import ParamSpec, Self, TypeAlias
 
 __all__ = ["run", "runctx", "Profile"]
@@ -11,25 +12,20 @@
     statement: str, globals: dict[str, Any], locals: dict[str, Any], filename: str | None = None, sort: str | int = -1
 ) -> None: ...
 
 _T = TypeVar("_T")
 _P = ParamSpec("_P")
 _Label: TypeAlias = tuple[str, int, str]
 
-class Profile:
+class Profile(_lsprof.Profiler):
     stats: dict[_Label, tuple[int, int, int, int, dict[_Label, tuple[int, int, int, int]]]]  # undocumented
-    def __init__(
-        self, timer: Callable[[], float] = ..., timeunit: float = ..., subcalls: bool = ..., builtins: bool = ...
-    ) -> None: ...
-    def enable(self) -> None: ...
-    def disable(self) -> None: ...
     def print_stats(self, sort: str | int = -1) -> None: ...
     def dump_stats(self, file: StrOrBytesPath) -> None: ...
     def create_stats(self) -> None: ...
     def snapshot_stats(self) -> None: ...
     def run(self, cmd: str) -> Self: ...
     def runctx(self, cmd: str, globals: dict[str, Any], locals: dict[str, Any]) -> Self: ...
-    def runcall(self, __func: Callable[_P, _T], *args: _P.args, **kw: _P.kwargs) -> _T: ...
+    def runcall(self, func: Callable[_P, _T], /, *args: _P.args, **kw: _P.kwargs) -> _T: ...
     def __enter__(self) -> Self: ...
     def __exit__(self, *exc_info: Unused) -> None: ...
 
 def label(code: str | CodeType) -> _Label: ...  # undocumented
```

## puya/_vendor/mypy/typeshed/stdlib/calendar.pyi

```diff
@@ -120,15 +120,15 @@
     def formatweekday(self, day: int) -> str: ...
     def formatweekheader(self) -> str: ...
     def formatmonthname(self, theyear: int, themonth: int, withyear: bool = True) -> str: ...
     def formatmonth(self, theyear: int, themonth: int, withyear: bool = True) -> str: ...
     def formatyear(self, theyear: int, width: int = 3) -> str: ...
     def formatyearpage(
         self, theyear: int, width: int = 3, css: str | None = "calendar.css", encoding: str | None = None
-    ) -> str: ...
+    ) -> bytes: ...
 
 class different_locale:
     def __init__(self, locale: _LocaleType) -> None: ...
     def __enter__(self) -> None: ...
     def __exit__(self, *args: Unused) -> None: ...
 
 class LocaleTextCalendar(TextCalendar):
@@ -162,14 +162,15 @@
         JUNE: Literal[6]
         JULY: Literal[7]
         AUGUST: Literal[8]
         SEPTEMBER: Literal[9]
         OCTOBER: Literal[10]
         NOVEMBER: Literal[11]
         DECEMBER: Literal[12]
+
     JANUARY = Month.JANUARY
     FEBRUARY = Month.FEBRUARY
     MARCH = Month.MARCH
     APRIL = Month.APRIL
     MAY = Month.MAY
     JUNE = Month.JUNE
     JULY = Month.JULY
@@ -183,14 +184,15 @@
         MONDAY: Literal[0]
         TUESDAY: Literal[1]
         WEDNESDAY: Literal[2]
         THURSDAY: Literal[3]
         FRIDAY: Literal[4]
         SATURDAY: Literal[5]
         SUNDAY: Literal[6]
+
     MONDAY = Day.MONDAY
     TUESDAY = Day.TUESDAY
     WEDNESDAY = Day.WEDNESDAY
     THURSDAY = Day.THURSDAY
     FRIDAY = Day.FRIDAY
     SATURDAY = Day.SATURDAY
     SUNDAY = Day.SUNDAY
```

## puya/_vendor/mypy/typeshed/stdlib/cgi.pyi

```diff
@@ -29,15 +29,15 @@
     separator: str = "&",
 ) -> dict[str, list[str]]: ...
 def parse_multipart(
     fp: IO[Any], pdict: SupportsGetItem[str, bytes], encoding: str = "utf-8", errors: str = "replace", separator: str = "&"
 ) -> dict[str, list[Any]]: ...
 
 class _Environ(Protocol):
-    def __getitem__(self, __k: str) -> str: ...
+    def __getitem__(self, k: str, /) -> str: ...
     def keys(self) -> Iterable[str]: ...
 
 def parse_header(line: str) -> tuple[str, dict[str, str]]: ...
 def test(environ: _Environ = ...) -> None: ...
 def print_environ(environ: _Environ = ...) -> None: ...
 def print_form(form: dict[str, Any]) -> None: ...
 def print_directory() -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/cmath.pyi

```diff
@@ -7,30 +7,30 @@
 infj: complex
 nan: float
 nanj: complex
 tau: float
 
 _C: TypeAlias = SupportsFloat | SupportsComplex | SupportsIndex | complex
 
-def acos(__z: _C) -> complex: ...
-def acosh(__z: _C) -> complex: ...
-def asin(__z: _C) -> complex: ...
-def asinh(__z: _C) -> complex: ...
-def atan(__z: _C) -> complex: ...
-def atanh(__z: _C) -> complex: ...
-def cos(__z: _C) -> complex: ...
-def cosh(__z: _C) -> complex: ...
-def exp(__z: _C) -> complex: ...
+def acos(z: _C, /) -> complex: ...
+def acosh(z: _C, /) -> complex: ...
+def asin(z: _C, /) -> complex: ...
+def asinh(z: _C, /) -> complex: ...
+def atan(z: _C, /) -> complex: ...
+def atanh(z: _C, /) -> complex: ...
+def cos(z: _C, /) -> complex: ...
+def cosh(z: _C, /) -> complex: ...
+def exp(z: _C, /) -> complex: ...
 def isclose(a: _C, b: _C, *, rel_tol: SupportsFloat = 1e-09, abs_tol: SupportsFloat = 0.0) -> bool: ...
-def isinf(__z: _C) -> bool: ...
-def isnan(__z: _C) -> bool: ...
-def log(__x: _C, __base: _C = ...) -> complex: ...
-def log10(__z: _C) -> complex: ...
-def phase(__z: _C) -> float: ...
-def polar(__z: _C) -> tuple[float, float]: ...
-def rect(__r: float, __phi: float) -> complex: ...
-def sin(__z: _C) -> complex: ...
-def sinh(__z: _C) -> complex: ...
-def sqrt(__z: _C) -> complex: ...
-def tan(__z: _C) -> complex: ...
-def tanh(__z: _C) -> complex: ...
-def isfinite(__z: _C) -> bool: ...
+def isinf(z: _C, /) -> bool: ...
+def isnan(z: _C, /) -> bool: ...
+def log(x: _C, base: _C = ..., /) -> complex: ...
+def log10(z: _C, /) -> complex: ...
+def phase(z: _C, /) -> float: ...
+def polar(z: _C, /) -> tuple[float, float]: ...
+def rect(r: float, phi: float, /) -> complex: ...
+def sin(z: _C, /) -> complex: ...
+def sinh(z: _C, /) -> complex: ...
+def sqrt(z: _C, /) -> complex: ...
+def tan(z: _C, /) -> complex: ...
+def tanh(z: _C, /) -> complex: ...
+def isfinite(z: _C, /) -> bool: ...
```

## puya/_vendor/mypy/typeshed/stdlib/codecs.pyi

```diff
@@ -55,42 +55,42 @@
 
 BOM32_BE: Literal[b"\xfe\xff"]
 BOM32_LE: Literal[b"\xff\xfe"]
 BOM64_BE: Literal[b"\x00\x00\xfe\xff"]
 BOM64_LE: Literal[b"\xff\xfe\x00\x00"]
 
 class _WritableStream(Protocol):
-    def write(self, __data: bytes) -> object: ...
-    def seek(self, __offset: int, __whence: int) -> object: ...
+    def write(self, data: bytes, /) -> object: ...
+    def seek(self, offset: int, whence: int, /) -> object: ...
     def close(self) -> object: ...
 
 class _ReadableStream(Protocol):
-    def read(self, __size: int = ...) -> bytes: ...
-    def seek(self, __offset: int, __whence: int) -> object: ...
+    def read(self, size: int = ..., /) -> bytes: ...
+    def seek(self, offset: int, whence: int, /) -> object: ...
     def close(self) -> object: ...
 
 class _Stream(_WritableStream, _ReadableStream, Protocol): ...
 
 # TODO: this only satisfies the most common interface, where
 # bytes is the raw form and str is the cooked form.
 # In the long run, both should become template parameters maybe?
 # There *are* bytes->bytes and str->str encodings in the standard library.
 # They were much more common in Python 2 than in Python 3.
 
 class _Encoder(Protocol):
-    def __call__(self, __input: str, __errors: str = ...) -> tuple[bytes, int]: ...  # signature of Codec().encode
+    def __call__(self, input: str, errors: str = ..., /) -> tuple[bytes, int]: ...  # signature of Codec().encode
 
 class _Decoder(Protocol):
-    def __call__(self, __input: bytes, __errors: str = ...) -> tuple[str, int]: ...  # signature of Codec().decode
+    def __call__(self, input: bytes, errors: str = ..., /) -> tuple[str, int]: ...  # signature of Codec().decode
 
 class _StreamReader(Protocol):
-    def __call__(self, __stream: _ReadableStream, __errors: str = ...) -> StreamReader: ...
+    def __call__(self, stream: _ReadableStream, errors: str = ..., /) -> StreamReader: ...
 
 class _StreamWriter(Protocol):
-    def __call__(self, __stream: _WritableStream, __errors: str = ...) -> StreamWriter: ...
+    def __call__(self, stream: _WritableStream, errors: str = ..., /) -> StreamWriter: ...
 
 class _IncrementalEncoder(Protocol):
     def __call__(self, errors: str = ...) -> IncrementalEncoder: ...
 
 class _IncrementalDecoder(Protocol):
     def __call__(self, errors: str = ...) -> IncrementalDecoder: ...
```

## puya/_vendor/mypy/typeshed/stdlib/collections/__init__.pyi

```diff
@@ -45,29 +45,29 @@
     defaults: Iterable[Any] | None = None,
 ) -> type[tuple[Any, ...]]: ...
 
 class UserDict(MutableMapping[_KT, _VT]):
     data: dict[_KT, _VT]
     # __init__ should be kept roughly in line with `dict.__init__`, which has the same semantics
     @overload
-    def __init__(self, __dict: None = None) -> None: ...
+    def __init__(self, dict: None = None, /) -> None: ...
     @overload
-    def __init__(self: UserDict[str, _VT], __dict: None = None, **kwargs: _VT) -> None: ...
+    def __init__(self: UserDict[str, _VT], dict: None = None, /, **kwargs: _VT) -> None: ...
     @overload
-    def __init__(self, __dict: SupportsKeysAndGetItem[_KT, _VT]) -> None: ...
+    def __init__(self, dict: SupportsKeysAndGetItem[_KT, _VT], /) -> None: ...
     @overload
-    def __init__(self: UserDict[str, _VT], __dict: SupportsKeysAndGetItem[str, _VT], **kwargs: _VT) -> None: ...
+    def __init__(self: UserDict[str, _VT], dict: SupportsKeysAndGetItem[str, _VT], /, **kwargs: _VT) -> None: ...
     @overload
-    def __init__(self, __iterable: Iterable[tuple[_KT, _VT]]) -> None: ...
+    def __init__(self, iterable: Iterable[tuple[_KT, _VT]], /) -> None: ...
     @overload
-    def __init__(self: UserDict[str, _VT], __iterable: Iterable[tuple[str, _VT]], **kwargs: _VT) -> None: ...
+    def __init__(self: UserDict[str, _VT], iterable: Iterable[tuple[str, _VT]], /, **kwargs: _VT) -> None: ...
     @overload
-    def __init__(self: UserDict[str, str], __iterable: Iterable[list[str]]) -> None: ...
+    def __init__(self: UserDict[str, str], iterable: Iterable[list[str]], /) -> None: ...
     @overload
-    def __init__(self: UserDict[bytes, bytes], __iterable: Iterable[list[bytes]]) -> None: ...
+    def __init__(self: UserDict[bytes, bytes], iterable: Iterable[list[bytes]], /) -> None: ...
     def __len__(self) -> int: ...
     def __getitem__(self, key: _KT) -> _VT: ...
     def __setitem__(self, key: _KT, item: _VT) -> None: ...
     def __delitem__(self, key: _KT) -> None: ...
     def __iter__(self) -> Iterator[_KT]: ...
     def __contains__(self, key: object) -> bool: ...
     def copy(self) -> Self: ...
@@ -133,16 +133,18 @@
     def append(self, item: _T) -> None: ...
     def insert(self, i: int, item: _T) -> None: ...
     def pop(self, i: int = -1) -> _T: ...
     def remove(self, item: _T) -> None: ...
     def copy(self) -> Self: ...
     def __copy__(self) -> Self: ...
     def count(self, item: _T) -> int: ...
-    # All arguments are passed to `list.index` at runtime, so the signature should be kept in line with `list.index`.
-    def index(self, item: _T, __start: SupportsIndex = 0, __stop: SupportsIndex = sys.maxsize) -> int: ...
+    # The runtime signature is "item, *args", and the arguments are then passed
+    # to `list.index`. In order to give more precise types, we pretend that the
+    # `item` argument is positional-only.
+    def index(self, item: _T, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...
     # All arguments are passed to `list.sort` at runtime, so the signature should be kept in line with `list.sort`.
     @overload
     def sort(self: UserList[SupportsRichComparisonT], *, key: None = None, reverse: bool = False) -> None: ...
     @overload
     def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> None: ...
     def extend(self, other: Iterable[_T]) -> None: ...
 
@@ -196,16 +198,16 @@
     def join(self, seq: Iterable[str]) -> str: ...
     def ljust(self, width: int, *args: Any) -> Self: ...
     def lower(self) -> Self: ...
     def lstrip(self, chars: str | None = None) -> Self: ...
     maketrans = str.maketrans
     def partition(self, sep: str) -> tuple[str, str, str]: ...
     if sys.version_info >= (3, 9):
-        def removeprefix(self, __prefix: str | UserString) -> Self: ...
-        def removesuffix(self, __suffix: str | UserString) -> Self: ...
+        def removeprefix(self, prefix: str | UserString, /) -> Self: ...
+        def removesuffix(self, suffix: str | UserString, /) -> Self: ...
 
     def replace(self, old: str | UserString, new: str | UserString, maxsplit: int = -1) -> Self: ...
     def rfind(self, sub: str | UserString, start: int = 0, end: int = sys.maxsize) -> int: ...
     def rindex(self, sub: str | UserString, start: int = 0, end: int = sys.maxsize) -> int: ...
     def rjust(self, width: int, *args: Any) -> Self: ...
     def rpartition(self, sep: str) -> tuple[str, str, str]: ...
     def rstrip(self, chars: str | None = None) -> Self: ...
@@ -223,78 +225,78 @@
 class deque(MutableSequence[_T]):
     @property
     def maxlen(self) -> int | None: ...
     @overload
     def __init__(self, *, maxlen: int | None = None) -> None: ...
     @overload
     def __init__(self, iterable: Iterable[_T], maxlen: int | None = None) -> None: ...
-    def append(self, __x: _T) -> None: ...
-    def appendleft(self, __x: _T) -> None: ...
+    def append(self, x: _T, /) -> None: ...
+    def appendleft(self, x: _T, /) -> None: ...
     def copy(self) -> Self: ...
-    def count(self, __x: _T) -> int: ...
-    def extend(self, __iterable: Iterable[_T]) -> None: ...
-    def extendleft(self, __iterable: Iterable[_T]) -> None: ...
-    def insert(self, __i: int, __x: _T) -> None: ...
-    def index(self, __x: _T, __start: int = 0, __stop: int = ...) -> int: ...
+    def count(self, x: _T, /) -> int: ...
+    def extend(self, iterable: Iterable[_T], /) -> None: ...
+    def extendleft(self, iterable: Iterable[_T], /) -> None: ...
+    def insert(self, i: int, x: _T, /) -> None: ...
+    def index(self, x: _T, start: int = 0, stop: int = ..., /) -> int: ...
     def pop(self) -> _T: ...  # type: ignore[override]
     def popleft(self) -> _T: ...
-    def remove(self, __value: _T) -> None: ...
-    def rotate(self, __n: int = 1) -> None: ...
+    def remove(self, value: _T, /) -> None: ...
+    def rotate(self, n: int = 1, /) -> None: ...
     def __copy__(self) -> Self: ...
     def __len__(self) -> int: ...
     # These methods of deque don't take slices, unlike MutableSequence, hence the type: ignores
-    def __getitem__(self, __key: SupportsIndex) -> _T: ...  # type: ignore[override]
-    def __setitem__(self, __key: SupportsIndex, __value: _T) -> None: ...  # type: ignore[override]
-    def __delitem__(self, __key: SupportsIndex) -> None: ...  # type: ignore[override]
-    def __contains__(self, __key: object) -> bool: ...
+    def __getitem__(self, key: SupportsIndex, /) -> _T: ...  # type: ignore[override]
+    def __setitem__(self, key: SupportsIndex, value: _T, /) -> None: ...  # type: ignore[override]
+    def __delitem__(self, key: SupportsIndex, /) -> None: ...  # type: ignore[override]
+    def __contains__(self, key: object, /) -> bool: ...
     def __reduce__(self) -> tuple[type[Self], tuple[()], None, Iterator[_T]]: ...
-    def __iadd__(self, __value: Iterable[_T]) -> Self: ...
-    def __add__(self, __value: Self) -> Self: ...
-    def __mul__(self, __value: int) -> Self: ...
-    def __imul__(self, __value: int) -> Self: ...
-    def __lt__(self, __value: deque[_T]) -> bool: ...
-    def __le__(self, __value: deque[_T]) -> bool: ...
-    def __gt__(self, __value: deque[_T]) -> bool: ...
-    def __ge__(self, __value: deque[_T]) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __iadd__(self, value: Iterable[_T], /) -> Self: ...
+    def __add__(self, value: Self, /) -> Self: ...
+    def __mul__(self, value: int, /) -> Self: ...
+    def __imul__(self, value: int, /) -> Self: ...
+    def __lt__(self, value: deque[_T], /) -> bool: ...
+    def __le__(self, value: deque[_T], /) -> bool: ...
+    def __gt__(self, value: deque[_T], /) -> bool: ...
+    def __ge__(self, value: deque[_T], /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 class Counter(dict[_T, int], Generic[_T]):
     @overload
-    def __init__(self, __iterable: None = None) -> None: ...
+    def __init__(self, iterable: None = None, /) -> None: ...
     @overload
-    def __init__(self: Counter[str], __iterable: None = None, **kwargs: int) -> None: ...
+    def __init__(self: Counter[str], iterable: None = None, /, **kwargs: int) -> None: ...
     @overload
-    def __init__(self, __mapping: SupportsKeysAndGetItem[_T, int]) -> None: ...
+    def __init__(self, mapping: SupportsKeysAndGetItem[_T, int], /) -> None: ...
     @overload
-    def __init__(self, __iterable: Iterable[_T]) -> None: ...
+    def __init__(self, iterable: Iterable[_T], /) -> None: ...
     def copy(self) -> Self: ...
     def elements(self) -> Iterator[_T]: ...
     def most_common(self, n: int | None = None) -> list[tuple[_T, int]]: ...
     @classmethod
     def fromkeys(cls, iterable: Any, v: int | None = None) -> NoReturn: ...  # type: ignore[override]
     @overload
-    def subtract(self, __iterable: None = None) -> None: ...
+    def subtract(self, iterable: None = None, /) -> None: ...
     @overload
-    def subtract(self, __mapping: Mapping[_T, int]) -> None: ...
+    def subtract(self, mapping: Mapping[_T, int], /) -> None: ...
     @overload
-    def subtract(self, __iterable: Iterable[_T]) -> None: ...
+    def subtract(self, iterable: Iterable[_T], /) -> None: ...
     # Unlike dict.update(), use Mapping instead of SupportsKeysAndGetItem for the first overload
     # (source code does an `isinstance(other, Mapping)` check)
     #
     # The second overload is also deliberately different to dict.update()
     # (if it were `Iterable[_T] | Iterable[tuple[_T, int]]`,
     # the tuples would be added as keys, breaking type safety)
     @overload  # type: ignore[override]
-    def update(self, __m: Mapping[_T, int], **kwargs: int) -> None: ...
+    def update(self, m: Mapping[_T, int], /, **kwargs: int) -> None: ...
     @overload
-    def update(self, __iterable: Iterable[_T], **kwargs: int) -> None: ...
+    def update(self, iterable: Iterable[_T], /, **kwargs: int) -> None: ...
     @overload
-    def update(self, __iterable: None = None, **kwargs: int) -> None: ...
+    def update(self, iterable: None = None, /, **kwargs: int) -> None: ...
     def __missing__(self, key: _T) -> int: ...
     def __delitem__(self, elem: object) -> None: ...
     if sys.version_info >= (3, 10):
         def __eq__(self, other: object) -> bool: ...
         def __ne__(self, other: object) -> bool: ...
 
     def __add__(self, other: Counter[_S]) -> Counter[_T | _S]: ...
@@ -367,65 +369,67 @@
     # Same as dict.pop, but accepts keyword arguments
     @overload
     def pop(self, key: _KT) -> _VT: ...
     @overload
     def pop(self, key: _KT, default: _VT) -> _VT: ...
     @overload
     def pop(self, key: _KT, default: _T) -> _VT | _T: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     if sys.version_info >= (3, 9):
         @overload
-        def __or__(self, __value: dict[_KT, _VT]) -> Self: ...
+        def __or__(self, value: dict[_KT, _VT], /) -> Self: ...
         @overload
-        def __or__(self, __value: dict[_T1, _T2]) -> OrderedDict[_KT | _T1, _VT | _T2]: ...
+        def __or__(self, value: dict[_T1, _T2], /) -> OrderedDict[_KT | _T1, _VT | _T2]: ...
         @overload
-        def __ror__(self, __value: dict[_KT, _VT]) -> Self: ...
+        def __ror__(self, value: dict[_KT, _VT], /) -> Self: ...
         @overload
-        def __ror__(self, __value: dict[_T1, _T2]) -> OrderedDict[_KT | _T1, _VT | _T2]: ...  # type: ignore[misc]
+        def __ror__(self, value: dict[_T1, _T2], /) -> OrderedDict[_KT | _T1, _VT | _T2]: ...  # type: ignore[misc]
 
 class defaultdict(dict[_KT, _VT]):
     default_factory: Callable[[], _VT] | None
     @overload
     def __init__(self) -> None: ...
     @overload
     def __init__(self: defaultdict[str, _VT], **kwargs: _VT) -> None: ...
     @overload
-    def __init__(self, __default_factory: Callable[[], _VT] | None) -> None: ...
+    def __init__(self, default_factory: Callable[[], _VT] | None, /) -> None: ...
     @overload
-    def __init__(self: defaultdict[str, _VT], __default_factory: Callable[[], _VT] | None, **kwargs: _VT) -> None: ...
+    def __init__(self: defaultdict[str, _VT], default_factory: Callable[[], _VT] | None, /, **kwargs: _VT) -> None: ...
     @overload
-    def __init__(self, __default_factory: Callable[[], _VT] | None, __map: SupportsKeysAndGetItem[_KT, _VT]) -> None: ...
+    def __init__(self, default_factory: Callable[[], _VT] | None, map: SupportsKeysAndGetItem[_KT, _VT], /) -> None: ...
     @overload
     def __init__(
         self: defaultdict[str, _VT],
-        __default_factory: Callable[[], _VT] | None,
-        __map: SupportsKeysAndGetItem[str, _VT],
+        default_factory: Callable[[], _VT] | None,
+        map: SupportsKeysAndGetItem[str, _VT],
+        /,
         **kwargs: _VT,
     ) -> None: ...
     @overload
-    def __init__(self, __default_factory: Callable[[], _VT] | None, __iterable: Iterable[tuple[_KT, _VT]]) -> None: ...
+    def __init__(self, default_factory: Callable[[], _VT] | None, iterable: Iterable[tuple[_KT, _VT]], /) -> None: ...
     @overload
     def __init__(
         self: defaultdict[str, _VT],
-        __default_factory: Callable[[], _VT] | None,
-        __iterable: Iterable[tuple[str, _VT]],
+        default_factory: Callable[[], _VT] | None,
+        iterable: Iterable[tuple[str, _VT]],
+        /,
         **kwargs: _VT,
     ) -> None: ...
-    def __missing__(self, __key: _KT) -> _VT: ...
+    def __missing__(self, key: _KT, /) -> _VT: ...
     def __copy__(self) -> Self: ...
     def copy(self) -> Self: ...
     if sys.version_info >= (3, 9):
         @overload
-        def __or__(self, __value: dict[_KT, _VT]) -> Self: ...
+        def __or__(self, value: dict[_KT, _VT], /) -> Self: ...
         @overload
-        def __or__(self, __value: dict[_T1, _T2]) -> defaultdict[_KT | _T1, _VT | _T2]: ...
+        def __or__(self, value: dict[_T1, _T2], /) -> defaultdict[_KT | _T1, _VT | _T2]: ...
         @overload
-        def __ror__(self, __value: dict[_KT, _VT]) -> Self: ...
+        def __ror__(self, value: dict[_KT, _VT], /) -> Self: ...
         @overload
-        def __ror__(self, __value: dict[_T1, _T2]) -> defaultdict[_KT | _T1, _VT | _T2]: ...  # type: ignore[misc]
+        def __ror__(self, value: dict[_T1, _T2], /) -> defaultdict[_KT | _T1, _VT | _T2]: ...  # type: ignore[misc]
 
 class ChainMap(MutableMapping[_KT, _VT]):
     maps: list[MutableMapping[_KT, _VT]]
     def __init__(self, *maps: MutableMapping[_KT, _VT]) -> None: ...
     def new_child(self, m: MutableMapping[_KT, _VT] | None = None) -> Self: ...
     @property
     def parents(self) -> Self: ...
@@ -453,18 +457,22 @@
     @overload
     def pop(self, key: _KT, default: _T) -> _VT | _T: ...
     def copy(self) -> Self: ...
     __copy__ = copy
     # All arguments to `fromkeys` are passed to `dict.fromkeys` at runtime, so the signature should be kept in line with `dict.fromkeys`.
     @classmethod
     @overload
-    def fromkeys(cls, iterable: Iterable[_T], __value: None = None) -> ChainMap[_T, Any | None]: ...
+    def fromkeys(cls, iterable: Iterable[_T]) -> ChainMap[_T, Any | None]: ...
     @classmethod
     @overload
-    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> ChainMap[_T, _S]: ...
+    # Special-case None: the user probably wants to add non-None values later.
+    def fromkeys(cls, iterable: Iterable[_T], value: None, /) -> ChainMap[_T, Any | None]: ...
+    @classmethod
+    @overload
+    def fromkeys(cls, iterable: Iterable[_T], value: _S, /) -> ChainMap[_T, _S]: ...
     if sys.version_info >= (3, 9):
         @overload
         def __or__(self, other: Mapping[_KT, _VT]) -> Self: ...
         @overload
         def __or__(self, other: Mapping[_T1, _T2]) -> ChainMap[_KT | _T1, _VT | _T2]: ...
         @overload
         def __ror__(self, other: Mapping[_KT, _VT]) -> Self: ...
```

## puya/_vendor/mypy/typeshed/stdlib/compileall.pyi

```diff
@@ -2,15 +2,15 @@
 from _typeshed import StrPath
 from py_compile import PycInvalidationMode
 from typing import Any, Protocol
 
 __all__ = ["compile_dir", "compile_file", "compile_path"]
 
 class _SupportsSearch(Protocol):
-    def search(self, __string: str) -> Any: ...
+    def search(self, string: str, /) -> Any: ...
 
 if sys.version_info >= (3, 10):
     def compile_dir(
         dir: StrPath,
         maxlevels: int | None = None,
         ddir: StrPath | None = None,
         force: bool = False,
```

## puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/_base.pyi

```diff
@@ -1,11 +1,11 @@
 import sys
 import threading
 from _typeshed import Unused
-from collections.abc import Callable, Iterable, Iterator
+from collections.abc import Callable, Collection, Iterable, Iterator
 from logging import Logger
 from types import TracebackType
 from typing import Any, Generic, Literal, NamedTuple, Protocol, TypeVar
 from typing_extensions import ParamSpec, Self
 
 if sys.version_info >= (3, 9):
     from types import GenericAlias
@@ -54,15 +54,15 @@
     def exception(self, timeout: float | None = None) -> BaseException | None: ...
     def set_exception(self, exception: BaseException | None) -> None: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 class Executor:
     if sys.version_info >= (3, 9):
-        def submit(self, __fn: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -> Future[_T]: ...
+        def submit(self, fn: Callable[_P, _T], /, *args: _P.args, **kwargs: _P.kwargs) -> Future[_T]: ...
     else:
         def submit(self, fn: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -> Future[_T]: ...
 
     def map(
         self, fn: Callable[..., _T], *iterables: Iterable[Any], timeout: float | None = None, chunksize: int = 1
     ) -> Iterator[_T]: ...
     if sys.version_info >= (3, 9):
@@ -87,17 +87,23 @@
 
 def as_completed(fs: Iterable[_AsCompletedFuture[_T]], timeout: float | None = None) -> Iterator[Future[_T]]: ...
 
 class DoneAndNotDoneFutures(NamedTuple, Generic[_T]):
     done: set[Future[_T]]
     not_done: set[Future[_T]]
 
-def wait(
-    fs: Iterable[Future[_T]], timeout: float | None = None, return_when: str = "ALL_COMPLETED"
-) -> DoneAndNotDoneFutures[_T]: ...
+if sys.version_info >= (3, 9):
+    def wait(
+        fs: Iterable[Future[_T]], timeout: float | None = None, return_when: str = "ALL_COMPLETED"
+    ) -> DoneAndNotDoneFutures[_T]: ...
+
+else:
+    def wait(
+        fs: Collection[Future[_T]], timeout: float | None = None, return_when: str = "ALL_COMPLETED"
+    ) -> DoneAndNotDoneFutures[_T]: ...
 
 class _Waiter:
     event: threading.Event
     finished_futures: list[Future[Any]]
     def add_result(self, future: Future[Any]) -> None: ...
     def add_exception(self, future: Future[Any]) -> None: ...
     def add_cancelled(self, future: Future[Any]) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/contextlib.pyi

```diff
@@ -38,23 +38,23 @@
 _CM_EF = TypeVar("_CM_EF", bound=AbstractContextManager[Any] | _ExitFunc)
 
 @runtime_checkable
 class AbstractContextManager(Protocol[_T_co]):
     def __enter__(self) -> _T_co: ...
     @abstractmethod
     def __exit__(
-        self, __exc_type: type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None
+        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None, /
     ) -> bool | None: ...
 
 @runtime_checkable
 class AbstractAsyncContextManager(Protocol[_T_co]):
     async def __aenter__(self) -> _T_co: ...
     @abstractmethod
     async def __aexit__(
-        self, __exc_type: type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None
+        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None, /
     ) -> bool | None: ...
 
 class ContextDecorator:
     def __call__(self, func: _F) -> _F: ...
 
 class _GeneratorContextManager(AbstractContextManager[_T_co], ContextDecorator):
     # __init__ and all instance attributes are actually inherited from _GeneratorContextManagerBase
@@ -114,14 +114,15 @@
 class closing(AbstractContextManager[_SupportsCloseT]):
     def __init__(self, thing: _SupportsCloseT) -> None: ...
     def __exit__(self, *exc_info: Unused) -> None: ...
 
 if sys.version_info >= (3, 10):
     class _SupportsAclose(Protocol):
         def aclose(self) -> Awaitable[object]: ...
+
     _SupportsAcloseT = TypeVar("_SupportsAcloseT", bound=_SupportsAclose)
 
     class aclosing(AbstractAsyncContextManager[_SupportsAcloseT]):
         def __init__(self, thing: _SupportsAcloseT) -> None: ...
         async def __aexit__(self, *exc_info: Unused) -> None: ...
 
 class suppress(AbstractContextManager[None]):
@@ -140,43 +141,43 @@
 class redirect_stderr(_RedirectStream[_T_io]): ...
 
 # In reality this is a subclass of `AbstractContextManager`;
 # see #7961 for why we don't do that in the stub
 class ExitStack(metaclass=abc.ABCMeta):
     def enter_context(self, cm: AbstractContextManager[_T]) -> _T: ...
     def push(self, exit: _CM_EF) -> _CM_EF: ...
-    def callback(self, __callback: Callable[_P, _T], *args: _P.args, **kwds: _P.kwargs) -> Callable[_P, _T]: ...
+    def callback(self, callback: Callable[_P, _T], /, *args: _P.args, **kwds: _P.kwargs) -> Callable[_P, _T]: ...
     def pop_all(self) -> Self: ...
     def close(self) -> None: ...
     def __enter__(self) -> Self: ...
     def __exit__(
-        self, __exc_type: type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None
+        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None, /
     ) -> bool: ...
 
 _ExitCoroFunc: TypeAlias = Callable[
     [type[BaseException] | None, BaseException | None, TracebackType | None], Awaitable[bool | None]
 ]
 _ACM_EF = TypeVar("_ACM_EF", bound=AbstractAsyncContextManager[Any] | _ExitCoroFunc)
 
 # In reality this is a subclass of `AbstractAsyncContextManager`;
 # see #7961 for why we don't do that in the stub
 class AsyncExitStack(metaclass=abc.ABCMeta):
     def enter_context(self, cm: AbstractContextManager[_T]) -> _T: ...
     async def enter_async_context(self, cm: AbstractAsyncContextManager[_T]) -> _T: ...
     def push(self, exit: _CM_EF) -> _CM_EF: ...
     def push_async_exit(self, exit: _ACM_EF) -> _ACM_EF: ...
-    def callback(self, __callback: Callable[_P, _T], *args: _P.args, **kwds: _P.kwargs) -> Callable[_P, _T]: ...
+    def callback(self, callback: Callable[_P, _T], /, *args: _P.args, **kwds: _P.kwargs) -> Callable[_P, _T]: ...
     def push_async_callback(
-        self, __callback: Callable[_P, Awaitable[_T]], *args: _P.args, **kwds: _P.kwargs
+        self, callback: Callable[_P, Awaitable[_T]], /, *args: _P.args, **kwds: _P.kwargs
     ) -> Callable[_P, Awaitable[_T]]: ...
     def pop_all(self) -> Self: ...
     async def aclose(self) -> None: ...
     async def __aenter__(self) -> Self: ...
     async def __aexit__(
-        self, __exc_type: type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None
+        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None, /
     ) -> bool: ...
 
 if sys.version_info >= (3, 10):
     class nullcontext(AbstractContextManager[_T], AbstractAsyncContextManager[_T]):
         enter_result: _T
         @overload
         def __init__(self: nullcontext[None], enter_result: None = None) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/contextvars.pyi

```diff
@@ -20,19 +20,19 @@
     def __init__(self, name: str, *, default: _T) -> None: ...
     def __hash__(self) -> int: ...
     @property
     def name(self) -> str: ...
     @overload
     def get(self) -> _T: ...
     @overload
-    def get(self, __default: _T) -> _T: ...
+    def get(self, default: _T, /) -> _T: ...
     @overload
-    def get(self, __default: _D) -> _D | _T: ...
-    def set(self, __value: _T) -> Token[_T]: ...
-    def reset(self, __token: Token[_T]) -> None: ...
+    def get(self, default: _D, /) -> _D | _T: ...
+    def set(self, value: _T, /) -> Token[_T]: ...
+    def reset(self, token: Token[_T], /) -> None: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 @final
 class Token(Generic[_T]):
     @property
     def var(self) -> ContextVar[_T]: ...
@@ -46,18 +46,18 @@
 
 # It doesn't make sense to make this generic, because for most Contexts each ContextVar will have
 # a different value.
 @final
 class Context(Mapping[ContextVar[Any], Any]):
     def __init__(self) -> None: ...
     @overload
-    def get(self, __key: ContextVar[_T], __default: None = None) -> _T | None: ...
+    def get(self, key: ContextVar[_T], default: None = None, /) -> _T | None: ...
     @overload
-    def get(self, __key: ContextVar[_T], __default: _T) -> _T: ...
+    def get(self, key: ContextVar[_T], default: _T, /) -> _T: ...
     @overload
-    def get(self, __key: ContextVar[_T], __default: _D) -> _T | _D: ...
+    def get(self, key: ContextVar[_T], default: _D, /) -> _T | _D: ...
     def run(self, callable: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -> _T: ...
     def copy(self) -> Context: ...
-    def __getitem__(self, __key: ContextVar[_T]) -> _T: ...
+    def __getitem__(self, key: ContextVar[_T], /) -> _T: ...
     def __iter__(self) -> Iterator[ContextVar[Any]]: ...
     def __len__(self) -> int: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
```

## puya/_vendor/mypy/typeshed/stdlib/curses/__init__.pyi

```diff
@@ -1,21 +1,22 @@
-import sys
+from _curses import *
+from _curses import _CursesWindow as _CursesWindow
 from collections.abc import Callable
 from typing import TypeVar
 from typing_extensions import Concatenate, ParamSpec
 
-if sys.platform != "win32":
-    from _curses import *
-    from _curses import _CursesWindow as _CursesWindow
+# NOTE: The _curses module is ordinarily only available on Unix, but the
+# windows-curses package makes it available on Windows as well with the same
+# contents.
 
-    _T = TypeVar("_T")
-    _P = ParamSpec("_P")
+_T = TypeVar("_T")
+_P = ParamSpec("_P")
 
-    # available after calling `curses.initscr()`
-    LINES: int
-    COLS: int
+# available after calling `curses.initscr()`
+LINES: int
+COLS: int
 
-    # available after calling `curses.start_color()`
-    COLORS: int
-    COLOR_PAIRS: int
+# available after calling `curses.start_color()`
+COLORS: int
+COLOR_PAIRS: int
 
-    def wrapper(__func: Callable[Concatenate[_CursesWindow, _P], _T], *arg: _P.args, **kwds: _P.kwargs) -> _T: ...
+def wrapper(func: Callable[Concatenate[_CursesWindow, _P], _T], /, *arg: _P.args, **kwds: _P.kwargs) -> _T: ...
```

## puya/_vendor/mypy/typeshed/stdlib/curses/ascii.pyi

```diff
@@ -1,63 +1,62 @@
-import sys
 from typing import TypeVar
 
-if sys.platform != "win32":
-    _CharT = TypeVar("_CharT", str, int)
+_CharT = TypeVar("_CharT", str, int)
 
-    NUL: int
-    SOH: int
-    STX: int
-    ETX: int
-    EOT: int
-    ENQ: int
-    ACK: int
-    BEL: int
-    BS: int
-    TAB: int
-    HT: int
-    LF: int
-    NL: int
-    VT: int
-    FF: int
-    CR: int
-    SO: int
-    SI: int
-    DLE: int
-    DC1: int
-    DC2: int
-    DC3: int
-    DC4: int
-    NAK: int
-    SYN: int
-    ETB: int
-    CAN: int
-    EM: int
-    SUB: int
-    ESC: int
-    FS: int
-    GS: int
-    RS: int
-    US: int
-    SP: int
-    DEL: int
+NUL: int
+SOH: int
+STX: int
+ETX: int
+EOT: int
+ENQ: int
+ACK: int
+BEL: int
+BS: int
+TAB: int
+HT: int
+LF: int
+NL: int
+VT: int
+FF: int
+CR: int
+SO: int
+SI: int
+DLE: int
+DC1: int
+DC2: int
+DC3: int
+DC4: int
+NAK: int
+SYN: int
+ETB: int
+CAN: int
+EM: int
+SUB: int
+ESC: int
+FS: int
+GS: int
+RS: int
+US: int
+SP: int
+DEL: int
 
-    controlnames: list[int]
-    def isalnum(c: str | int) -> bool: ...
-    def isalpha(c: str | int) -> bool: ...
-    def isascii(c: str | int) -> bool: ...
-    def isblank(c: str | int) -> bool: ...
-    def iscntrl(c: str | int) -> bool: ...
-    def isdigit(c: str | int) -> bool: ...
-    def isgraph(c: str | int) -> bool: ...
-    def islower(c: str | int) -> bool: ...
-    def isprint(c: str | int) -> bool: ...
-    def ispunct(c: str | int) -> bool: ...
-    def isspace(c: str | int) -> bool: ...
-    def isupper(c: str | int) -> bool: ...
-    def isxdigit(c: str | int) -> bool: ...
-    def isctrl(c: str | int) -> bool: ...
-    def ismeta(c: str | int) -> bool: ...
-    def ascii(c: _CharT) -> _CharT: ...
-    def ctrl(c: _CharT) -> _CharT: ...
-    def alt(c: _CharT) -> _CharT: ...
-    def unctrl(c: str | int) -> str: ...
+controlnames: list[int]
+
+def isalnum(c: str | int) -> bool: ...
+def isalpha(c: str | int) -> bool: ...
+def isascii(c: str | int) -> bool: ...
+def isblank(c: str | int) -> bool: ...
+def iscntrl(c: str | int) -> bool: ...
+def isdigit(c: str | int) -> bool: ...
+def isgraph(c: str | int) -> bool: ...
+def islower(c: str | int) -> bool: ...
+def isprint(c: str | int) -> bool: ...
+def ispunct(c: str | int) -> bool: ...
+def isspace(c: str | int) -> bool: ...
+def isupper(c: str | int) -> bool: ...
+def isxdigit(c: str | int) -> bool: ...
+def isctrl(c: str | int) -> bool: ...
+def ismeta(c: str | int) -> bool: ...
+def ascii(c: _CharT) -> _CharT: ...
+def ctrl(c: _CharT) -> _CharT: ...
+def alt(c: _CharT) -> _CharT: ...
+def unctrl(c: str | int) -> str: ...
```

## puya/_vendor/mypy/typeshed/stdlib/curses/has_key.pyi

```diff
@@ -1,4 +1 @@
-import sys
-
-if sys.platform != "win32":
-    def has_key(ch: int | str) -> bool: ...
+def has_key(ch: int | str) -> bool: ...
```

## puya/_vendor/mypy/typeshed/stdlib/curses/panel.pyi

```diff
@@ -1,25 +1,22 @@
-import sys
+from _curses import _CursesWindow
 
-if sys.platform != "win32":
-    from _curses import _CursesWindow
+version: str
 
-    version: str
+class _Curses_Panel:  # type is <class '_curses_panel.curses panel'> (note the space in the class name)
+    def above(self) -> _Curses_Panel: ...
+    def below(self) -> _Curses_Panel: ...
+    def bottom(self) -> None: ...
+    def hidden(self) -> bool: ...
+    def hide(self) -> None: ...
+    def move(self, y: int, x: int) -> None: ...
+    def replace(self, win: _CursesWindow) -> None: ...
+    def set_userptr(self, obj: object) -> None: ...
+    def show(self) -> None: ...
+    def top(self) -> None: ...
+    def userptr(self) -> object: ...
+    def window(self) -> _CursesWindow: ...
 
-    class _Curses_Panel:  # type is <class '_curses_panel.curses panel'> (note the space in the class name)
-        def above(self) -> _Curses_Panel: ...
-        def below(self) -> _Curses_Panel: ...
-        def bottom(self) -> None: ...
-        def hidden(self) -> bool: ...
-        def hide(self) -> None: ...
-        def move(self, y: int, x: int) -> None: ...
-        def replace(self, win: _CursesWindow) -> None: ...
-        def set_userptr(self, obj: object) -> None: ...
-        def show(self) -> None: ...
-        def top(self) -> None: ...
-        def userptr(self) -> object: ...
-        def window(self) -> _CursesWindow: ...
-
-    def bottom_panel() -> _Curses_Panel: ...
-    def new_panel(__win: _CursesWindow) -> _Curses_Panel: ...
-    def top_panel() -> _Curses_Panel: ...
-    def update_panels() -> _Curses_Panel: ...
+def bottom_panel() -> _Curses_Panel: ...
+def new_panel(win: _CursesWindow, /) -> _Curses_Panel: ...
+def top_panel() -> _Curses_Panel: ...
+def update_panels() -> _Curses_Panel: ...
```

## puya/_vendor/mypy/typeshed/stdlib/curses/textpad.pyi

```diff
@@ -1,13 +1,11 @@
-import sys
+from _curses import _CursesWindow
 from collections.abc import Callable
 
-if sys.platform != "win32":
-    from _curses import _CursesWindow
-    def rectangle(win: _CursesWindow, uly: int, ulx: int, lry: int, lrx: int) -> None: ...
+def rectangle(win: _CursesWindow, uly: int, ulx: int, lry: int, lrx: int) -> None: ...
 
-    class Textbox:
-        stripspaces: bool
-        def __init__(self, win: _CursesWindow, insert_mode: bool = False) -> None: ...
-        def edit(self, validate: Callable[[int], int] | None = None) -> str: ...
-        def do_command(self, ch: str | int) -> None: ...
-        def gather(self) -> str: ...
+class Textbox:
+    stripspaces: bool
+    def __init__(self, win: _CursesWindow, insert_mode: bool = False) -> None: ...
+    def edit(self, validate: Callable[[int], int] | None = None) -> str: ...
+    def do_command(self, ch: str | int) -> None: ...
+    def gather(self) -> str: ...
```

## puya/_vendor/mypy/typeshed/stdlib/dataclasses.pyi

```diff
@@ -51,17 +51,17 @@
 @overload
 def asdict(obj: DataclassInstance, *, dict_factory: Callable[[list[tuple[str, Any]]], _T]) -> _T: ...
 @overload
 def astuple(obj: DataclassInstance) -> tuple[Any, ...]: ...
 @overload
 def astuple(obj: DataclassInstance, *, tuple_factory: Callable[[list[Any]], _T]) -> _T: ...
 @overload
-def dataclass(__cls: None) -> Callable[[type[_T]], type[_T]]: ...
+def dataclass(cls: None, /) -> Callable[[type[_T]], type[_T]]: ...
 @overload
-def dataclass(__cls: type[_T]) -> type[_T]: ...
+def dataclass(cls: type[_T], /) -> type[_T]: ...
 
 if sys.version_info >= (3, 11):
     @overload
     def dataclass(
         *,
         init: bool = True,
         repr: bool = True,
@@ -223,29 +223,31 @@
 class FrozenInstanceError(AttributeError): ...
 
 if sys.version_info >= (3, 9):
     _InitVarMeta: TypeAlias = type
 else:
     class _InitVarMeta(type):
         # Not used, instead `InitVar.__class_getitem__` is called.
-        def __getitem__(self, params: Any) -> InitVar[Any]: ...
+        # pyright ignore is needed because pyright (not unreasonably) thinks this
+        # is an invalid use of InitVar.
+        def __getitem__(self, params: Any) -> InitVar[Any]: ...  # pyright: ignore
 
 class InitVar(Generic[_T], metaclass=_InitVarMeta):
     type: Type[_T]
     def __init__(self, type: Type[_T]) -> None: ...
     if sys.version_info >= (3, 9):
         @overload
-        def __class_getitem__(cls, type: Type[_T]) -> InitVar[_T]: ...
+        def __class_getitem__(cls, type: Type[_T]) -> InitVar[_T]: ...  # pyright: ignore
         @overload
-        def __class_getitem__(cls, type: Any) -> InitVar[Any]: ...
+        def __class_getitem__(cls, type: Any) -> InitVar[Any]: ...  # pyright: ignore
 
 if sys.version_info >= (3, 12):
     def make_dataclass(
         cls_name: str,
-        fields: Iterable[str | tuple[str, type] | tuple[str, type, Any]],
+        fields: Iterable[str | tuple[str, Any] | tuple[str, Any, Any]],
         *,
         bases: tuple[type, ...] = (),
         namespace: dict[str, Any] | None = None,
         init: bool = True,
         repr: bool = True,
         eq: bool = True,
         order: bool = False,
@@ -257,15 +259,15 @@
         weakref_slot: bool = False,
         module: str | None = None,
     ) -> type: ...
 
 elif sys.version_info >= (3, 11):
     def make_dataclass(
         cls_name: str,
-        fields: Iterable[str | tuple[str, type] | tuple[str, type, Any]],
+        fields: Iterable[str | tuple[str, Any] | tuple[str, Any, Any]],
         *,
         bases: tuple[type, ...] = (),
         namespace: dict[str, Any] | None = None,
         init: bool = True,
         repr: bool = True,
         eq: bool = True,
         order: bool = False,
@@ -276,15 +278,15 @@
         slots: bool = False,
         weakref_slot: bool = False,
     ) -> type: ...
 
 elif sys.version_info >= (3, 10):
     def make_dataclass(
         cls_name: str,
-        fields: Iterable[str | tuple[str, type] | tuple[str, type, Any]],
+        fields: Iterable[str | tuple[str, Any] | tuple[str, Any, Any]],
         *,
         bases: tuple[type, ...] = (),
         namespace: dict[str, Any] | None = None,
         init: bool = True,
         repr: bool = True,
         eq: bool = True,
         order: bool = False,
@@ -294,20 +296,20 @@
         kw_only: bool = False,
         slots: bool = False,
     ) -> type: ...
 
 else:
     def make_dataclass(
         cls_name: str,
-        fields: Iterable[str | tuple[str, type] | tuple[str, type, Any]],
+        fields: Iterable[str | tuple[str, Any] | tuple[str, Any, Any]],
         *,
         bases: tuple[type, ...] = (),
         namespace: dict[str, Any] | None = None,
         init: bool = True,
         repr: bool = True,
         eq: bool = True,
         order: bool = False,
         unsafe_hash: bool = False,
         frozen: bool = False,
     ) -> type: ...
 
-def replace(__obj: _DataclassT, **changes: Any) -> _DataclassT: ...
+def replace(obj: _DataclassT, /, **changes: Any) -> _DataclassT: ...
```

## puya/_vendor/mypy/typeshed/stdlib/datetime.pyi

```diff
@@ -1,46 +1,44 @@
 import sys
 from abc import abstractmethod
 from time import struct_time
-from typing import ClassVar, Literal, NamedTuple, NoReturn, SupportsIndex, TypeVar, final, overload
-from typing_extensions import Self, TypeAlias
+from typing import ClassVar, Literal, NamedTuple, NoReturn, SupportsIndex, final, overload
+from typing_extensions import Self, TypeAlias, deprecated
 
 if sys.version_info >= (3, 11):
     __all__ = ("date", "datetime", "time", "timedelta", "timezone", "tzinfo", "MINYEAR", "MAXYEAR", "UTC")
 elif sys.version_info >= (3, 9):
     __all__ = ("date", "datetime", "time", "timedelta", "timezone", "tzinfo", "MINYEAR", "MAXYEAR")
 
-_D = TypeVar("_D", bound=date)
-
 MINYEAR: Literal[1]
 MAXYEAR: Literal[9999]
 
 class tzinfo:
     @abstractmethod
-    def tzname(self, __dt: datetime | None) -> str | None: ...
+    def tzname(self, dt: datetime | None, /) -> str | None: ...
     @abstractmethod
-    def utcoffset(self, __dt: datetime | None) -> timedelta | None: ...
+    def utcoffset(self, dt: datetime | None, /) -> timedelta | None: ...
     @abstractmethod
-    def dst(self, __dt: datetime | None) -> timedelta | None: ...
-    def fromutc(self, __dt: datetime) -> datetime: ...
+    def dst(self, dt: datetime | None, /) -> timedelta | None: ...
+    def fromutc(self, dt: datetime, /) -> datetime: ...
 
 # Alias required to avoid name conflicts with date(time).tzinfo.
 _TzInfo: TypeAlias = tzinfo
 
 @final
 class timezone(tzinfo):
     utc: ClassVar[timezone]
     min: ClassVar[timezone]
     max: ClassVar[timezone]
     def __init__(self, offset: timedelta, name: str = ...) -> None: ...
-    def tzname(self, __dt: datetime | None) -> str: ...
-    def utcoffset(self, __dt: datetime | None) -> timedelta: ...
-    def dst(self, __dt: datetime | None) -> None: ...
+    def tzname(self, dt: datetime | None, /) -> str: ...
+    def utcoffset(self, dt: datetime | None, /) -> timedelta: ...
+    def dst(self, dt: datetime | None, /) -> None: ...
     def __hash__(self) -> int: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
 
 if sys.version_info >= (3, 11):
     UTC: timezone
 
 if sys.version_info >= (3, 9):
     class _IsoCalendarDate(NamedTuple):
         year: int
@@ -49,21 +47,21 @@
 
 class date:
     min: ClassVar[date]
     max: ClassVar[date]
     resolution: ClassVar[timedelta]
     def __new__(cls, year: SupportsIndex, month: SupportsIndex, day: SupportsIndex) -> Self: ...
     @classmethod
-    def fromtimestamp(cls, __timestamp: float) -> Self: ...
+    def fromtimestamp(cls, timestamp: float, /) -> Self: ...
     @classmethod
     def today(cls) -> Self: ...
     @classmethod
-    def fromordinal(cls, __n: int) -> Self: ...
+    def fromordinal(cls, n: int, /) -> Self: ...
     @classmethod
-    def fromisoformat(cls, __date_string: str) -> Self: ...
+    def fromisoformat(cls, date_string: str, /) -> Self: ...
     @classmethod
     def fromisocalendar(cls, year: int, week: int, day: int) -> Self: ...
     @property
     def year(self) -> int: ...
     @property
     def month(self) -> int: ...
     @property
@@ -71,34 +69,34 @@
     def ctime(self) -> str: ...
     # On <3.12, the name of the parameter in the pure-Python implementation
     # didn't match the name in the C implementation,
     # meaning it is only *safe* to pass it as a keyword argument on 3.12+
     if sys.version_info >= (3, 12):
         def strftime(self, format: str) -> str: ...
     else:
-        def strftime(self, __format: str) -> str: ...
+        def strftime(self, format: str, /) -> str: ...
 
-    def __format__(self, __fmt: str) -> str: ...
+    def __format__(self, fmt: str, /) -> str: ...
     def isoformat(self) -> str: ...
     def timetuple(self) -> struct_time: ...
     def toordinal(self) -> int: ...
     def replace(self, year: SupportsIndex = ..., month: SupportsIndex = ..., day: SupportsIndex = ...) -> Self: ...
-    def __le__(self, __value: date) -> bool: ...
-    def __lt__(self, __value: date) -> bool: ...
-    def __ge__(self, __value: date) -> bool: ...
-    def __gt__(self, __value: date) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __add__(self, __value: timedelta) -> Self: ...
-    def __radd__(self, __value: timedelta) -> Self: ...
+    def __le__(self, value: date, /) -> bool: ...
+    def __lt__(self, value: date, /) -> bool: ...
+    def __ge__(self, value: date, /) -> bool: ...
+    def __gt__(self, value: date, /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __add__(self, value: timedelta, /) -> Self: ...
+    def __radd__(self, value: timedelta, /) -> Self: ...
     @overload
-    def __sub__(self, __value: timedelta) -> Self: ...
+    def __sub__(self, value: datetime, /) -> NoReturn: ...
     @overload
-    def __sub__(self, __value: datetime) -> NoReturn: ...
+    def __sub__(self, value: Self, /) -> timedelta: ...
     @overload
-    def __sub__(self: _D, __value: _D) -> timedelta: ...
+    def __sub__(self, value: timedelta, /) -> Self: ...
     def __hash__(self) -> int: ...
     def weekday(self) -> int: ...
     def isoweekday(self) -> int: ...
     if sys.version_info >= (3, 9):
         def isocalendar(self) -> _IsoCalendarDate: ...
     else:
         def isocalendar(self) -> tuple[int, int, int]: ...
@@ -125,32 +123,32 @@
     def second(self) -> int: ...
     @property
     def microsecond(self) -> int: ...
     @property
     def tzinfo(self) -> _TzInfo | None: ...
     @property
     def fold(self) -> int: ...
-    def __le__(self, __value: time) -> bool: ...
-    def __lt__(self, __value: time) -> bool: ...
-    def __ge__(self, __value: time) -> bool: ...
-    def __gt__(self, __value: time) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __le__(self, value: time, /) -> bool: ...
+    def __lt__(self, value: time, /) -> bool: ...
+    def __ge__(self, value: time, /) -> bool: ...
+    def __gt__(self, value: time, /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     def isoformat(self, timespec: str = ...) -> str: ...
     @classmethod
-    def fromisoformat(cls, __time_string: str) -> Self: ...
+    def fromisoformat(cls, time_string: str, /) -> Self: ...
     # On <3.12, the name of the parameter in the pure-Python implementation
     # didn't match the name in the C implementation,
     # meaning it is only *safe* to pass it as a keyword argument on 3.12+
     if sys.version_info >= (3, 12):
         def strftime(self, format: str) -> str: ...
     else:
-        def strftime(self, __format: str) -> str: ...
+        def strftime(self, format: str, /) -> str: ...
 
-    def __format__(self, __fmt: str) -> str: ...
+    def __format__(self, fmt: str, /) -> str: ...
     def utcoffset(self) -> timedelta | None: ...
     def tzname(self) -> str | None: ...
     def dst(self) -> timedelta | None: ...
     def replace(
         self,
         hour: SupportsIndex = ...,
         minute: SupportsIndex = ...,
@@ -181,38 +179,38 @@
     @property
     def days(self) -> int: ...
     @property
     def seconds(self) -> int: ...
     @property
     def microseconds(self) -> int: ...
     def total_seconds(self) -> float: ...
-    def __add__(self, __value: timedelta) -> timedelta: ...
-    def __radd__(self, __value: timedelta) -> timedelta: ...
-    def __sub__(self, __value: timedelta) -> timedelta: ...
-    def __rsub__(self, __value: timedelta) -> timedelta: ...
+    def __add__(self, value: timedelta, /) -> timedelta: ...
+    def __radd__(self, value: timedelta, /) -> timedelta: ...
+    def __sub__(self, value: timedelta, /) -> timedelta: ...
+    def __rsub__(self, value: timedelta, /) -> timedelta: ...
     def __neg__(self) -> timedelta: ...
     def __pos__(self) -> timedelta: ...
     def __abs__(self) -> timedelta: ...
-    def __mul__(self, __value: float) -> timedelta: ...
-    def __rmul__(self, __value: float) -> timedelta: ...
+    def __mul__(self, value: float, /) -> timedelta: ...
+    def __rmul__(self, value: float, /) -> timedelta: ...
     @overload
-    def __floordiv__(self, __value: timedelta) -> int: ...
+    def __floordiv__(self, value: timedelta, /) -> int: ...
     @overload
-    def __floordiv__(self, __value: int) -> timedelta: ...
+    def __floordiv__(self, value: int, /) -> timedelta: ...
     @overload
-    def __truediv__(self, __value: timedelta) -> float: ...
+    def __truediv__(self, value: timedelta, /) -> float: ...
     @overload
-    def __truediv__(self, __value: float) -> timedelta: ...
-    def __mod__(self, __value: timedelta) -> timedelta: ...
-    def __divmod__(self, __value: timedelta) -> tuple[int, timedelta]: ...
-    def __le__(self, __value: timedelta) -> bool: ...
-    def __lt__(self, __value: timedelta) -> bool: ...
-    def __ge__(self, __value: timedelta) -> bool: ...
-    def __gt__(self, __value: timedelta) -> bool: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __truediv__(self, value: float, /) -> timedelta: ...
+    def __mod__(self, value: timedelta, /) -> timedelta: ...
+    def __divmod__(self, value: timedelta, /) -> tuple[int, timedelta]: ...
+    def __le__(self, value: timedelta, /) -> bool: ...
+    def __lt__(self, value: timedelta, /) -> bool: ...
+    def __ge__(self, value: timedelta, /) -> bool: ...
+    def __gt__(self, value: timedelta, /) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __bool__(self) -> bool: ...
     def __hash__(self) -> int: ...
 
 class datetime(date):
     min: ClassVar[datetime]
     max: ClassVar[datetime]
     def __new__(
@@ -244,21 +242,23 @@
     # didn't match the name in the C implementation,
     # meaning it is only *safe* to pass it as a keyword argument on 3.12+
     if sys.version_info >= (3, 12):
         @classmethod
         def fromtimestamp(cls, timestamp: float, tz: _TzInfo | None = ...) -> Self: ...
     else:
         @classmethod
-        def fromtimestamp(cls, __timestamp: float, tz: _TzInfo | None = ...) -> Self: ...
+        def fromtimestamp(cls, timestamp: float, /, tz: _TzInfo | None = ...) -> Self: ...
 
     @classmethod
-    def utcfromtimestamp(cls, __t: float) -> Self: ...
+    @deprecated("Use timezone-aware objects to represent datetimes in UTC; e.g. by calling .fromtimestamp(datetime.UTC)")
+    def utcfromtimestamp(cls, t: float, /) -> Self: ...
     @classmethod
     def now(cls, tz: _TzInfo | None = None) -> Self: ...
     @classmethod
+    @deprecated("Use timezone-aware objects to represent datetimes in UTC; e.g. by calling .now(datetime.UTC)")
     def utcnow(cls) -> Self: ...
     @classmethod
     def combine(cls, date: _Date, time: _Time, tzinfo: _TzInfo | None = ...) -> Self: ...
     def timestamp(self) -> float: ...
     def utctimetuple(self) -> struct_time: ...
     def date(self) -> _Date: ...
     def time(self) -> _Time: ...
@@ -275,21 +275,21 @@
         tzinfo: _TzInfo | None = ...,
         *,
         fold: int = ...,
     ) -> Self: ...
     def astimezone(self, tz: _TzInfo | None = ...) -> Self: ...
     def isoformat(self, sep: str = ..., timespec: str = ...) -> str: ...
     @classmethod
-    def strptime(cls, __date_string: str, __format: str) -> Self: ...
+    def strptime(cls, date_string: str, format: str, /) -> Self: ...
     def utcoffset(self) -> timedelta | None: ...
     def tzname(self) -> str | None: ...
     def dst(self) -> timedelta | None: ...
-    def __le__(self, __value: datetime) -> bool: ...  # type: ignore[override]
-    def __lt__(self, __value: datetime) -> bool: ...  # type: ignore[override]
-    def __ge__(self, __value: datetime) -> bool: ...  # type: ignore[override]
-    def __gt__(self, __value: datetime) -> bool: ...  # type: ignore[override]
-    def __eq__(self, __value: object) -> bool: ...
+    def __le__(self, value: datetime, /) -> bool: ...  # type: ignore[override]
+    def __lt__(self, value: datetime, /) -> bool: ...  # type: ignore[override]
+    def __ge__(self, value: datetime, /) -> bool: ...  # type: ignore[override]
+    def __gt__(self, value: datetime, /) -> bool: ...  # type: ignore[override]
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     @overload  # type: ignore[override]
-    def __sub__(self, __value: timedelta) -> Self: ...
+    def __sub__(self, value: Self, /) -> timedelta: ...
     @overload
-    def __sub__(self: _D, __value: _D) -> timedelta: ...
+    def __sub__(self, value: timedelta, /) -> Self: ...
```

## puya/_vendor/mypy/typeshed/stdlib/dbm/gnu.pyi

```diff
@@ -33,8 +33,9 @@
         @overload
         def get(self, k: _KeyType, default: _T) -> bytes | _T: ...
         def keys(self) -> list[bytes]: ...
         def setdefault(self, k: _KeyType, default: _ValueType = ...) -> bytes: ...
         # Don't exist at runtime
         __new__: None  # type: ignore[assignment]
         __init__: None  # type: ignore[assignment]
-    def open(__filename: str, __flags: str = "r", __mode: int = 0o666) -> _gdbm: ...
+
+    def open(filename: str, flags: str = "r", mode: int = 0o666, /) -> _gdbm: ...
```

## puya/_vendor/mypy/typeshed/stdlib/dbm/ndbm.pyi

```diff
@@ -29,8 +29,9 @@
         @overload
         def get(self, k: _KeyType, default: _T) -> bytes | _T: ...
         def keys(self) -> list[bytes]: ...
         def setdefault(self, k: _KeyType, default: _ValueType = ...) -> bytes: ...
         # Don't exist at runtime
         __new__: None  # type: ignore[assignment]
         __init__: None  # type: ignore[assignment]
-    def open(__filename: str, __flags: str = "r", __mode: int = 0o666) -> _dbm: ...
+
+    def open(filename: str, flags: str = "r", mode: int = 0o666, /) -> _dbm: ...
```

## puya/_vendor/mypy/typeshed/stdlib/difflib.pyi

```diff
@@ -1,10 +1,10 @@
 import sys
 from collections.abc import Callable, Iterable, Iterator, Sequence
-from typing import Any, AnyStr, Generic, NamedTuple, TypeVar, overload
+from typing import Any, AnyStr, Generic, Literal, NamedTuple, TypeVar, overload
 
 if sys.version_info >= (3, 9):
     from types import GenericAlias
 
 __all__ = [
     "get_close_matches",
     "ndiff",
@@ -45,15 +45,15 @@
     def set_seq2(self, b: Sequence[_T]) -> None: ...
     if sys.version_info >= (3, 9):
         def find_longest_match(self, alo: int = 0, ahi: int | None = None, blo: int = 0, bhi: int | None = None) -> Match: ...
     else:
         def find_longest_match(self, alo: int, ahi: int, blo: int, bhi: int) -> Match: ...
 
     def get_matching_blocks(self) -> list[Match]: ...
-    def get_opcodes(self) -> list[tuple[str, int, int, int, int]]: ...
+    def get_opcodes(self) -> list[tuple[Literal["replace", "delete", "insert", "equal"], int, int, int, int]]: ...
     def get_grouped_opcodes(self, n: int = 3) -> Iterable[list[tuple[str, int, int, int, int]]]: ...
     def ratio(self) -> float: ...
     def quick_ratio(self) -> float: ...
     def real_quick_ratio(self) -> float: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
```

## puya/_vendor/mypy/typeshed/stdlib/distutils/core.pyi

```diff
@@ -49,9 +49,9 @@
     libraries: list[str] = ...,
     headers: list[str] = ...,
     ext_package: str = ...,
     include_dirs: list[str] = ...,
     password: str = ...,
     fullname: str = ...,
     **attrs: Any,
-) -> None: ...
+) -> Distribution: ...
 def run_setup(script_name: str, script_args: list[str] | None = None, stop_after: str = "run") -> Distribution: ...
```

## puya/_vendor/mypy/typeshed/stdlib/distutils/sysconfig.pyi

```diff
@@ -1,21 +1,30 @@
 import sys
 from collections.abc import Mapping
 from distutils.ccompiler import CCompiler
+from typing import Literal, overload
+from typing_extensions import deprecated
 
 PREFIX: str
 EXEC_PREFIX: str
 BASE_PREFIX: str
 BASE_EXEC_PREFIX: str
 project_base: str
 python_build: bool
 
 def expand_makefile_vars(s: str, vars: Mapping[str, str]) -> str: ...
+@overload
+@deprecated("SO is deprecated, use EXT_SUFFIX. Support is removed in Python 3.11")
+def get_config_var(name: Literal["SO"]) -> int | str | None: ...
+@overload
 def get_config_var(name: str) -> int | str | None: ...
-def get_config_vars(*args: str) -> Mapping[str, int | str]: ...
+@overload
+def get_config_vars() -> dict[str, str | int]: ...
+@overload
+def get_config_vars(arg: str, /, *args: str) -> list[str | int]: ...
 def get_config_h_filename() -> str: ...
 def get_makefile_filename() -> str: ...
 def get_python_inc(plat_specific: bool = ..., prefix: str | None = None) -> str: ...
 def get_python_lib(plat_specific: bool = ..., standard_lib: bool = ..., prefix: str | None = None) -> str: ...
 def customize_compiler(compiler: CCompiler) -> None: ...
 
 if sys.version_info < (3, 10):
```

## puya/_vendor/mypy/typeshed/stdlib/email/charset.pyi

```diff
@@ -21,14 +21,14 @@
     def header_encode(self, string: str) -> str: ...
     def header_encode_lines(self, string: str, maxlengths: Iterator[int]) -> list[str | None]: ...
     @overload
     def body_encode(self, string: None) -> None: ...
     @overload
     def body_encode(self, string: str | bytes) -> str: ...
     def __eq__(self, other: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
 
 def add_charset(
     charset: str, header_enc: int | None = None, body_enc: int | None = None, output_charset: str | None = None
 ) -> None: ...
 def add_alias(alias: str, canonical: str) -> None: ...
 def add_codec(charset: str, codecname: str) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/email/header.pyi

```diff
@@ -13,15 +13,15 @@
         header_name: str | None = None,
         continuation_ws: str = " ",
         errors: str = "strict",
     ) -> None: ...
     def append(self, s: bytes | bytearray | str, charset: Charset | str | None = None, errors: str = "strict") -> None: ...
     def encode(self, splitchars: str = ";, \t", maxlinelen: int | None = None, linesep: str = "\n") -> str: ...
     def __eq__(self, other: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
 
 # decode_header() either returns list[tuple[str, None]] if the header
 # contains no encoded parts, or list[tuple[bytes, str | None]] if the header
 # contains at least one encoded part.
 def decode_header(header: Header | str) -> list[tuple[Any, Any | None]]: ...
 def make_header(
     decoded_seq: Iterable[tuple[bytes | bytearray | str, str | None]],
```

## puya/_vendor/mypy/typeshed/stdlib/email/headerregistry.pyi

```diff
@@ -136,17 +136,17 @@
     def parse(cls, value: str, kwds: dict[str, Any]) -> None: ...
     @staticmethod
     def value_parser(value: str) -> MessageID: ...
 
 class _HeaderParser(Protocol):
     max_count: ClassVar[Literal[1] | None]
     @staticmethod
-    def value_parser(__value: str) -> TokenList: ...
+    def value_parser(value: str, /) -> TokenList: ...
     @classmethod
-    def parse(cls, __value: str, __kwds: dict[str, Any]) -> None: ...
+    def parse(cls, value: str, kwds: dict[str, Any], /) -> None: ...
 
 class HeaderRegistry:
     registry: dict[str, type[_HeaderParser]]
     base_class: type[BaseHeader]
     default_class: type[_HeaderParser]
     def __init__(
         self, base_class: type[BaseHeader] = ..., default_class: type[_HeaderParser] = ..., use_default_map: bool = True
```

## puya/_vendor/mypy/typeshed/stdlib/email/message.pyi

```diff
@@ -11,24 +11,28 @@
 __all__ = ["Message", "EmailMessage"]
 
 _T = TypeVar("_T")
 _PayloadType: TypeAlias = Message | str
 _EncodedPayloadType: TypeAlias = Message | bytes
 _MultipartPayloadType: TypeAlias = list[_PayloadType]
 _CharsetType: TypeAlias = Charset | str | None
-# Type returned by Policy.header_fetch_parse, AnyOf[str | Header]
+# Type returned by Policy.header_fetch_parse, often str or Header.
 _HeaderType: TypeAlias = Any
-_HeaderTypeParam: TypeAlias = str | Header
+# Type accepted by Policy.header_store_parse.
+_HeaderTypeParam: TypeAlias = str | Header | Any
 
 class _SupportsEncodeToPayload(Protocol):
-    def encode(self, __encoding: str) -> _PayloadType | _MultipartPayloadType | _SupportsDecodeToPayload: ...
+    def encode(self, encoding: str, /) -> _PayloadType | _MultipartPayloadType | _SupportsDecodeToPayload: ...
 
 class _SupportsDecodeToPayload(Protocol):
-    def decode(self, __encoding: str, __errors: str) -> _PayloadType | _MultipartPayloadType: ...
+    def decode(self, encoding: str, errors: str, /) -> _PayloadType | _MultipartPayloadType: ...
 
+# TODO: This class should be generic over the header policy and/or the header
+# value types allowed by the policy. This depends on PEP 696 support
+# (https://github.com/python/typeshed/issues/11422).
 class Message:
     policy: Policy  # undocumented
     preamble: str | None
     epilogue: str | None
     defects: list[MessageDefect]
     def is_multipart(self) -> bool: ...
     def set_unixfrom(self, unixfrom: str) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/email/utils.pyi

```diff
@@ -1,14 +1,14 @@
 import datetime
 import sys
 from _typeshed import Unused
 from email import _ParamType
 from email.charset import Charset
 from typing import overload
-from typing_extensions import TypeAlias
+from typing_extensions import TypeAlias, deprecated
 
 __all__ = [
     "collapse_rfc2231_value",
     "decode_params",
     "decode_rfc2231",
     "encode_rfc2231",
     "formataddr",
@@ -50,14 +50,18 @@
     def parsedate_to_datetime(data: str) -> datetime.datetime: ...
 
 def mktime_tz(data: _PDTZ) -> int: ...
 def formatdate(timeval: float | None = None, localtime: bool = False, usegmt: bool = False) -> str: ...
 def format_datetime(dt: datetime.datetime, usegmt: bool = False) -> str: ...
 
 if sys.version_info >= (3, 12):
+    @overload
+    def localtime(dt: datetime.datetime | None = None) -> datetime.datetime: ...
+    @overload
+    @deprecated("The `isdst` parameter does nothing and will be removed in Python 3.14.")
     def localtime(dt: datetime.datetime | None = None, isdst: Unused = None) -> datetime.datetime: ...
 
 else:
     def localtime(dt: datetime.datetime | None = None, isdst: int = -1) -> datetime.datetime: ...
 
 def make_msgid(idstring: str | None = None, domain: str | None = None) -> str: ...
 def decode_rfc2231(s: str) -> tuple[str | None, str | None, str]: ...  # May return list[str]. See issue #10431 for details.
```

## puya/_vendor/mypy/typeshed/stdlib/encodings/utf_8.pyi

```diff
@@ -2,20 +2,20 @@
 from _typeshed import ReadableBuffer
 
 class IncrementalEncoder(codecs.IncrementalEncoder):
     def encode(self, input: str, final: bool = False) -> bytes: ...
 
 class IncrementalDecoder(codecs.BufferedIncrementalDecoder):
     @staticmethod
-    def _buffer_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
+    def _buffer_decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
 
 class StreamWriter(codecs.StreamWriter):
     @staticmethod
-    def encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
+    def encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
 
 class StreamReader(codecs.StreamReader):
     @staticmethod
-    def decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...
+    def decode(data: ReadableBuffer, errors: str | None = None, final: bool = False, /) -> tuple[str, int]: ...
 
 def getregentry() -> codecs.CodecInfo: ...
-def encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...
+def encode(str: str, errors: str | None = None, /) -> tuple[bytes, int]: ...
 def decode(input: ReadableBuffer, errors: str | None = "strict") -> tuple[str, int]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/enum.pyi

```diff
@@ -171,14 +171,15 @@
     EnumType = EnumMeta
 
     class property(types.DynamicClassAttribute):
         def __set_name__(self, ownerclass: type[Enum], name: str) -> None: ...
         name: str
         clsname: str
         member: Enum | None
+
     _magic_enum_attr = property
 else:
     _magic_enum_attr = types.DynamicClassAttribute
 
 class Enum(metaclass=EnumMeta):
     @_magic_enum_attr
     def name(self) -> str: ...
@@ -257,27 +258,29 @@
         @staticmethod
         def _generate_next_value_(name: str, start: int, count: int, last_values: list[str]) -> str: ...
 
     class EnumCheck(StrEnum):
         CONTINUOUS: str
         NAMED_FLAGS: str
         UNIQUE: str
+
     CONTINUOUS = EnumCheck.CONTINUOUS
     NAMED_FLAGS = EnumCheck.NAMED_FLAGS
     UNIQUE = EnumCheck.UNIQUE
 
     class verify:
         def __init__(self, *checks: EnumCheck) -> None: ...
         def __call__(self, enumeration: _EnumerationT) -> _EnumerationT: ...
 
     class FlagBoundary(StrEnum):
         STRICT: str
         CONFORM: str
         EJECT: str
         KEEP: str
+
     STRICT = FlagBoundary.STRICT
     CONFORM = FlagBoundary.CONFORM
     EJECT = FlagBoundary.EJECT
     KEEP = FlagBoundary.KEEP
 
     def global_str(self: Enum) -> str: ...
     def global_enum(cls: _EnumerationT, update_str: bool = False) -> _EnumerationT: ...
```

## puya/_vendor/mypy/typeshed/stdlib/fcntl.pyi

```diff
@@ -102,26 +102,26 @@
         I_UNLINK: int
 
     if sys.version_info >= (3, 12) and sys.platform == "linux":
         FICLONE: int
         FICLONERANGE: int
 
     @overload
-    def fcntl(__fd: FileDescriptorLike, __cmd: int, __arg: int = 0) -> int: ...
+    def fcntl(fd: FileDescriptorLike, cmd: int, arg: int = 0, /) -> int: ...
     @overload
-    def fcntl(__fd: FileDescriptorLike, __cmd: int, __arg: str | ReadOnlyBuffer) -> bytes: ...
+    def fcntl(fd: FileDescriptorLike, cmd: int, arg: str | ReadOnlyBuffer, /) -> bytes: ...
     # If arg is an int, return int
     @overload
-    def ioctl(__fd: FileDescriptorLike, __request: int, __arg: int = 0, __mutate_flag: bool = True) -> int: ...
+    def ioctl(fd: FileDescriptorLike, request: int, arg: int = 0, mutate_flag: bool = True, /) -> int: ...
     # The return type works as follows:
     # - If arg is a read-write buffer, return int if mutate_flag is True, otherwise bytes
     # - If arg is a read-only buffer, return bytes (and ignore the value of mutate_flag)
     # We can't represent that precisely as we can't distinguish between read-write and read-only
     # buffers, so we add overloads for a few unambiguous cases and use Any for the rest.
     @overload
-    def ioctl(__fd: FileDescriptorLike, __request: int, __arg: bytes, __mutate_flag: bool = True) -> bytes: ...
+    def ioctl(fd: FileDescriptorLike, request: int, arg: bytes, mutate_flag: bool = True, /) -> bytes: ...
     @overload
-    def ioctl(__fd: FileDescriptorLike, __request: int, __arg: WriteableBuffer, __mutate_flag: Literal[False]) -> bytes: ...
+    def ioctl(fd: FileDescriptorLike, request: int, arg: WriteableBuffer, mutate_flag: Literal[False], /) -> bytes: ...
     @overload
-    def ioctl(__fd: FileDescriptorLike, __request: int, __arg: Buffer, __mutate_flag: bool = True) -> Any: ...
-    def flock(__fd: FileDescriptorLike, __operation: int) -> None: ...
-    def lockf(__fd: FileDescriptorLike, __cmd: int, __len: int = 0, __start: int = 0, __whence: int = 0) -> Any: ...
+    def ioctl(fd: FileDescriptorLike, request: int, arg: Buffer, mutate_flag: bool = True, /) -> Any: ...
+    def flock(fd: FileDescriptorLike, operation: int, /) -> None: ...
+    def lockf(fd: FileDescriptorLike, cmd: int, len: int = 0, start: int = 0, whence: int = 0, /) -> Any: ...
```

## puya/_vendor/mypy/typeshed/stdlib/fractions.pyi

```diff
@@ -20,15 +20,15 @@
     @overload
     def gcd(a: Integral, b: Integral) -> Integral: ...
 
 class Fraction(Rational):
     @overload
     def __new__(cls, numerator: int | Rational = 0, denominator: int | Rational | None = None) -> Self: ...
     @overload
-    def __new__(cls, __value: float | Decimal | str) -> Self: ...
+    def __new__(cls, value: float | Decimal | str, /) -> Self: ...
     @classmethod
     def from_float(cls, f: float) -> Self: ...
     @classmethod
     def from_decimal(cls, dec: Decimal) -> Self: ...
     def limit_denominator(self, max_denominator: int = 1000000) -> Fraction: ...
     def as_integer_ratio(self) -> tuple[int, int]: ...
     if sys.version_info >= (3, 12):
```

## puya/_vendor/mypy/typeshed/stdlib/ftplib.pyi

```diff
@@ -27,15 +27,15 @@
     debugging: int
     host: str
     port: int
     maxline: int
     sock: socket | None
     welcome: str | None
     passiveserver: int
-    timeout: int
+    timeout: float | None
     af: int
     lastresp: str
     file: TextIO | None
     encoding: str
     def __enter__(self) -> Self: ...
     def __exit__(
         self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
@@ -44,27 +44,27 @@
     if sys.version_info >= (3, 9):
         def __init__(
             self,
             host: str = "",
             user: str = "",
             passwd: str = "",
             acct: str = "",
-            timeout: float = ...,
+            timeout: float | None = ...,
             source_address: tuple[str, int] | None = None,
             *,
             encoding: str = "utf-8",
         ) -> None: ...
     else:
         def __init__(
             self,
             host: str = "",
             user: str = "",
             passwd: str = "",
             acct: str = "",
-            timeout: float = ...,
+            timeout: float | None = ...,
             source_address: tuple[str, int] | None = None,
         ) -> None: ...
 
     def connect(
         self, host: str = "", port: int = 0, timeout: float = -999, source_address: tuple[str, int] | None = None
     ) -> str: ...
     def getwelcome(self) -> str: ...
@@ -123,44 +123,44 @@
             self,
             host: str = "",
             user: str = "",
             passwd: str = "",
             acct: str = "",
             *,
             context: SSLContext | None = None,
-            timeout: float = ...,
+            timeout: float | None = ...,
             source_address: tuple[str, int] | None = None,
             encoding: str = "utf-8",
         ) -> None: ...
     elif sys.version_info >= (3, 9):
         def __init__(
             self,
             host: str = "",
             user: str = "",
             passwd: str = "",
             acct: str = "",
             keyfile: str | None = None,
             certfile: str | None = None,
             context: SSLContext | None = None,
-            timeout: float = ...,
+            timeout: float | None = ...,
             source_address: tuple[str, int] | None = None,
             *,
             encoding: str = "utf-8",
         ) -> None: ...
     else:
         def __init__(
             self,
             host: str = "",
             user: str = "",
             passwd: str = "",
             acct: str = "",
             keyfile: str | None = None,
             certfile: str | None = None,
             context: SSLContext | None = None,
-            timeout: float = ...,
+            timeout: float | None = ...,
             source_address: tuple[str, int] | None = None,
         ) -> None: ...
     ssl_version: int
     keyfile: str | None
     certfile: str | None
     context: SSLContext
     def login(self, user: str = "", passwd: str = "", acct: str = "", secure: bool = True) -> str: ...
```

## puya/_vendor/mypy/typeshed/stdlib/functools.pyi

```diff
@@ -1,13 +1,13 @@
 import sys
 import types
-from _typeshed import IdentityFunction, SupportsAllComparisons, SupportsItems
+from _typeshed import SupportsAllComparisons, SupportsItems
 from collections.abc import Callable, Hashable, Iterable, Sequence, Sized
 from typing import Any, Generic, Literal, NamedTuple, TypedDict, TypeVar, final, overload
-from typing_extensions import Self, TypeAlias
+from typing_extensions import ParamSpec, Self, TypeAlias
 
 if sys.version_info >= (3, 9):
     from types import GenericAlias
 
 __all__ = [
     "update_wrapper",
     "wraps",
@@ -23,23 +23,26 @@
     "cached_property",
     "singledispatchmethod",
 ]
 
 if sys.version_info >= (3, 9):
     __all__ += ["cache"]
 
-_AnyCallable: TypeAlias = Callable[..., object]
-
 _T = TypeVar("_T")
+_T_co = TypeVar("_T_co", covariant=True)
 _S = TypeVar("_S")
+_PWrapped = ParamSpec("_PWrapped")
+_RWrapped = TypeVar("_RWrapped")
+_PWrapper = ParamSpec("_PWrapper")
+_RWrapper = TypeVar("_RWrapper")
 
 @overload
-def reduce(__function: Callable[[_T, _S], _T], __sequence: Iterable[_S], __initial: _T) -> _T: ...
+def reduce(function: Callable[[_T, _S], _T], sequence: Iterable[_S], initial: _T, /) -> _T: ...
 @overload
-def reduce(__function: Callable[[_T, _T], _T], __sequence: Iterable[_T]) -> _T: ...
+def reduce(function: Callable[[_T, _T], _T], sequence: Iterable[_T], /) -> _T: ...
 
 class _CacheInfo(NamedTuple):
     hits: int
     misses: int
     maxsize: int | None
     currsize: int
 
@@ -54,15 +57,15 @@
     def __call__(self, *args: Hashable, **kwargs: Hashable) -> _T: ...
     def cache_info(self) -> _CacheInfo: ...
     def cache_clear(self) -> None: ...
     if sys.version_info >= (3, 9):
         def cache_parameters(self) -> _CacheParameters: ...
 
     def __copy__(self) -> _lru_cache_wrapper[_T]: ...
-    def __deepcopy__(self, __memo: Any) -> _lru_cache_wrapper[_T]: ...
+    def __deepcopy__(self, memo: Any, /) -> _lru_cache_wrapper[_T]: ...
 
 @overload
 def lru_cache(maxsize: int | None = 128, typed: bool = False) -> Callable[[Callable[..., _T]], _lru_cache_wrapper[_T]]: ...
 @overload
 def lru_cache(maxsize: Callable[..., _T], typed: bool = False) -> _lru_cache_wrapper[_T]: ...
 
 if sys.version_info >= (3, 12):
@@ -76,66 +79,76 @@
     ]
 else:
     WRAPPER_ASSIGNMENTS: tuple[
         Literal["__module__"], Literal["__name__"], Literal["__qualname__"], Literal["__doc__"], Literal["__annotations__"]
     ]
 WRAPPER_UPDATES: tuple[Literal["__dict__"]]
 
+class _Wrapped(Generic[_PWrapped, _RWrapped, _PWrapper, _RWrapper]):
+    __wrapped__: Callable[_PWrapped, _RWrapped]
+    def __call__(self, *args: _PWrapper.args, **kwargs: _PWrapper.kwargs) -> _RWrapper: ...
+    # as with ``Callable``, we'll assume that these attributes exist
+    __name__: str
+    __qualname__: str
+
+class _Wrapper(Generic[_PWrapped, _RWrapped]):
+    def __call__(self, f: Callable[_PWrapper, _RWrapper]) -> _Wrapped[_PWrapped, _RWrapped, _PWrapper, _RWrapper]: ...
+
 if sys.version_info >= (3, 12):
     def update_wrapper(
-        wrapper: _T,
-        wrapped: _AnyCallable,
+        wrapper: Callable[_PWrapper, _RWrapper],
+        wrapped: Callable[_PWrapped, _RWrapped],
         assigned: Sequence[str] = ("__module__", "__name__", "__qualname__", "__doc__", "__annotations__", "__type_params__"),
         updated: Sequence[str] = ("__dict__",),
-    ) -> _T: ...
+    ) -> _Wrapped[_PWrapped, _RWrapped, _PWrapper, _RWrapper]: ...
     def wraps(
-        wrapped: _AnyCallable,
+        wrapped: Callable[_PWrapped, _RWrapped],
         assigned: Sequence[str] = ("__module__", "__name__", "__qualname__", "__doc__", "__annotations__", "__type_params__"),
         updated: Sequence[str] = ("__dict__",),
-    ) -> IdentityFunction: ...
+    ) -> _Wrapper[_PWrapped, _RWrapped]: ...
 
 else:
     def update_wrapper(
-        wrapper: _T,
-        wrapped: _AnyCallable,
+        wrapper: Callable[_PWrapper, _RWrapper],
+        wrapped: Callable[_PWrapped, _RWrapped],
         assigned: Sequence[str] = ("__module__", "__name__", "__qualname__", "__doc__", "__annotations__"),
         updated: Sequence[str] = ("__dict__",),
-    ) -> _T: ...
+    ) -> _Wrapped[_PWrapped, _RWrapped, _PWrapper, _RWrapper]: ...
     def wraps(
-        wrapped: _AnyCallable,
+        wrapped: Callable[_PWrapped, _RWrapped],
         assigned: Sequence[str] = ("__module__", "__name__", "__qualname__", "__doc__", "__annotations__"),
         updated: Sequence[str] = ("__dict__",),
-    ) -> IdentityFunction: ...
+    ) -> _Wrapper[_PWrapped, _RWrapped]: ...
 
 def total_ordering(cls: type[_T]) -> type[_T]: ...
 def cmp_to_key(mycmp: Callable[[_T, _T], int]) -> Callable[[_T], SupportsAllComparisons]: ...
 
 class partial(Generic[_T]):
     @property
     def func(self) -> Callable[..., _T]: ...
     @property
     def args(self) -> tuple[Any, ...]: ...
     @property
     def keywords(self) -> dict[str, Any]: ...
-    def __new__(cls, __func: Callable[..., _T], *args: Any, **kwargs: Any) -> Self: ...
-    def __call__(__self, *args: Any, **kwargs: Any) -> _T: ...
+    def __new__(cls, func: Callable[..., _T], /, *args: Any, **kwargs: Any) -> Self: ...
+    def __call__(self, /, *args: Any, **kwargs: Any) -> _T: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 # With protocols, this could change into a generic protocol that defines __get__ and returns _T
 _Descriptor: TypeAlias = Any
 
 class partialmethod(Generic[_T]):
     func: Callable[..., _T] | _Descriptor
     args: tuple[Any, ...]
     keywords: dict[str, Any]
     @overload
-    def __init__(self, __func: Callable[..., _T], *args: Any, **keywords: Any) -> None: ...
+    def __init__(self, func: Callable[..., _T], /, *args: Any, **keywords: Any) -> None: ...
     @overload
-    def __init__(self, __func: _Descriptor, *args: Any, **keywords: Any) -> None: ...
+    def __init__(self, func: _Descriptor, /, *args: Any, **keywords: Any) -> None: ...
     def __get__(self, obj: Any, cls: type[Any] | None = None) -> Callable[..., _T]: ...
     @property
     def __isabstractmethod__(self) -> bool: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 class _SingleDispatchCallable(Generic[_T]):
@@ -149,15 +162,15 @@
     # def _(arg: int, verbose=False):
     @overload
     def register(self, cls: Callable[..., _T], func: None = None) -> Callable[..., _T]: ...
     # fun.register(int, lambda x: x)
     @overload
     def register(self, cls: type[Any], func: Callable[..., _T]) -> Callable[..., _T]: ...
     def _clear_cache(self) -> None: ...
-    def __call__(__self, *args: Any, **kwargs: Any) -> _T: ...
+    def __call__(self, /, *args: Any, **kwargs: Any) -> _T: ...
 
 def singledispatch(func: Callable[..., _T]) -> _SingleDispatchCallable[_T]: ...
 
 class singledispatchmethod(Generic[_T]):
     dispatcher: _SingleDispatchCallable[_T]
     func: Callable[..., _T]
     def __init__(self, func: Callable[..., _T]) -> None: ...
@@ -167,30 +180,30 @@
     def register(self, cls: type[Any], method: None = None) -> Callable[[Callable[..., _T]], Callable[..., _T]]: ...
     @overload
     def register(self, cls: Callable[..., _T], method: None = None) -> Callable[..., _T]: ...
     @overload
     def register(self, cls: type[Any], method: Callable[..., _T]) -> Callable[..., _T]: ...
     def __get__(self, obj: _S, cls: type[_S] | None = None) -> Callable[..., _T]: ...
 
-class cached_property(Generic[_T]):
-    func: Callable[[Any], _T]
+class cached_property(Generic[_T_co]):
+    func: Callable[[Any], _T_co]
     attrname: str | None
-    def __init__(self, func: Callable[[Any], _T]) -> None: ...
+    def __init__(self, func: Callable[[Any], _T_co]) -> None: ...
     @overload
     def __get__(self, instance: None, owner: type[Any] | None = None) -> Self: ...
     @overload
-    def __get__(self, instance: object, owner: type[Any] | None = None) -> _T: ...
+    def __get__(self, instance: object, owner: type[Any] | None = None) -> _T_co: ...
     def __set_name__(self, owner: type[Any], name: str) -> None: ...
     # __set__ is not defined at runtime, but @cached_property is designed to be settable
-    def __set__(self, instance: object, value: _T) -> None: ...
+    def __set__(self, instance: object, value: _T_co) -> None: ...  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 if sys.version_info >= (3, 9):
-    def cache(__user_function: Callable[..., _T]) -> _lru_cache_wrapper[_T]: ...
+    def cache(user_function: Callable[..., _T], /) -> _lru_cache_wrapper[_T]: ...
 
 def _make_key(
     args: tuple[Hashable, ...],
     kwds: SupportsItems[Any, Any],
     typed: bool,
     kwd_mark: tuple[object, ...] = ...,
     fasttypes: set[type] = ...,
```

## puya/_vendor/mypy/typeshed/stdlib/gc.pyi

```diff
@@ -23,15 +23,15 @@
 def freeze() -> None: ...
 def unfreeze() -> None: ...
 def get_freeze_count() -> int: ...
 def get_referents(*objs: Any) -> list[Any]: ...
 def get_referrers(*objs: Any) -> list[Any]: ...
 def get_stats() -> list[dict[str, Any]]: ...
 def get_threshold() -> tuple[int, int, int]: ...
-def is_tracked(__obj: Any) -> bool: ...
+def is_tracked(obj: Any, /) -> bool: ...
 
 if sys.version_info >= (3, 9):
-    def is_finalized(__obj: Any) -> bool: ...
+    def is_finalized(obj: Any, /) -> bool: ...
 
 def isenabled() -> bool: ...
-def set_debug(__flags: int) -> None: ...
+def set_debug(flags: int, /) -> None: ...
 def set_threshold(threshold0: int, threshold1: int = ..., threshold2: int = ...) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/grp.pyi

```diff
@@ -3,14 +3,15 @@
 from typing import Any, Final, final
 
 if sys.platform != "win32":
     @final
     class struct_group(structseq[Any], tuple[str, str | None, int, list[str]]):
         if sys.version_info >= (3, 10):
             __match_args__: Final = ("gr_name", "gr_passwd", "gr_gid", "gr_mem")
+
         @property
         def gr_name(self) -> str: ...
         @property
         def gr_passwd(self) -> str | None: ...
         @property
         def gr_gid(self) -> int: ...
         @property
```

## puya/_vendor/mypy/typeshed/stdlib/gzip.pyi

```diff
@@ -18,23 +18,23 @@
 FTEXT: int  # actually Literal[1] # undocumented
 FHCRC: int  # actually Literal[2] # undocumented
 FEXTRA: int  # actually Literal[4] # undocumented
 FNAME: int  # actually Literal[8] # undocumented
 FCOMMENT: int  # actually Literal[16] # undocumented
 
 class _ReadableFileobj(Protocol):
-    def read(self, __n: int) -> bytes: ...
-    def seek(self, __n: int) -> object: ...
+    def read(self, n: int, /) -> bytes: ...
+    def seek(self, n: int, /) -> object: ...
     # The following attributes and methods are optional:
     # name: str
     # mode: str
     # def fileno() -> int: ...
 
 class _WritableFileobj(Protocol):
-    def write(self, __b: bytes) -> object: ...
+    def write(self, b: bytes, /) -> object: ...
     def flush(self) -> object: ...
     # The following attributes and methods are optional:
     # name: str
     # mode: str
     # def fileno() -> int: ...
 
 @overload
```

## puya/_vendor/mypy/typeshed/stdlib/hashlib.pyi

```diff
@@ -55,15 +55,15 @@
     def block_size(self) -> int: ...
     @property
     def name(self) -> str: ...
     def __init__(self, data: ReadableBuffer = ...) -> None: ...
     def copy(self) -> Self: ...
     def digest(self) -> bytes: ...
     def hexdigest(self) -> str: ...
-    def update(self, __data: ReadableBuffer) -> None: ...
+    def update(self, data: ReadableBuffer, /) -> None: ...
 
 if sys.version_info >= (3, 9):
     def new(name: str, data: ReadableBuffer = b"", *, usedforsecurity: bool = ...) -> _Hash: ...
     def md5(string: ReadableBuffer = b"", *, usedforsecurity: bool = True) -> _Hash: ...
     def sha1(string: ReadableBuffer = b"", *, usedforsecurity: bool = True) -> _Hash: ...
     def sha224(string: ReadableBuffer = b"", *, usedforsecurity: bool = True) -> _Hash: ...
     def sha256(string: ReadableBuffer = b"", *, usedforsecurity: bool = True) -> _Hash: ...
@@ -88,17 +88,17 @@
 
 class _VarLenHash:
     digest_size: int
     block_size: int
     name: str
     def __init__(self, data: ReadableBuffer = ...) -> None: ...
     def copy(self) -> _VarLenHash: ...
-    def digest(self, __length: int) -> bytes: ...
-    def hexdigest(self, __length: int) -> str: ...
-    def update(self, __data: ReadableBuffer) -> None: ...
+    def digest(self, length: int, /) -> bytes: ...
+    def hexdigest(self, length: int, /) -> str: ...
+    def update(self, data: ReadableBuffer, /) -> None: ...
 
 sha3_224 = _Hash
 sha3_256 = _Hash
 sha3_384 = _Hash
 sha3_512 = _Hash
 shake_128 = _VarLenHash
 shake_256 = _VarLenHash
@@ -112,15 +112,16 @@
     MAX_KEY_SIZE: int
     PERSON_SIZE: int
     SALT_SIZE: int
 
     if sys.version_info >= (3, 9):
         def __init__(
             self,
-            __data: ReadableBuffer = ...,
+            data: ReadableBuffer = ...,
+            /,
             *,
             digest_size: int = ...,
             key: ReadableBuffer = ...,
             salt: ReadableBuffer = ...,
             person: ReadableBuffer = ...,
             fanout: int = ...,
             depth: int = ...,
@@ -130,15 +131,16 @@
             inner_size: int = ...,
             last_node: bool = ...,
             usedforsecurity: bool = ...,
         ) -> None: ...
     else:
         def __init__(
             self,
-            __data: ReadableBuffer = ...,
+            data: ReadableBuffer = ...,
+            /,
             *,
             digest_size: int = ...,
             key: ReadableBuffer = ...,
             salt: ReadableBuffer = ...,
             person: ReadableBuffer = ...,
             fanout: int = ...,
             depth: int = ...,
@@ -153,13 +155,13 @@
 blake2s = _BlakeHash
 
 if sys.version_info >= (3, 11):
     class _BytesIOLike(Protocol):
         def getbuffer(self) -> ReadableBuffer: ...
 
     class _FileDigestFileObj(Protocol):
-        def readinto(self, __buf: bytearray) -> int: ...
+        def readinto(self, buf: bytearray, /) -> int: ...
         def readable(self) -> bool: ...
 
     def file_digest(
-        __fileobj: _BytesIOLike | _FileDigestFileObj, __digest: str | Callable[[], _Hash], *, _bufsize: int = 262144
+        fileobj: _BytesIOLike | _FileDigestFileObj, digest: str | Callable[[], _Hash], /, *, _bufsize: int = 262144
     ) -> _Hash: ...
```

## puya/_vendor/mypy/typeshed/stdlib/heapq.pyi

```diff
@@ -10,8 +10,8 @@
 __about__: Final[str]
 
 def merge(
     *iterables: Iterable[_S], key: Callable[[_S], SupportsRichComparison] | None = None, reverse: bool = False
 ) -> Iterable[_S]: ...
 def nlargest(n: int, iterable: Iterable[_S], key: Callable[[_S], SupportsRichComparison] | None = None) -> list[_S]: ...
 def nsmallest(n: int, iterable: Iterable[_S], key: Callable[[_S], SupportsRichComparison] | None = None) -> list[_S]: ...
-def _heapify_max(__heap: list[Any]) -> None: ...  # undocumented
+def _heapify_max(heap: list[Any], /) -> None: ...  # undocumented
```

## puya/_vendor/mypy/typeshed/stdlib/hmac.pyi

```diff
@@ -28,11 +28,11 @@
     def __init__(self, key: bytes | bytearray, msg: ReadableBuffer | None = None, digestmod: _DigestMod = "") -> None: ...
     def update(self, msg: ReadableBuffer) -> None: ...
     def digest(self) -> bytes: ...
     def hexdigest(self) -> str: ...
     def copy(self) -> HMAC: ...
 
 @overload
-def compare_digest(__a: ReadableBuffer, __b: ReadableBuffer) -> bool: ...
+def compare_digest(a: ReadableBuffer, b: ReadableBuffer, /) -> bool: ...
 @overload
-def compare_digest(__a: AnyStr, __b: AnyStr) -> bool: ...
+def compare_digest(a: AnyStr, b: AnyStr, /) -> bool: ...
 def digest(key: SizedBuffer, msg: ReadableBuffer, digest: _DigestMod) -> bytes: ...
```

## puya/_vendor/mypy/typeshed/stdlib/imghdr.pyi

```diff
@@ -2,16 +2,16 @@
 from collections.abc import Callable
 from typing import Any, BinaryIO, Protocol, overload
 
 __all__ = ["what"]
 
 class _ReadableBinary(Protocol):
     def tell(self) -> int: ...
-    def read(self, __size: int) -> bytes: ...
-    def seek(self, __offset: int) -> Any: ...
+    def read(self, size: int, /) -> bytes: ...
+    def seek(self, offset: int, /) -> Any: ...
 
 @overload
 def what(file: StrPath | _ReadableBinary, h: None = None) -> str | None: ...
 @overload
 def what(file: Any, h: bytes) -> str | None: ...
 
 tests: list[Callable[[bytes, BinaryIO | None], str | None]]
```

## puya/_vendor/mypy/typeshed/stdlib/imp.pyi

```diff
@@ -41,15 +41,15 @@
 # but we ignore that here.
 class _FileLike(Protocol):
     closed: bool
     mode: str
     def read(self) -> str | bytes: ...
     def close(self) -> Any: ...
     def __enter__(self) -> Any: ...
-    def __exit__(self, __typ: type[BaseException] | None, __exc: BaseException | None, __tb: TracebackType | None) -> Any: ...
+    def __exit__(self, typ: type[BaseException] | None, exc: BaseException | None, tb: TracebackType | None, /) -> Any: ...
 
 # PathLike doesn't work for the pathname argument here
 def load_source(name: str, pathname: str, file: _FileLike | None = None) -> types.ModuleType: ...
 def load_compiled(name: str, pathname: str, file: _FileLike | None = None) -> types.ModuleType: ...
 def load_package(name: str, path: StrPath) -> types.ModuleType: ...
 def load_module(name: str, file: _FileLike | None, filename: str, details: tuple[str, str, int]) -> types.ModuleType: ...
```

## puya/_vendor/mypy/typeshed/stdlib/importlib/abc.pyi

```diff
@@ -68,15 +68,15 @@
     class MetaPathFinder(metaclass=ABCMeta):
         if sys.version_info < (3, 12):
             def find_module(self, fullname: str, path: Sequence[str] | None) -> Loader | None: ...
 
         def invalidate_caches(self) -> None: ...
         # Not defined on the actual class, but expected to exist.
         def find_spec(
-            self, __fullname: str, __path: Sequence[str] | None, __target: types.ModuleType | None = ...
+            self, fullname: str, path: Sequence[str] | None, target: types.ModuleType | None = ..., /
         ) -> ModuleSpec | None: ...
 
     class PathEntryFinder(metaclass=ABCMeta):
         if sys.version_info < (3, 12):
             def find_module(self, fullname: str) -> Loader | None: ...
             def find_loader(self, fullname: str) -> tuple[Loader | None, Sequence[str]]: ...
 
@@ -87,15 +87,15 @@
 else:
     # Please keep in sync with sys._MetaPathFinder
     class MetaPathFinder(Finder):
         def find_module(self, fullname: str, path: Sequence[str] | None) -> Loader | None: ...
         def invalidate_caches(self) -> None: ...
         # Not defined on the actual class, but expected to exist.
         def find_spec(
-            self, __fullname: str, __path: Sequence[str] | None, __target: types.ModuleType | None = ...
+            self, fullname: str, path: Sequence[str] | None, target: types.ModuleType | None = ..., /
         ) -> ModuleSpec | None: ...
 
     class PathEntryFinder(Finder):
         def find_module(self, fullname: str) -> Loader | None: ...
         def find_loader(self, fullname: str) -> tuple[Loader | None, Sequence[str]]: ...
         def invalidate_caches(self) -> None: ...
         # Not defined on the actual class, but expected to exist.
@@ -134,33 +134,33 @@
         @abstractmethod
         def iterdir(self) -> Iterator[Traversable]: ...
         if sys.version_info >= (3, 11):
             @abstractmethod
             def joinpath(self, *descendants: str) -> Traversable: ...
         else:
             @abstractmethod
-            def joinpath(self, __child: str) -> Traversable: ...
+            def joinpath(self, child: str, /) -> Traversable: ...
 
         # The documentation and runtime protocol allows *args, **kwargs arguments,
         # but this would mean that all implementers would have to support them,
         # which is not the case.
         @overload
         @abstractmethod
-        def open(self, __mode: Literal["r"] = "r", *, encoding: str | None = None, errors: str | None = None) -> IO[str]: ...
+        def open(self, mode: Literal["r"] = "r", /, *, encoding: str | None = None, errors: str | None = None) -> IO[str]: ...
         @overload
         @abstractmethod
-        def open(self, __mode: Literal["rb"]) -> IO[bytes]: ...
+        def open(self, mode: Literal["rb"], /) -> IO[bytes]: ...
         @property
         @abstractmethod
         def name(self) -> str: ...
         if sys.version_info >= (3, 10):
-            def __truediv__(self, __child: str) -> Traversable: ...
+            def __truediv__(self, child: str, /) -> Traversable: ...
         else:
             @abstractmethod
-            def __truediv__(self, __child: str) -> Traversable: ...
+            def __truediv__(self, child: str, /) -> Traversable: ...
 
         @abstractmethod
         def read_bytes(self) -> bytes: ...
         @abstractmethod
         def read_text(self, encoding: str | None = None) -> str: ...
 
     class TraversableResources(ResourceReader):
```

## puya/_vendor/mypy/typeshed/stdlib/importlib/metadata/__init__.pyi

```diff
@@ -6,15 +6,15 @@
 from collections.abc import Iterable, Iterator, Mapping
 from email.message import Message
 from importlib.abc import MetaPathFinder
 from os import PathLike
 from pathlib import Path
 from re import Pattern
 from typing import Any, ClassVar, Generic, NamedTuple, TypeVar, overload
-from typing_extensions import Self
+from typing_extensions import Self, TypeAlias
 
 _T = TypeVar("_T")
 _KT = TypeVar("_KT")
 _VT = TypeVar("_VT")
 
 __all__ = [
     "Distribution",
@@ -29,24 +29,33 @@
     "version",
 ]
 
 if sys.version_info >= (3, 10):
     __all__ += ["PackageMetadata", "packages_distributions"]
 
 if sys.version_info >= (3, 10):
-    from importlib.metadata._meta import PackageMetadata as PackageMetadata
+    from importlib.metadata._meta import PackageMetadata as PackageMetadata, SimplePath
     def packages_distributions() -> Mapping[str, list[str]]: ...
 
+    if sys.version_info >= (3, 12):
+        # It's generic but shouldn't be
+        _SimplePath: TypeAlias = SimplePath[Any]
+    else:
+        _SimplePath: TypeAlias = SimplePath
+else:
+    _SimplePath: TypeAlias = Path
+
 class PackageNotFoundError(ModuleNotFoundError):
     @property
     def name(self) -> str: ...  # type: ignore[override]
 
 if sys.version_info >= (3, 11):
     class DeprecatedTuple:
         def __getitem__(self, item: int) -> str: ...
+
     _EntryPointBase = DeprecatedTuple
 else:
     class _EntryPointBase(NamedTuple):
         name: str
         value: str
         group: str
 
@@ -179,15 +188,15 @@
 else:
     _distribution_parent = object
 
 class Distribution(_distribution_parent):
     @abc.abstractmethod
     def read_text(self, filename: str) -> str | None: ...
     @abc.abstractmethod
-    def locate_file(self, path: StrPath) -> PathLike[str]: ...
+    def locate_file(self, path: StrPath) -> _SimplePath: ...
     @classmethod
     def from_name(cls, name: str) -> Distribution: ...
     @overload
     @classmethod
     def discover(cls, *, context: DistributionFinder.Context) -> Iterable[Distribution]: ...
     @overload
     @classmethod
@@ -228,22 +237,22 @@
     @abc.abstractmethod
     def find_distributions(self, context: DistributionFinder.Context = ...) -> Iterable[Distribution]: ...
 
 class MetadataPathFinder(DistributionFinder):
     @classmethod
     def find_distributions(cls, context: DistributionFinder.Context = ...) -> Iterable[PathDistribution]: ...
     if sys.version_info >= (3, 10):
-        # Yes, this is an instance method that has argumend named "cls"
+        # Yes, this is an instance method that has a parameter named "cls"
         def invalidate_caches(cls) -> None: ...
 
 class PathDistribution(Distribution):
-    _path: Path
-    def __init__(self, path: Path) -> None: ...
-    def read_text(self, filename: StrPath) -> str: ...
-    def locate_file(self, path: StrPath) -> PathLike[str]: ...
+    _path: _SimplePath
+    def __init__(self, path: _SimplePath) -> None: ...
+    def read_text(self, filename: StrPath) -> str | None: ...
+    def locate_file(self, path: StrPath) -> _SimplePath: ...
 
 def distribution(distribution_name: str) -> Distribution: ...
 @overload
 def distributions(*, context: DistributionFinder.Context) -> Iterable[Distribution]: ...
 @overload
 def distributions(
     *, context: None = None, name: str | None = ..., path: list[str] = ..., **kwargs: Any
```

## puya/_vendor/mypy/typeshed/stdlib/importlib/metadata/_meta.pyi

```diff
@@ -1,12 +1,13 @@
 import sys
 from collections.abc import Iterator
 from typing import Any, Protocol, TypeVar, overload
 
 _T = TypeVar("_T")
+_T_co = TypeVar("_T_co", covariant=True)
 
 class PackageMetadata(Protocol):
     def __len__(self) -> int: ...
     def __contains__(self, item: str) -> bool: ...
     def __getitem__(self, key: str) -> str: ...
     def __iter__(self) -> Iterator[str]: ...
     @property
@@ -18,23 +19,31 @@
     if sys.version_info >= (3, 12):
         @overload
         def get(self, name: str, failobj: None = None) -> str | None: ...
         @overload
         def get(self, name: str, failobj: _T) -> _T | str: ...
 
 if sys.version_info >= (3, 12):
-    class SimplePath(Protocol[_T]):
-        def joinpath(self) -> _T: ...
+    class SimplePath(Protocol[_T_co]):
+        # At runtime this is defined as taking `str | _T`, but that causes trouble.
+        # See #11436.
+        def joinpath(self, other: str, /) -> _T_co: ...
         @property
-        def parent(self) -> _T: ...
+        def parent(self) -> _T_co: ...
         def read_text(self) -> str: ...
-        def __truediv__(self, other: _T | str) -> _T: ...
+        # As with joinpath(), this is annotated as taking `str | _T` at runtime.
+        def __truediv__(self, other: str, /) -> _T_co: ...
 
 else:
     class SimplePath(Protocol):
-        def joinpath(self) -> SimplePath: ...
-        def parent(self) -> SimplePath: ...
+        # Actually takes only self at runtime, but that's clearly wrong
+        def joinpath(self, other: Any, /) -> SimplePath: ...
+        # Not defined as a property at runtime, but it should be
+        @property
+        def parent(self) -> Any: ...
         def read_text(self) -> str: ...
         # There was a bug in `SimplePath` definition in cpython, see #8451
         #  Strictly speaking `__div__` was defined in 3.10, not __truediv__,
         # but it should have always been `__truediv__`.
-        def __truediv__(self) -> SimplePath: ...
+        # Also, the runtime defines this method as taking no arguments,
+        # which is obviously wrong.
+        def __truediv__(self, other: Any, /) -> SimplePath: ...
```

## puya/_vendor/mypy/typeshed/stdlib/importlib/resources/simple.pyi

```diff
@@ -1,10 +1,9 @@
 import abc
 import sys
-from _typeshed import Incomplete, OpenBinaryMode, OpenTextMode, Unused
 from collections.abc import Iterator
 from io import TextIOWrapper
 from typing import IO, Any, BinaryIO, Literal, NoReturn, overload
 from typing_extensions import Never
 
 if sys.version_info >= (3, 11):
     from .abc import Traversable, TraversableResources
@@ -24,19 +23,27 @@
 
     class ResourceHandle(Traversable, metaclass=abc.ABCMeta):
         parent: ResourceContainer
         def __init__(self, parent: ResourceContainer, name: str) -> None: ...
         def is_file(self) -> Literal[True]: ...
         def is_dir(self) -> Literal[False]: ...
         @overload
-        def open(self, mode: OpenTextMode = "r", *args: Incomplete, **kwargs: Incomplete) -> TextIOWrapper: ...
+        def open(
+            self,
+            mode: Literal["r"] = "r",
+            encoding: str | None = None,
+            errors: str | None = None,
+            newline: str | None = None,
+            line_buffering: bool = False,
+            write_through: bool = False,
+        ) -> TextIOWrapper: ...
         @overload
-        def open(self, mode: OpenBinaryMode, *args: Unused, **kwargs: Unused) -> BinaryIO: ...
+        def open(self, mode: Literal["rb"]) -> BinaryIO: ...
         @overload
-        def open(self, mode: str, *args: Incomplete, **kwargs: Incomplete) -> IO[Any]: ...
+        def open(self, mode: str) -> IO[Any]: ...
         def joinpath(self, name: Never) -> NoReturn: ...  # type: ignore[override]
 
     class ResourceContainer(Traversable, metaclass=abc.ABCMeta):
         reader: SimpleReader
         def __init__(self, reader: SimpleReader) -> None: ...
         def is_dir(self) -> Literal[True]: ...
         def is_file(self) -> Literal[False]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/inspect.pyi

```diff
@@ -221,18 +221,18 @@
 def isasyncgenfunction(obj: Callable[..., AsyncGenerator[Any, Any]]) -> bool: ...
 @overload
 def isasyncgenfunction(obj: Callable[_P, Any]) -> TypeGuard[Callable[_P, AsyncGeneratorType[Any, Any]]]: ...
 @overload
 def isasyncgenfunction(obj: object) -> TypeGuard[Callable[..., AsyncGeneratorType[Any, Any]]]: ...
 
 class _SupportsSet(Protocol[_T_cont, _V_cont]):
-    def __set__(self, __instance: _T_cont, __value: _V_cont) -> None: ...
+    def __set__(self, instance: _T_cont, value: _V_cont, /) -> None: ...
 
 class _SupportsDelete(Protocol[_T_cont]):
-    def __delete__(self, __instance: _T_cont) -> None: ...
+    def __delete__(self, instance: _T_cont, /) -> None: ...
 
 def isasyncgen(object: object) -> TypeGuard[AsyncGeneratorType[Any, Any]]: ...
 def istraceback(object: object) -> TypeGuard[TracebackType]: ...
 def isframe(object: object) -> TypeGuard[FrameType]: ...
 def iscode(object: object) -> TypeGuard[CodeType]: ...
 def isbuiltin(object: object) -> TypeGuard[BuiltinFunctionType]: ...
 
@@ -426,14 +426,15 @@
 
 if sys.version_info < (3, 11):
     class ArgSpec(NamedTuple):
         args: list[str]
         varargs: str | None
         keywords: str | None
         defaults: tuple[Any, ...]
+
     def getargspec(func: object) -> ArgSpec: ...
 
 class FullArgSpec(NamedTuple):
     args: list[str]
     varargs: str | None
     varkw: str | None
     defaults: tuple[Any, ...] | None
@@ -477,15 +478,15 @@
     locals: Mapping[str, Any] | None,
     formatarg: Callable[[str], str] | None = ...,
     formatvarargs: Callable[[str], str] | None = ...,
     formatvarkw: Callable[[str], str] | None = ...,
     formatvalue: Callable[[Any], str] | None = ...,
 ) -> str: ...
 def getmro(cls: type) -> tuple[type, ...]: ...
-def getcallargs(__func: Callable[_P, Any], *args: _P.args, **kwds: _P.kwargs) -> dict[str, Any]: ...
+def getcallargs(func: Callable[_P, Any], /, *args: _P.args, **kwds: _P.kwargs) -> dict[str, Any]: ...
 
 class ClosureVars(NamedTuple):
     nonlocals: Mapping[str, Any]
     globals: Mapping[str, Any]
     builtins: Mapping[str, Any]
     unbound: AbstractSet[str]
```

## puya/_vendor/mypy/typeshed/stdlib/io.pyi

```diff
@@ -2,15 +2,15 @@
 import builtins
 import codecs
 import sys
 from _typeshed import FileDescriptorOrPath, ReadableBuffer, WriteableBuffer
 from collections.abc import Callable, Iterable, Iterator
 from os import _Opener
 from types import TracebackType
-from typing import IO, Any, BinaryIO, Literal, TextIO, TypeVar, overload
+from typing import IO, Any, BinaryIO, Literal, Protocol, TextIO, TypeVar, overload, type_check_only
 from typing_extensions import Self
 
 __all__ = [
     "BlockingIOError",
     "open",
     "open_code",
     "IOBase",
@@ -59,107 +59,137 @@
     ) -> None: ...
     def close(self) -> None: ...
     def fileno(self) -> int: ...
     def flush(self) -> None: ...
     def isatty(self) -> bool: ...
     def readable(self) -> bool: ...
     read: Callable[..., Any]
-    def readlines(self, __hint: int = -1) -> list[bytes]: ...
-    def seek(self, __offset: int, __whence: int = ...) -> int: ...
+    def readlines(self, hint: int = -1, /) -> list[bytes]: ...
+    def seek(self, offset: int, whence: int = ..., /) -> int: ...
     def seekable(self) -> bool: ...
     def tell(self) -> int: ...
-    def truncate(self, __size: int | None = ...) -> int: ...
+    def truncate(self, size: int | None = ..., /) -> int: ...
     def writable(self) -> bool: ...
     write: Callable[..., Any]
-    def writelines(self, __lines: Iterable[ReadableBuffer]) -> None: ...
-    def readline(self, __size: int | None = -1) -> bytes: ...
+    def writelines(self, lines: Iterable[ReadableBuffer], /) -> None: ...
+    def readline(self, size: int | None = -1, /) -> bytes: ...
     def __del__(self) -> None: ...
     @property
     def closed(self) -> bool: ...
     def _checkClosed(self, msg: str | None = ...) -> None: ...  # undocumented
 
 class RawIOBase(IOBase):
     def readall(self) -> bytes: ...
-    def readinto(self, __buffer: WriteableBuffer) -> int | None: ...
-    def write(self, __b: ReadableBuffer) -> int | None: ...
-    def read(self, __size: int = -1) -> bytes | None: ...
+    def readinto(self, buffer: WriteableBuffer, /) -> int | None: ...
+    def write(self, b: ReadableBuffer, /) -> int | None: ...
+    def read(self, size: int = -1, /) -> bytes | None: ...
 
 class BufferedIOBase(IOBase):
     raw: RawIOBase  # This is not part of the BufferedIOBase API and may not exist on some implementations.
     def detach(self) -> RawIOBase: ...
-    def readinto(self, __buffer: WriteableBuffer) -> int: ...
-    def write(self, __buffer: ReadableBuffer) -> int: ...
-    def readinto1(self, __buffer: WriteableBuffer) -> int: ...
-    def read(self, __size: int | None = ...) -> bytes: ...
-    def read1(self, __size: int = ...) -> bytes: ...
+    def readinto(self, buffer: WriteableBuffer, /) -> int: ...
+    def write(self, buffer: ReadableBuffer, /) -> int: ...
+    def readinto1(self, buffer: WriteableBuffer, /) -> int: ...
+    def read(self, size: int | None = ..., /) -> bytes: ...
+    def read1(self, size: int = ..., /) -> bytes: ...
 
 class FileIO(RawIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of writelines in the base classes
     mode: str
-    name: FileDescriptorOrPath
+    # The type of "name" equals the argument passed in to the constructor,
+    # but that can make FileIO incompatible with other I/O types that assume
+    # "name" is a str. In the future, making FileIO generic might help.
+    name: Any
     def __init__(
         self, file: FileDescriptorOrPath, mode: str = ..., closefd: bool = ..., opener: _Opener | None = ...
     ) -> None: ...
     @property
     def closefd(self) -> bool: ...
-    def write(self, __b: ReadableBuffer) -> int: ...
-    def read(self, __size: int = -1) -> bytes: ...
+    def write(self, b: ReadableBuffer, /) -> int: ...
+    def read(self, size: int = -1, /) -> bytes: ...
     def __enter__(self) -> Self: ...
 
 class BytesIO(BufferedIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of methods in the base classes
     def __init__(self, initial_bytes: ReadableBuffer = ...) -> None: ...
     # BytesIO does not contain a "name" field. This workaround is necessary
     # to allow BytesIO sub-classes to add this field, as it is defined
     # as a read-only property on IO[].
     name: Any
     def __enter__(self) -> Self: ...
     def getvalue(self) -> bytes: ...
     def getbuffer(self) -> memoryview: ...
-    def read1(self, __size: int | None = -1) -> bytes: ...
+    def read1(self, size: int | None = -1, /) -> bytes: ...
 
 class BufferedReader(BufferedIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of methods in the base classes
     def __enter__(self) -> Self: ...
     def __init__(self, raw: RawIOBase, buffer_size: int = ...) -> None: ...
-    def peek(self, __size: int = 0) -> bytes: ...
+    def peek(self, size: int = 0, /) -> bytes: ...
 
 class BufferedWriter(BufferedIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of writelines in the base classes
     def __enter__(self) -> Self: ...
     def __init__(self, raw: RawIOBase, buffer_size: int = ...) -> None: ...
-    def write(self, __buffer: ReadableBuffer) -> int: ...
+    def write(self, buffer: ReadableBuffer, /) -> int: ...
 
 class BufferedRandom(BufferedReader, BufferedWriter):  # type: ignore[misc]  # incompatible definitions of methods in the base classes
     def __enter__(self) -> Self: ...
-    def seek(self, __target: int, __whence: int = 0) -> int: ...  # stubtest needs this
+    def seek(self, target: int, whence: int = 0, /) -> int: ...  # stubtest needs this
 
 class BufferedRWPair(BufferedIOBase):
     def __init__(self, reader: RawIOBase, writer: RawIOBase, buffer_size: int = ...) -> None: ...
-    def peek(self, __size: int = ...) -> bytes: ...
+    def peek(self, size: int = ..., /) -> bytes: ...
 
 class TextIOBase(IOBase):
     encoding: str
     errors: str | None
     newlines: str | tuple[str, ...] | None
     def __iter__(self) -> Iterator[str]: ...  # type: ignore[override]
     def __next__(self) -> str: ...  # type: ignore[override]
     def detach(self) -> BinaryIO: ...
-    def write(self, __s: str) -> int: ...
-    def writelines(self, __lines: Iterable[str]) -> None: ...  # type: ignore[override]
-    def readline(self, __size: int = ...) -> str: ...  # type: ignore[override]
-    def readlines(self, __hint: int = -1) -> list[str]: ...  # type: ignore[override]
-    def read(self, __size: int | None = ...) -> str: ...
+    def write(self, s: str, /) -> int: ...
+    def writelines(self, lines: Iterable[str], /) -> None: ...  # type: ignore[override]
+    def readline(self, size: int = ..., /) -> str: ...  # type: ignore[override]
+    def readlines(self, hint: int = -1, /) -> list[str]: ...  # type: ignore[override]
+    def read(self, size: int | None = ..., /) -> str: ...
+
+@type_check_only
+class _WrappedBuffer(Protocol):
+    # "name" is wrapped by TextIOWrapper. Its type is inconsistent between
+    # the various I/O types, see the comments on TextIOWrapper.name and
+    # TextIO.name.
+    @property
+    def name(self) -> Any: ...
+    @property
+    def closed(self) -> bool: ...
+    def read(self, size: int = ..., /) -> ReadableBuffer: ...
+    # Optional: def read1(self, size: int, /) -> ReadableBuffer: ...
+    def write(self, b: bytes, /) -> object: ...
+    def flush(self) -> object: ...
+    def close(self) -> object: ...
+    def seekable(self) -> bool: ...
+    def readable(self) -> bool: ...
+    def writable(self) -> bool: ...
+    def truncate(self, size: int, /) -> int: ...
+    def fileno(self) -> int: ...
+    def isatty(self) -> int: ...
+    # Optional: Only needs to be present if seekable() returns True.
+    # def seek(self, offset: Literal[0], whence: Literal[2]) -> int: ...
+    # def tell(self) -> int: ...
 
+# TODO: Should be generic over the buffer type, but needs to wait for
+# TypeVar defaults.
 class TextIOWrapper(TextIOBase, TextIO):  # type: ignore[misc]  # incompatible definitions of write in the base classes
     def __init__(
         self,
-        buffer: IO[bytes],
-        encoding: str | None = ...,
-        errors: str | None = ...,
-        newline: str | None = ...,
-        line_buffering: bool = ...,
-        write_through: bool = ...,
+        buffer: _WrappedBuffer,
+        encoding: str | None = None,
+        errors: str | None = None,
+        newline: str | None = None,
+        line_buffering: bool = False,
+        write_through: bool = False,
     ) -> None: ...
+    # Equals the "buffer" argument passed in to the constructor.
     @property
     def buffer(self) -> BinaryIO: ...
     @property
     def closed(self) -> bool: ...
     @property
     def line_buffering(self) -> bool: ...
     @property
@@ -173,32 +203,36 @@
         line_buffering: bool | None = None,
         write_through: bool | None = None,
     ) -> None: ...
     # These are inherited from TextIOBase, but must exist in the stub to satisfy mypy.
     def __enter__(self) -> Self: ...
     def __iter__(self) -> Iterator[str]: ...  # type: ignore[override]
     def __next__(self) -> str: ...  # type: ignore[override]
-    def writelines(self, __lines: Iterable[str]) -> None: ...  # type: ignore[override]
-    def readline(self, __size: int = -1) -> str: ...  # type: ignore[override]
-    def readlines(self, __hint: int = -1) -> list[str]: ...  # type: ignore[override]
-    def seek(self, __cookie: int, __whence: int = 0) -> int: ...  # stubtest needs this
+    def writelines(self, lines: Iterable[str], /) -> None: ...  # type: ignore[override]
+    def readline(self, size: int = -1, /) -> str: ...  # type: ignore[override]
+    def readlines(self, hint: int = -1, /) -> list[str]: ...  # type: ignore[override]
+    # Equals the "buffer" argument passed in to the constructor.
+    def detach(self) -> BinaryIO: ...
+    # TextIOWrapper's version of seek only supports a limited subset of
+    # operations.
+    def seek(self, cookie: int, whence: int = 0, /) -> int: ...
 
 class StringIO(TextIOWrapper):
     def __init__(self, initial_value: str | None = ..., newline: str | None = ...) -> None: ...
     # StringIO does not contain a "name" field. This workaround is necessary
     # to allow StringIO sub-classes to add this field, as it is defined
     # as a read-only property on IO[].
     name: Any
     def getvalue(self) -> str: ...
 
 class IncrementalNewlineDecoder(codecs.IncrementalDecoder):
     def __init__(self, decoder: codecs.IncrementalDecoder | None, translate: bool, errors: str = ...) -> None: ...
     def decode(self, input: ReadableBuffer | str, final: bool = False) -> str: ...
     @property
     def newlines(self) -> str | tuple[str, ...] | None: ...
-    def setstate(self, __state: tuple[bytes, int]) -> None: ...
+    def setstate(self, state: tuple[bytes, int], /) -> None: ...
 
 if sys.version_info >= (3, 10):
     @overload
-    def text_encoding(__encoding: None, __stacklevel: int = 2) -> Literal["locale", "utf-8"]: ...
+    def text_encoding(encoding: None, stacklevel: int = 2, /) -> Literal["locale", "utf-8"]: ...
     @overload
-    def text_encoding(__encoding: _T, __stacklevel: int = 2) -> _T: ...
+    def text_encoding(encoding: _T, stacklevel: int = 2, /) -> _T: ...
```

## puya/_vendor/mypy/typeshed/stdlib/itertools.pyi

```diff
@@ -31,15 +31,15 @@
     def __new__(cls, start: _N, step: _Step = ...) -> count[_N]: ...
     @overload
     def __new__(cls, *, step: _N) -> count[_N]: ...
     def __next__(self) -> _N: ...
     def __iter__(self) -> Self: ...
 
 class cycle(Iterator[_T]):
-    def __init__(self, __iterable: Iterable[_T]) -> None: ...
+    def __init__(self, iterable: Iterable[_T], /) -> None: ...
     def __next__(self) -> _T: ...
     def __iter__(self) -> Self: ...
 
 class repeat(Iterator[_T]):
     @overload
     def __init__(self, object: _T) -> None: ...
     @overload
@@ -58,187 +58,167 @@
 
 class chain(Iterator[_T]):
     def __init__(self, *iterables: Iterable[_T]) -> None: ...
     def __next__(self) -> _T: ...
     def __iter__(self) -> Self: ...
     @classmethod
     # We use type[Any] and not type[_S] to not lose the type inference from __iterable
-    def from_iterable(cls: type[Any], __iterable: Iterable[Iterable[_S]]) -> chain[_S]: ...
+    def from_iterable(cls: type[Any], iterable: Iterable[Iterable[_S]], /) -> chain[_S]: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 class compress(Iterator[_T]):
     def __init__(self, data: Iterable[_T], selectors: Iterable[Any]) -> None: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T: ...
 
 class dropwhile(Iterator[_T]):
-    def __init__(self, __predicate: _Predicate[_T], __iterable: Iterable[_T]) -> None: ...
+    def __init__(self, predicate: _Predicate[_T], iterable: Iterable[_T], /) -> None: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T: ...
 
 class filterfalse(Iterator[_T]):
-    def __init__(self, __predicate: _Predicate[_T] | None, __iterable: Iterable[_T]) -> None: ...
+    def __init__(self, predicate: _Predicate[_T] | None, iterable: Iterable[_T], /) -> None: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T: ...
 
 class groupby(Iterator[tuple[_T_co, Iterator[_S_co]]], Generic[_T_co, _S_co]):
     @overload
     def __new__(cls, iterable: Iterable[_T1], key: None = None) -> groupby[_T1, _T1]: ...
     @overload
     def __new__(cls, iterable: Iterable[_T1], key: Callable[[_T1], _T2]) -> groupby[_T2, _T1]: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> tuple[_T_co, Iterator[_S_co]]: ...
 
 class islice(Iterator[_T]):
     @overload
-    def __init__(self, __iterable: Iterable[_T], __stop: int | None) -> None: ...
+    def __init__(self, iterable: Iterable[_T], stop: int | None, /) -> None: ...
     @overload
-    def __init__(self, __iterable: Iterable[_T], __start: int | None, __stop: int | None, __step: int | None = ...) -> None: ...
+    def __init__(self, iterable: Iterable[_T], start: int | None, stop: int | None, step: int | None = ..., /) -> None: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T: ...
 
 class starmap(Iterator[_T_co]):
-    def __new__(cls, __function: Callable[..., _T], __iterable: Iterable[Iterable[Any]]) -> starmap[_T]: ...
+    def __new__(cls, function: Callable[..., _T], iterable: Iterable[Iterable[Any]], /) -> starmap[_T]: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T_co: ...
 
 class takewhile(Iterator[_T]):
-    def __init__(self, __predicate: _Predicate[_T], __iterable: Iterable[_T]) -> None: ...
+    def __init__(self, predicate: _Predicate[_T], iterable: Iterable[_T], /) -> None: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T: ...
 
-def tee(__iterable: Iterable[_T], __n: int = 2) -> tuple[Iterator[_T], ...]: ...
+def tee(iterable: Iterable[_T], n: int = 2, /) -> tuple[Iterator[_T], ...]: ...
 
 class zip_longest(Iterator[_T_co]):
     # one iterable (fillvalue doesn't matter)
     @overload
-    def __new__(cls, __iter1: Iterable[_T1], *, fillvalue: object = ...) -> zip_longest[tuple[_T1]]: ...
+    def __new__(cls, iter1: Iterable[_T1], /, *, fillvalue: object = ...) -> zip_longest[tuple[_T1]]: ...
     # two iterables
     @overload
     # In the overloads without fillvalue, all of the tuple members could theoretically be None,
     # but we return Any instead to avoid false positives for code where we know one of the iterables
     # is longer.
-    def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> zip_longest[tuple[_T1 | Any, _T2 | Any]]: ...
+    def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> zip_longest[tuple[_T1 | Any, _T2 | Any]]: ...
     @overload
     def __new__(
-        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], *, fillvalue: _T
+        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /, *, fillvalue: _T
     ) -> zip_longest[tuple[_T1 | _T, _T2 | _T]]: ...
     # three iterables
     @overload
     def __new__(
-        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]
+        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /
     ) -> zip_longest[tuple[_T1 | Any, _T2 | Any, _T3 | Any]]: ...
     @overload
     def __new__(
-        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], *, fillvalue: _T
+        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /, *, fillvalue: _T
     ) -> zip_longest[tuple[_T1 | _T, _T2 | _T, _T3 | _T]]: ...
     # four iterables
     @overload
     def __new__(
-        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], __iter4: Iterable[_T4]
+        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /
     ) -> zip_longest[tuple[_T1 | Any, _T2 | Any, _T3 | Any, _T4 | Any]]: ...
     @overload
     def __new__(
-        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], __iter4: Iterable[_T4], *, fillvalue: _T
+        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /, *, fillvalue: _T
     ) -> zip_longest[tuple[_T1 | _T, _T2 | _T, _T3 | _T, _T4 | _T]]: ...
     # five iterables
     @overload
     def __new__(
-        cls,
-        __iter1: Iterable[_T1],
-        __iter2: Iterable[_T2],
-        __iter3: Iterable[_T3],
-        __iter4: Iterable[_T4],
-        __iter5: Iterable[_T5],
+        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], iter5: Iterable[_T5], /
     ) -> zip_longest[tuple[_T1 | Any, _T2 | Any, _T3 | Any, _T4 | Any, _T5 | Any]]: ...
     @overload
     def __new__(
         cls,
-        __iter1: Iterable[_T1],
-        __iter2: Iterable[_T2],
-        __iter3: Iterable[_T3],
-        __iter4: Iterable[_T4],
-        __iter5: Iterable[_T5],
+        iter1: Iterable[_T1],
+        iter2: Iterable[_T2],
+        iter3: Iterable[_T3],
+        iter4: Iterable[_T4],
+        iter5: Iterable[_T5],
+        /,
         *,
         fillvalue: _T,
     ) -> zip_longest[tuple[_T1 | _T, _T2 | _T, _T3 | _T, _T4 | _T, _T5 | _T]]: ...
     # six or more iterables
     @overload
     def __new__(
         cls,
-        __iter1: Iterable[_T],
-        __iter2: Iterable[_T],
-        __iter3: Iterable[_T],
-        __iter4: Iterable[_T],
-        __iter5: Iterable[_T],
-        __iter6: Iterable[_T],
+        iter1: Iterable[_T],
+        iter2: Iterable[_T],
+        iter3: Iterable[_T],
+        iter4: Iterable[_T],
+        iter5: Iterable[_T],
+        iter6: Iterable[_T],
+        /,
         *iterables: Iterable[_T],
     ) -> zip_longest[tuple[_T | Any, ...]]: ...
     @overload
     def __new__(
         cls,
-        __iter1: Iterable[_T],
-        __iter2: Iterable[_T],
-        __iter3: Iterable[_T],
-        __iter4: Iterable[_T],
-        __iter5: Iterable[_T],
-        __iter6: Iterable[_T],
+        iter1: Iterable[_T],
+        iter2: Iterable[_T],
+        iter3: Iterable[_T],
+        iter4: Iterable[_T],
+        iter5: Iterable[_T],
+        iter6: Iterable[_T],
+        /,
         *iterables: Iterable[_T],
         fillvalue: _T,
     ) -> zip_longest[tuple[_T, ...]]: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T_co: ...
 
 class product(Iterator[_T_co]):
     @overload
-    def __new__(cls, __iter1: Iterable[_T1]) -> product[tuple[_T1]]: ...
+    def __new__(cls, iter1: Iterable[_T1], /) -> product[tuple[_T1]]: ...
     @overload
-    def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> product[tuple[_T1, _T2]]: ...
+    def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> product[tuple[_T1, _T2]]: ...
     @overload
-    def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]) -> product[tuple[_T1, _T2, _T3]]: ...
+    def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /) -> product[tuple[_T1, _T2, _T3]]: ...
     @overload
     def __new__(
-        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], __iter4: Iterable[_T4]
+        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /
     ) -> product[tuple[_T1, _T2, _T3, _T4]]: ...
     @overload
     def __new__(
-        cls,
-        __iter1: Iterable[_T1],
-        __iter2: Iterable[_T2],
-        __iter3: Iterable[_T3],
-        __iter4: Iterable[_T4],
-        __iter5: Iterable[_T5],
+        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], iter5: Iterable[_T5], /
     ) -> product[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
     @overload
     def __new__(
         cls,
-        __iter1: Iterable[_T1],
-        __iter2: Iterable[_T2],
-        __iter3: Iterable[_T3],
-        __iter4: Iterable[_T4],
-        __iter5: Iterable[_T5],
-        __iter6: Iterable[_T6],
+        iter1: Iterable[_T1],
+        iter2: Iterable[_T2],
+        iter3: Iterable[_T3],
+        iter4: Iterable[_T4],
+        iter5: Iterable[_T5],
+        iter6: Iterable[_T6],
+        /,
     ) -> product[tuple[_T1, _T2, _T3, _T4, _T5, _T6]]: ...
     @overload
-    def __new__(
-        cls,
-        __iter1: Iterable[Any],
-        __iter2: Iterable[Any],
-        __iter3: Iterable[Any],
-        __iter4: Iterable[Any],
-        __iter5: Iterable[Any],
-        __iter6: Iterable[Any],
-        __iter7: Iterable[Any],
-        *iterables: Iterable[Any],
-    ) -> product[tuple[Any, ...]]: ...
-    @overload
-    def __new__(cls, *iterables: Iterable[_T1], repeat: int) -> product[tuple[_T1, ...]]: ...
-    @overload
-    def __new__(cls, *iterables: Iterable[Any], repeat: int = ...) -> product[tuple[Any, ...]]: ...
+    def __new__(cls, *iterables: Iterable[_T1], repeat: int = 1) -> product[tuple[_T1, ...]]: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T_co: ...
 
 class permutations(Iterator[_T_co]):
     @overload
     def __new__(cls, iterable: Iterable[_T], r: Literal[2]) -> permutations[tuple[_T, _T]]: ...
     @overload
@@ -278,15 +258,15 @@
     @overload
     def __new__(cls, iterable: Iterable[_T], r: int) -> combinations_with_replacement[tuple[_T, ...]]: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> _T_co: ...
 
 if sys.version_info >= (3, 10):
     class pairwise(Iterator[_T_co]):
-        def __new__(cls, __iterable: Iterable[_T]) -> pairwise[tuple[_T, _T]]: ...
+        def __new__(cls, iterable: Iterable[_T], /) -> pairwise[tuple[_T, _T]]: ...
         def __iter__(self) -> Self: ...
         def __next__(self) -> _T_co: ...
 
 if sys.version_info >= (3, 12):
     class batched(Iterator[tuple[_T_co, ...]], Generic[_T_co]):
         def __new__(cls, iterable: Iterable[_T_co], n: int) -> Self: ...
         def __iter__(self) -> Self: ...
```

## puya/_vendor/mypy/typeshed/stdlib/json/encoder.pyi

```diff
@@ -6,14 +6,16 @@
 ESCAPE_ASCII: Pattern[str]
 HAS_UTF8: Pattern[bytes]
 ESCAPE_DCT: dict[str, str]
 INFINITY: float
 
 def py_encode_basestring(s: str) -> str: ...  # undocumented
 def py_encode_basestring_ascii(s: str) -> str: ...  # undocumented
+def encode_basestring(s: str) -> str: ...  # undocumented
+def encode_basestring_ascii(s: str) -> str: ...  # undocumented
 
 class JSONEncoder:
     item_separator: str
     key_separator: str
 
     skipkeys: bool
     ensure_ascii: bool
```

## puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixer_base.pyi

```diff
@@ -34,9 +34,9 @@
     def cannot_convert(self, node: Base, reason: str | None = None) -> None: ...
     def warning(self, node: Base, reason: str) -> None: ...
     def start_tree(self, tree: Node, filename: StrPath) -> None: ...
     def finish_tree(self, tree: Node, filename: StrPath) -> None: ...
 
 class ConditionalFix(BaseFix, metaclass=ABCMeta):
     skip_on: ClassVar[str | None]
-    def start_tree(self, __tree: Node, __filename: StrPath) -> None: ...
+    def start_tree(self, tree: Node, filename: StrPath, /) -> None: ...
     def should_skip(self, node: Base) -> bool: ...
```

## puya/_vendor/mypy/typeshed/stdlib/logging/__init__.pyi

```diff
@@ -67,20 +67,20 @@
 _ExcInfoType: TypeAlias = None | bool | _SysExcInfoType | BaseException
 _ArgsType: TypeAlias = tuple[object, ...] | Mapping[str, object]
 _Level: TypeAlias = int | str
 _FormatStyle: TypeAlias = Literal["%", "{", "$"]
 
 if sys.version_info >= (3, 12):
     class _SupportsFilter(Protocol):
-        def filter(self, __record: LogRecord) -> bool | LogRecord: ...
+        def filter(self, record: LogRecord, /) -> bool | LogRecord: ...
 
     _FilterType: TypeAlias = Filter | Callable[[LogRecord], bool | LogRecord] | _SupportsFilter
 else:
     class _SupportsFilter(Protocol):
-        def filter(self, __record: LogRecord) -> bool: ...
+        def filter(self, record: LogRecord, /) -> bool: ...
 
     _FilterType: TypeAlias = Filter | Callable[[LogRecord], bool] | _SupportsFilter
 
 raiseExceptions: bool
 logThreads: bool
 logMultiprocessing: bool
 logProcesses: bool
@@ -337,29 +337,32 @@
     pathname: str
     process: int | None
     processName: str | None
     relativeCreated: float
     stack_info: str | None
     thread: int | None
     threadName: str | None
+    if sys.version_info >= (3, 12):
+        taskName: str | None
+
     def __init__(
         self,
         name: str,
         level: int,
         pathname: str,
         lineno: int,
         msg: object,
         args: _ArgsType | None,
         exc_info: _SysExcInfoType | None,
         func: str | None = None,
         sinfo: str | None = None,
     ) -> None: ...
     def getMessage(self) -> str: ...
     # Allows setting contextual information on LogRecord objects as per the docs, see #7833
-    def __setattr__(self, __name: str, __value: Any) -> None: ...
+    def __setattr__(self, name: str, value: Any, /) -> None: ...
 
 _L = TypeVar("_L", bound=Logger | LoggerAdapter[Any])
 
 class LoggerAdapter(Generic[_L]):
     logger: _L
     manager: Manager  # undocumented
     if sys.version_info >= (3, 10):
```

## puya/_vendor/mypy/typeshed/stdlib/logging/handlers.pyi

```diff
@@ -249,15 +249,15 @@
     ) -> None: ...
     def mapLogRecord(self, record: LogRecord) -> dict[str, Any]: ...
     if sys.version_info >= (3, 9):
         def getConnection(self, host: str, secure: bool) -> http.client.HTTPConnection: ...  # undocumented
 
 class _QueueLike(Protocol[_T]):
     def get(self) -> _T: ...
-    def put_nowait(self, __item: _T) -> None: ...
+    def put_nowait(self, item: _T, /) -> None: ...
 
 class QueueHandler(Handler):
     queue: _QueueLike[Any]
     def __init__(self, queue: _QueueLike[Any]) -> None: ...
     def prepare(self, record: LogRecord) -> Any: ...
     def enqueue(self, record: LogRecord) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/lzma.pyi

```diff
@@ -95,15 +95,15 @@
 
 # from _lzma.c
 @final
 class LZMACompressor:
     def __init__(
         self, format: int | None = ..., check: int = ..., preset: int | None = ..., filters: _FilterChain | None = ...
     ) -> None: ...
-    def compress(self, __data: ReadableBuffer) -> bytes: ...
+    def compress(self, data: ReadableBuffer, /) -> bytes: ...
     def flush(self) -> bytes: ...
 
 class LZMAError(Exception): ...
 
 class LZMAFile(BaseStream, IO[bytes]):  # type: ignore[misc]  # incompatible definitions of writelines in the base classes
     def __init__(
         self,
@@ -190,8 +190,8 @@
 ) -> LZMAFile | TextIO: ...
 def compress(
     data: ReadableBuffer, format: int = 1, check: int = -1, preset: int | None = None, filters: _FilterChain | None = None
 ) -> bytes: ...
 def decompress(
     data: ReadableBuffer, format: int = 0, memlimit: int | None = None, filters: _FilterChain | None = None
 ) -> bytes: ...
-def is_check_supported(__check_id: int) -> bool: ...
+def is_check_supported(check_id: int, /) -> bool: ...
```

## puya/_vendor/mypy/typeshed/stdlib/marshal.pyi

```diff
@@ -23,11 +23,11 @@
     | dict[Any, Any]
     | set[Any]
     | frozenset[_Marshallable]
     | types.CodeType
     | ReadableBuffer
 )
 
-def dump(__value: _Marshallable, __file: SupportsWrite[bytes], __version: int = 4) -> None: ...
-def load(__file: SupportsRead[bytes]) -> Any: ...
-def dumps(__value: _Marshallable, __version: int = 4) -> bytes: ...
-def loads(__bytes: ReadableBuffer) -> Any: ...
+def dump(value: _Marshallable, file: SupportsWrite[bytes], version: int = 4, /) -> None: ...
+def load(file: SupportsRead[bytes], /) -> Any: ...
+def dumps(value: _Marshallable, version: int = 4, /) -> bytes: ...
+def loads(bytes: ReadableBuffer, /) -> Any: ...
```

## puya/_vendor/mypy/typeshed/stdlib/math.pyi

```diff
@@ -10,116 +10,116 @@
 
 e: float
 pi: float
 inf: float
 nan: float
 tau: float
 
-def acos(__x: _SupportsFloatOrIndex) -> float: ...
-def acosh(__x: _SupportsFloatOrIndex) -> float: ...
-def asin(__x: _SupportsFloatOrIndex) -> float: ...
-def asinh(__x: _SupportsFloatOrIndex) -> float: ...
-def atan(__x: _SupportsFloatOrIndex) -> float: ...
-def atan2(__y: _SupportsFloatOrIndex, __x: _SupportsFloatOrIndex) -> float: ...
-def atanh(__x: _SupportsFloatOrIndex) -> float: ...
+def acos(x: _SupportsFloatOrIndex, /) -> float: ...
+def acosh(x: _SupportsFloatOrIndex, /) -> float: ...
+def asin(x: _SupportsFloatOrIndex, /) -> float: ...
+def asinh(x: _SupportsFloatOrIndex, /) -> float: ...
+def atan(x: _SupportsFloatOrIndex, /) -> float: ...
+def atan2(y: _SupportsFloatOrIndex, x: _SupportsFloatOrIndex, /) -> float: ...
+def atanh(x: _SupportsFloatOrIndex, /) -> float: ...
 
 if sys.version_info >= (3, 11):
-    def cbrt(__x: _SupportsFloatOrIndex) -> float: ...
+    def cbrt(x: _SupportsFloatOrIndex, /) -> float: ...
 
 class _SupportsCeil(Protocol[_T_co]):
     def __ceil__(self) -> _T_co: ...
 
 @overload
-def ceil(__x: _SupportsCeil[_T]) -> _T: ...
+def ceil(x: _SupportsCeil[_T], /) -> _T: ...
 @overload
-def ceil(__x: _SupportsFloatOrIndex) -> int: ...
-def comb(__n: SupportsIndex, __k: SupportsIndex) -> int: ...
-def copysign(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...
-def cos(__x: _SupportsFloatOrIndex) -> float: ...
-def cosh(__x: _SupportsFloatOrIndex) -> float: ...
-def degrees(__x: _SupportsFloatOrIndex) -> float: ...
-def dist(__p: Iterable[_SupportsFloatOrIndex], __q: Iterable[_SupportsFloatOrIndex]) -> float: ...
-def erf(__x: _SupportsFloatOrIndex) -> float: ...
-def erfc(__x: _SupportsFloatOrIndex) -> float: ...
-def exp(__x: _SupportsFloatOrIndex) -> float: ...
+def ceil(x: _SupportsFloatOrIndex, /) -> int: ...
+def comb(n: SupportsIndex, k: SupportsIndex, /) -> int: ...
+def copysign(x: _SupportsFloatOrIndex, y: _SupportsFloatOrIndex, /) -> float: ...
+def cos(x: _SupportsFloatOrIndex, /) -> float: ...
+def cosh(x: _SupportsFloatOrIndex, /) -> float: ...
+def degrees(x: _SupportsFloatOrIndex, /) -> float: ...
+def dist(p: Iterable[_SupportsFloatOrIndex], q: Iterable[_SupportsFloatOrIndex], /) -> float: ...
+def erf(x: _SupportsFloatOrIndex, /) -> float: ...
+def erfc(x: _SupportsFloatOrIndex, /) -> float: ...
+def exp(x: _SupportsFloatOrIndex, /) -> float: ...
 
 if sys.version_info >= (3, 11):
-    def exp2(__x: _SupportsFloatOrIndex) -> float: ...
+    def exp2(x: _SupportsFloatOrIndex, /) -> float: ...
 
-def expm1(__x: _SupportsFloatOrIndex) -> float: ...
-def fabs(__x: _SupportsFloatOrIndex) -> float: ...
-def factorial(__x: SupportsIndex) -> int: ...
+def expm1(x: _SupportsFloatOrIndex, /) -> float: ...
+def fabs(x: _SupportsFloatOrIndex, /) -> float: ...
+def factorial(x: SupportsIndex, /) -> int: ...
 
 class _SupportsFloor(Protocol[_T_co]):
     def __floor__(self) -> _T_co: ...
 
 @overload
-def floor(__x: _SupportsFloor[_T]) -> _T: ...
+def floor(x: _SupportsFloor[_T], /) -> _T: ...
 @overload
-def floor(__x: _SupportsFloatOrIndex) -> int: ...
-def fmod(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...
-def frexp(__x: _SupportsFloatOrIndex) -> tuple[float, int]: ...
-def fsum(__seq: Iterable[_SupportsFloatOrIndex]) -> float: ...
-def gamma(__x: _SupportsFloatOrIndex) -> float: ...
+def floor(x: _SupportsFloatOrIndex, /) -> int: ...
+def fmod(x: _SupportsFloatOrIndex, y: _SupportsFloatOrIndex, /) -> float: ...
+def frexp(x: _SupportsFloatOrIndex, /) -> tuple[float, int]: ...
+def fsum(seq: Iterable[_SupportsFloatOrIndex], /) -> float: ...
+def gamma(x: _SupportsFloatOrIndex, /) -> float: ...
 
 if sys.version_info >= (3, 9):
     def gcd(*integers: SupportsIndex) -> int: ...
 
 else:
-    def gcd(__x: SupportsIndex, __y: SupportsIndex) -> int: ...
+    def gcd(x: SupportsIndex, y: SupportsIndex, /) -> int: ...
 
 def hypot(*coordinates: _SupportsFloatOrIndex) -> float: ...
 def isclose(
     a: _SupportsFloatOrIndex,
     b: _SupportsFloatOrIndex,
     *,
     rel_tol: _SupportsFloatOrIndex = 1e-09,
     abs_tol: _SupportsFloatOrIndex = 0.0,
 ) -> bool: ...
-def isinf(__x: _SupportsFloatOrIndex) -> bool: ...
-def isfinite(__x: _SupportsFloatOrIndex) -> bool: ...
-def isnan(__x: _SupportsFloatOrIndex) -> bool: ...
-def isqrt(__n: SupportsIndex) -> int: ...
+def isinf(x: _SupportsFloatOrIndex, /) -> bool: ...
+def isfinite(x: _SupportsFloatOrIndex, /) -> bool: ...
+def isnan(x: _SupportsFloatOrIndex, /) -> bool: ...
+def isqrt(n: SupportsIndex, /) -> int: ...
 
 if sys.version_info >= (3, 9):
     def lcm(*integers: SupportsIndex) -> int: ...
 
-def ldexp(__x: _SupportsFloatOrIndex, __i: int) -> float: ...
-def lgamma(__x: _SupportsFloatOrIndex) -> float: ...
+def ldexp(x: _SupportsFloatOrIndex, i: int, /) -> float: ...
+def lgamma(x: _SupportsFloatOrIndex, /) -> float: ...
 def log(x: _SupportsFloatOrIndex, base: _SupportsFloatOrIndex = ...) -> float: ...
-def log10(__x: _SupportsFloatOrIndex) -> float: ...
-def log1p(__x: _SupportsFloatOrIndex) -> float: ...
-def log2(__x: _SupportsFloatOrIndex) -> float: ...
-def modf(__x: _SupportsFloatOrIndex) -> tuple[float, float]: ...
+def log10(x: _SupportsFloatOrIndex, /) -> float: ...
+def log1p(x: _SupportsFloatOrIndex, /) -> float: ...
+def log2(x: _SupportsFloatOrIndex, /) -> float: ...
+def modf(x: _SupportsFloatOrIndex, /) -> tuple[float, float]: ...
 
 if sys.version_info >= (3, 12):
-    def nextafter(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex, *, steps: SupportsIndex | None = None) -> float: ...
+    def nextafter(x: _SupportsFloatOrIndex, y: _SupportsFloatOrIndex, /, *, steps: SupportsIndex | None = None) -> float: ...
 
 elif sys.version_info >= (3, 9):
-    def nextafter(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...
+    def nextafter(x: _SupportsFloatOrIndex, y: _SupportsFloatOrIndex, /) -> float: ...
 
-def perm(__n: SupportsIndex, __k: SupportsIndex | None = None) -> int: ...
-def pow(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...
+def perm(n: SupportsIndex, k: SupportsIndex | None = None, /) -> int: ...
+def pow(x: _SupportsFloatOrIndex, y: _SupportsFloatOrIndex, /) -> float: ...
 @overload
-def prod(__iterable: Iterable[SupportsIndex], *, start: SupportsIndex = 1) -> int: ...  # type: ignore[overload-overlap]
+def prod(iterable: Iterable[SupportsIndex], /, *, start: SupportsIndex = 1) -> int: ...  # type: ignore[overload-overlap]
 @overload
-def prod(__iterable: Iterable[_SupportsFloatOrIndex], *, start: _SupportsFloatOrIndex = 1) -> float: ...
-def radians(__x: _SupportsFloatOrIndex) -> float: ...
-def remainder(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...
-def sin(__x: _SupportsFloatOrIndex) -> float: ...
-def sinh(__x: _SupportsFloatOrIndex) -> float: ...
+def prod(iterable: Iterable[_SupportsFloatOrIndex], /, *, start: _SupportsFloatOrIndex = 1) -> float: ...
+def radians(x: _SupportsFloatOrIndex, /) -> float: ...
+def remainder(x: _SupportsFloatOrIndex, y: _SupportsFloatOrIndex, /) -> float: ...
+def sin(x: _SupportsFloatOrIndex, /) -> float: ...
+def sinh(x: _SupportsFloatOrIndex, /) -> float: ...
 
 if sys.version_info >= (3, 12):
-    def sumprod(__p: Iterable[float], __q: Iterable[float]) -> float: ...
+    def sumprod(p: Iterable[float], q: Iterable[float], /) -> float: ...
 
-def sqrt(__x: _SupportsFloatOrIndex) -> float: ...
-def tan(__x: _SupportsFloatOrIndex) -> float: ...
-def tanh(__x: _SupportsFloatOrIndex) -> float: ...
+def sqrt(x: _SupportsFloatOrIndex, /) -> float: ...
+def tan(x: _SupportsFloatOrIndex, /) -> float: ...
+def tanh(x: _SupportsFloatOrIndex, /) -> float: ...
 
 # Is different from `_typeshed.SupportsTrunc`, which is not generic
 class _SupportsTrunc(Protocol[_T_co]):
     def __trunc__(self) -> _T_co: ...
 
-def trunc(__x: _SupportsTrunc[_T]) -> _T: ...
+def trunc(x: _SupportsTrunc[_T], /) -> _T: ...
 
 if sys.version_info >= (3, 9):
-    def ulp(__x: _SupportsFloatOrIndex) -> float: ...
+    def ulp(x: _SupportsFloatOrIndex, /) -> float: ...
```

## puya/_vendor/mypy/typeshed/stdlib/mmap.pyi

```diff
@@ -54,32 +54,32 @@
         def madvise(self, option: int, start: int = ..., length: int = ...) -> None: ...
 
     def find(self, sub: ReadableBuffer, start: int = ..., stop: int = ...) -> int: ...
     def rfind(self, sub: ReadableBuffer, start: int = ..., stop: int = ...) -> int: ...
     def read(self, n: int | None = ...) -> bytes: ...
     def write(self, bytes: ReadableBuffer) -> int: ...
     @overload
-    def __getitem__(self, __key: int) -> int: ...
+    def __getitem__(self, key: int, /) -> int: ...
     @overload
-    def __getitem__(self, __key: slice) -> bytes: ...
-    def __delitem__(self, __key: int | slice) -> NoReturn: ...
+    def __getitem__(self, key: slice, /) -> bytes: ...
+    def __delitem__(self, key: int | slice, /) -> NoReturn: ...
     @overload
-    def __setitem__(self, __key: int, __value: int) -> None: ...
+    def __setitem__(self, key: int, value: int, /) -> None: ...
     @overload
-    def __setitem__(self, __key: slice, __value: ReadableBuffer) -> None: ...
+    def __setitem__(self, key: slice, value: ReadableBuffer, /) -> None: ...
     # Doesn't actually exist, but the object actually supports "in" because it has __getitem__,
     # so we claim that there is also a __contains__ to help type checkers.
-    def __contains__(self, __o: object) -> bool: ...
+    def __contains__(self, o: object, /) -> bool: ...
     # Doesn't actually exist, but the object is actually iterable because it has __getitem__ and __len__,
     # so we claim that there is also an __iter__ to help type checkers.
     def __iter__(self) -> Iterator[int]: ...
     def __enter__(self) -> Self: ...
     def __exit__(self, *args: Unused) -> None: ...
-    def __buffer__(self, __flags: int) -> memoryview: ...
-    def __release_buffer__(self, __buffer: memoryview) -> None: ...
+    def __buffer__(self, flags: int, /) -> memoryview: ...
+    def __release_buffer__(self, buffer: memoryview, /) -> None: ...
 
 if sys.platform != "win32":
     MADV_NORMAL: int
     MADV_RANDOM: int
     MADV_SEQUENTIAL: int
     MADV_WILLNEED: int
     MADV_DONTNEED: int
```

## puya/_vendor/mypy/typeshed/stdlib/msilib/__init__.pyi

```diff
@@ -52,14 +52,15 @@
         files: list[tuple[str, str]]
         filenames: set[str]
         index: int
         def __init__(self, name: str) -> None: ...
         def gen_id(self, file: str) -> str: ...
         def append(self, full: str, file: str, logical: str) -> tuple[int, str]: ...
         def commit(self, db: _Database) -> None: ...
+
     _directories: set[str]
 
     class Directory:
         db: _Database
         cab: CAB
         basedir: str
         physical: str
```

## puya/_vendor/mypy/typeshed/stdlib/msvcrt.pyi

```diff
@@ -9,24 +9,24 @@
     LK_NBLCK: Literal[2]
     LK_RLCK: Literal[3]
     LK_NBRLCK: Literal[4]
     SEM_FAILCRITICALERRORS: int
     SEM_NOALIGNMENTFAULTEXCEPT: int
     SEM_NOGPFAULTERRORBOX: int
     SEM_NOOPENFILEERRORBOX: int
-    def locking(__fd: int, __mode: int, __nbytes: int) -> None: ...
-    def setmode(__fd: int, __mode: int) -> int: ...
-    def open_osfhandle(__handle: int, __flags: int) -> int: ...
-    def get_osfhandle(__fd: int) -> int: ...
+    def locking(fd: int, mode: int, nbytes: int, /) -> None: ...
+    def setmode(fd: int, mode: int, /) -> int: ...
+    def open_osfhandle(handle: int, flags: int, /) -> int: ...
+    def get_osfhandle(fd: int, /) -> int: ...
     def kbhit() -> bool: ...
     def getch() -> bytes: ...
     def getwch() -> str: ...
     def getche() -> bytes: ...
     def getwche() -> str: ...
-    def putch(__char: bytes | bytearray) -> None: ...
-    def putwch(__unicode_char: str) -> None: ...
-    def ungetch(__char: bytes | bytearray) -> None: ...
-    def ungetwch(__unicode_char: str) -> None: ...
+    def putch(char: bytes | bytearray, /) -> None: ...
+    def putwch(unicode_char: str, /) -> None: ...
+    def ungetch(char: bytes | bytearray, /) -> None: ...
+    def ungetwch(unicode_char: str, /) -> None: ...
     def heapmin() -> None: ...
-    def SetErrorMode(__mode: int) -> int: ...
+    def SetErrorMode(mode: int, /) -> int: ...
     if sys.version_info >= (3, 10):
         def GetErrorMode() -> int: ...  # undocumented
```

## puya/_vendor/mypy/typeshed/stdlib/multiprocessing/context.pyi

```diff
@@ -3,15 +3,15 @@
 from collections.abc import Callable, Iterable, Sequence
 from ctypes import _CData
 from logging import Logger, _Level as _LoggingLevel
 from multiprocessing import popen_fork, popen_forkserver, popen_spawn_posix, popen_spawn_win32, queues, synchronize
 from multiprocessing.managers import SyncManager
 from multiprocessing.pool import Pool as _Pool
 from multiprocessing.process import BaseProcess
-from multiprocessing.sharedctypes import SynchronizedArray, SynchronizedBase
+from multiprocessing.sharedctypes import Synchronized, SynchronizedArray
 from typing import Any, ClassVar, Literal, TypeVar, overload
 from typing_extensions import TypeAlias
 
 if sys.platform != "win32":
     from multiprocessing.connection import Connection
 else:
     from multiprocessing.connection import PipeConnection
@@ -75,23 +75,25 @@
     @overload
     def RawValue(self, typecode_or_type: str, *args: Any) -> Any: ...
     @overload
     def RawArray(self, typecode_or_type: type[_CT], size_or_initializer: int | Sequence[Any]) -> ctypes.Array[_CT]: ...
     @overload
     def RawArray(self, typecode_or_type: str, size_or_initializer: int | Sequence[Any]) -> Any: ...
     @overload
-    def Value(self, typecode_or_type: type[_CT], *args: Any, lock: Literal[False]) -> _CT: ...
+    def Value(self, typecode_or_type: type[_CT], *args: Any, lock: Literal[False]) -> Synchronized[_CT]: ...
     @overload
-    def Value(self, typecode_or_type: type[_CT], *args: Any, lock: Literal[True] | _LockLike = True) -> SynchronizedBase[_CT]: ...
+    def Value(self, typecode_or_type: type[_CT], *args: Any, lock: Literal[True] | _LockLike = True) -> Synchronized[_CT]: ...
     @overload
-    def Value(self, typecode_or_type: str, *args: Any, lock: Literal[True] | _LockLike = True) -> SynchronizedBase[Any]: ...
+    def Value(self, typecode_or_type: str, *args: Any, lock: Literal[True] | _LockLike = True) -> Synchronized[Any]: ...
     @overload
     def Value(self, typecode_or_type: str | type[_CData], *args: Any, lock: bool | _LockLike = True) -> Any: ...
     @overload
-    def Array(self, typecode_or_type: type[_CT], size_or_initializer: int | Sequence[Any], *, lock: Literal[False]) -> _CT: ...
+    def Array(
+        self, typecode_or_type: type[_CT], size_or_initializer: int | Sequence[Any], *, lock: Literal[False]
+    ) -> SynchronizedArray[_CT]: ...
     @overload
     def Array(
         self, typecode_or_type: type[_CT], size_or_initializer: int | Sequence[Any], *, lock: Literal[True] | _LockLike = True
     ) -> SynchronizedArray[_CT]: ...
     @overload
     def Array(
         self, typecode_or_type: str, size_or_initializer: int | Sequence[Any], *, lock: Literal[True] | _LockLike = True
```

## puya/_vendor/mypy/typeshed/stdlib/multiprocessing/dummy/__init__.pyi

```diff
@@ -53,16 +53,16 @@
         kwargs: Mapping[str, Any] = {},
     ) -> None: ...
 
 Process = DummyProcess
 
 class Namespace:
     def __init__(self, **kwds: Any) -> None: ...
-    def __getattr__(self, __name: str) -> Any: ...
-    def __setattr__(self, __name: str, __value: Any) -> None: ...
+    def __getattr__(self, name: str, /) -> Any: ...
+    def __setattr__(self, name: str, value: Any, /) -> None: ...
 
 class Value:
     _typecode: Any
     _value: Any
     value: Any
     def __init__(self, typecode: Any, value: Any, lock: Any = True) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/multiprocessing/managers.pyi

```diff
@@ -18,16 +18,16 @@
 
 _T = TypeVar("_T")
 _KT = TypeVar("_KT")
 _VT = TypeVar("_VT")
 
 class Namespace:
     def __init__(self, **kwds: Any) -> None: ...
-    def __getattr__(self, __name: str) -> Any: ...
-    def __setattr__(self, __name: str, __value: Any) -> None: ...
+    def __getattr__(self, name: str, /) -> Any: ...
+    def __setattr__(self, name: str, value: Any, /) -> None: ...
 
 _Namespace: TypeAlias = Namespace
 
 class Token:
     typeid: str | bytes | None
     address: tuple[str | bytes, int]
     id: str | bytes | int | None
@@ -59,68 +59,68 @@
     value: _T
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 class DictProxy(BaseProxy, MutableMapping[_KT, _VT]):
     __builtins__: ClassVar[dict[str, Any]]
     def __len__(self) -> int: ...
-    def __getitem__(self, __key: _KT) -> _VT: ...
-    def __setitem__(self, __key: _KT, __value: _VT) -> None: ...
-    def __delitem__(self, __key: _KT) -> None: ...
+    def __getitem__(self, key: _KT, /) -> _VT: ...
+    def __setitem__(self, key: _KT, value: _VT, /) -> None: ...
+    def __delitem__(self, key: _KT, /) -> None: ...
     def __iter__(self) -> Iterator[_KT]: ...
     def copy(self) -> dict[_KT, _VT]: ...
     @overload  # type: ignore[override]
-    def get(self, __key: _KT) -> _VT | None: ...
+    def get(self, key: _KT, /) -> _VT | None: ...
     @overload
-    def get(self, __key: _KT, __default: _VT) -> _VT: ...
+    def get(self, key: _KT, default: _VT, /) -> _VT: ...
     @overload
-    def get(self, __key: _KT, __default: _T) -> _VT | _T: ...
+    def get(self, key: _KT, default: _T, /) -> _VT | _T: ...
     @overload
-    def pop(self, __key: _KT) -> _VT: ...
+    def pop(self, key: _KT, /) -> _VT: ...
     @overload
-    def pop(self, __key: _KT, __default: _VT) -> _VT: ...
+    def pop(self, key: _KT, default: _VT, /) -> _VT: ...
     @overload
-    def pop(self, __key: _KT, __default: _T) -> _VT | _T: ...
+    def pop(self, key: _KT, default: _T, /) -> _VT | _T: ...
     def keys(self) -> list[_KT]: ...  # type: ignore[override]
     def items(self) -> list[tuple[_KT, _VT]]: ...  # type: ignore[override]
     def values(self) -> list[_VT]: ...  # type: ignore[override]
 
 class BaseListProxy(BaseProxy, MutableSequence[_T]):
     __builtins__: ClassVar[dict[str, Any]]
     def __len__(self) -> int: ...
-    def __add__(self, __x: list[_T]) -> list[_T]: ...
-    def __delitem__(self, __i: SupportsIndex | slice) -> None: ...
+    def __add__(self, x: list[_T], /) -> list[_T]: ...
+    def __delitem__(self, i: SupportsIndex | slice, /) -> None: ...
     @overload
-    def __getitem__(self, __i: SupportsIndex) -> _T: ...
+    def __getitem__(self, i: SupportsIndex, /) -> _T: ...
     @overload
-    def __getitem__(self, __s: slice) -> list[_T]: ...
+    def __getitem__(self, s: slice, /) -> list[_T]: ...
     @overload
-    def __setitem__(self, __i: SupportsIndex, __o: _T) -> None: ...
+    def __setitem__(self, i: SupportsIndex, o: _T, /) -> None: ...
     @overload
-    def __setitem__(self, __s: slice, __o: Iterable[_T]) -> None: ...
-    def __mul__(self, __n: SupportsIndex) -> list[_T]: ...
-    def __rmul__(self, __n: SupportsIndex) -> list[_T]: ...
+    def __setitem__(self, s: slice, o: Iterable[_T], /) -> None: ...
+    def __mul__(self, n: SupportsIndex, /) -> list[_T]: ...
+    def __rmul__(self, n: SupportsIndex, /) -> list[_T]: ...
     def __reversed__(self) -> Iterator[_T]: ...
-    def append(self, __object: _T) -> None: ...
-    def extend(self, __iterable: Iterable[_T]) -> None: ...
-    def pop(self, __index: SupportsIndex = ...) -> _T: ...
-    def index(self, __value: _T, __start: SupportsIndex = ..., __stop: SupportsIndex = ...) -> int: ...
-    def count(self, __value: _T) -> int: ...
-    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...
-    def remove(self, __value: _T) -> None: ...
+    def append(self, object: _T, /) -> None: ...
+    def extend(self, iterable: Iterable[_T], /) -> None: ...
+    def pop(self, index: SupportsIndex = ..., /) -> _T: ...
+    def index(self, value: _T, start: SupportsIndex = ..., stop: SupportsIndex = ..., /) -> int: ...
+    def count(self, value: _T, /) -> int: ...
+    def insert(self, index: SupportsIndex, object: _T, /) -> None: ...
+    def remove(self, value: _T, /) -> None: ...
     # Use BaseListProxy[SupportsRichComparisonT] for the first overload rather than [SupportsRichComparison]
     # to work around invariance
     @overload
     def sort(self: BaseListProxy[SupportsRichComparisonT], *, key: None = None, reverse: bool = ...) -> None: ...
     @overload
     def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = ...) -> None: ...
 
 class ListProxy(BaseListProxy[_T]):
-    def __iadd__(self, __value: Iterable[_T]) -> Self: ...  # type: ignore[override]
-    def __imul__(self, __value: SupportsIndex) -> Self: ...  # type: ignore[override]
+    def __iadd__(self, value: Iterable[_T], /) -> Self: ...  # type: ignore[override]
+    def __imul__(self, value: SupportsIndex, /) -> Self: ...  # type: ignore[override]
 
 # Returned by BaseManager.get_server()
 class Server:
     address: Any
     def __init__(
         self, registry: dict[str, tuple[Callable[..., Any], Any, Any, Any]], address: Any, authkey: bytes, serializer: str
     ) -> None: ...
@@ -182,27 +182,27 @@
     def Value(self, typecode: Any, value: _T) -> ValueProxy[_T]: ...
     # Overloads are copied from builtins.dict.__init__
     @overload
     def dict(self) -> DictProxy[Any, Any]: ...
     @overload
     def dict(self, **kwargs: _VT) -> DictProxy[str, _VT]: ...
     @overload
-    def dict(self, __map: SupportsKeysAndGetItem[_KT, _VT]) -> DictProxy[_KT, _VT]: ...
+    def dict(self, map: SupportsKeysAndGetItem[_KT, _VT], /) -> DictProxy[_KT, _VT]: ...
     @overload
-    def dict(self, __map: SupportsKeysAndGetItem[str, _VT], **kwargs: _VT) -> DictProxy[str, _VT]: ...
+    def dict(self, map: SupportsKeysAndGetItem[str, _VT], /, **kwargs: _VT) -> DictProxy[str, _VT]: ...
     @overload
-    def dict(self, __iterable: Iterable[tuple[_KT, _VT]]) -> DictProxy[_KT, _VT]: ...
+    def dict(self, iterable: Iterable[tuple[_KT, _VT]], /) -> DictProxy[_KT, _VT]: ...
     @overload
-    def dict(self, __iterable: Iterable[tuple[str, _VT]], **kwargs: _VT) -> DictProxy[str, _VT]: ...
+    def dict(self, iterable: Iterable[tuple[str, _VT]], /, **kwargs: _VT) -> DictProxy[str, _VT]: ...
     @overload
-    def dict(self, __iterable: Iterable[list[str]]) -> DictProxy[str, str]: ...
+    def dict(self, iterable: Iterable[list[str]], /) -> DictProxy[str, str]: ...
     @overload
-    def dict(self, __iterable: Iterable[list[bytes]]) -> DictProxy[bytes, bytes]: ...
+    def dict(self, iterable: Iterable[list[bytes]], /) -> DictProxy[bytes, bytes]: ...
     @overload
-    def list(self, __sequence: Sequence[_T]) -> ListProxy[_T]: ...
+    def list(self, sequence: Sequence[_T], /) -> ListProxy[_T]: ...
     @overload
     def list(self) -> ListProxy[Any]: ...
 
 class RemoteError(Exception): ...
 class SharedMemoryServer(Server): ...
 
 class SharedMemoryManager(BaseManager):
```

## puya/_vendor/mypy/typeshed/stdlib/multiprocessing/queues.pyi

```diff
@@ -19,15 +19,15 @@
     def full(self) -> bool: ...
     def get_nowait(self) -> _T: ...
     def put_nowait(self, obj: _T) -> None: ...
     def close(self) -> None: ...
     def join_thread(self) -> None: ...
     def cancel_join_thread(self) -> None: ...
     if sys.version_info >= (3, 12):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 class JoinableQueue(Queue[_T]):
     def task_done(self) -> None: ...
     def join(self) -> None: ...
 
 class SimpleQueue(Generic[_T]):
     def __init__(self, *, ctx: Any = ...) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/multiprocessing/reduction.pyi

```diff
@@ -82,8 +82,9 @@
         steal_handle = _steal_handle
         duplicate = _duplicate
         DupHandle = _DupHandle
     else:
         sendfds = _sendfds
         recvfds = _recvfds
         DupFd = _DupFd
+
     def __init__(self, *args: Unused) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/multiprocessing/resource_tracker.pyi

```diff
@@ -1,17 +1,17 @@
-from _typeshed import FileDescriptorOrPath, Incomplete
+from _typeshed import FileDescriptorOrPath
 from collections.abc import Sized
 
 __all__ = ["ensure_running", "register", "unregister"]
 
 class ResourceTracker:
     def getfd(self) -> int | None: ...
     def ensure_running(self) -> None: ...
-    def register(self, name: Sized, rtype: Incomplete) -> None: ...
-    def unregister(self, name: Sized, rtype: Incomplete) -> None: ...
+    def register(self, name: Sized, rtype: str) -> None: ...
+    def unregister(self, name: Sized, rtype: str) -> None: ...
 
 _resource_tracker: ResourceTracker
 ensure_running = _resource_tracker.ensure_running
 register = _resource_tracker.register
 unregister = _resource_tracker.unregister
 getfd = _resource_tracker.getfd
```

## puya/_vendor/mypy/typeshed/stdlib/multiprocessing/sharedctypes.pyi

```diff
@@ -68,34 +68,40 @@
 def synchronized(obj: ctypes.Array[c_char], lock: _LockLike | None = None, ctx: Any | None = None) -> SynchronizedString: ...
 @overload
 def synchronized(obj: ctypes.Array[_CT], lock: _LockLike | None = None, ctx: Any | None = None) -> SynchronizedArray[_CT]: ...
 @overload
 def synchronized(obj: _CT, lock: _LockLike | None = None, ctx: Any | None = None) -> SynchronizedBase[_CT]: ...
 
 class _AcquireFunc(Protocol):
-    def __call__(self, __block: bool = ..., __timeout: float | None = ...) -> bool: ...
+    def __call__(self, block: bool = ..., timeout: float | None = ..., /) -> bool: ...
 
 class SynchronizedBase(Generic[_CT]):
     acquire: _AcquireFunc
     release: Callable[[], None]
     def __init__(self, obj: Any, lock: _LockLike | None = None, ctx: Any | None = None) -> None: ...
     def __reduce__(self) -> tuple[Callable[[Any, _LockLike], SynchronizedBase[Any]], tuple[Any, _LockLike]]: ...
     def get_obj(self) -> _CT: ...
     def get_lock(self) -> _LockLike: ...
     def __enter__(self) -> bool: ...
     def __exit__(
-        self, __exc_type: type[BaseException] | None, __exc_val: BaseException | None, __exc_tb: TracebackType | None
+        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None, /
     ) -> None: ...
 
 class Synchronized(SynchronizedBase[_SimpleCData[_T]], Generic[_T]):
     value: _T
 
 class SynchronizedArray(SynchronizedBase[ctypes.Array[_CT]], Generic[_CT]):
     def __len__(self) -> int: ...
+    @overload
+    def __getitem__(self, i: slice) -> list[_CT]: ...
+    @overload
     def __getitem__(self, i: int) -> _CT: ...
+    @overload
+    def __setitem__(self, i: slice, value: Iterable[_CT]) -> None: ...
+    @overload
     def __setitem__(self, i: int, value: _CT) -> None: ...
     def __getslice__(self, start: int, stop: int) -> list[_CT]: ...
     def __setslice__(self, start: int, stop: int, values: Iterable[_CT]) -> None: ...
 
 class SynchronizedString(SynchronizedArray[c_char]):
     value: bytes
     raw: bytes
```

## puya/_vendor/mypy/typeshed/stdlib/multiprocessing/synchronize.pyi

```diff
@@ -19,30 +19,30 @@
     def notify(self, n: int = 1) -> None: ...
     def notify_all(self) -> None: ...
     def wait(self, timeout: float | None = None) -> bool: ...
     def wait_for(self, predicate: Callable[[], bool], timeout: float | None = None) -> bool: ...
     def acquire(self, block: bool = ..., timeout: float | None = ...) -> bool: ...
     def release(self) -> None: ...
     def __exit__(
-        self, __exc_type: type[BaseException] | None, __exc_val: BaseException | None, __exc_tb: TracebackType | None
+        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None, /
     ) -> None: ...
 
 class Event:
     def __init__(self, *, ctx: BaseContext) -> None: ...
     def is_set(self) -> bool: ...
     def set(self) -> None: ...
     def clear(self) -> None: ...
     def wait(self, timeout: float | None = None) -> bool: ...
 
 # Not part of public API
 class SemLock(AbstractContextManager[bool]):
     def acquire(self, block: bool = ..., timeout: float | None = ...) -> bool: ...
     def release(self) -> None: ...
     def __exit__(
-        self, __exc_type: type[BaseException] | None, __exc_val: BaseException | None, __exc_tb: TracebackType | None
+        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None, /
     ) -> None: ...
 
 class Lock(SemLock):
     def __init__(self, *, ctx: BaseContext) -> None: ...
 
 class RLock(SemLock):
     def __init__(self, *, ctx: BaseContext) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/multiprocessing/util.pyi

```diff
@@ -1,12 +1,12 @@
 import threading
 from _typeshed import ConvertibleToInt, Incomplete, Unused
 from collections.abc import Callable, Iterable, Mapping, MutableMapping, Sequence
 from logging import Logger, _Level as _LoggingLevel
-from typing import Any
+from typing import Any, Generic, TypeVar, overload
 
 __all__ = [
     "sub_debug",
     "debug",
     "info",
     "sub_warning",
     "get_logger",
@@ -18,14 +18,17 @@
     "ForkAwareThreadLock",
     "ForkAwareLocal",
     "close_all_fds_except",
     "SUBDEBUG",
     "SUBWARNING",
 ]
 
+_T = TypeVar("_T")
+_R_co = TypeVar("_R_co", default=Any, covariant=True)
+
 NOTSET: int
 SUBDEBUG: int
 DEBUG: int
 INFO: int
 SUBWARNING: int
 
 LOGGER_NAME: str
@@ -38,32 +41,48 @@
 def get_logger() -> Logger: ...
 def log_to_stderr(level: _LoggingLevel | None = None) -> Logger: ...
 def is_abstract_socket_namespace(address: str | bytes | None) -> bool: ...
 
 abstract_sockets_supported: bool
 
 def get_temp_dir() -> str: ...
-def register_after_fork(obj: Incomplete, func: Callable[[Incomplete], object]) -> None: ...
+def register_after_fork(obj: _T, func: Callable[[_T], object]) -> None: ...
 
-class Finalize:
+class Finalize(Generic[_R_co]):
+    # "args" and "kwargs" are passed as arguments to "callback".
+    @overload
+    def __init__(
+        self,
+        obj: None,
+        callback: Callable[..., _R_co],
+        *,
+        args: Sequence[Any] = (),
+        kwargs: Mapping[str, Any] | None = None,
+        exitpriority: int,
+    ) -> None: ...
+    @overload
+    def __init__(
+        self, obj: None, callback: Callable[..., _R_co], args: Sequence[Any], kwargs: Mapping[str, Any] | None, exitpriority: int
+    ) -> None: ...
+    @overload
     def __init__(
         self,
-        obj: Incomplete | None,
-        callback: Callable[..., Incomplete],
+        obj: Any,
+        callback: Callable[..., _R_co],
         args: Sequence[Any] = (),
         kwargs: Mapping[str, Any] | None = None,
         exitpriority: int | None = None,
     ) -> None: ...
     def __call__(
         self,
         wr: Unused = None,
         _finalizer_registry: MutableMapping[Incomplete, Incomplete] = {},
         sub_debug: Callable[..., object] = ...,
         getpid: Callable[[], int] = ...,
-    ) -> Incomplete: ...
+    ) -> _R_co: ...
     def cancel(self) -> None: ...
     def still_active(self) -> bool: ...
 
 def is_exiting() -> bool: ...
 
 class ForkAwareThreadLock:
     acquire: Callable[[bool, float], bool]
```

## puya/_vendor/mypy/typeshed/stdlib/ntpath.pyi

```diff
@@ -93,19 +93,19 @@
 
 altsep: LiteralString
 
 # First parameter is not actually pos-only,
 # but must be defined as pos-only in the stub or cross-platform code doesn't type-check,
 # as the parameter name is different in posixpath.join()
 @overload
-def join(__path: LiteralString, *paths: LiteralString) -> LiteralString: ...
+def join(path: LiteralString, /, *paths: LiteralString) -> LiteralString: ...
 @overload
-def join(__path: StrPath, *paths: StrPath) -> str: ...
+def join(path: StrPath, /, *paths: StrPath) -> str: ...
 @overload
-def join(__path: BytesPath, *paths: BytesPath) -> bytes: ...
+def join(path: BytesPath, /, *paths: BytesPath) -> bytes: ...
 
 if sys.platform == "win32":
     if sys.version_info >= (3, 10):
         @overload
         def realpath(path: PathLike[AnyStr], *, strict: bool = False) -> AnyStr: ...
         @overload
         def realpath(path: AnyStr, *, strict: bool = False) -> AnyStr: ...
```

## puya/_vendor/mypy/typeshed/stdlib/numbers.pyi

```diff
@@ -1,154 +1,209 @@
 # Note: these stubs are incomplete. The more complex type
 # signatures are currently omitted.
 #
-# Use SupportsComplex, SupportsFloat and SupportsIndex for return types in this module
+# Use _ComplexLike, _RealLike and _IntegralLike for return types in this module
 # rather than `numbers.Complex`, `numbers.Real` and `numbers.Integral`,
 # to avoid an excessive number of `type: ignore`s in subclasses of these ABCs
 # (since type checkers don't see `complex` as a subtype of `numbers.Complex`,
 # nor `float` as a subtype of `numbers.Real`, etc.)
 
-import sys
 from _typeshed import Incomplete
 from abc import ABCMeta, abstractmethod
-from typing import Literal, SupportsFloat, SupportsIndex, overload
-from typing_extensions import TypeAlias
+from typing import Literal, Protocol, overload
 
-if sys.version_info >= (3, 11):
-    from typing import SupportsComplex as _SupportsComplex
-else:
-    # builtins.complex didn't have a __complex__ method on older Pythons
-    import typing
+__all__ = ["Number", "Complex", "Real", "Rational", "Integral"]
 
-    _SupportsComplex: TypeAlias = typing.SupportsComplex | complex
+############################
+# Protocols for return types
+############################
 
-__all__ = ["Number", "Complex", "Real", "Rational", "Integral"]
+# `_ComplexLike` is a structural-typing approximation
+# of the `Complex` ABC, which is not (and cannot be) a protocol
+#
+# NOTE: We can't include `__complex__` here,
+# as we want `int` to be seen as a subtype of `_ComplexLike`,
+# and `int.__complex__` does not exist :(
+class _ComplexLike(Protocol):
+    def __neg__(self) -> _ComplexLike: ...
+    def __pos__(self) -> _ComplexLike: ...
+    def __abs__(self) -> _RealLike: ...
+
+# _RealLike is a structural-typing approximation
+# of the `Real` ABC, which is not (and cannot be) a protocol
+class _RealLike(_ComplexLike, Protocol):
+    def __trunc__(self) -> _IntegralLike: ...
+    def __floor__(self) -> _IntegralLike: ...
+    def __ceil__(self) -> _IntegralLike: ...
+    def __float__(self) -> float: ...
+    # Overridden from `_ComplexLike`
+    # for a more precise return type:
+    def __neg__(self) -> _RealLike: ...
+    def __pos__(self) -> _RealLike: ...
+
+# _IntegralLike is a structural-typing approximation
+# of the `Integral` ABC, which is not (and cannot be) a protocol
+class _IntegralLike(_RealLike, Protocol):
+    def __invert__(self) -> _IntegralLike: ...
+    def __int__(self) -> int: ...
+    def __index__(self) -> int: ...
+    # Overridden from `_ComplexLike`
+    # for a more precise return type:
+    def __abs__(self) -> _IntegralLike: ...
+    # Overridden from `RealLike`
+    # for a more precise return type:
+    def __neg__(self) -> _IntegralLike: ...
+    def __pos__(self) -> _IntegralLike: ...
+
+#################
+# Module "proper"
+#################
 
 class Number(metaclass=ABCMeta):
     @abstractmethod
     def __hash__(self) -> int: ...
 
 # See comment at the top of the file
 # for why some of these return types are purposefully vague
-class Complex(Number):
+class Complex(Number, _ComplexLike):
     @abstractmethod
     def __complex__(self) -> complex: ...
     def __bool__(self) -> bool: ...
     @property
     @abstractmethod
-    def real(self) -> SupportsFloat: ...
+    def real(self) -> _RealLike: ...
     @property
     @abstractmethod
-    def imag(self) -> SupportsFloat: ...
+    def imag(self) -> _RealLike: ...
     @abstractmethod
-    def __add__(self, other) -> _SupportsComplex: ...
+    def __add__(self, other) -> _ComplexLike: ...
     @abstractmethod
-    def __radd__(self, other) -> _SupportsComplex: ...
+    def __radd__(self, other) -> _ComplexLike: ...
     @abstractmethod
-    def __neg__(self) -> _SupportsComplex: ...
+    def __neg__(self) -> _ComplexLike: ...
     @abstractmethod
-    def __pos__(self) -> _SupportsComplex: ...
-    def __sub__(self, other) -> _SupportsComplex: ...
-    def __rsub__(self, other) -> _SupportsComplex: ...
+    def __pos__(self) -> _ComplexLike: ...
+    def __sub__(self, other) -> _ComplexLike: ...
+    def __rsub__(self, other) -> _ComplexLike: ...
     @abstractmethod
-    def __mul__(self, other) -> _SupportsComplex: ...
+    def __mul__(self, other) -> _ComplexLike: ...
     @abstractmethod
-    def __rmul__(self, other) -> _SupportsComplex: ...
+    def __rmul__(self, other) -> _ComplexLike: ...
     @abstractmethod
-    def __truediv__(self, other) -> _SupportsComplex: ...
+    def __truediv__(self, other) -> _ComplexLike: ...
     @abstractmethod
-    def __rtruediv__(self, other) -> _SupportsComplex: ...
+    def __rtruediv__(self, other) -> _ComplexLike: ...
     @abstractmethod
-    def __pow__(self, exponent) -> _SupportsComplex: ...
+    def __pow__(self, exponent) -> _ComplexLike: ...
     @abstractmethod
-    def __rpow__(self, base) -> _SupportsComplex: ...
+    def __rpow__(self, base) -> _ComplexLike: ...
     @abstractmethod
-    def __abs__(self) -> SupportsFloat: ...
+    def __abs__(self) -> _RealLike: ...
     @abstractmethod
-    def conjugate(self) -> _SupportsComplex: ...
+    def conjugate(self) -> _ComplexLike: ...
     @abstractmethod
     def __eq__(self, other: object) -> bool: ...
 
 # See comment at the top of the file
 # for why some of these return types are purposefully vague
-class Real(Complex, SupportsFloat):
+class Real(Complex, _RealLike):
     @abstractmethod
     def __float__(self) -> float: ...
     @abstractmethod
-    def __trunc__(self) -> SupportsIndex: ...
+    def __trunc__(self) -> _IntegralLike: ...
     @abstractmethod
-    def __floor__(self) -> SupportsIndex: ...
+    def __floor__(self) -> _IntegralLike: ...
     @abstractmethod
-    def __ceil__(self) -> SupportsIndex: ...
+    def __ceil__(self) -> _IntegralLike: ...
     @abstractmethod
     @overload
-    def __round__(self, ndigits: None = None) -> SupportsIndex: ...
+    def __round__(self, ndigits: None = None) -> _IntegralLike: ...
     @abstractmethod
     @overload
-    def __round__(self, ndigits: int) -> SupportsFloat: ...
-    def __divmod__(self, other) -> tuple[SupportsFloat, SupportsFloat]: ...
-    def __rdivmod__(self, other) -> tuple[SupportsFloat, SupportsFloat]: ...
+    def __round__(self, ndigits: int) -> _RealLike: ...
+    def __divmod__(self, other) -> tuple[_RealLike, _RealLike]: ...
+    def __rdivmod__(self, other) -> tuple[_RealLike, _RealLike]: ...
     @abstractmethod
-    def __floordiv__(self, other) -> SupportsFloat: ...
+    def __floordiv__(self, other) -> _RealLike: ...
     @abstractmethod
-    def __rfloordiv__(self, other) -> SupportsFloat: ...
+    def __rfloordiv__(self, other) -> _RealLike: ...
     @abstractmethod
-    def __mod__(self, other) -> SupportsFloat: ...
+    def __mod__(self, other) -> _RealLike: ...
     @abstractmethod
-    def __rmod__(self, other) -> SupportsFloat: ...
+    def __rmod__(self, other) -> _RealLike: ...
     @abstractmethod
     def __lt__(self, other) -> bool: ...
     @abstractmethod
     def __le__(self, other) -> bool: ...
     def __complex__(self) -> complex: ...
     @property
-    def real(self) -> SupportsFloat: ...
+    def real(self) -> _RealLike: ...
     @property
     def imag(self) -> Literal[0]: ...
-    def conjugate(self) -> SupportsFloat: ...  # type: ignore[override]
+    def conjugate(self) -> _RealLike: ...
+    # Not actually overridden at runtime,
+    # but we override these in the stub to give them more precise return types:
+    @abstractmethod
+    def __pos__(self) -> _RealLike: ...
+    @abstractmethod
+    def __neg__(self) -> _RealLike: ...
 
 # See comment at the top of the file
 # for why some of these return types are purposefully vague
 class Rational(Real):
     @property
     @abstractmethod
-    def numerator(self) -> SupportsIndex: ...
+    def numerator(self) -> _IntegralLike: ...
     @property
     @abstractmethod
-    def denominator(self) -> SupportsIndex: ...
+    def denominator(self) -> _IntegralLike: ...
     def __float__(self) -> float: ...
 
 # See comment at the top of the file
 # for why some of these return types are purposefully vague
-class Integral(Rational):
+class Integral(Rational, _IntegralLike):
     @abstractmethod
     def __int__(self) -> int: ...
     def __index__(self) -> int: ...
     @abstractmethod
-    def __pow__(self, exponent, modulus: Incomplete | None = None) -> SupportsIndex: ...  # type: ignore[override]
+    def __pow__(self, exponent, modulus: Incomplete | None = None) -> _IntegralLike: ...
     @abstractmethod
-    def __lshift__(self, other) -> SupportsIndex: ...
+    def __lshift__(self, other) -> _IntegralLike: ...
     @abstractmethod
-    def __rlshift__(self, other) -> SupportsIndex: ...
+    def __rlshift__(self, other) -> _IntegralLike: ...
     @abstractmethod
-    def __rshift__(self, other) -> SupportsIndex: ...
+    def __rshift__(self, other) -> _IntegralLike: ...
     @abstractmethod
-    def __rrshift__(self, other) -> SupportsIndex: ...
+    def __rrshift__(self, other) -> _IntegralLike: ...
     @abstractmethod
-    def __and__(self, other) -> SupportsIndex: ...
+    def __and__(self, other) -> _IntegralLike: ...
     @abstractmethod
-    def __rand__(self, other) -> SupportsIndex: ...
+    def __rand__(self, other) -> _IntegralLike: ...
     @abstractmethod
-    def __xor__(self, other) -> SupportsIndex: ...
+    def __xor__(self, other) -> _IntegralLike: ...
     @abstractmethod
-    def __rxor__(self, other) -> SupportsIndex: ...
+    def __rxor__(self, other) -> _IntegralLike: ...
     @abstractmethod
-    def __or__(self, other) -> SupportsIndex: ...
+    def __or__(self, other) -> _IntegralLike: ...
     @abstractmethod
-    def __ror__(self, other) -> SupportsIndex: ...
+    def __ror__(self, other) -> _IntegralLike: ...
     @abstractmethod
-    def __invert__(self) -> SupportsIndex: ...
+    def __invert__(self) -> _IntegralLike: ...
     def __float__(self) -> float: ...
     @property
-    def numerator(self) -> SupportsIndex: ...
+    def numerator(self) -> _IntegralLike: ...
     @property
     def denominator(self) -> Literal[1]: ...
+    # Not actually overridden at runtime,
+    # but we override these in the stub to give them more precise return types:
+    @abstractmethod
+    def __pos__(self) -> _IntegralLike: ...
+    @abstractmethod
+    def __neg__(self) -> _IntegralLike: ...
+    @abstractmethod
+    def __abs__(self) -> _IntegralLike: ...
+    @abstractmethod
+    @overload
+    def __round__(self, ndigits: None = None) -> _IntegralLike: ...
+    @abstractmethod
+    @overload
+    def __round__(self, ndigits: int) -> _IntegralLike: ...
```

## puya/_vendor/mypy/typeshed/stdlib/opcode.pyi

```diff
@@ -52,8 +52,8 @@
     hasnargs: list[int]
 opname: list[str]
 
 opmap: dict[str, int]
 HAVE_ARGUMENT: Literal[90]
 EXTENDED_ARG: Literal[144]
 
-def stack_effect(__opcode: int, __oparg: int | None = None, *, jump: bool | None = None) -> int: ...
+def stack_effect(opcode: int, oparg: int | None = None, /, *, jump: bool | None = None) -> int: ...
```

## puya/_vendor/mypy/typeshed/stdlib/optparse.pyi

```diff
@@ -1,10 +1,11 @@
+from _typeshed import Incomplete
 from abc import abstractmethod
 from collections.abc import Callable, Iterable, Mapping, Sequence
-from typing import IO, Any, AnyStr, overload
+from typing import IO, Any, AnyStr, Literal, overload
 
 __all__ = [
     "Option",
     "make_option",
     "SUPPRESS_HELP",
     "SUPPRESS_USAGE",
     "Values",
@@ -22,16 +23,16 @@
     "check_choice",
 ]
 
 NO_DEFAULT: tuple[str, ...]
 SUPPRESS_HELP: str
 SUPPRESS_USAGE: str
 
-def check_builtin(option: Option, opt: Any, value: str) -> Any: ...
-def check_choice(option: Option, opt: Any, value: str) -> str: ...
+def check_builtin(option: Option, opt, value: str): ...
+def check_choice(option: Option, opt, value: str) -> str: ...
 
 class OptParseError(Exception):
     msg: str
     def __init__(self, msg: str) -> None: ...
 
 class BadOptionError(OptParseError):
     opt_str: str
@@ -50,34 +51,34 @@
 
 class HelpFormatter:
     NO_DEFAULT_VALUE: str
     _long_opt_fmt: str
     _short_opt_fmt: str
     current_indent: int
     default_tag: str
-    help_position: Any
-    help_width: Any
+    help_position: int
+    help_width: int | Any  # initialized as None and computed later as int when storing option strings
     indent_increment: int
     level: int
     max_help_position: int
     option_strings: dict[Option, str]
     parser: OptionParser
-    short_first: Any
+    short_first: Incomplete
     width: int
     def __init__(self, indent_increment: int, max_help_position: int, width: int | None, short_first: int) -> None: ...
     def dedent(self) -> None: ...
     def expand_default(self, option: Option) -> str: ...
-    def format_description(self, description: str) -> str: ...
-    def format_epilog(self, epilog: str) -> str: ...
+    def format_description(self, description: str | None) -> str: ...
+    def format_epilog(self, epilog: str | None) -> str: ...
     @abstractmethod
-    def format_heading(self, heading: Any) -> str: ...
+    def format_heading(self, heading: str) -> str: ...
     def format_option(self, option: Option) -> str: ...
     def format_option_strings(self, option: Option) -> str: ...
     @abstractmethod
-    def format_usage(self, usage: Any) -> str: ...
+    def format_usage(self, usage: str) -> str: ...
     def indent(self) -> None: ...
     def set_long_opt_delimiter(self, delim: str) -> None: ...
     def set_parser(self, parser: OptionParser) -> None: ...
     def set_short_opt_delimiter(self, delim: str) -> None: ...
     def store_option_strings(self, parser: OptionParser) -> None: ...
 
 class IndentedHelpFormatter(HelpFormatter):
@@ -94,109 +95,111 @@
     def format_heading(self, heading: str) -> str: ...
     def format_usage(self, usage: str) -> str: ...
 
 class Option:
     ACTIONS: tuple[str, ...]
     ALWAYS_TYPED_ACTIONS: tuple[str, ...]
     ATTRS: list[str]
-    CHECK_METHODS: list[Callable[..., Any]] | None
+    CHECK_METHODS: list[Callable[..., Incomplete]] | None
     CONST_ACTIONS: tuple[str, ...]
     STORE_ACTIONS: tuple[str, ...]
     TYPED_ACTIONS: tuple[str, ...]
     TYPES: tuple[str, ...]
-    TYPE_CHECKER: dict[str, Callable[..., Any]]
+    TYPE_CHECKER: dict[str, Callable[[Option, str, Incomplete], Any]]
     _long_opts: list[str]
     _short_opts: list[str]
     action: str
     dest: str | None
-    default: Any
+    default: Incomplete
     nargs: int
-    type: Any
-    callback: Callable[..., Any] | None
-    callback_args: tuple[Any, ...] | None
-    callback_kwargs: dict[str, Any] | None
+    type: Incomplete
+    callback: Callable[..., Incomplete] | None
+    callback_args: tuple[Incomplete, ...] | None
+    callback_kwargs: dict[str, Incomplete] | None
     help: str | None
     metavar: str | None
-    def __init__(self, *opts: str | None, **attrs: Any) -> None: ...
+    def __init__(self, *opts: str | None, **attrs) -> None: ...
     def _check_action(self) -> None: ...
     def _check_callback(self) -> None: ...
     def _check_choice(self) -> None: ...
     def _check_const(self) -> None: ...
     def _check_dest(self) -> None: ...
     def _check_nargs(self) -> None: ...
     def _check_opt_strings(self, opts: Iterable[str | None]) -> list[str]: ...
     def _check_type(self) -> None: ...
-    def _set_attrs(self, attrs: dict[str, Any]) -> None: ...
+    def _set_attrs(self, attrs: dict[str, Incomplete]) -> None: ...
     def _set_opt_strings(self, opts: Iterable[str]) -> None: ...
-    def check_value(self, opt: str, value: Any) -> Any: ...
-    def convert_value(self, opt: str, value: Any) -> Any: ...
+    def check_value(self, opt: str, value): ...
+    def convert_value(self, opt: str, value): ...
     def get_opt_string(self) -> str: ...
-    def process(self, opt: Any, value: Any, values: Any, parser: OptionParser) -> int: ...
-    def take_action(self, action: str, dest: str, opt: Any, value: Any, values: Any, parser: OptionParser) -> int: ...
+    def process(self, opt, value, values, parser: OptionParser) -> int: ...
+    def take_action(self, action: str, dest: str, opt, value, values, parser: OptionParser) -> int: ...
     def takes_value(self) -> bool: ...
 
 make_option = Option
 
 class OptionContainer:
     _long_opt: dict[str, Option]
     _short_opt: dict[str, Option]
     conflict_handler: str
-    defaults: dict[str, Any]
-    description: Any
+    defaults: dict[str, Incomplete]
+    description: str | None
     option_class: type[Option]
-    def __init__(self, option_class: type[Option], conflict_handler: Any, description: Any) -> None: ...
-    def _check_conflict(self, option: Any) -> None: ...
+    def __init__(
+        self, option_class: type[Option], conflict_handler: Literal["error", "resolve"], description: str | None
+    ) -> None: ...
+    def _check_conflict(self, option: Option) -> None: ...
     def _create_option_mappings(self) -> None: ...
     def _share_option_mappings(self, parser: OptionParser) -> None: ...
     @overload
     def add_option(self, opt: Option) -> Option: ...
     @overload
-    def add_option(self, *args: str | None, **kwargs: Any) -> Any: ...
+    def add_option(self, arg: str, /, *args: str | None, **kwargs) -> Option: ...
     def add_options(self, option_list: Iterable[Option]) -> None: ...
     def destroy(self) -> None: ...
-    def format_description(self, formatter: HelpFormatter | None) -> Any: ...
-    def format_help(self, formatter: HelpFormatter | None) -> str: ...
-    def format_option_help(self, formatter: HelpFormatter | None) -> str: ...
-    def get_description(self) -> Any: ...
+    def format_option_help(self, formatter: HelpFormatter) -> str: ...
+    def format_description(self, formatter: HelpFormatter) -> str: ...
+    def format_help(self, formatter: HelpFormatter) -> str: ...
+    def get_description(self) -> str | None: ...
     def get_option(self, opt_str: str) -> Option | None: ...
     def has_option(self, opt_str: str) -> bool: ...
     def remove_option(self, opt_str: str) -> None: ...
-    def set_conflict_handler(self, handler: Any) -> None: ...
-    def set_description(self, description: Any) -> None: ...
+    def set_conflict_handler(self, handler: Literal["error", "resolve"]) -> None: ...
+    def set_description(self, description: str | None) -> None: ...
 
 class OptionGroup(OptionContainer):
     option_list: list[Option]
     parser: OptionParser
     title: str
     def __init__(self, parser: OptionParser, title: str, description: str | None = None) -> None: ...
     def _create_option_list(self) -> None: ...
     def set_title(self, title: str) -> None: ...
 
 class Values:
-    def __init__(self, defaults: Mapping[str, Any] | None = None) -> None: ...
-    def _update(self, dict: Mapping[str, Any], mode: Any) -> None: ...
-    def _update_careful(self, dict: Mapping[str, Any]) -> None: ...
-    def _update_loose(self, dict: Mapping[str, Any]) -> None: ...
-    def ensure_value(self, attr: str, value: Any) -> Any: ...
+    def __init__(self, defaults: Mapping[str, Incomplete] | None = None) -> None: ...
+    def _update(self, dict: Mapping[str, Incomplete], mode) -> None: ...
+    def _update_careful(self, dict: Mapping[str, Incomplete]) -> None: ...
+    def _update_loose(self, dict: Mapping[str, Incomplete]) -> None: ...
+    def ensure_value(self, attr: str, value): ...
     def read_file(self, filename: str, mode: str = "careful") -> None: ...
     def read_module(self, modname: str, mode: str = "careful") -> None: ...
-    def __getattr__(self, name: str) -> Any: ...
-    def __setattr__(self, __name: str, __value: Any) -> None: ...
+    def __getattr__(self, name: str): ...
+    def __setattr__(self, name: str, value, /) -> None: ...
     def __eq__(self, other: object) -> bool: ...
 
 class OptionParser(OptionContainer):
     allow_interspersed_args: bool
     epilog: str | None
     formatter: HelpFormatter
     largs: list[str] | None
     option_groups: list[OptionGroup]
     option_list: list[Option]
-    process_default_values: Any
+    process_default_values: bool
     prog: str | None
-    rargs: list[Any] | None
+    rargs: list[str] | None
     standard_option_list: list[Option]
     usage: str | None
     values: Values | None
     version: str
     def __init__(
         self,
         usage: str | None = None,
@@ -210,43 +213,43 @@
         prog: str | None = None,
         epilog: str | None = None,
     ) -> None: ...
     def _add_help_option(self) -> None: ...
     def _add_version_option(self) -> None: ...
     def _create_option_list(self) -> None: ...
     def _get_all_options(self) -> list[Option]: ...
-    def _get_args(self, args: Iterable[Any]) -> list[Any]: ...
+    def _get_args(self, args: Iterable[Incomplete]) -> list[Incomplete]: ...
     def _init_parsing_state(self) -> None: ...
     def _match_long_opt(self, opt: str) -> str: ...
     def _populate_option_list(self, option_list: Iterable[Option], add_help: bool = True) -> None: ...
-    def _process_args(self, largs: list[Any], rargs: list[Any], values: Values) -> None: ...
-    def _process_long_opt(self, rargs: list[Any], values: Any) -> None: ...
-    def _process_short_opts(self, rargs: list[Any], values: Any) -> None: ...
+    def _process_args(self, largs: list[Incomplete], rargs: list[Incomplete], values: Values) -> None: ...
+    def _process_long_opt(self, rargs: list[Incomplete], values) -> None: ...
+    def _process_short_opts(self, rargs: list[Incomplete], values) -> None: ...
     @overload
-    def add_option_group(self, __opt_group: OptionGroup) -> OptionGroup: ...
+    def add_option_group(self, opt_group: OptionGroup, /) -> OptionGroup: ...
     @overload
-    def add_option_group(self, *args: Any, **kwargs: Any) -> OptionGroup: ...
+    def add_option_group(self, *args, **kwargs) -> OptionGroup: ...
     def check_values(self, values: Values, args: list[str]) -> tuple[Values, list[str]]: ...
     def disable_interspersed_args(self) -> None: ...
     def enable_interspersed_args(self) -> None: ...
     def error(self, msg: str) -> None: ...
     def exit(self, status: int = 0, msg: str | None = None) -> None: ...
-    def expand_prog_name(self, s: str | None) -> Any: ...
-    def format_epilog(self, formatter: HelpFormatter) -> Any: ...
+    def expand_prog_name(self, s: str) -> str: ...
+    def format_epilog(self, formatter: HelpFormatter) -> str: ...
     def format_help(self, formatter: HelpFormatter | None = None) -> str: ...
     def format_option_help(self, formatter: HelpFormatter | None = None) -> str: ...
     def get_default_values(self) -> Values: ...
-    def get_option_group(self, opt_str: str) -> Any: ...
+    def get_option_group(self, opt_str: str) -> OptionGroup | None: ...
     def get_prog_name(self) -> str: ...
     def get_usage(self) -> str: ...
     def get_version(self) -> str: ...
     @overload
     def parse_args(self, args: None = None, values: Values | None = None) -> tuple[Values, list[str]]: ...
     @overload
     def parse_args(self, args: Sequence[AnyStr], values: Values | None = None) -> tuple[Values, list[AnyStr]]: ...
     def print_usage(self, file: IO[str] | None = None) -> None: ...
     def print_help(self, file: IO[str] | None = None) -> None: ...
     def print_version(self, file: IO[str] | None = None) -> None: ...
-    def set_default(self, dest: Any, value: Any) -> None: ...
-    def set_defaults(self, **kwargs: Any) -> None: ...
-    def set_process_default_values(self, process: Any) -> None: ...
+    def set_default(self, dest, value) -> None: ...
+    def set_defaults(self, **kwargs) -> None: ...
+    def set_process_default_values(self, process) -> None: ...
     def set_usage(self, usage: str) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/os/__init__.pyi

```diff
@@ -36,15 +36,15 @@
     NoReturn,
     Protocol,
     TypeVar,
     final,
     overload,
     runtime_checkable,
 )
-from typing_extensions import Self, TypeAlias, Unpack
+from typing_extensions import Self, TypeAlias, Unpack, deprecated
 
 from . import path as _path
 
 if sys.version_info >= (3, 9):
     from types import GenericAlias
 
 # This unnecessary alias is to work around various errors
@@ -304,15 +304,16 @@
     EX_CANTCREAT: int
     EX_IOERR: int
     EX_TEMPFAIL: int
     EX_PROTOCOL: int
     EX_NOPERM: int
     EX_CONFIG: int
 
-if sys.platform != "win32" and sys.platform != "darwin":
+# Exists on some Unix platforms, e.g. Solaris.
+if sys.platform != "win32" and sys.platform != "darwin" and sys.platform != "linux":
     EX_NOTFOUND: int
 
 P_NOWAIT: int
 P_NOWAITO: int
 P_WAIT: int
 if sys.platform == "win32":
     P_DETACH: int
@@ -337,14 +338,15 @@
     #
     # The 10 elements always present are st_mode, st_ino, st_dev, st_nlink,
     # st_uid, st_gid, st_size, st_atime, st_mtime, st_ctime.
     #
     # More items may be added at the end by some implementations.
     if sys.version_info >= (3, 10):
         __match_args__: Final = ("st_mode", "st_ino", "st_dev", "st_nlink", "st_uid", "st_gid", "st_size")
+
     @property
     def st_mode(self) -> int: ...  # protection bits,
     @property
     def st_ino(self) -> int: ...  # inode number,
     @property
     def st_dev(self) -> int: ...  # device,
     @property
@@ -356,16 +358,24 @@
     @property
     def st_size(self) -> int: ...  # size of file, in bytes,
     @property
     def st_atime(self) -> float: ...  # time of most recent access,
     @property
     def st_mtime(self) -> float: ...  # time of most recent content modification,
     # platform dependent (time of most recent metadata change on Unix, or the time of creation on Windows)
-    @property
-    def st_ctime(self) -> float: ...
+    if sys.version_info >= (3, 12) and sys.platform == "win32":
+        @property
+        @deprecated(
+            "Use st_birthtime instead to retrieve the file creation time. In the future, this property will contain the last metadata change time."
+        )
+        def st_ctime(self) -> float: ...
+    else:
+        @property
+        def st_ctime(self) -> float: ...
+
     @property
     def st_atime_ns(self) -> int: ...  # time of most recent access, in nanoseconds
     @property
     def st_mtime_ns(self) -> int: ...  # time of most recent content modification in nanoseconds
     # platform dependent (time of most recent metadata change on Unix, or the time of creation on Windows) in nanoseconds
     @property
     def st_ctime_ns(self) -> int: ...
@@ -442,14 +452,15 @@
             "f_bavail",
             "f_files",
             "f_ffree",
             "f_favail",
             "f_flag",
             "f_namemax",
         )
+
     @property
     def f_bsize(self) -> int: ...
     @property
     def f_frsize(self) -> int: ...
     @property
     def f_blocks(self) -> int: ...
     @property
@@ -478,20 +489,21 @@
 def fspath(path: bytes) -> bytes: ...
 @overload
 def fspath(path: PathLike[AnyStr]) -> AnyStr: ...
 def get_exec_path(env: Mapping[str, str] | None = None) -> list[str]: ...
 def getlogin() -> str: ...
 def getpid() -> int: ...
 def getppid() -> int: ...
-def strerror(__code: int) -> str: ...
-def umask(__mask: int) -> int: ...
+def strerror(code: int, /) -> str: ...
+def umask(mask: int, /) -> int: ...
 @final
 class uname_result(structseq[str], tuple[str, str, str, str, str]):
     if sys.version_info >= (3, 10):
         __match_args__: Final = ("sysname", "nodename", "release", "version", "machine")
+
     @property
     def sysname(self) -> str: ...
     @property
     def nodename(self) -> str: ...
     @property
     def release(self) -> str: ...
     @property
@@ -500,61 +512,61 @@
     def machine(self) -> str: ...
 
 if sys.platform != "win32":
     def ctermid() -> str: ...
     def getegid() -> int: ...
     def geteuid() -> int: ...
     def getgid() -> int: ...
-    def getgrouplist(__user: str, __group: int) -> list[int]: ...
+    def getgrouplist(user: str, group: int, /) -> list[int]: ...
     def getgroups() -> list[int]: ...  # Unix only, behaves differently on Mac
-    def initgroups(__username: str, __gid: int) -> None: ...
+    def initgroups(username: str, gid: int, /) -> None: ...
     def getpgid(pid: int) -> int: ...
     def getpgrp() -> int: ...
     def getpriority(which: int, who: int) -> int: ...
     def setpriority(which: int, who: int, priority: int) -> None: ...
     if sys.platform != "darwin":
         def getresuid() -> tuple[int, int, int]: ...
         def getresgid() -> tuple[int, int, int]: ...
 
     def getuid() -> int: ...
-    def setegid(__egid: int) -> None: ...
-    def seteuid(__euid: int) -> None: ...
-    def setgid(__gid: int) -> None: ...
-    def setgroups(__groups: Sequence[int]) -> None: ...
+    def setegid(egid: int, /) -> None: ...
+    def seteuid(euid: int, /) -> None: ...
+    def setgid(gid: int, /) -> None: ...
+    def setgroups(groups: Sequence[int], /) -> None: ...
     def setpgrp() -> None: ...
-    def setpgid(__pid: int, __pgrp: int) -> None: ...
-    def setregid(__rgid: int, __egid: int) -> None: ...
+    def setpgid(pid: int, pgrp: int, /) -> None: ...
+    def setregid(rgid: int, egid: int, /) -> None: ...
     if sys.platform != "darwin":
-        def setresgid(__rgid: int, __egid: int, __sgid: int) -> None: ...
-        def setresuid(__ruid: int, __euid: int, __suid: int) -> None: ...
+        def setresgid(rgid: int, egid: int, sgid: int, /) -> None: ...
+        def setresuid(ruid: int, euid: int, suid: int, /) -> None: ...
 
-    def setreuid(__ruid: int, __euid: int) -> None: ...
-    def getsid(__pid: int) -> int: ...
+    def setreuid(ruid: int, euid: int, /) -> None: ...
+    def getsid(pid: int, /) -> int: ...
     def setsid() -> None: ...
-    def setuid(__uid: int) -> None: ...
+    def setuid(uid: int, /) -> None: ...
     def uname() -> uname_result: ...
 
 @overload
 def getenv(key: str) -> str | None: ...
 @overload
 def getenv(key: str, default: _T) -> str | _T: ...
 
 if sys.platform != "win32":
     @overload
     def getenvb(key: bytes) -> bytes | None: ...
     @overload
     def getenvb(key: bytes, default: _T) -> bytes | _T: ...
-    def putenv(__name: StrOrBytesPath, __value: StrOrBytesPath) -> None: ...
-    def unsetenv(__name: StrOrBytesPath) -> None: ...
+    def putenv(name: StrOrBytesPath, value: StrOrBytesPath, /) -> None: ...
+    def unsetenv(name: StrOrBytesPath, /) -> None: ...
 
 else:
-    def putenv(__name: str, __value: str) -> None: ...
+    def putenv(name: str, value: str, /) -> None: ...
 
     if sys.version_info >= (3, 9):
-        def unsetenv(__name: str) -> None: ...
+        def unsetenv(name: str, /) -> None: ...
 
 _Opener: TypeAlias = Callable[[str, int], int]
 
 @overload
 def fdopen(
     fd: int,
     mode: OpenTextMode = "r",
@@ -628,58 +640,58 @@
     encoding: str | None = None,
     errors: str | None = ...,
     newline: str | None = ...,
     closefd: bool = ...,
     opener: _Opener | None = ...,
 ) -> IO[Any]: ...
 def close(fd: int) -> None: ...
-def closerange(__fd_low: int, __fd_high: int) -> None: ...
+def closerange(fd_low: int, fd_high: int, /) -> None: ...
 def device_encoding(fd: int) -> str | None: ...
-def dup(__fd: int) -> int: ...
+def dup(fd: int, /) -> int: ...
 def dup2(fd: int, fd2: int, inheritable: bool = True) -> int: ...
 def fstat(fd: int) -> stat_result: ...
-def ftruncate(__fd: int, __length: int) -> None: ...
+def ftruncate(fd: int, length: int, /) -> None: ...
 def fsync(fd: FileDescriptorLike) -> None: ...
-def isatty(__fd: int) -> bool: ...
+def isatty(fd: int, /) -> bool: ...
 
 if sys.platform != "win32" and sys.version_info >= (3, 11):
-    def login_tty(__fd: int) -> None: ...
+    def login_tty(fd: int, /) -> None: ...
 
 if sys.version_info >= (3, 11):
-    def lseek(__fd: int, __position: int, __whence: int) -> int: ...
+    def lseek(fd: int, position: int, whence: int, /) -> int: ...
 
 else:
-    def lseek(__fd: int, __position: int, __how: int) -> int: ...
+    def lseek(fd: int, position: int, how: int, /) -> int: ...
 
 def open(path: StrOrBytesPath, flags: int, mode: int = 0o777, *, dir_fd: int | None = None) -> int: ...
 def pipe() -> tuple[int, int]: ...
-def read(__fd: int, __length: int) -> bytes: ...
+def read(fd: int, length: int, /) -> bytes: ...
 
 if sys.version_info >= (3, 12) or sys.platform != "win32":
-    def get_blocking(__fd: int) -> bool: ...
-    def set_blocking(__fd: int, __blocking: bool) -> None: ...
+    def get_blocking(fd: int, /) -> bool: ...
+    def set_blocking(fd: int, blocking: bool, /) -> None: ...
 
 if sys.platform != "win32":
     def fchmod(fd: int, mode: int) -> None: ...
     def fchown(fd: int, uid: int, gid: int) -> None: ...
-    def fpathconf(__fd: int, __name: str | int) -> int: ...
-    def fstatvfs(__fd: int) -> statvfs_result: ...
-    def lockf(__fd: int, __command: int, __length: int) -> None: ...
+    def fpathconf(fd: int, name: str | int, /) -> int: ...
+    def fstatvfs(fd: int, /) -> statvfs_result: ...
+    def lockf(fd: int, command: int, length: int, /) -> None: ...
     def openpty() -> tuple[int, int]: ...  # some flavors of Unix
     if sys.platform != "darwin":
         def fdatasync(fd: FileDescriptorLike) -> None: ...
-        def pipe2(__flags: int) -> tuple[int, int]: ...  # some flavors of Unix
-        def posix_fallocate(__fd: int, __offset: int, __length: int) -> None: ...
-        def posix_fadvise(__fd: int, __offset: int, __length: int, __advice: int) -> None: ...
+        def pipe2(flags: int, /) -> tuple[int, int]: ...  # some flavors of Unix
+        def posix_fallocate(fd: int, offset: int, length: int, /) -> None: ...
+        def posix_fadvise(fd: int, offset: int, length: int, advice: int, /) -> None: ...
 
-    def pread(__fd: int, __length: int, __offset: int) -> bytes: ...
-    def pwrite(__fd: int, __buffer: ReadableBuffer, __offset: int) -> int: ...
+    def pread(fd: int, length: int, offset: int, /) -> bytes: ...
+    def pwrite(fd: int, buffer: ReadableBuffer, offset: int, /) -> int: ...
     # In CI, stubtest sometimes reports that these are available on MacOS, sometimes not
-    def preadv(__fd: int, __buffers: SupportsLenAndGetItem[WriteableBuffer], __offset: int, __flags: int = 0) -> int: ...
-    def pwritev(__fd: int, __buffers: SupportsLenAndGetItem[ReadableBuffer], __offset: int, __flags: int = 0) -> int: ...
+    def preadv(fd: int, buffers: SupportsLenAndGetItem[WriteableBuffer], offset: int, flags: int = 0, /) -> int: ...
+    def pwritev(fd: int, buffers: SupportsLenAndGetItem[ReadableBuffer], offset: int, flags: int = 0, /) -> int: ...
     if sys.platform != "darwin":
         if sys.version_info >= (3, 10):
             RWF_APPEND: int  # docs say available on 3.7+, stubtest says otherwise
         RWF_DSYNC: int
         RWF_SYNC: int
         RWF_HIPRI: int
         RWF_NOWAIT: int
@@ -693,41 +705,42 @@
             offset: int,
             count: int,
             headers: Sequence[ReadableBuffer] = ...,
             trailers: Sequence[ReadableBuffer] = ...,
             flags: int = 0,
         ) -> int: ...  # FreeBSD and Mac OS X only
 
-    def readv(__fd: int, __buffers: SupportsLenAndGetItem[WriteableBuffer]) -> int: ...
-    def writev(__fd: int, __buffers: SupportsLenAndGetItem[ReadableBuffer]) -> int: ...
+    def readv(fd: int, buffers: SupportsLenAndGetItem[WriteableBuffer], /) -> int: ...
+    def writev(fd: int, buffers: SupportsLenAndGetItem[ReadableBuffer], /) -> int: ...
 
 @final
 class terminal_size(structseq[int], tuple[int, int]):
     if sys.version_info >= (3, 10):
         __match_args__: Final = ("columns", "lines")
+
     @property
     def columns(self) -> int: ...
     @property
     def lines(self) -> int: ...
 
-def get_terminal_size(__fd: int = ...) -> terminal_size: ...
-def get_inheritable(__fd: int) -> bool: ...
-def set_inheritable(__fd: int, __inheritable: bool) -> None: ...
+def get_terminal_size(fd: int = ..., /) -> terminal_size: ...
+def get_inheritable(fd: int, /) -> bool: ...
+def set_inheritable(fd: int, inheritable: bool, /) -> None: ...
 
 if sys.platform == "win32":
-    def get_handle_inheritable(__handle: int) -> bool: ...
-    def set_handle_inheritable(__handle: int, __inheritable: bool) -> None: ...
+    def get_handle_inheritable(handle: int, /) -> bool: ...
+    def set_handle_inheritable(handle: int, inheritable: bool, /) -> None: ...
 
 if sys.platform != "win32":
     # Unix only
-    def tcgetpgrp(__fd: int) -> int: ...
-    def tcsetpgrp(__fd: int, __pgid: int) -> None: ...
-    def ttyname(__fd: int) -> str: ...
+    def tcgetpgrp(fd: int, /) -> int: ...
+    def tcsetpgrp(fd: int, pgid: int, /) -> None: ...
+    def ttyname(fd: int, /) -> str: ...
 
-def write(__fd: int, __data: ReadableBuffer) -> int: ...
+def write(fd: int, data: ReadableBuffer, /) -> int: ...
 def access(
     path: FileDescriptorOrPath, mode: int, *, dir_fd: int | None = None, effective_ids: bool = False, follow_symlinks: bool = True
 ) -> bool: ...
 def chdir(path: FileDescriptorOrPath) -> None: ...
 
 if sys.platform != "win32":
     def fchdir(fd: FileDescriptorLike) -> None: ...
@@ -762,17 +775,17 @@
 if sys.platform != "win32":
     def mkfifo(path: StrOrBytesPath, mode: int = 0o666, *, dir_fd: int | None = None) -> None: ...  # Unix only
 
 def makedirs(name: StrOrBytesPath, mode: int = 0o777, exist_ok: bool = False) -> None: ...
 
 if sys.platform != "win32":
     def mknod(path: StrOrBytesPath, mode: int = 0o600, device: int = 0, *, dir_fd: int | None = None) -> None: ...
-    def major(__device: int) -> int: ...
-    def minor(__device: int) -> int: ...
-    def makedev(__major: int, __minor: int) -> int: ...
+    def major(device: int, /) -> int: ...
+    def minor(device: int, /) -> int: ...
+    def makedev(major: int, minor: int, /) -> int: ...
     def pathconf(path: FileDescriptorOrPath, name: str | int) -> int: ...  # Unix only
 
 def readlink(path: GenericPath[AnyStr], *, dir_fd: int | None = None) -> AnyStr: ...
 def remove(path: StrOrBytesPath, *, dir_fd: int | None = None) -> None: ...
 def removedirs(name: StrOrBytesPath) -> None: ...
 def rename(src: StrOrBytesPath, dst: StrOrBytesPath, *, src_dir_fd: int | None = None, dst_dir_fd: int | None = None) -> None: ...
 def renames(old: StrOrBytesPath, new: StrOrBytesPath) -> None: ...
@@ -852,16 +865,16 @@
             *,
             follow_symlinks: bool = True,
         ) -> None: ...
 
 def abort() -> NoReturn: ...
 
 # These are defined as execl(file, *args) but the first *arg is mandatory.
-def execl(file: StrOrBytesPath, __arg0: StrOrBytesPath, *args: StrOrBytesPath) -> NoReturn: ...
-def execlp(file: StrOrBytesPath, __arg0: StrOrBytesPath, *args: StrOrBytesPath) -> NoReturn: ...
+def execl(file: StrOrBytesPath, *args: Unpack[tuple[StrOrBytesPath, Unpack[tuple[StrOrBytesPath, ...]]]]) -> NoReturn: ...
+def execlp(file: StrOrBytesPath, *args: Unpack[tuple[StrOrBytesPath, Unpack[tuple[StrOrBytesPath, ...]]]]) -> NoReturn: ...
 
 # These are: execle(file, *args, env) but env is pulled from the last element of the args.
 def execle(
     file: StrOrBytesPath, *args: Unpack[tuple[StrOrBytesPath, Unpack[tuple[StrOrBytesPath, ...]], _ExecEnv]]
 ) -> NoReturn: ...
 def execlpe(
     file: StrOrBytesPath, *args: Unpack[tuple[StrOrBytesPath, Unpack[tuple[StrOrBytesPath, ...]], _ExecEnv]]
@@ -884,64 +897,65 @@
 )
 # Depending on the OS, the keys and values are passed either to
 # PyUnicode_FSDecoder (which accepts str | ReadableBuffer) or to
 # PyUnicode_FSConverter (which accepts StrOrBytesPath). For simplicity,
 # we limit to str | bytes.
 _ExecEnv: TypeAlias = Mapping[bytes, bytes | str] | Mapping[str, bytes | str]
 
-def execv(__path: StrOrBytesPath, __argv: _ExecVArgs) -> NoReturn: ...
+def execv(path: StrOrBytesPath, argv: _ExecVArgs, /) -> NoReturn: ...
 def execve(path: FileDescriptorOrPath, argv: _ExecVArgs, env: _ExecEnv) -> NoReturn: ...
 def execvp(file: StrOrBytesPath, args: _ExecVArgs) -> NoReturn: ...
 def execvpe(file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> NoReturn: ...
 def _exit(status: int) -> NoReturn: ...
-def kill(__pid: int, __signal: int) -> None: ...
+def kill(pid: int, signal: int, /) -> None: ...
 
 if sys.platform != "win32":
     # Unix only
     def fork() -> int: ...
     def forkpty() -> tuple[int, int]: ...  # some flavors of Unix
-    def killpg(__pgid: int, __signal: int) -> None: ...
-    def nice(__increment: int) -> int: ...
+    def killpg(pgid: int, signal: int, /) -> None: ...
+    def nice(increment: int, /) -> int: ...
     if sys.platform != "darwin":
-        def plock(__op: int) -> None: ...  # ???op is int?
+        def plock(op: int, /) -> None: ...  # ???op is int?
 
 class _wrap_close(_TextIOWrapper):
     def __init__(self, stream: _TextIOWrapper, proc: Popen[str]) -> None: ...
     def close(self) -> int | None: ...  # type: ignore[override]
 
 def popen(cmd: str, mode: str = "r", buffering: int = -1) -> _wrap_close: ...
 def spawnl(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: StrOrBytesPath) -> int: ...
 def spawnle(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: Any) -> int: ...  # Imprecise sig
 
 if sys.platform != "win32":
     def spawnv(mode: int, file: StrOrBytesPath, args: _ExecVArgs) -> int: ...
     def spawnve(mode: int, file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> int: ...
 
 else:
-    def spawnv(__mode: int, __path: StrOrBytesPath, __argv: _ExecVArgs) -> int: ...
-    def spawnve(__mode: int, __path: StrOrBytesPath, __argv: _ExecVArgs, __env: _ExecEnv) -> int: ...
+    def spawnv(mode: int, path: StrOrBytesPath, argv: _ExecVArgs, /) -> int: ...
+    def spawnve(mode: int, path: StrOrBytesPath, argv: _ExecVArgs, env: _ExecEnv, /) -> int: ...
 
 def system(command: StrOrBytesPath) -> int: ...
 @final
 class times_result(structseq[float], tuple[float, float, float, float, float]):
     if sys.version_info >= (3, 10):
         __match_args__: Final = ("user", "system", "children_user", "children_system", "elapsed")
+
     @property
     def user(self) -> float: ...
     @property
     def system(self) -> float: ...
     @property
     def children_user(self) -> float: ...
     @property
     def children_system(self) -> float: ...
     @property
     def elapsed(self) -> float: ...
 
 def times() -> times_result: ...
-def waitpid(__pid: int, __options: int) -> tuple[int, int]: ...
+def waitpid(pid: int, options: int, /) -> tuple[int, int]: ...
 
 if sys.platform == "win32":
     if sys.version_info >= (3, 10):
         def startfile(
             filepath: StrOrBytesPath,
             operation: str = ...,
             arguments: str = "",
@@ -958,56 +972,59 @@
     def spawnvpe(mode: int, file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> int: ...
     def wait() -> tuple[int, int]: ...  # Unix only
     if sys.platform != "darwin":
         @final
         class waitid_result(structseq[int], tuple[int, int, int, int, int]):
             if sys.version_info >= (3, 10):
                 __match_args__: Final = ("si_pid", "si_uid", "si_signo", "si_status", "si_code")
+
             @property
             def si_pid(self) -> int: ...
             @property
             def si_uid(self) -> int: ...
             @property
             def si_signo(self) -> int: ...
             @property
             def si_status(self) -> int: ...
             @property
             def si_code(self) -> int: ...
 
-        def waitid(__idtype: int, __ident: int, __options: int) -> waitid_result | None: ...
+        def waitid(idtype: int, ident: int, options: int, /) -> waitid_result | None: ...
 
     from resource import struct_rusage
 
     def wait3(options: int) -> tuple[int, int, struct_rusage]: ...
     def wait4(pid: int, options: int) -> tuple[int, int, struct_rusage]: ...
-    def WCOREDUMP(__status: int) -> bool: ...
+    def WCOREDUMP(status: int, /) -> bool: ...
     def WIFCONTINUED(status: int) -> bool: ...
     def WIFSTOPPED(status: int) -> bool: ...
     def WIFSIGNALED(status: int) -> bool: ...
     def WIFEXITED(status: int) -> bool: ...
     def WEXITSTATUS(status: int) -> int: ...
     def WSTOPSIG(status: int) -> int: ...
     def WTERMSIG(status: int) -> int: ...
     def posix_spawn(
-        __path: StrOrBytesPath,
-        __argv: _ExecVArgs,
-        __env: _ExecEnv,
+        path: StrOrBytesPath,
+        argv: _ExecVArgs,
+        env: _ExecEnv,
+        /,
         *,
         file_actions: Sequence[tuple[Any, ...]] | None = ...,
         setpgroup: int | None = ...,
         resetids: bool = ...,
         setsid: bool = ...,
         setsigmask: Iterable[int] = ...,
         setsigdef: Iterable[int] = ...,
         scheduler: tuple[Any, sched_param] | None = ...,
     ) -> int: ...
     def posix_spawnp(
-        __path: StrOrBytesPath,
-        __argv: _ExecVArgs,
-        __env: _ExecEnv,
+        path: StrOrBytesPath,
+        argv: _ExecVArgs,
+        env: _ExecEnv,
+        /,
         *,
         file_actions: Sequence[tuple[Any, ...]] | None = ...,
         setpgroup: int | None = ...,
         resetids: bool = ...,
         setsid: bool = ...,
         setsigmask: Iterable[int] = ...,
         setsigdef: Iterable[int] = ...,
@@ -1018,42 +1035,43 @@
     POSIX_SPAWN_DUP2: int
 
 if sys.platform != "win32":
     @final
     class sched_param(structseq[int], tuple[int]):
         if sys.version_info >= (3, 10):
             __match_args__: Final = ("sched_priority",)
+
         def __new__(cls, sched_priority: int) -> Self: ...
         @property
         def sched_priority(self) -> int: ...
 
     def sched_get_priority_min(policy: int) -> int: ...  # some flavors of Unix
     def sched_get_priority_max(policy: int) -> int: ...  # some flavors of Unix
     def sched_yield() -> None: ...  # some flavors of Unix
     if sys.platform != "darwin":
-        def sched_setscheduler(__pid: int, __policy: int, __param: sched_param) -> None: ...  # some flavors of Unix
-        def sched_getscheduler(__pid: int) -> int: ...  # some flavors of Unix
-        def sched_rr_get_interval(__pid: int) -> float: ...  # some flavors of Unix
-        def sched_setparam(__pid: int, __param: sched_param) -> None: ...  # some flavors of Unix
-        def sched_getparam(__pid: int) -> sched_param: ...  # some flavors of Unix
-        def sched_setaffinity(__pid: int, __mask: Iterable[int]) -> None: ...  # some flavors of Unix
-        def sched_getaffinity(__pid: int) -> set[int]: ...  # some flavors of Unix
+        def sched_setscheduler(pid: int, policy: int, param: sched_param, /) -> None: ...  # some flavors of Unix
+        def sched_getscheduler(pid: int, /) -> int: ...  # some flavors of Unix
+        def sched_rr_get_interval(pid: int, /) -> float: ...  # some flavors of Unix
+        def sched_setparam(pid: int, param: sched_param, /) -> None: ...  # some flavors of Unix
+        def sched_getparam(pid: int, /) -> sched_param: ...  # some flavors of Unix
+        def sched_setaffinity(pid: int, mask: Iterable[int], /) -> None: ...  # some flavors of Unix
+        def sched_getaffinity(pid: int, /) -> set[int]: ...  # some flavors of Unix
 
 def cpu_count() -> int | None: ...
 
 if sys.platform != "win32":
     # Unix only
-    def confstr(__name: str | int) -> str | None: ...
+    def confstr(name: str | int, /) -> str | None: ...
     def getloadavg() -> tuple[float, float, float]: ...
-    def sysconf(__name: str | int) -> int: ...
+    def sysconf(name: str | int, /) -> int: ...
 
 if sys.platform == "linux":
     def getrandom(size: int, flags: int = 0) -> bytes: ...
 
-def urandom(__size: int) -> bytes: ...
+def urandom(size: int, /) -> bytes: ...
 
 if sys.platform != "win32":
     def register_at_fork(
         *,
         before: Callable[..., Any] | None = ...,
         after_in_parent: Callable[..., Any] | None = ...,
         after_in_child: Callable[..., Any] | None = ...,
```

## puya/_vendor/mypy/typeshed/stdlib/pathlib.pyi

```diff
@@ -55,25 +55,25 @@
     def __rtruediv__(self, key: StrPath) -> Self: ...
     def __bytes__(self) -> bytes: ...
     def as_posix(self) -> str: ...
     def as_uri(self) -> str: ...
     def is_absolute(self) -> bool: ...
     def is_reserved(self) -> bool: ...
     if sys.version_info >= (3, 12):
-        def is_relative_to(self, __other: StrPath, *_deprecated: StrPath) -> bool: ...
+        def is_relative_to(self, other: StrPath, /, *_deprecated: StrPath) -> bool: ...
     elif sys.version_info >= (3, 9):
         def is_relative_to(self, *other: StrPath) -> bool: ...
 
     if sys.version_info >= (3, 12):
         def match(self, path_pattern: str, *, case_sensitive: bool | None = None) -> bool: ...
     else:
         def match(self, path_pattern: str) -> bool: ...
 
     if sys.version_info >= (3, 12):
-        def relative_to(self, __other: StrPath, *_deprecated: StrPath, walk_up: bool = False) -> Self: ...
+        def relative_to(self, other: StrPath, /, *_deprecated: StrPath, walk_up: bool = False) -> Self: ...
     else:
         def relative_to(self, *other: StrPath) -> Self: ...
 
     def with_name(self, name: str) -> Self: ...
     if sys.version_info >= (3, 9):
         def with_stem(self, stem: str) -> Self: ...
```

## puya/_vendor/mypy/typeshed/stdlib/pickle.pyi

```diff
@@ -90,24 +90,24 @@
 
 HIGHEST_PROTOCOL: int
 DEFAULT_PROTOCOL: int
 
 bytes_types: tuple[type[Any], ...]  # undocumented
 
 class _ReadableFileobj(Protocol):
-    def read(self, __n: int) -> bytes: ...
+    def read(self, n: int, /) -> bytes: ...
     def readline(self) -> bytes: ...
 
 @final
 class PickleBuffer:
     def __init__(self, buffer: ReadableBuffer) -> None: ...
     def raw(self) -> memoryview: ...
     def release(self) -> None: ...
-    def __buffer__(self, __flags: int) -> memoryview: ...
-    def __release_buffer__(self, __buffer: memoryview) -> None: ...
+    def __buffer__(self, flags: int, /) -> memoryview: ...
+    def __release_buffer__(self, buffer: memoryview, /) -> None: ...
 
 _BufferCallback: TypeAlias = Callable[[PickleBuffer], Any] | None
 
 def dump(
     obj: Any,
     file: SupportsWrite[bytes],
     protocol: int | None = None,
@@ -123,15 +123,16 @@
     *,
     fix_imports: bool = True,
     encoding: str = "ASCII",
     errors: str = "strict",
     buffers: Iterable[Any] | None = (),
 ) -> Any: ...
 def loads(
-    __data: ReadableBuffer,
+    data: ReadableBuffer,
+    /,
     *,
     fix_imports: bool = True,
     encoding: str = "ASCII",
     errors: str = "strict",
     buffers: Iterable[Any] | None = (),
 ) -> Any: ...
 
@@ -158,15 +159,15 @@
         file: SupportsWrite[bytes],
         protocol: int | None = ...,
         *,
         fix_imports: bool = ...,
         buffer_callback: _BufferCallback = ...,
     ) -> None: ...
     def reducer_override(self, obj: Any) -> Any: ...
-    def dump(self, __obj: Any) -> None: ...
+    def dump(self, obj: Any, /) -> None: ...
     def clear_memo(self) -> None: ...
     def persistent_id(self, obj: Any) -> Any: ...
 
 class Unpickler:
     dispatch: ClassVar[dict[int, Callable[[Unpickler], None]]]  # undocumented, _Unpickler only
 
     def __init__(
@@ -175,15 +176,15 @@
         *,
         fix_imports: bool = ...,
         encoding: str = ...,
         errors: str = ...,
         buffers: Iterable[Any] | None = ...,
     ) -> None: ...
     def load(self) -> Any: ...
-    def find_class(self, __module_name: str, __global_name: str) -> Any: ...
+    def find_class(self, module_name: str, global_name: str, /) -> Any: ...
     def persistent_load(self, pid: Any) -> Any: ...
 
 MARK: bytes
 STOP: bytes
 POP: bytes
 POP_MARK: bytes
 DUP: bytes
```

## puya/_vendor/mypy/typeshed/stdlib/posix.pyi

```diff
@@ -235,17 +235,19 @@
 
     if sys.version_info >= (3, 11):
         from os import login_tty as login_tty
 
     if sys.platform != "linux":
         from os import chflags as chflags, lchflags as lchflags, lchmod as lchmod
 
+    if sys.platform != "linux" and sys.platform != "darwin":
+        from os import EX_NOTFOUND as EX_NOTFOUND
+
     if sys.platform != "darwin":
         from os import (
-            EX_NOTFOUND as EX_NOTFOUND,
             POSIX_FADV_DONTNEED as POSIX_FADV_DONTNEED,
             POSIX_FADV_NOREUSE as POSIX_FADV_NOREUSE,
             POSIX_FADV_NORMAL as POSIX_FADV_NORMAL,
             POSIX_FADV_RANDOM as POSIX_FADV_RANDOM,
             POSIX_FADV_SEQUENTIAL as POSIX_FADV_SEQUENTIAL,
             POSIX_FADV_WILLNEED as POSIX_FADV_WILLNEED,
             RWF_DSYNC as RWF_DSYNC,
```

## puya/_vendor/mypy/typeshed/stdlib/posixpath.pyi

```diff
@@ -108,19 +108,19 @@
 @overload
 def commonpath(paths: Iterable[BytesPath]) -> bytes: ...
 
 # First parameter is not actually pos-only,
 # but must be defined as pos-only in the stub or cross-platform code doesn't type-check,
 # as the parameter name is different in ntpath.join()
 @overload
-def join(__a: LiteralString, *paths: LiteralString) -> LiteralString: ...
+def join(a: LiteralString, /, *paths: LiteralString) -> LiteralString: ...
 @overload
-def join(__a: StrPath, *paths: StrPath) -> str: ...
+def join(a: StrPath, /, *paths: StrPath) -> str: ...
 @overload
-def join(__a: BytesPath, *paths: BytesPath) -> bytes: ...
+def join(a: BytesPath, /, *paths: BytesPath) -> bytes: ...
 
 if sys.version_info >= (3, 10):
     @overload
     def realpath(filename: PathLike[AnyStr], *, strict: bool = False) -> AnyStr: ...
     @overload
     def realpath(filename: AnyStr, *, strict: bool = False) -> AnyStr: ...
```

## puya/_vendor/mypy/typeshed/stdlib/profile.pyi

```diff
@@ -23,9 +23,9 @@
     def simulate_cmd_complete(self) -> None: ...
     def print_stats(self, sort: str | int = -1) -> None: ...
     def dump_stats(self, file: StrOrBytesPath) -> None: ...
     def create_stats(self) -> None: ...
     def snapshot_stats(self) -> None: ...
     def run(self, cmd: str) -> Self: ...
     def runctx(self, cmd: str, globals: dict[str, Any], locals: dict[str, Any]) -> Self: ...
-    def runcall(self, __func: Callable[_P, _T], *args: _P.args, **kw: _P.kwargs) -> _T: ...
+    def runcall(self, func: Callable[_P, _T], /, *args: _P.args, **kw: _P.kwargs) -> _T: ...
     def calibrate(self, m: int, verbose: int = 0) -> float: ...
```

## puya/_vendor/mypy/typeshed/stdlib/pstats.pyi

```diff
@@ -32,26 +32,28 @@
         ncalls: str
         tottime: float
         percall_tottime: float
         cumtime: float
         percall_cumtime: float
         file_name: str
         line_number: int
+
     @dataclass(unsafe_hash=True)
     class StatsProfile:
         total_tt: float
         func_profiles: dict[str, FunctionProfile]
 
 _SortArgDict: TypeAlias = dict[str, tuple[tuple[tuple[int, int], ...], str]]
 
 class Stats:
     sort_arg_dict_default: _SortArgDict
     def __init__(
         self,
-        __arg: None | str | Profile | _cProfile = ...,
+        arg: None | str | Profile | _cProfile = ...,
+        /,
         *args: None | str | Profile | _cProfile | Self,
         stream: IO[Any] | None = None,
     ) -> None: ...
     def init(self, arg: None | str | Profile | _cProfile) -> None: ...
     def load_stats(self, arg: None | str | Profile | _cProfile) -> None: ...
     def get_top_level_stats(self) -> None: ...
     def add(self, *arg_list: None | str | Profile | _cProfile | Self) -> Self: ...
```

## puya/_vendor/mypy/typeshed/stdlib/pwd.pyi

```diff
@@ -3,14 +3,15 @@
 from typing import Any, Final, final
 
 if sys.platform != "win32":
     @final
     class struct_passwd(structseq[Any], tuple[str, str, int, int, str, str, str]):
         if sys.version_info >= (3, 10):
             __match_args__: Final = ("pw_name", "pw_passwd", "pw_uid", "pw_gid", "pw_gecos", "pw_dir", "pw_shell")
+
         @property
         def pw_name(self) -> str: ...
         @property
         def pw_passwd(self) -> str: ...
         @property
         def pw_uid(self) -> int: ...
         @property
@@ -19,9 +20,9 @@
         def pw_gecos(self) -> str: ...
         @property
         def pw_dir(self) -> str: ...
         @property
         def pw_shell(self) -> str: ...
 
     def getpwall() -> list[struct_passwd]: ...
-    def getpwuid(__uid: int) -> struct_passwd: ...
-    def getpwnam(__name: str) -> struct_passwd: ...
+    def getpwuid(uid: int, /) -> struct_passwd: ...
+    def getpwnam(name: str, /) -> struct_passwd: ...
```

## puya/_vendor/mypy/typeshed/stdlib/pyexpat/__init__.pyi

```diff
@@ -20,22 +20,24 @@
 XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE: int
 XML_PARAM_ENTITY_PARSING_ALWAYS: int
 
 _Model: TypeAlias = tuple[int, int, str | None, tuple[Any, ...]]
 
 @final
 class XMLParserType:
-    def Parse(self, __data: str | ReadableBuffer, __isfinal: bool = False) -> int: ...
-    def ParseFile(self, __file: SupportsRead[bytes]) -> int: ...
-    def SetBase(self, __base: str) -> None: ...
+    def Parse(self, data: str | ReadableBuffer, isfinal: bool = False, /) -> int: ...
+    def ParseFile(self, file: SupportsRead[bytes], /) -> int: ...
+    def SetBase(self, base: str, /) -> None: ...
     def GetBase(self) -> str | None: ...
     def GetInputContext(self) -> bytes | None: ...
-    def ExternalEntityParserCreate(self, __context: str | None, __encoding: str = ...) -> XMLParserType: ...
-    def SetParamEntityParsing(self, __flag: int) -> int: ...
-    def UseForeignDTD(self, __flag: bool = True) -> None: ...
+    def ExternalEntityParserCreate(self, context: str | None, encoding: str = ..., /) -> XMLParserType: ...
+    def SetParamEntityParsing(self, flag: int, /) -> int: ...
+    def UseForeignDTD(self, flag: bool = True, /) -> None: ...
+    def GetReparseDeferralEnabled(self) -> bool: ...
+    def SetReparseDeferralEnabled(self, enabled: bool, /) -> None: ...
     @property
     def intern(self) -> dict[str, str]: ...
     buffer_size: int
     buffer_text: bool
     buffer_used: int
     namespace_prefixes: bool  # undocumented
     ordered_attributes: bool
@@ -48,17 +50,20 @@
     CurrentColumnNumber: int
     CurrentLineNumber: int
     XmlDeclHandler: Callable[[str, str | None, int], Any] | None
     StartDoctypeDeclHandler: Callable[[str, str | None, str | None, bool], Any] | None
     EndDoctypeDeclHandler: Callable[[], Any] | None
     ElementDeclHandler: Callable[[str, _Model], Any] | None
     AttlistDeclHandler: Callable[[str, str, str, str | None, bool], Any] | None
-    StartElementHandler: Callable[[str, dict[str, str]], Any] | Callable[[str, list[str]], Any] | Callable[
-        [str, dict[str, str], list[str]], Any
-    ] | None
+    StartElementHandler: (
+        Callable[[str, dict[str, str]], Any]
+        | Callable[[str, list[str]], Any]
+        | Callable[[str, dict[str, str], list[str]], Any]
+        | None
+    )
     EndElementHandler: Callable[[str], Any] | None
     ProcessingInstructionHandler: Callable[[str, str], Any] | None
     CharacterDataHandler: Callable[[str], Any] | None
     UnparsedEntityDeclHandler: Callable[[str, str | None, str, str | None, str], Any] | None
     EntityDeclHandler: Callable[[str, bool, str | None, str | None, str, str | None, str | None], Any] | None
     NotationDeclHandler: Callable[[str, str | None, str, str | None], Any] | None
     StartNamespaceDeclHandler: Callable[[str, str], Any] | None
@@ -68,13 +73,13 @@
     EndCdataSectionHandler: Callable[[], Any] | None
     DefaultHandler: Callable[[str], Any] | None
     DefaultHandlerExpand: Callable[[str], Any] | None
     NotStandaloneHandler: Callable[[], int] | None
     ExternalEntityRefHandler: Callable[[str, str | None, str | None, str | None], int] | None
     SkippedEntityHandler: Callable[[str, bool], Any] | None
 
-def ErrorString(__code: int) -> str: ...
+def ErrorString(code: int, /) -> str: ...
 
 # intern is undocumented
 def ParserCreate(
     encoding: str | None = None, namespace_separator: str | None = None, intern: dict[str, Any] | None = None
 ) -> XMLParserType: ...
```

## puya/_vendor/mypy/typeshed/stdlib/queue.pyi

```diff
@@ -8,31 +8,39 @@
 __all__ = ["Empty", "Full", "Queue", "PriorityQueue", "LifoQueue", "SimpleQueue"]
 
 _T = TypeVar("_T")
 
 class Empty(Exception): ...
 class Full(Exception): ...
 
+if sys.version_info >= (3, 13):
+    class ShutDown(Exception): ...
+
 class Queue(Generic[_T]):
     maxsize: int
 
     mutex: Lock  # undocumented
     not_empty: Condition  # undocumented
     not_full: Condition  # undocumented
     all_tasks_done: Condition  # undocumented
     unfinished_tasks: int  # undocumented
+    if sys.version_info >= (3, 13):
+        is_shutdown: bool  # undocumented
     # Despite the fact that `queue` has `deque` type,
     # we treat it as `Any` to allow different implementations in subtypes.
     queue: Any  # undocumented
     def __init__(self, maxsize: int = 0) -> None: ...
     def _init(self, maxsize: int) -> None: ...
     def empty(self) -> bool: ...
     def full(self) -> bool: ...
     def get(self, block: bool = True, timeout: float | None = None) -> _T: ...
     def get_nowait(self) -> _T: ...
+    if sys.version_info >= (3, 13):
+        def shutdown(self, immediate: bool = False) -> None: ...
+
     def _get(self) -> _T: ...
     def put(self, item: _T, block: bool = True, timeout: float | None = None) -> None: ...
     def put_nowait(self, item: _T) -> None: ...
     def _put(self, item: _T) -> None: ...
     def join(self) -> None: ...
     def qsize(self) -> int: ...
     def _qsize(self) -> int: ...
```

## puya/_vendor/mypy/typeshed/stdlib/re.pyi

```diff
@@ -68,43 +68,43 @@
     def expand(self: Match[str], template: str) -> str: ...
     @overload
     def expand(self: Match[bytes], template: ReadableBuffer) -> bytes: ...  # type: ignore[overload-overlap]
     @overload
     def expand(self, template: AnyStr) -> AnyStr: ...
     # group() returns "AnyStr" or "AnyStr | None", depending on the pattern.
     @overload
-    def group(self, __group: Literal[0] = 0) -> AnyStr: ...
+    def group(self, group: Literal[0] = 0, /) -> AnyStr: ...
     @overload
-    def group(self, __group: str | int) -> AnyStr | Any: ...
+    def group(self, group: str | int, /) -> AnyStr | Any: ...
     @overload
-    def group(self, __group1: str | int, __group2: str | int, *groups: str | int) -> tuple[AnyStr | Any, ...]: ...
+    def group(self, group1: str | int, group2: str | int, /, *groups: str | int) -> tuple[AnyStr | Any, ...]: ...
     # Each item of groups()'s return tuple is either "AnyStr" or
     # "AnyStr | None", depending on the pattern.
     @overload
     def groups(self) -> tuple[AnyStr | Any, ...]: ...
     @overload
     def groups(self, default: _T) -> tuple[AnyStr | _T, ...]: ...
     # Each value in groupdict()'s return dict is either "AnyStr" or
     # "AnyStr | None", depending on the pattern.
     @overload
     def groupdict(self) -> dict[str, AnyStr | Any]: ...
     @overload
     def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...
-    def start(self, __group: int | str = 0) -> int: ...
-    def end(self, __group: int | str = 0) -> int: ...
-    def span(self, __group: int | str = 0) -> tuple[int, int]: ...
+    def start(self, group: int | str = 0, /) -> int: ...
+    def end(self, group: int | str = 0, /) -> int: ...
+    def span(self, group: int | str = 0, /) -> tuple[int, int]: ...
     @property
     def regs(self) -> tuple[tuple[int, int], ...]: ...  # undocumented
     # __getitem__() returns "AnyStr" or "AnyStr | None", depending on the pattern.
     @overload
-    def __getitem__(self, __key: Literal[0]) -> AnyStr: ...
+    def __getitem__(self, key: Literal[0], /) -> AnyStr: ...
     @overload
-    def __getitem__(self, __key: int | str) -> AnyStr | Any: ...
+    def __getitem__(self, key: int | str, /) -> AnyStr | Any: ...
     def __copy__(self) -> Match[AnyStr]: ...
-    def __deepcopy__(self, __memo: Any) -> Match[AnyStr]: ...
+    def __deepcopy__(self, memo: Any, /) -> Match[AnyStr]: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 @final
 class Pattern(Generic[AnyStr]):
     @property
     def flags(self) -> int: ...
@@ -170,16 +170,16 @@
         repl: ReadableBuffer | Callable[[Match[bytes]], ReadableBuffer],
         string: ReadableBuffer,
         count: int = 0,
     ) -> tuple[bytes, int]: ...
     @overload
     def subn(self, repl: AnyStr | Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = 0) -> tuple[AnyStr, int]: ...
     def __copy__(self) -> Pattern[AnyStr]: ...
-    def __deepcopy__(self, __memo: Any) -> Pattern[AnyStr]: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __deepcopy__(self, memo: Any, /) -> Pattern[AnyStr]: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 # ----- re variables and constants -----
 
 class RegexFlag(enum.IntFlag):
```

## puya/_vendor/mypy/typeshed/stdlib/readline.pyi

```diff
@@ -3,34 +3,34 @@
 from collections.abc import Callable, Sequence
 from typing_extensions import TypeAlias
 
 if sys.platform != "win32":
     _Completer: TypeAlias = Callable[[str, int], str | None]
     _CompDisp: TypeAlias = Callable[[str, Sequence[str], int], None]
 
-    def parse_and_bind(__string: str) -> None: ...
-    def read_init_file(__filename: StrOrBytesPath | None = None) -> None: ...
+    def parse_and_bind(string: str, /) -> None: ...
+    def read_init_file(filename: StrOrBytesPath | None = None, /) -> None: ...
     def get_line_buffer() -> str: ...
-    def insert_text(__string: str) -> None: ...
+    def insert_text(string: str, /) -> None: ...
     def redisplay() -> None: ...
-    def read_history_file(__filename: StrOrBytesPath | None = None) -> None: ...
-    def write_history_file(__filename: StrOrBytesPath | None = None) -> None: ...
-    def append_history_file(__nelements: int, __filename: StrOrBytesPath | None = None) -> None: ...
+    def read_history_file(filename: StrOrBytesPath | None = None, /) -> None: ...
+    def write_history_file(filename: StrOrBytesPath | None = None, /) -> None: ...
+    def append_history_file(nelements: int, filename: StrOrBytesPath | None = None, /) -> None: ...
     def get_history_length() -> int: ...
-    def set_history_length(__length: int) -> None: ...
+    def set_history_length(length: int, /) -> None: ...
     def clear_history() -> None: ...
     def get_current_history_length() -> int: ...
-    def get_history_item(__index: int) -> str: ...
-    def remove_history_item(__pos: int) -> None: ...
-    def replace_history_item(__pos: int, __line: str) -> None: ...
-    def add_history(__string: str) -> None: ...
-    def set_auto_history(__enabled: bool) -> None: ...
-    def set_startup_hook(__function: Callable[[], object] | None = None) -> None: ...
-    def set_pre_input_hook(__function: Callable[[], object] | None = None) -> None: ...
-    def set_completer(__function: _Completer | None = None) -> None: ...
+    def get_history_item(index: int, /) -> str: ...
+    def remove_history_item(pos: int, /) -> None: ...
+    def replace_history_item(pos: int, line: str, /) -> None: ...
+    def add_history(string: str, /) -> None: ...
+    def set_auto_history(enabled: bool, /) -> None: ...
+    def set_startup_hook(function: Callable[[], object] | None = None, /) -> None: ...
+    def set_pre_input_hook(function: Callable[[], object] | None = None, /) -> None: ...
+    def set_completer(function: _Completer | None = None, /) -> None: ...
     def get_completer() -> _Completer | None: ...
     def get_completion_type() -> int: ...
     def get_begidx() -> int: ...
     def get_endidx() -> int: ...
-    def set_completer_delims(__string: str) -> None: ...
+    def set_completer_delims(string: str, /) -> None: ...
     def get_completer_delims() -> str: ...
-    def set_completion_display_matches_hook(__function: _CompDisp | None = None) -> None: ...
+    def set_completion_display_matches_hook(function: _CompDisp | None = None, /) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/resource.pyi

```diff
@@ -20,14 +20,15 @@
         RLIMIT_MSGQUEUE: int
         RLIMIT_NICE: int
         RLIMIT_OFILE: int
         RLIMIT_RTPRIO: int
         RLIMIT_RTTIME: int
         RLIMIT_SIGPENDING: int
         RUSAGE_THREAD: int
+
     @final
     class struct_rusage(
         structseq[float], tuple[float, float, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
     ):
         if sys.version_info >= (3, 10):
             __match_args__: Final = (
                 "ru_utime",
@@ -43,14 +44,15 @@
                 "ru_oublock",
                 "ru_msgsnd",
                 "ru_msgrcv",
                 "ru_nsignals",
                 "ru_nvcsw",
                 "ru_nivcsw",
             )
+
         @property
         def ru_utime(self) -> float: ...
         @property
         def ru_stime(self) -> float: ...
         @property
         def ru_maxrss(self) -> int: ...
         @property
@@ -77,16 +79,16 @@
         def ru_nsignals(self) -> int: ...
         @property
         def ru_nvcsw(self) -> int: ...
         @property
         def ru_nivcsw(self) -> int: ...
 
     def getpagesize() -> int: ...
-    def getrlimit(__resource: int) -> tuple[int, int]: ...
-    def getrusage(__who: int) -> struct_rusage: ...
-    def setrlimit(__resource: int, __limits: tuple[int, int]) -> None: ...
+    def getrlimit(resource: int, /) -> tuple[int, int]: ...
+    def getrusage(who: int, /) -> struct_rusage: ...
+    def setrlimit(resource: int, limits: tuple[int, int], /) -> None: ...
     if sys.platform == "linux":
         if sys.version_info >= (3, 12):
-            def prlimit(__pid: int, __resource: int, __limits: tuple[int, int] | None = None) -> tuple[int, int]: ...
+            def prlimit(pid: int, resource: int, limits: tuple[int, int] | None = None, /) -> tuple[int, int]: ...
         else:
-            def prlimit(__pid: int, __resource: int, __limits: tuple[int, int] = ...) -> tuple[int, int]: ...
+            def prlimit(pid: int, resource: int, limits: tuple[int, int] = ..., /) -> tuple[int, int]: ...
     error = OSError
```

## puya/_vendor/mypy/typeshed/stdlib/select.pyi

```diff
@@ -24,15 +24,15 @@
 class poll:
     def register(self, fd: FileDescriptorLike, eventmask: int = ...) -> None: ...
     def modify(self, fd: FileDescriptorLike, eventmask: int) -> None: ...
     def unregister(self, fd: FileDescriptorLike) -> None: ...
     def poll(self, timeout: float | None = ...) -> list[tuple[int, int]]: ...
 
 def select(
-    __rlist: Iterable[Any], __wlist: Iterable[Any], __xlist: Iterable[Any], __timeout: float | None = None
+    rlist: Iterable[Any], wlist: Iterable[Any], xlist: Iterable[Any], timeout: float | None = None, /
 ) -> tuple[list[Any], list[Any], list[Any]]: ...
 
 error = OSError
 
 if sys.platform != "linux" and sys.platform != "win32":
     # BSD only
     @final
@@ -48,26 +48,28 @@
             ident: FileDescriptorLike,
             filter: int = ...,
             flags: int = ...,
             fflags: int = ...,
             data: Any = ...,
             udata: Any = ...,
         ) -> None: ...
+
     # BSD only
     @final
     class kqueue:
         closed: bool
         def __init__(self) -> None: ...
         def close(self) -> None: ...
         def control(
-            self, __changelist: Iterable[kevent] | None, __maxevents: int, __timeout: float | None = None
+            self, changelist: Iterable[kevent] | None, maxevents: int, timeout: float | None = None, /
         ) -> list[kevent]: ...
         def fileno(self) -> int: ...
         @classmethod
-        def fromfd(cls, __fd: FileDescriptorLike) -> kqueue: ...
+        def fromfd(cls, fd: FileDescriptorLike, /) -> kqueue: ...
+
     KQ_EV_ADD: int
     KQ_EV_CLEAR: int
     KQ_EV_DELETE: int
     KQ_EV_DISABLE: int
     KQ_EV_ENABLE: int
     KQ_EV_EOF: int
     KQ_EV_ERROR: int
@@ -106,27 +108,29 @@
 if sys.platform == "linux":
     @final
     class epoll:
         def __init__(self, sizehint: int = ..., flags: int = ...) -> None: ...
         def __enter__(self) -> Self: ...
         def __exit__(
             self,
-            __exc_type: type[BaseException] | None = None,
-            __exc_value: BaseException | None = ...,
-            __exc_tb: TracebackType | None = None,
+            exc_type: type[BaseException] | None = None,
+            exc_value: BaseException | None = ...,
+            exc_tb: TracebackType | None = None,
+            /,
         ) -> None: ...
         def close(self) -> None: ...
         closed: bool
         def fileno(self) -> int: ...
         def register(self, fd: FileDescriptorLike, eventmask: int = ...) -> None: ...
         def modify(self, fd: FileDescriptorLike, eventmask: int) -> None: ...
         def unregister(self, fd: FileDescriptorLike) -> None: ...
         def poll(self, timeout: float | None = None, maxevents: int = -1) -> list[tuple[int, int]]: ...
         @classmethod
-        def fromfd(cls, __fd: FileDescriptorLike) -> epoll: ...
+        def fromfd(cls, fd: FileDescriptorLike, /) -> epoll: ...
+
     EPOLLERR: int
     EPOLLEXCLUSIVE: int
     EPOLLET: int
     EPOLLHUP: int
     EPOLLIN: int
     EPOLLMSG: int
     EPOLLONESHOT: int
```

## puya/_vendor/mypy/typeshed/stdlib/shlex.pyi

```diff
@@ -1,43 +1,63 @@
+import sys
+from collections import deque
 from collections.abc import Iterable
-from typing import TextIO
-from typing_extensions import Self
+from io import TextIOWrapper
+from typing import Literal, Protocol, overload, type_check_only
+from typing_extensions import Self, deprecated
 
 __all__ = ["shlex", "split", "quote", "join"]
 
-def split(s: str, comments: bool = False, posix: bool = True) -> list[str]: ...
+@type_check_only
+class _ShlexInstream(Protocol):
+    def read(self, size: Literal[1], /) -> str: ...
+    def readline(self) -> object: ...
+    def close(self) -> object: ...
+
+if sys.version_info >= (3, 12):
+    def split(s: str | _ShlexInstream, comments: bool = False, posix: bool = True) -> list[str]: ...
+
+else:
+    @overload
+    def split(s: str | _ShlexInstream, comments: bool = False, posix: bool = True) -> list[str]: ...
+    @overload
+    @deprecated("Passing None for 's' to shlex.split() is deprecated and will raise an error in Python 3.12.")
+    def split(s: None, comments: bool = False, posix: bool = True) -> list[str]: ...
+
 def join(split_command: Iterable[str]) -> str: ...
 def quote(s: str) -> str: ...
 
+# TODO: Make generic over infile once PEP 696 is implemented.
 class shlex(Iterable[str]):
     commenters: str
     wordchars: str
     whitespace: str
     escape: str
     quotes: str
     escapedquotes: str
     whitespace_split: bool
     infile: str | None
-    instream: TextIO
+    instream: _ShlexInstream
     source: str
     debug: int
     lineno: int
     token: str
+    filestack: deque[tuple[str | None, _ShlexInstream, int]]
     eof: str | None
     @property
     def punctuation_chars(self) -> str: ...
     def __init__(
         self,
-        instream: str | TextIO | None = None,
+        instream: str | _ShlexInstream | None = None,
         infile: str | None = None,
         posix: bool = False,
         punctuation_chars: bool | str = False,
     ) -> None: ...
     def get_token(self) -> str | None: ...
     def push_token(self, tok: str) -> None: ...
     def read_token(self) -> str | None: ...
-    def sourcehook(self, newfile: str) -> tuple[str, TextIO] | None: ...
-    def push_source(self, newstream: str | TextIO, newfile: str | None = None) -> None: ...
+    def sourcehook(self, newfile: str) -> tuple[str, TextIOWrapper] | None: ...
+    def push_source(self, newstream: str | _ShlexInstream, newfile: str | None = None) -> None: ...
     def pop_source(self) -> None: ...
     def error_leader(self, infile: str | None = None, lineno: int | None = None) -> str: ...
     def __iter__(self) -> Self: ...
     def __next__(self) -> str: ...
```

## puya/_vendor/mypy/typeshed/stdlib/shutil.pyi

```diff
@@ -1,14 +1,14 @@
 import os
 import sys
 from _typeshed import BytesPath, FileDescriptorOrPath, StrOrBytesPath, StrPath, SupportsRead, SupportsWrite
 from collections.abc import Callable, Iterable, Sequence
 from tarfile import _TarfileFilter
 from typing import Any, AnyStr, NamedTuple, Protocol, TypeVar, overload
-from typing_extensions import TypeAlias
+from typing_extensions import TypeAlias, deprecated
 
 __all__ = [
     "copyfileobj",
     "copyfile",
     "copymode",
     "copystat",
     "copy",
@@ -74,32 +74,28 @@
 _OnErrorCallback: TypeAlias = Callable[[Callable[..., Any], str, Any], object]
 _OnExcCallback: TypeAlias = Callable[[Callable[..., Any], str, Exception], object]
 
 class _RmtreeType(Protocol):
     avoids_symlink_attacks: bool
     if sys.version_info >= (3, 12):
         @overload
+        def __call__(self, path: StrOrBytesPath, ignore_errors: bool = False, *, dir_fd: int | None = None) -> None: ...
+        @overload
+        @deprecated("The `onerror` parameter is deprecated and will be removed in Python 3.14. Use `onexc` instead.")
         def __call__(
             self,
             path: StrOrBytesPath,
             ignore_errors: bool = False,
             onerror: _OnErrorCallback | None = None,
             *,
-            onexc: None = None,
             dir_fd: int | None = None,
         ) -> None: ...
         @overload
         def __call__(
-            self,
-            path: StrOrBytesPath,
-            ignore_errors: bool = False,
-            onerror: None = None,
-            *,
-            onexc: _OnExcCallback,
-            dir_fd: int | None = None,
+            self, path: StrOrBytesPath, ignore_errors: bool = False, *, onexc: _OnExcCallback, dir_fd: int | None = None
         ) -> None: ...
     elif sys.version_info >= (3, 11):
         def __call__(
             self,
             path: StrOrBytesPath,
             ignore_errors: bool = False,
             onerror: _OnErrorCallback | None = None,
```

## puya/_vendor/mypy/typeshed/stdlib/signal.pyi

```diff
@@ -63,23 +63,23 @@
 
 SIG_DFL: Handlers
 SIG_IGN: Handlers
 
 _SIGNUM: TypeAlias = int | Signals
 _HANDLER: TypeAlias = Callable[[int, FrameType | None], Any] | int | Handlers | None
 
-def default_int_handler(__signalnum: int, __frame: FrameType | None) -> Never: ...
+def default_int_handler(signalnum: int, frame: FrameType | None, /) -> Never: ...
 
 if sys.version_info >= (3, 10):  # arguments changed in 3.10.2
     def getsignal(signalnum: _SIGNUM) -> _HANDLER: ...
     def signal(signalnum: _SIGNUM, handler: _HANDLER) -> _HANDLER: ...
 
 else:
-    def getsignal(__signalnum: _SIGNUM) -> _HANDLER: ...
-    def signal(__signalnum: _SIGNUM, __handler: _HANDLER) -> _HANDLER: ...
+    def getsignal(signalnum: _SIGNUM, /) -> _HANDLER: ...
+    def signal(signalnum: _SIGNUM, handler: _HANDLER, /) -> _HANDLER: ...
 
 SIGABRT: Signals
 SIGFPE: Signals
 SIGILL: Signals
 SIGINT: Signals
 SIGSEGV: Signals
 SIGTERM: Signals
@@ -122,45 +122,48 @@
     ITIMER_REAL: int
     ITIMER_VIRTUAL: int
 
     class Sigmasks(IntEnum):
         SIG_BLOCK: int
         SIG_UNBLOCK: int
         SIG_SETMASK: int
+
     SIG_BLOCK = Sigmasks.SIG_BLOCK
     SIG_UNBLOCK = Sigmasks.SIG_UNBLOCK
     SIG_SETMASK = Sigmasks.SIG_SETMASK
-    def alarm(__seconds: int) -> int: ...
-    def getitimer(__which: int) -> tuple[float, float]: ...
+    def alarm(seconds: int, /) -> int: ...
+    def getitimer(which: int, /) -> tuple[float, float]: ...
     def pause() -> None: ...
-    def pthread_kill(__thread_id: int, __signalnum: int) -> None: ...
+    def pthread_kill(thread_id: int, signalnum: int, /) -> None: ...
     if sys.version_info >= (3, 10):  # arguments changed in 3.10.2
         def pthread_sigmask(how: int, mask: Iterable[int]) -> set[_SIGNUM]: ...
     else:
-        def pthread_sigmask(__how: int, __mask: Iterable[int]) -> set[_SIGNUM]: ...
+        def pthread_sigmask(how: int, mask: Iterable[int], /) -> set[_SIGNUM]: ...
 
-    def setitimer(__which: int, __seconds: float, __interval: float = 0.0) -> tuple[float, float]: ...
-    def siginterrupt(__signalnum: int, __flag: bool) -> None: ...
+    def setitimer(which: int, seconds: float, interval: float = 0.0, /) -> tuple[float, float]: ...
+    def siginterrupt(signalnum: int, flag: bool, /) -> None: ...
     def sigpending() -> Any: ...
     if sys.version_info >= (3, 10):  # argument changed in 3.10.2
         def sigwait(sigset: Iterable[int]) -> _SIGNUM: ...
     else:
-        def sigwait(__sigset: Iterable[int]) -> _SIGNUM: ...
+        def sigwait(sigset: Iterable[int], /) -> _SIGNUM: ...
     if sys.platform != "darwin":
         SIGCLD: Signals
         SIGPOLL: Signals
         SIGPWR: Signals
         SIGRTMAX: Signals
         SIGRTMIN: Signals
         if sys.version_info >= (3, 11):
             SIGSTKFLT: Signals
+
         @final
         class struct_siginfo(structseq[int], tuple[int, int, int, int, int, int, int]):
             if sys.version_info >= (3, 10):
                 __match_args__: Final = ("si_signo", "si_code", "si_errno", "si_pid", "si_uid", "si_status", "si_band")
+
             @property
             def si_signo(self) -> int: ...
             @property
             def si_code(self) -> int: ...
             @property
             def si_errno(self) -> int: ...
             @property
@@ -168,22 +171,18 @@
             @property
             def si_uid(self) -> int: ...
             @property
             def si_status(self) -> int: ...
             @property
             def si_band(self) -> int: ...
 
-        if sys.version_info >= (3, 10):
-            def sigtimedwait(__sigset: Iterable[int], __timeout: float) -> struct_siginfo | None: ...
-            def sigwaitinfo(__sigset: Iterable[int]) -> struct_siginfo: ...
-        else:
-            def sigtimedwait(sigset: Iterable[int], timeout: float) -> struct_siginfo | None: ...
-            def sigwaitinfo(sigset: Iterable[int]) -> struct_siginfo: ...
+        def sigtimedwait(sigset: Iterable[int], timeout: float, /) -> struct_siginfo | None: ...
+        def sigwaitinfo(sigset: Iterable[int], /) -> struct_siginfo: ...
 
-def strsignal(__signalnum: _SIGNUM) -> str | None: ...
+def strsignal(signalnum: _SIGNUM, /) -> str | None: ...
 def valid_signals() -> set[Signals]: ...
-def raise_signal(__signalnum: _SIGNUM) -> None: ...
+def raise_signal(signalnum: _SIGNUM, /) -> None: ...
 def set_wakeup_fd(fd: int, *, warn_on_full_buffer: bool = ...) -> int: ...
 
 if sys.version_info >= (3, 9):
     if sys.platform == "linux":
-        def pidfd_send_signal(__pidfd: int, __sig: int, __siginfo: None = None, __flags: int = ...) -> None: ...
+        def pidfd_send_signal(pidfd: int, sig: int, siginfo: None = None, flags: int = ..., /) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/smtplib.pyi

```diff
@@ -64,17 +64,17 @@
 class SMTPAuthenticationError(SMTPResponseException): ...
 
 def quoteaddr(addrstring: str) -> str: ...
 def quotedata(data: str) -> str: ...
 
 class _AuthObject(Protocol):
     @overload
-    def __call__(self, __challenge: None = None) -> str | None: ...
+    def __call__(self, challenge: None = None, /) -> str | None: ...
     @overload
-    def __call__(self, __challenge: bytes) -> str: ...
+    def __call__(self, challenge: bytes, /) -> str: ...
 
 class SMTP:
     debuglevel: int
     sock: socket | None
     # Type of file should match what socket.makefile() returns
     file: Any | None
     helo_resp: bytes | None
```

## puya/_vendor/mypy/typeshed/stdlib/socket.pyi

```diff
@@ -678,16 +678,16 @@
     AI_MASK = AddressInfo.AI_MASK
     AI_V4MAPPED_CFG = AddressInfo.AI_V4MAPPED_CFG
 
 if sys.platform == "win32":
     errorTab: dict[int, str]  # undocumented
 
 class _SendableFile(Protocol):
-    def read(self, __size: int) -> bytes: ...
-    def seek(self, __offset: int) -> object: ...
+    def read(self, size: int, /) -> bytes: ...
+    def seek(self, offset: int, /) -> object: ...
 
     # optional fields:
     #
     # @property
     # def mode(self) -> str: ...
     # def fileno(self) -> int: ...
 
@@ -799,23 +799,23 @@
     def mode(self) -> Literal["rb", "wb", "rwb"]: ...
 
 def getfqdn(name: str = "") -> str: ...
 
 if sys.version_info >= (3, 11):
     def create_connection(
         address: tuple[str | None, int],
-        timeout: float | None = ...,  # noqa: F811
+        timeout: float | None = ...,
         source_address: _Address | None = None,
         *,
         all_errors: bool = False,
     ) -> socket: ...
 
 else:
     def create_connection(
-        address: tuple[str | None, int], timeout: float | None = ..., source_address: _Address | None = None  # noqa: F811
+        address: tuple[str | None, int], timeout: float | None = ..., source_address: _Address | None = None
     ) -> socket: ...
 
 def has_dualstack_ipv6() -> bool: ...
 def create_server(
     address: _Address, *, family: int = ..., backlog: int | None = None, reuse_port: bool = False, dualstack_ipv6: bool = False
 ) -> socket: ...
```

## puya/_vendor/mypy/typeshed/stdlib/spwd.pyi

```diff
@@ -13,14 +13,15 @@
                 "sp_min",
                 "sp_max",
                 "sp_warn",
                 "sp_inact",
                 "sp_expire",
                 "sp_flag",
             )
+
         @property
         def sp_namp(self) -> str: ...
         @property
         def sp_pwdp(self) -> str: ...
         @property
         def sp_lstchg(self) -> int: ...
         @property
@@ -33,8 +34,8 @@
         def sp_inact(self) -> int: ...
         @property
         def sp_expire(self) -> int: ...
         @property
         def sp_flag(self) -> int: ...
 
     def getspall() -> list[struct_spwd]: ...
-    def getspnam(__arg: str) -> struct_spwd: ...
+    def getspnam(arg: str, /) -> struct_spwd: ...
```

## puya/_vendor/mypy/typeshed/stdlib/sqlite3/dbapi2.pyi

```diff
@@ -4,14 +4,15 @@
 from collections.abc import Callable, Generator, Iterable, Iterator, Mapping
 from datetime import date, datetime, time
 from types import TracebackType
 from typing import Any, Literal, Protocol, SupportsIndex, TypeVar, final, overload
 from typing_extensions import Self, TypeAlias
 
 _T = TypeVar("_T")
+_ConnectionT = TypeVar("_ConnectionT", bound=Connection)
 _CursorT = TypeVar("_CursorT", bound=Cursor)
 _SqliteData: TypeAlias = str | ReadableBuffer | int | float | None
 # Data that is passed through adapters can be of any type accepted by an adapter.
 _AdaptedInputData: TypeAlias = _SqliteData | Any
 # The Mapping must really be a dict, but making it invariant is too annoying.
 _Parameters: TypeAlias = SupportsLenAndGetItem[_AdaptedInputData] | Mapping[str, _AdaptedInputData]
 _Adapter: TypeAlias = Callable[[_T], _SqliteData]
@@ -213,49 +214,115 @@
     SQLITE_DBCONFIG_RESET_DATABASE: int
     SQLITE_DBCONFIG_TRIGGER_EQP: int
     SQLITE_DBCONFIG_TRUSTED_SCHEMA: int
     SQLITE_DBCONFIG_WRITABLE_SCHEMA: int
 
 # Can take or return anything depending on what's in the registry.
 @overload
-def adapt(__obj: Any, __proto: Any) -> Any: ...
+def adapt(obj: Any, proto: Any, /) -> Any: ...
 @overload
-def adapt(__obj: Any, __proto: Any, __alt: _T) -> Any | _T: ...
+def adapt(obj: Any, proto: Any, alt: _T, /) -> Any | _T: ...
 def complete_statement(statement: str) -> bool: ...
-def connect(
-    database: StrOrBytesPath,
-    timeout: float = ...,
-    detect_types: int = ...,
-    isolation_level: str | None = ...,
-    check_same_thread: bool = ...,
-    factory: type[Connection] | None = ...,
-    cached_statements: int = ...,
-    uri: bool = ...,
-) -> Connection: ...
-def enable_callback_tracebacks(__enable: bool) -> None: ...
+
+if sys.version_info >= (3, 12):
+    @overload
+    def connect(
+        database: StrOrBytesPath,
+        timeout: float = 5.0,
+        detect_types: int = 0,
+        isolation_level: Literal["DEFERRED", "EXCLUSIVE", "IMMEDIATE"] | None = "DEFERRED",
+        check_same_thread: bool = True,
+        cached_statements: int = 128,
+        uri: bool = False,
+        *,
+        autocommit: bool = ...,
+    ) -> Connection: ...
+    @overload
+    def connect(
+        database: StrOrBytesPath,
+        timeout: float,
+        detect_types: int,
+        isolation_level: Literal["DEFERRED", "EXCLUSIVE", "IMMEDIATE"] | None,
+        check_same_thread: bool,
+        factory: type[_ConnectionT],
+        cached_statements: int = 128,
+        uri: bool = False,
+        *,
+        autocommit: bool = ...,
+    ) -> _ConnectionT: ...
+    @overload
+    def connect(
+        database: StrOrBytesPath,
+        timeout: float = 5.0,
+        detect_types: int = 0,
+        isolation_level: Literal["DEFERRED", "EXCLUSIVE", "IMMEDIATE"] | None = "DEFERRED",
+        check_same_thread: bool = True,
+        *,
+        factory: type[_ConnectionT],
+        cached_statements: int = 128,
+        uri: bool = False,
+        autocommit: bool = ...,
+    ) -> _ConnectionT: ...
+
+else:
+    @overload
+    def connect(
+        database: StrOrBytesPath,
+        timeout: float = 5.0,
+        detect_types: int = 0,
+        isolation_level: Literal["DEFERRED", "EXCLUSIVE", "IMMEDIATE"] | None = "DEFERRED",
+        check_same_thread: bool = True,
+        cached_statements: int = 128,
+        uri: bool = False,
+    ) -> Connection: ...
+    @overload
+    def connect(
+        database: StrOrBytesPath,
+        timeout: float,
+        detect_types: int,
+        isolation_level: Literal["DEFERRED", "EXCLUSIVE", "IMMEDIATE"] | None,
+        check_same_thread: bool,
+        factory: type[_ConnectionT],
+        cached_statements: int = 128,
+        uri: bool = False,
+    ) -> _ConnectionT: ...
+    @overload
+    def connect(
+        database: StrOrBytesPath,
+        timeout: float = 5.0,
+        detect_types: int = 0,
+        isolation_level: Literal["DEFERRED", "EXCLUSIVE", "IMMEDIATE"] | None = "DEFERRED",
+        check_same_thread: bool = True,
+        *,
+        factory: type[_ConnectionT],
+        cached_statements: int = 128,
+        uri: bool = False,
+    ) -> _ConnectionT: ...
+
+def enable_callback_tracebacks(enable: bool, /) -> None: ...
 
 if sys.version_info < (3, 12):
     # takes a pos-or-keyword argument because there is a C wrapper
     def enable_shared_cache(enable: int) -> None: ...
 
 if sys.version_info >= (3, 10):
-    def register_adapter(__type: type[_T], __adapter: _Adapter[_T]) -> None: ...
-    def register_converter(__typename: str, __converter: _Converter) -> None: ...
+    def register_adapter(type: type[_T], adapter: _Adapter[_T], /) -> None: ...
+    def register_converter(typename: str, converter: _Converter, /) -> None: ...
 
 else:
-    def register_adapter(__type: type[_T], __caster: _Adapter[_T]) -> None: ...
-    def register_converter(__name: str, __converter: _Converter) -> None: ...
+    def register_adapter(type: type[_T], caster: _Adapter[_T], /) -> None: ...
+    def register_converter(name: str, converter: _Converter, /) -> None: ...
 
 class _AggregateProtocol(Protocol):
-    def step(self, __value: int) -> object: ...
+    def step(self, value: int, /) -> object: ...
     def finalize(self) -> int: ...
 
 class _SingleParamWindowAggregateClass(Protocol):
-    def step(self, __param: Any) -> object: ...
-    def inverse(self, __param: Any) -> object: ...
+    def step(self, param: Any, /) -> object: ...
+    def inverse(self, param: Any, /) -> object: ...
     def value(self) -> _SqliteData: ...
     def finalize(self) -> _SqliteData: ...
 
 class _AnyParamWindowAggregateClass(Protocol):
     def step(self, *args: Any) -> object: ...
     def inverse(self, *args: Any) -> object: ...
     def value(self) -> _SqliteData: ...
@@ -296,119 +363,134 @@
     if sys.version_info >= (3, 12):
         @property
         def autocommit(self) -> int: ...
         @autocommit.setter
         def autocommit(self, val: int) -> None: ...
     row_factory: Any
     text_factory: Any
-    def __init__(
-        self,
-        database: StrOrBytesPath,
-        timeout: float = ...,
-        detect_types: int = ...,
-        isolation_level: str | None = ...,
-        check_same_thread: bool = ...,
-        factory: type[Connection] | None = ...,
-        cached_statements: int = ...,
-        uri: bool = ...,
-    ) -> None: ...
+    if sys.version_info >= (3, 12):
+        def __init__(
+            self,
+            database: StrOrBytesPath,
+            timeout: float = ...,
+            detect_types: int = ...,
+            isolation_level: str | None = ...,
+            check_same_thread: bool = ...,
+            factory: type[Connection] | None = ...,
+            cached_statements: int = ...,
+            uri: bool = ...,
+            autocommit: bool = ...,
+        ) -> None: ...
+    else:
+        def __init__(
+            self,
+            database: StrOrBytesPath,
+            timeout: float = ...,
+            detect_types: int = ...,
+            isolation_level: str | None = ...,
+            check_same_thread: bool = ...,
+            factory: type[Connection] | None = ...,
+            cached_statements: int = ...,
+            uri: bool = ...,
+        ) -> None: ...
+
     def close(self) -> None: ...
     if sys.version_info >= (3, 11):
-        def blobopen(self, __table: str, __column: str, __row: int, *, readonly: bool = False, name: str = "main") -> Blob: ...
+        def blobopen(self, table: str, column: str, row: int, /, *, readonly: bool = False, name: str = "main") -> Blob: ...
 
     def commit(self) -> None: ...
     def create_aggregate(self, name: str, n_arg: int, aggregate_class: Callable[[], _AggregateProtocol]) -> None: ...
     if sys.version_info >= (3, 11):
         # num_params determines how many params will be passed to the aggregate class. We provide an overload
         # for the case where num_params = 1, which is expected to be the common case.
         @overload
         def create_window_function(
-            self, __name: str, __num_params: Literal[1], __aggregate_class: Callable[[], _SingleParamWindowAggregateClass] | None
+            self, name: str, num_params: Literal[1], aggregate_class: Callable[[], _SingleParamWindowAggregateClass] | None, /
         ) -> None: ...
         # And for num_params = -1, which means the aggregate must accept any number of parameters.
         @overload
         def create_window_function(
-            self, __name: str, __num_params: Literal[-1], __aggregate_class: Callable[[], _AnyParamWindowAggregateClass] | None
+            self, name: str, num_params: Literal[-1], aggregate_class: Callable[[], _AnyParamWindowAggregateClass] | None, /
         ) -> None: ...
         @overload
         def create_window_function(
-            self, __name: str, __num_params: int, __aggregate_class: Callable[[], _WindowAggregateClass] | None
+            self, name: str, num_params: int, aggregate_class: Callable[[], _WindowAggregateClass] | None, /
         ) -> None: ...
 
-    def create_collation(self, __name: str, __callback: Callable[[str, str], int | SupportsIndex] | None) -> None: ...
+    def create_collation(self, name: str, callback: Callable[[str, str], int | SupportsIndex] | None, /) -> None: ...
     def create_function(
         self, name: str, narg: int, func: Callable[..., _SqliteData] | None, *, deterministic: bool = False
     ) -> None: ...
     @overload
     def cursor(self, factory: None = None) -> Cursor: ...
     @overload
     def cursor(self, factory: Callable[[Connection], _CursorT]) -> _CursorT: ...
-    def execute(self, __sql: str, __parameters: _Parameters = ...) -> Cursor: ...
-    def executemany(self, __sql: str, __parameters: Iterable[_Parameters]) -> Cursor: ...
-    def executescript(self, __sql_script: str) -> Cursor: ...
+    def execute(self, sql: str, parameters: _Parameters = ..., /) -> Cursor: ...
+    def executemany(self, sql: str, parameters: Iterable[_Parameters], /) -> Cursor: ...
+    def executescript(self, sql_script: str, /) -> Cursor: ...
     def interrupt(self) -> None: ...
     def iterdump(self) -> Generator[str, None, None]: ...
     def rollback(self) -> None: ...
     def set_authorizer(
         self, authorizer_callback: Callable[[int, str | None, str | None, str | None, str | None], int] | None
     ) -> None: ...
     def set_progress_handler(self, progress_handler: Callable[[], int | None] | None, n: int) -> None: ...
     def set_trace_callback(self, trace_callback: Callable[[str], object] | None) -> None: ...
     # enable_load_extension and load_extension is not available on python distributions compiled
     # without sqlite3 loadable extension support. see footnotes https://docs.python.org/3/library/sqlite3.html#f1
-    def enable_load_extension(self, __enable: bool) -> None: ...
-    def load_extension(self, __name: str) -> None: ...
+    def enable_load_extension(self, enable: bool, /) -> None: ...
+    def load_extension(self, name: str, /) -> None: ...
     def backup(
         self,
         target: Connection,
         *,
         pages: int = -1,
         progress: Callable[[int, int, int], object] | None = None,
         name: str = "main",
         sleep: float = 0.25,
     ) -> None: ...
     if sys.version_info >= (3, 11):
-        def setlimit(self, __category: int, __limit: int) -> int: ...
-        def getlimit(self, __category: int) -> int: ...
+        def setlimit(self, category: int, limit: int, /) -> int: ...
+        def getlimit(self, category: int, /) -> int: ...
         def serialize(self, *, name: str = "main") -> bytes: ...
-        def deserialize(self, __data: ReadableBuffer, *, name: str = "main") -> None: ...
+        def deserialize(self, data: ReadableBuffer, /, *, name: str = "main") -> None: ...
     if sys.version_info >= (3, 12):
-        def getconfig(self, __op: int) -> bool: ...
-        def setconfig(self, __op: int, __enable: bool = True) -> bool: ...
+        def getconfig(self, op: int, /) -> bool: ...
+        def setconfig(self, op: int, enable: bool = True, /) -> bool: ...
 
-    def __call__(self, __sql: str) -> _Statement: ...
+    def __call__(self, sql: str, /) -> _Statement: ...
     def __enter__(self) -> Self: ...
     def __exit__(
-        self, __type: type[BaseException] | None, __value: BaseException | None, __traceback: TracebackType | None
+        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None, /
     ) -> Literal[False]: ...
 
 class Cursor(Iterator[Any]):
     arraysize: int
     @property
     def connection(self) -> Connection: ...
     # May be None, but using | Any instead to avoid slightly annoying false positives.
     @property
     def description(self) -> tuple[tuple[str, None, None, None, None, None, None], ...] | Any: ...
     @property
     def lastrowid(self) -> int | None: ...
     row_factory: Callable[[Cursor, Row], object] | None
     @property
     def rowcount(self) -> int: ...
-    def __init__(self, __cursor: Connection) -> None: ...
+    def __init__(self, cursor: Connection, /) -> None: ...
     def close(self) -> None: ...
-    def execute(self, __sql: str, __parameters: _Parameters = ()) -> Self: ...
-    def executemany(self, __sql: str, __seq_of_parameters: Iterable[_Parameters]) -> Self: ...
-    def executescript(self, __sql_script: str) -> Cursor: ...
+    def execute(self, sql: str, parameters: _Parameters = (), /) -> Self: ...
+    def executemany(self, sql: str, seq_of_parameters: Iterable[_Parameters], /) -> Self: ...
+    def executescript(self, sql_script: str, /) -> Cursor: ...
     def fetchall(self) -> list[Any]: ...
     def fetchmany(self, size: int | None = 1) -> list[Any]: ...
     # Returns either a row (as created by the row_factory) or None, but
     # putting None in the return annotation causes annoying false positives.
     def fetchone(self) -> Any: ...
-    def setinputsizes(self, __sizes: Unused) -> None: ...  # does nothing
-    def setoutputsize(self, __size: Unused, __column: Unused = None) -> None: ...  # does nothing
+    def setinputsizes(self, sizes: Unused, /) -> None: ...  # does nothing
+    def setoutputsize(self, size: Unused, column: Unused = None, /) -> None: ...  # does nothing
     def __iter__(self) -> Self: ...
     def __next__(self) -> Any: ...
 
 class Error(Exception):
     if sys.version_info >= (3, 11):
         sqlite_errorcode: int
         sqlite_errorname: str
@@ -427,43 +509,43 @@
 @final
 class PrepareProtocol:
     def __init__(self, *args: object, **kwargs: object) -> None: ...
 
 class ProgrammingError(DatabaseError): ...
 
 class Row:
-    def __init__(self, __cursor: Cursor, __data: tuple[Any, ...]) -> None: ...
+    def __init__(self, cursor: Cursor, data: tuple[Any, ...], /) -> None: ...
     def keys(self) -> list[str]: ...
     @overload
-    def __getitem__(self, __key: int | str) -> Any: ...
+    def __getitem__(self, key: int | str, /) -> Any: ...
     @overload
-    def __getitem__(self, __key: slice) -> tuple[Any, ...]: ...
+    def __getitem__(self, key: slice, /) -> tuple[Any, ...]: ...
     def __hash__(self) -> int: ...
     def __iter__(self) -> Iterator[Any]: ...
     def __len__(self) -> int: ...
     # These return NotImplemented for anything that is not a Row.
-    def __eq__(self, __value: object) -> bool: ...
-    def __ge__(self, __value: object) -> bool: ...
-    def __gt__(self, __value: object) -> bool: ...
-    def __le__(self, __value: object) -> bool: ...
-    def __lt__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ge__(self, value: object, /) -> bool: ...
+    def __gt__(self, value: object, /) -> bool: ...
+    def __le__(self, value: object, /) -> bool: ...
+    def __lt__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
 
 @final
 class _Statement: ...
 
 class Warning(Exception): ...
 
 if sys.version_info >= (3, 11):
     @final
     class Blob:
         def close(self) -> None: ...
-        def read(self, __length: int = -1) -> bytes: ...
-        def write(self, __data: ReadableBuffer) -> None: ...
+        def read(self, length: int = -1, /) -> bytes: ...
+        def write(self, data: ReadableBuffer, /) -> None: ...
         def tell(self) -> int: ...
         # whence must be one of os.SEEK_SET, os.SEEK_CUR, os.SEEK_END
-        def seek(self, __offset: int, __origin: int = 0) -> None: ...
+        def seek(self, offset: int, origin: int = 0, /) -> None: ...
         def __len__(self) -> int: ...
         def __enter__(self) -> Self: ...
-        def __exit__(self, __type: object, __val: object, __tb: object) -> Literal[False]: ...
-        def __getitem__(self, __key: SupportsIndex | slice) -> int: ...
-        def __setitem__(self, __key: SupportsIndex | slice, __value: int) -> None: ...
+        def __exit__(self, type: object, val: object, tb: object, /) -> Literal[False]: ...
+        def __getitem__(self, key: SupportsIndex | slice, /) -> int: ...
+        def __setitem__(self, key: SupportsIndex | slice, value: int, /) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/ssl.pyi

```diff
@@ -11,14 +11,16 @@
 _PeerCertRetDictType: TypeAlias = dict[str, str | _PCTRTTT | _PCTRTT]
 _PeerCertRetType: TypeAlias = _PeerCertRetDictType | bytes | None
 _EnumRetType: TypeAlias = list[tuple[bytes, str, set[str] | bool]]
 _PasswordType: TypeAlias = Callable[[], str | bytes | bytearray] | str | bytes | bytearray
 
 _SrvnmeCbType: TypeAlias = Callable[[SSLSocket | SSLObject, str | None, SSLSocket], int | None]
 
+socket_error = OSError
+
 class _Cipher(TypedDict):
     aead: bool
     alg_bits: int
     auth: str
     description: str
     digest: str | None
     id: int
@@ -92,22 +94,22 @@
         cafile: StrOrBytesPath | None = None,
         capath: StrOrBytesPath | None = None,
         cadata: str | ReadableBuffer | None = None,
     ) -> SSLContext: ...
 
 _create_default_https_context: Callable[..., SSLContext]
 
-def RAND_bytes(__n: int) -> bytes: ...
+def RAND_bytes(n: int, /) -> bytes: ...
 
 if sys.version_info < (3, 12):
-    def RAND_pseudo_bytes(__n: int) -> tuple[bytes, bool]: ...
+    def RAND_pseudo_bytes(n: int, /) -> tuple[bytes, bool]: ...
 
 def RAND_status() -> bool: ...
 def RAND_egd(path: str) -> None: ...
-def RAND_add(__string: str | ReadableBuffer, __entropy: float) -> None: ...
+def RAND_add(string: str | ReadableBuffer, entropy: float, /) -> None: ...
 
 if sys.version_info < (3, 12):
     def match_hostname(cert: _PeerCertRetDictType, hostname: str) -> None: ...
 
 def cert_time_to_seconds(cert_time: str) -> int: ...
 
 if sys.version_info >= (3, 10):
@@ -360,14 +362,17 @@
     def version(self) -> str | None: ...
     def pending(self) -> int: ...
     def verify_client_post_handshake(self) -> None: ...
     # These methods always raise `NotImplementedError`:
     def recvmsg(self, *args: Never, **kwargs: Never) -> Never: ...  # type: ignore[override]
     def recvmsg_into(self, *args: Never, **kwargs: Never) -> Never: ...  # type: ignore[override]
     def sendmsg(self, *args: Never, **kwargs: Never) -> Never: ...  # type: ignore[override]
+    if sys.version_info >= (3, 13):
+        def get_verified_chain(self) -> list[bytes]: ...
+        def get_unverified_chain(self) -> list[bytes]: ...
 
 class TLSVersion(enum.IntEnum):
     MINIMUM_SUPPORTED: int
     MAXIMUM_SUPPORTED: int
     SSLv3: int
     TLSv1: int
     TLSv1_1: int
@@ -416,20 +421,20 @@
     def get_ca_certs(self, binary_form: Literal[False] = False) -> list[_PeerCertRetDictType]: ...
     @overload
     def get_ca_certs(self, binary_form: Literal[True]) -> list[bytes]: ...
     @overload
     def get_ca_certs(self, binary_form: bool = False) -> Any: ...
     def get_ciphers(self) -> list[_Cipher]: ...
     def set_default_verify_paths(self) -> None: ...
-    def set_ciphers(self, __cipherlist: str) -> None: ...
+    def set_ciphers(self, cipherlist: str, /) -> None: ...
     def set_alpn_protocols(self, alpn_protocols: Iterable[str]) -> None: ...
     def set_npn_protocols(self, npn_protocols: Iterable[str]) -> None: ...
     def set_servername_callback(self, server_name_callback: _SrvnmeCbType | None) -> None: ...
-    def load_dh_params(self, __path: str) -> None: ...
-    def set_ecdh_curve(self, __name: str) -> None: ...
+    def load_dh_params(self, path: str, /) -> None: ...
+    def set_ecdh_curve(self, name: str, /) -> None: ...
     def wrap_socket(
         self,
         sock: socket.socket,
         server_side: bool = False,
         do_handshake_on_connect: bool = True,
         suppress_ragged_eofs: bool = True,
         server_hostname: str | bytes | None = None,
@@ -470,36 +475,39 @@
     def compression(self) -> str | None: ...
     def pending(self) -> int: ...
     def do_handshake(self) -> None: ...
     def unwrap(self) -> None: ...
     def version(self) -> str | None: ...
     def get_channel_binding(self, cb_type: str = "tls-unique") -> bytes | None: ...
     def verify_client_post_handshake(self) -> None: ...
+    if sys.version_info >= (3, 13):
+        def get_verified_chain(self) -> list[bytes]: ...
+        def get_unverified_chain(self) -> list[bytes]: ...
 
 @final
 class MemoryBIO:
     pending: int
     eof: bool
-    def read(self, __size: int = -1) -> bytes: ...
-    def write(self, __b: ReadableBuffer) -> int: ...
+    def read(self, size: int = -1, /) -> bytes: ...
+    def write(self, b: ReadableBuffer, /) -> int: ...
     def write_eof(self) -> None: ...
 
 @final
 class SSLSession:
     @property
     def has_ticket(self) -> bool: ...
     @property
     def id(self) -> bytes: ...
     @property
     def ticket_lifetime_hint(self) -> int: ...
     @property
     def time(self) -> int: ...
     @property
     def timeout(self) -> int: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
 
 class SSLErrorNumber(enum.IntEnum):
     SSL_ERROR_EOF: int
     SSL_ERROR_INVALID_ERROR_CODE: int
     SSL_ERROR_SSL: int
     SSL_ERROR_SYSCALL: int
     SSL_ERROR_WANT_CONNECT: int
```

## puya/_vendor/mypy/typeshed/stdlib/statistics.pyi

```diff
@@ -106,27 +106,27 @@
     __radd__ = __add__
     def __rsub__(self, x2: float | NormalDist) -> NormalDist: ...
     __rmul__ = __mul__
     def __hash__(self) -> int: ...
 
 if sys.version_info >= (3, 12):
     def correlation(
-        __x: Sequence[_Number], __y: Sequence[_Number], *, method: Literal["linear", "ranked"] = "linear"
+        x: Sequence[_Number], y: Sequence[_Number], /, *, method: Literal["linear", "ranked"] = "linear"
     ) -> float: ...
 
 elif sys.version_info >= (3, 10):
-    def correlation(__x: Sequence[_Number], __y: Sequence[_Number]) -> float: ...
+    def correlation(x: Sequence[_Number], y: Sequence[_Number], /) -> float: ...
 
 if sys.version_info >= (3, 10):
-    def covariance(__x: Sequence[_Number], __y: Sequence[_Number]) -> float: ...
+    def covariance(x: Sequence[_Number], y: Sequence[_Number], /) -> float: ...
 
     class LinearRegression(NamedTuple):
         slope: float
         intercept: float
 
 if sys.version_info >= (3, 11):
     def linear_regression(
-        __regressor: Sequence[_Number], __dependent_variable: Sequence[_Number], *, proportional: bool = False
+        regressor: Sequence[_Number], dependent_variable: Sequence[_Number], /, *, proportional: bool = False
     ) -> LinearRegression: ...
 
 elif sys.version_info >= (3, 10):
-    def linear_regression(__regressor: Sequence[_Number], __dependent_variable: Sequence[_Number]) -> LinearRegression: ...
+    def linear_regression(regressor: Sequence[_Number], dependent_variable: Sequence[_Number], /) -> LinearRegression: ...
```

## puya/_vendor/mypy/typeshed/stdlib/string.pyi

```diff
@@ -43,25 +43,25 @@
     template: str
     delimiter: ClassVar[str]
     idpattern: ClassVar[str]
     braceidpattern: ClassVar[str | None]
     flags: ClassVar[RegexFlag]
     pattern: ClassVar[Pattern[str]]
     def __init__(self, template: str) -> None: ...
-    def substitute(self, __mapping: Mapping[str, object] = {}, **kwds: object) -> str: ...
-    def safe_substitute(self, __mapping: Mapping[str, object] = {}, **kwds: object) -> str: ...
+    def substitute(self, mapping: Mapping[str, object] = {}, /, **kwds: object) -> str: ...
+    def safe_substitute(self, mapping: Mapping[str, object] = {}, /, **kwds: object) -> str: ...
     if sys.version_info >= (3, 11):
         def get_identifiers(self) -> list[str]: ...
         def is_valid(self) -> bool: ...
 
 class Formatter:
     @overload
-    def format(self, __format_string: LiteralString, *args: LiteralString, **kwargs: LiteralString) -> LiteralString: ...
+    def format(self, format_string: LiteralString, /, *args: LiteralString, **kwargs: LiteralString) -> LiteralString: ...
     @overload
-    def format(self, __format_string: str, *args: Any, **kwargs: Any) -> str: ...
+    def format(self, format_string: str, /, *args: Any, **kwargs: Any) -> str: ...
     @overload
     def vformat(
         self, format_string: LiteralString, args: Sequence[LiteralString], kwargs: Mapping[LiteralString, LiteralString]
     ) -> LiteralString: ...
     @overload
     def vformat(self, format_string: str, args: Sequence[Any], kwargs: Mapping[str, Any]) -> str: ...
     def _vformat(  # undocumented
@@ -76,8 +76,8 @@
     def parse(
         self, format_string: StrOrLiteralStr
     ) -> Iterable[tuple[StrOrLiteralStr, StrOrLiteralStr | None, StrOrLiteralStr | None, StrOrLiteralStr | None]]: ...
     def get_field(self, field_name: str, args: Sequence[Any], kwargs: Mapping[str, Any]) -> Any: ...
     def get_value(self, key: int | str, args: Sequence[Any], kwargs: Mapping[str, Any]) -> Any: ...
     def check_unused_args(self, used_args: set[int | str], args: Sequence[Any], kwargs: Mapping[str, Any]) -> None: ...
     def format_field(self, value: Any, format_spec: str) -> Any: ...
-    def convert_field(self, value: Any, conversion: str) -> Any: ...
+    def convert_field(self, value: Any, conversion: str | None) -> Any: ...
```

## puya/_vendor/mypy/typeshed/stdlib/struct.pyi

```diff
@@ -2,25 +2,25 @@
 from collections.abc import Iterator
 from typing import Any
 
 __all__ = ["calcsize", "pack", "pack_into", "unpack", "unpack_from", "iter_unpack", "Struct", "error"]
 
 class error(Exception): ...
 
-def pack(__fmt: str | bytes, *v: Any) -> bytes: ...
-def pack_into(__fmt: str | bytes, __buffer: WriteableBuffer, __offset: int, *v: Any) -> None: ...
-def unpack(__format: str | bytes, __buffer: ReadableBuffer) -> tuple[Any, ...]: ...
-def unpack_from(__format: str | bytes, buffer: ReadableBuffer, offset: int = 0) -> tuple[Any, ...]: ...
-def iter_unpack(__format: str | bytes, __buffer: ReadableBuffer) -> Iterator[tuple[Any, ...]]: ...
-def calcsize(__format: str | bytes) -> int: ...
+def pack(fmt: str | bytes, /, *v: Any) -> bytes: ...
+def pack_into(fmt: str | bytes, buffer: WriteableBuffer, offset: int, /, *v: Any) -> None: ...
+def unpack(format: str | bytes, buffer: ReadableBuffer, /) -> tuple[Any, ...]: ...
+def unpack_from(format: str | bytes, /, buffer: ReadableBuffer, offset: int = 0) -> tuple[Any, ...]: ...
+def iter_unpack(format: str | bytes, buffer: ReadableBuffer, /) -> Iterator[tuple[Any, ...]]: ...
+def calcsize(format: str | bytes, /) -> int: ...
 
 class Struct:
     @property
     def format(self) -> str: ...
     @property
     def size(self) -> int: ...
     def __init__(self, format: str | bytes) -> None: ...
     def pack(self, *v: Any) -> bytes: ...
     def pack_into(self, buffer: WriteableBuffer, offset: int, *v: Any) -> None: ...
-    def unpack(self, __buffer: ReadableBuffer) -> tuple[Any, ...]: ...
+    def unpack(self, buffer: ReadableBuffer, /) -> tuple[Any, ...]: ...
     def unpack_from(self, buffer: ReadableBuffer, offset: int = 0) -> tuple[Any, ...]: ...
-    def iter_unpack(self, __buffer: ReadableBuffer) -> Iterator[tuple[Any, ...]]: ...
+    def iter_unpack(self, buffer: ReadableBuffer, /) -> Iterator[tuple[Any, ...]]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/subprocess.pyi

```diff
@@ -2560,20 +2560,20 @@
     ) -> None: ...
     def __del__(self) -> None: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
 
 # The result really is always a str.
 if sys.version_info >= (3, 11):
-    def getstatusoutput(cmd: str | bytes, *, encoding: str | None = None, errors: str | None = None) -> tuple[int, str]: ...
-    def getoutput(cmd: str | bytes, *, encoding: str | None = None, errors: str | None = None) -> str: ...
+    def getstatusoutput(cmd: _CMD, *, encoding: str | None = None, errors: str | None = None) -> tuple[int, str]: ...
+    def getoutput(cmd: _CMD, *, encoding: str | None = None, errors: str | None = None) -> str: ...
 
 else:
-    def getstatusoutput(cmd: str | bytes) -> tuple[int, str]: ...
-    def getoutput(cmd: str | bytes) -> str: ...
+    def getstatusoutput(cmd: _CMD) -> tuple[int, str]: ...
+    def getoutput(cmd: _CMD) -> str: ...
 
 def list2cmdline(seq: Iterable[StrOrBytesPath]) -> str: ...  # undocumented
 
 if sys.platform == "win32":
     class STARTUPINFO:
         def __init__(
             self,
@@ -2588,14 +2588,15 @@
         dwFlags: int
         hStdInput: Any | None
         hStdOutput: Any | None
         hStdError: Any | None
         wShowWindow: int
         lpAttributeList: Mapping[str, Any]
         def copy(self) -> STARTUPINFO: ...
+
     from _winapi import (
         ABOVE_NORMAL_PRIORITY_CLASS as ABOVE_NORMAL_PRIORITY_CLASS,
         BELOW_NORMAL_PRIORITY_CLASS as BELOW_NORMAL_PRIORITY_CLASS,
         CREATE_BREAKAWAY_FROM_JOB as CREATE_BREAKAWAY_FROM_JOB,
         CREATE_DEFAULT_ERROR_MODE as CREATE_DEFAULT_ERROR_MODE,
         CREATE_NEW_CONSOLE as CREATE_NEW_CONSOLE,
         CREATE_NEW_PROCESS_GROUP as CREATE_NEW_PROCESS_GROUP,
```

## puya/_vendor/mypy/typeshed/stdlib/sys/__init__.pyi

```diff
@@ -13,17 +13,15 @@
 
 # see https://github.com/python/typeshed/issues/8513#issue-1333671093 for the rationale behind this alias
 _ExitCode: TypeAlias = str | int | None
 _OptExcInfo: TypeAlias = OptExcInfo  # noqa: Y047  # TODO: obsolete, remove fall 2022 or later
 
 # Intentionally omits one deprecated and one optional method of `importlib.abc.MetaPathFinder`
 class _MetaPathFinder(Protocol):
-    def find_spec(
-        self, __fullname: str, __path: Sequence[str] | None, __target: ModuleType | None = ...
-    ) -> ModuleSpec | None: ...
+    def find_spec(self, fullname: str, path: Sequence[str] | None, target: ModuleType | None = ..., /) -> ModuleSpec | None: ...
 
 # ----- sys variables -----
 if sys.platform != "win32":
     abiflags: str
 argv: list[str]
 base_exec_prefix: str
 base_prefix: str
@@ -38,14 +36,16 @@
 exec_prefix: str
 executable: str
 float_repr_style: Literal["short", "legacy"]
 hexversion: int
 last_type: type[BaseException] | None
 last_value: BaseException | None
 last_traceback: TracebackType | None
+if sys.version_info >= (3, 12):
+    last_exc: BaseException  # or undefined.
 maxsize: int
 maxunicode: int
 meta_path: list[_MetaPathFinder]
 modules: dict[str, ModuleType]
 if sys.version_info >= (3, 10):
     orig_argv: list[str]
 path: list[str]
@@ -239,36 +239,36 @@
     @property
     def releaselevel(self) -> _ReleaseLevel: ...
     @property
     def serial(self) -> int: ...
 
 version_info: _version_info
 
-def call_tracing(__func: Callable[..., _T], __args: Any) -> _T: ...
+def call_tracing(func: Callable[..., _T], args: Any, /) -> _T: ...
 def _clear_type_cache() -> None: ...
 def _current_frames() -> dict[int, FrameType]: ...
-def _getframe(__depth: int = 0) -> FrameType: ...
+def _getframe(depth: int = 0, /) -> FrameType: ...
 def _debugmallocstats() -> None: ...
-def __displayhook__(__object: object) -> None: ...
-def __excepthook__(__exctype: type[BaseException], __value: BaseException, __traceback: TracebackType | None) -> None: ...
+def __displayhook__(object: object, /) -> None: ...
+def __excepthook__(exctype: type[BaseException], value: BaseException, traceback: TracebackType | None, /) -> None: ...
 def exc_info() -> OptExcInfo: ...
 
 if sys.version_info >= (3, 11):
     def exception() -> BaseException | None: ...
 
-def exit(__status: _ExitCode = None) -> NoReturn: ...
+def exit(status: _ExitCode = None, /) -> NoReturn: ...
 def getallocatedblocks() -> int: ...
 def getdefaultencoding() -> str: ...
 
 if sys.platform != "win32":
     def getdlopenflags() -> int: ...
 
 def getfilesystemencoding() -> str: ...
 def getfilesystemencodeerrors() -> str: ...
-def getrefcount(__object: Any) -> int: ...
+def getrefcount(object: Any, /) -> int: ...
 def getrecursionlimit() -> int: ...
 def getsizeof(obj: object, default: int = ...) -> int: ...
 def getswitchinterval() -> float: ...
 def getprofile() -> ProfileFunction | None: ...
 def setprofile(profilefunc: ProfileFunction | None) -> None: ...
 def gettrace() -> TraceFunction | None: ...
 def settrace(tracefunc: TraceFunction | None) -> None: ...
@@ -296,30 +296,30 @@
         @property
         def product_type(self) -> int: ...
         @property
         def platform_version(self) -> tuple[int, int, int]: ...
 
     def getwindowsversion() -> _WinVersion: ...
 
-def intern(__string: str) -> str: ...
+def intern(string: str, /) -> str: ...
 def is_finalizing() -> bool: ...
 def breakpointhook(*args: Any, **kwargs: Any) -> Any: ...
 
 __breakpointhook__ = breakpointhook  # Contains the original value of breakpointhook
 
 if sys.platform != "win32":
-    def setdlopenflags(__flags: int) -> None: ...
+    def setdlopenflags(flags: int, /) -> None: ...
 
-def setrecursionlimit(__limit: int) -> None: ...
-def setswitchinterval(__interval: float) -> None: ...
+def setrecursionlimit(limit: int, /) -> None: ...
+def setswitchinterval(interval: float, /) -> None: ...
 def gettotalrefcount() -> int: ...  # Debug builds only
 
 if sys.version_info < (3, 9):
     def getcheckinterval() -> int: ...  # deprecated
-    def setcheckinterval(__n: int) -> None: ...  # deprecated
+    def setcheckinterval(n: int, /) -> None: ...  # deprecated
 
 if sys.version_info < (3, 9):
     # An 11-tuple or None
     def callstats() -> tuple[int, int, int, int, int, int, int, int, int, int, int] | None: ...
 
 # Doesn't exist at runtime, but exported in the stubs so pytest etc. can annotate their code more easily.
 class UnraisableHookArgs(Protocol):
@@ -327,17 +327,17 @@
     exc_value: BaseException | None
     exc_traceback: TracebackType | None
     err_msg: str | None
     object: _object
 
 unraisablehook: Callable[[UnraisableHookArgs], Any]
 
-def __unraisablehook__(__unraisable: UnraisableHookArgs) -> Any: ...
+def __unraisablehook__(unraisable: UnraisableHookArgs, /) -> Any: ...
 def addaudithook(hook: Callable[[str, tuple[Any, ...]], Any]) -> None: ...
-def audit(__event: str, *args: Any) -> None: ...
+def audit(event: str, /, *args: Any) -> None: ...
 
 _AsyncgenHook: TypeAlias = Callable[[AsyncGenerator[Any, Any]], None] | None
 
 @final
 class _asyncgen_hooks(structseq[_AsyncgenHook], tuple[_AsyncgenHook, _AsyncgenHook]):
     @property
     def firstiter(self) -> _AsyncgenHook: ...
@@ -360,14 +360,14 @@
 
 if sys.version_info >= (3, 12):
     def getunicodeinternedsize() -> int: ...
     def deactivate_stack_trampoline() -> None: ...
     def is_stack_trampoline_active() -> bool: ...
     # It always exists, but raises on non-linux platforms:
     if sys.platform == "linux":
-        def activate_stack_trampoline(__backend: str) -> None: ...
+        def activate_stack_trampoline(backend: str, /) -> None: ...
     else:
-        def activate_stack_trampoline(__backend: str) -> NoReturn: ...
+        def activate_stack_trampoline(backend: str, /) -> NoReturn: ...
 
     from . import _monitoring
 
     monitoring = _monitoring
```

## puya/_vendor/mypy/typeshed/stdlib/sys/_monitoring.pyi

```diff
@@ -10,17 +10,17 @@
 from typing import Any
 
 DEBUGGER_ID: int
 COVERAGE_ID: int
 PROFILER_ID: int
 OPTIMIZER_ID: int
 
-def use_tool_id(__tool_id: int, __name: str) -> None: ...
-def free_tool_id(__tool_id: int) -> None: ...
-def get_tool(__tool_id: int) -> str | None: ...
+def use_tool_id(tool_id: int, name: str, /) -> None: ...
+def free_tool_id(tool_id: int, /) -> None: ...
+def get_tool(tool_id: int, /) -> str | None: ...
 
 events: _events
 
 class _events:
     BRANCH: int
     CALL: int
     C_RAISE: int
@@ -36,17 +36,17 @@
     PY_THROW: int
     PY_UNWIND: int
     PY_YIELD: int
     RAISE: int
     RERAISE: int
     STOP_ITERATION: int
 
-def get_events(__tool_id: int) -> int: ...
-def set_events(__tool_id: int, __event_set: int) -> None: ...
-def get_local_events(__tool_id: int, __code: CodeType) -> int: ...
-def set_local_events(__tool_id: int, __code: CodeType, __event_set: int) -> int: ...
+def get_events(tool_id: int, /) -> int: ...
+def set_events(tool_id: int, event_set: int, /) -> None: ...
+def get_local_events(tool_id: int, code: CodeType, /) -> int: ...
+def set_local_events(tool_id: int, code: CodeType, event_set: int, /) -> int: ...
 def restart_events() -> None: ...
 
 DISABLE: object
 MISSING: object
 
-def register_callback(__tool_id: int, __event: int, __func: Callable[..., Any] | None) -> Callable[..., Any] | None: ...
+def register_callback(tool_id: int, event: int, func: Callable[..., Any] | None, /) -> Callable[..., Any] | None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/sysconfig.pyi

```diff
@@ -1,9 +1,10 @@
 import sys
 from typing import IO, Any, Literal, overload
+from typing_extensions import deprecated
 
 __all__ = [
     "get_config_h_filename",
     "get_config_var",
     "get_config_vars",
     "get_makefile_filename",
     "get_path",
@@ -11,19 +12,23 @@
     "get_paths",
     "get_platform",
     "get_python_version",
     "get_scheme_names",
     "parse_config_h",
 ]
 
+@overload
+@deprecated("SO is deprecated, use EXT_SUFFIX. Support is removed in Python 3.11")
+def get_config_var(name: Literal["SO"]) -> Any: ...
+@overload
 def get_config_var(name: str) -> Any: ...
 @overload
 def get_config_vars() -> dict[str, Any]: ...
 @overload
-def get_config_vars(arg: str, *args: str) -> list[Any]: ...
+def get_config_vars(arg: str, /, *args: str) -> list[Any]: ...
 def get_scheme_names() -> tuple[str, ...]: ...
 
 if sys.version_info >= (3, 10):
     def get_default_scheme() -> str: ...
     def get_preferred_scheme(key: Literal["prefix", "home", "user"]) -> str: ...
 
 def get_path_names() -> tuple[str, ...]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/syslog.pyi

```diff
@@ -31,16 +31,16 @@
     LOG_ODELAY: Literal[4]
     LOG_PERROR: Literal[32]
     LOG_PID: Literal[1]
     LOG_SYSLOG: Literal[40]
     LOG_USER: Literal[8]
     LOG_UUCP: Literal[64]
     LOG_WARNING: Literal[4]
-    def LOG_MASK(__pri: int) -> int: ...
-    def LOG_UPTO(__pri: int) -> int: ...
+    def LOG_MASK(pri: int, /) -> int: ...
+    def LOG_UPTO(pri: int, /) -> int: ...
     def closelog() -> None: ...
     def openlog(ident: str = ..., logoption: int = ..., facility: int = ...) -> None: ...
-    def setlogmask(__maskpri: int) -> int: ...
+    def setlogmask(maskpri: int, /) -> int: ...
     @overload
     def syslog(priority: int, message: str) -> None: ...
     @overload
     def syslog(message: str) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/tarfile.pyi

```diff
@@ -39,18 +39,18 @@
         "LinkOutsideDestinationError",
     ]
 
 _FilterFunction: TypeAlias = Callable[[TarInfo, str], TarInfo | None]
 _TarfileFilter: TypeAlias = Literal["fully_trusted", "tar", "data"] | _FilterFunction
 
 class _Fileobj(Protocol):
-    def read(self, __size: int) -> bytes: ...
-    def write(self, __b: bytes) -> object: ...
+    def read(self, size: int, /) -> bytes: ...
+    def write(self, b: bytes, /) -> object: ...
     def tell(self) -> int: ...
-    def seek(self, __pos: int) -> object: ...
+    def seek(self, pos: int, /) -> object: ...
     def close(self) -> object: ...
     # Optional fields:
     # name: str | bytes
     # mode: Literal["rb", "r+b", "wb", "xb"]
 
 class _Bz2ReadableFileobj(bz2._ReadableFileobj):
     def close(self) -> object: ...
@@ -288,22 +288,25 @@
         errorlevel: int | None = ...,
     ) -> Self: ...
     def getmember(self, name: str) -> TarInfo: ...
     def getmembers(self) -> _list[TarInfo]: ...
     def getnames(self) -> _list[str]: ...
     def list(self, verbose: bool = True, *, members: _list[TarInfo] | None = None) -> None: ...
     def next(self) -> TarInfo | None: ...
+    # Calling this method without `filter` is deprecated, but it may be set either on the class or in an
+    # individual call, so we can't mark it as @deprecated here.
     def extractall(
         self,
         path: StrOrBytesPath = ".",
         members: Iterable[TarInfo] | None = None,
         *,
         numeric_owner: bool = False,
         filter: _TarfileFilter | None = ...,
     ) -> None: ...
+    # Same situation as for `extractall`.
     def extract(
         self,
         member: str | TarInfo,
         path: StrOrBytesPath = "",
         set_attrs: bool = True,
         *,
         numeric_owner: bool = False,
```

## puya/_vendor/mypy/typeshed/stdlib/tempfile.pyi

```diff
@@ -360,22 +360,22 @@
     def close(self) -> None: ...
     def fileno(self) -> int: ...
     def flush(self) -> None: ...
     def isatty(self) -> bool: ...
     if sys.version_info >= (3, 11):
         # These three work only if the SpooledTemporaryFile is opened in binary mode,
         # because the underlying object in text mode does not have these methods.
-        def read1(self, __size: int = ...) -> AnyStr: ...
+        def read1(self, size: int = ..., /) -> AnyStr: ...
         def readinto(self, b: WriteableBuffer) -> int: ...
         def readinto1(self, b: WriteableBuffer) -> int: ...
         def detach(self) -> io.RawIOBase: ...
 
-    def read(self, __n: int = ...) -> AnyStr: ...
-    def readline(self, __limit: int | None = ...) -> AnyStr: ...  # type: ignore[override]
-    def readlines(self, __hint: int = ...) -> list[AnyStr]: ...  # type: ignore[override]
+    def read(self, n: int = ..., /) -> AnyStr: ...
+    def readline(self, limit: int | None = ..., /) -> AnyStr: ...  # type: ignore[override]
+    def readlines(self, hint: int = ..., /) -> list[AnyStr]: ...  # type: ignore[override]
     def seek(self, offset: int, whence: int = ...) -> int: ...
     def tell(self) -> int: ...
     def truncate(self, size: int | None = None) -> None: ...  # type: ignore[override]
     @overload
     def write(self: SpooledTemporaryFile[str], s: str) -> int: ...
     @overload
     def write(self: SpooledTemporaryFile[bytes], s: ReadableBuffer) -> int: ...
```

## puya/_vendor/mypy/typeshed/stdlib/termios.pyi

```diff
@@ -250,18 +250,18 @@
     VT1: int
     VTDLY: int
     VTIME: int
     VWERASE: int
     XCASE: int
     XTABS: int
 
-    def tcgetattr(__fd: FileDescriptorLike) -> _AttrReturn: ...
-    def tcsetattr(__fd: FileDescriptorLike, __when: int, __attributes: _Attr) -> None: ...
-    def tcsendbreak(__fd: FileDescriptorLike, __duration: int) -> None: ...
-    def tcdrain(__fd: FileDescriptorLike) -> None: ...
-    def tcflush(__fd: FileDescriptorLike, __queue: int) -> None: ...
-    def tcflow(__fd: FileDescriptorLike, __action: int) -> None: ...
+    def tcgetattr(fd: FileDescriptorLike, /) -> _AttrReturn: ...
+    def tcsetattr(fd: FileDescriptorLike, when: int, attributes: _Attr, /) -> None: ...
+    def tcsendbreak(fd: FileDescriptorLike, duration: int, /) -> None: ...
+    def tcdrain(fd: FileDescriptorLike, /) -> None: ...
+    def tcflush(fd: FileDescriptorLike, queue: int, /) -> None: ...
+    def tcflow(fd: FileDescriptorLike, action: int, /) -> None: ...
     if sys.version_info >= (3, 11):
-        def tcgetwinsize(__fd: FileDescriptorLike) -> tuple[int, int]: ...
-        def tcsetwinsize(__fd: FileDescriptorLike, __winsize: tuple[int, int]) -> None: ...
+        def tcgetwinsize(fd: FileDescriptorLike, /) -> tuple[int, int]: ...
+        def tcsetwinsize(fd: FileDescriptorLike, winsize: tuple[int, int], /) -> None: ...
 
     class error(Exception): ...
```

## puya/_vendor/mypy/typeshed/stdlib/time.pyi

```diff
@@ -35,14 +35,15 @@
 # However, it always *behaves* like a tuple of 9 elements,
 # even if an iterable with length >9 is passed.
 # https://github.com/python/typeshed/pull/6560#discussion_r767162532
 @final
 class struct_time(structseq[Any | int], _TimeTuple):
     if sys.version_info >= (3, 10):
         __match_args__: Final = ("tm_year", "tm_mon", "tm_mday", "tm_hour", "tm_min", "tm_sec", "tm_wday", "tm_yday", "tm_isdst")
+
     @property
     def tm_year(self) -> int: ...
     @property
     def tm_mon(self) -> int: ...
     @property
     def tm_mday(self) -> int: ...
     @property
```

## puya/_vendor/mypy/typeshed/stdlib/tkinter/__init__.pyi

```diff
@@ -174,21 +174,20 @@
 _Anchor: TypeAlias = Literal["nw", "n", "ne", "w", "center", "e", "sw", "s", "se"]  # manual page: Tk_GetAnchor
 _ButtonCommand: TypeAlias = str | Callable[[], Any]  # accepts string of tcl code, return value is returned from Button.invoke()
 _Compound: TypeAlias = Literal["top", "left", "center", "right", "bottom", "none"]  # -compound in manual page named 'options'
 # manual page: Tk_GetCursor
 _Cursor: TypeAlias = str | tuple[str] | tuple[str, str] | tuple[str, str, str] | tuple[str, str, str, str]
 # example when it's sequence:  entry['invalidcommand'] = [entry.register(print), '%P']
 _EntryValidateCommand: TypeAlias = str | list[str] | tuple[str, ...] | Callable[[], bool]
-_GridIndex: TypeAlias = int | str
 _ImageSpec: TypeAlias = _Image | str  # str can be from e.g. tkinter.image_names()
 _Relief: TypeAlias = Literal["raised", "sunken", "flat", "ridge", "solid", "groove"]  # manual page: Tk_GetRelief
 _ScreenUnits: TypeAlias = str | float  # Often the right type instead of int. Manual page: Tk_GetPixels
 # -xscrollcommand and -yscrollcommand in 'options' manual page
 _XYScrollCommand: TypeAlias = str | Callable[[float, float], object]
-_TakeFocusValue: TypeAlias = int | Literal[""] | Callable[[str], bool | None]  # -takefocus in manual page named 'options'
+_TakeFocusValue: TypeAlias = bool | Literal[0, 1, ""] | Callable[[str], bool | None]  # -takefocus in manual page named 'options'
 
 if sys.version_info >= (3, 11):
     class _VersionInfoType(NamedTuple):
         major: int
         minor: int
         micro: int
         releaselevel: str
@@ -258,24 +257,22 @@
     keysym_num: int
     type: EventType
     widget: _W_co
     delta: int
 
 def NoDefaultRoot() -> None: ...
 
-_TraceMode: TypeAlias = Literal["array", "read", "write", "unset"]
-
 class Variable:
     def __init__(self, master: Misc | None = None, value: Incomplete | None = None, name: str | None = None) -> None: ...
     def set(self, value) -> None: ...
     initialize = set
     def get(self): ...
-    def trace_add(self, mode: _TraceMode, callback: Callable[[str, str, str], object]) -> str: ...
-    def trace_remove(self, mode: _TraceMode, cbname: str) -> None: ...
-    def trace_info(self) -> list[tuple[tuple[_TraceMode, ...], str]]: ...
+    def trace_add(self, mode: Literal["array", "read", "write", "unset"], callback: Callable[[str, str, str], object]) -> str: ...
+    def trace_remove(self, mode: Literal["array", "read", "write", "unset"], cbname: str) -> None: ...
+    def trace_info(self) -> list[tuple[tuple[Literal["array", "read", "write", "unset"], ...], str]]: ...
     @deprecated("use trace_add() instead of trace()")
     def trace(self, mode, callback): ...
     @deprecated("use trace_add() instead of trace_variable()")
     def trace_variable(self, mode, callback): ...
     @deprecated("use trace_remove() instead of trace_vdelete()")
     def trace_vdelete(self, mode, cbname) -> None: ...
     @deprecated("use trace_info() instead of trace_vinfo()")
@@ -501,25 +498,25 @@
     @overload
     def grid_bbox(self, column: int, row: int, col2: None = None, row2: None = None) -> tuple[int, int, int, int] | None: ...
     @overload
     def grid_bbox(self, column: int, row: int, col2: int, row2: int) -> tuple[int, int, int, int] | None: ...
     bbox = grid_bbox
     def grid_columnconfigure(
         self,
-        index: _GridIndex | list[int] | tuple[int, ...],
+        index: int | str | list[int] | tuple[int, ...],
         cnf: _GridIndexInfo = {},
         *,
         minsize: _ScreenUnits = ...,
         pad: _ScreenUnits = ...,
         uniform: str = ...,
         weight: int = ...,
     ) -> _GridIndexInfo | Any: ...  # can be None but annoying to check
     def grid_rowconfigure(
         self,
-        index: _GridIndex | list[int] | tuple[int, ...],
+        index: int | str | list[int] | tuple[int, ...],
         cnf: _GridIndexInfo = {},
         *,
         minsize: _ScreenUnits = ...,
         pad: _ScreenUnits = ...,
         uniform: str = ...,
         weight: int = ...,
     ) -> _GridIndexInfo | Any: ...  # can be None but annoying to check
@@ -617,26 +614,26 @@
     def wm_aspect(
         self, minNumer: None = None, minDenom: None = None, maxNumer: None = None, maxDenom: None = None
     ) -> tuple[int, int, int, int] | None: ...
     aspect = wm_aspect
     @overload
     def wm_attributes(self) -> tuple[Any, ...]: ...
     @overload
-    def wm_attributes(self, __option: str): ...
+    def wm_attributes(self, option: str, /): ...
     @overload
-    def wm_attributes(self, __option: str, __value, *__other_option_value_pairs: Any) -> None: ...
+    def wm_attributes(self, option: str, value, /, *__other_option_value_pairs: Any) -> None: ...
     attributes = wm_attributes
     def wm_client(self, name: str | None = None) -> str: ...
     client = wm_client
     @overload
     def wm_colormapwindows(self) -> list[Misc]: ...
     @overload
-    def wm_colormapwindows(self, __wlist: list[Misc] | tuple[Misc, ...]) -> None: ...
+    def wm_colormapwindows(self, wlist: list[Misc] | tuple[Misc, ...], /) -> None: ...
     @overload
-    def wm_colormapwindows(self, __first_wlist_item: Misc, *other_wlist_items: Misc) -> None: ...
+    def wm_colormapwindows(self, first_wlist_item: Misc, /, *other_wlist_items: Misc) -> None: ...
     colormapwindows = wm_colormapwindows
     def wm_command(self, value: str | None = None) -> str: ...
     command = wm_command
     # Some of these always return empty string, but return type is set to None to prevent accidentally using it
     def wm_deiconify(self) -> None: ...
     deiconify = wm_deiconify
     def wm_focusmodel(self, model: Literal["active", "passive"] | None = None) -> Literal["active", "passive", ""]: ...
@@ -664,15 +661,15 @@
     iconbitmap = wm_iconbitmap
     def wm_iconify(self) -> None: ...
     iconify = wm_iconify
     def wm_iconmask(self, bitmap: Incomplete | None = None): ...
     iconmask = wm_iconmask
     def wm_iconname(self, newName: Incomplete | None = None) -> str: ...
     iconname = wm_iconname
-    def wm_iconphoto(self, default: bool, __image1: _PhotoImageLike | str, *args: _PhotoImageLike | str) -> None: ...
+    def wm_iconphoto(self, default: bool, image1: _PhotoImageLike | str, /, *args: _PhotoImageLike | str) -> None: ...
     iconphoto = wm_iconphoto
     def wm_iconposition(self, x: int | None = None, y: int | None = None) -> tuple[int, int] | None: ...
     iconposition = wm_iconposition
     def wm_iconwindow(self, pathName: Incomplete | None = None): ...
     iconwindow = wm_iconwindow
     def wm_manage(self, widget) -> None: ...
     manage = wm_manage
@@ -766,39 +763,39 @@
     config = configure
     def destroy(self) -> None: ...
     def readprofile(self, baseName: str, className: str) -> None: ...
     report_callback_exception: Callable[[type[BaseException], BaseException, TracebackType | None], object]
     # Tk has __getattr__ so that tk_instance.foo falls back to tk_instance.tk.foo
     # Please keep in sync with _tkinter.TkappType.
     # Some methods are intentionally missing because they are inherited from Misc instead.
-    def adderrorinfo(self, __msg): ...
-    def call(self, __command: Any, *args: Any) -> Any: ...
-    def createcommand(self, __name, __func): ...
+    def adderrorinfo(self, msg, /): ...
+    def call(self, command: Any, /, *args: Any) -> Any: ...
+    def createcommand(self, name, func, /): ...
     if sys.platform != "win32":
-        def createfilehandler(self, __file, __mask, __func): ...
-        def deletefilehandler(self, __file): ...
+        def createfilehandler(self, file, mask, func, /): ...
+        def deletefilehandler(self, file, /): ...
 
-    def createtimerhandler(self, __milliseconds, __func): ...
-    def dooneevent(self, __flags: int = ...): ...
-    def eval(self, __script: str) -> str: ...
-    def evalfile(self, __fileName): ...
-    def exprboolean(self, __s): ...
-    def exprdouble(self, __s): ...
-    def exprlong(self, __s): ...
-    def exprstring(self, __s): ...
+    def createtimerhandler(self, milliseconds, func, /): ...
+    def dooneevent(self, flags: int = ..., /): ...
+    def eval(self, script: str, /) -> str: ...
+    def evalfile(self, fileName, /): ...
+    def exprboolean(self, s, /): ...
+    def exprdouble(self, s, /): ...
+    def exprlong(self, s, /): ...
+    def exprstring(self, s, /): ...
     def globalgetvar(self, *args, **kwargs): ...
     def globalsetvar(self, *args, **kwargs): ...
     def globalunsetvar(self, *args, **kwargs): ...
     def interpaddr(self): ...
     def loadtk(self) -> None: ...
-    def record(self, __script): ...
+    def record(self, script, /): ...
     if sys.version_info < (3, 11):
-        def split(self, __arg): ...
+        def split(self, arg, /): ...
 
-    def splitlist(self, __arg): ...
+    def splitlist(self, arg, /): ...
     def unsetvar(self, *args, **kwargs): ...
     def wantobjects(self, *args, **kwargs): ...
     def willdispatch(self): ...
 
 def Tcl(screenName: str | None = None, baseName: str | None = None, className: str = "Tk", useTk: bool = False) -> Tk: ...
 
 _InMiscTotal = TypedDict("_InMiscTotal", {"in": Misc})
@@ -825,15 +822,15 @@
     def pack_configure(
         self,
         cnf: Mapping[str, Any] | None = {},
         *,
         after: Misc = ...,
         anchor: _Anchor = ...,
         before: Misc = ...,
-        expand: int = ...,
+        expand: bool | Literal[0, 1] = 0,
         fill: Literal["none", "x", "y", "both"] = ...,
         side: Literal["left", "right", "top", "bottom"] = ...,
         ipadx: _ScreenUnits = ...,
         ipady: _ScreenUnits = ...,
         padx: _ScreenUnits | tuple[_ScreenUnits, _ScreenUnits] = ...,
         pady: _ScreenUnits | tuple[_ScreenUnits, _ScreenUnits] = ...,
         in_: Misc = ...,
@@ -945,36 +942,36 @@
     # copy/pasted here instead of aliasing as 'config = Tk.config'.
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         background: str = ...,
-        bd: _ScreenUnits = ...,
+        bd: _ScreenUnits = 0,
         bg: str = ...,
-        border: _ScreenUnits = ...,
-        borderwidth: _ScreenUnits = ...,
-        class_: str = ...,
-        colormap: Literal["new", ""] | Misc = ...,
-        container: bool = ...,
-        cursor: _Cursor = ...,
-        height: _ScreenUnits = ...,
+        border: _ScreenUnits = 0,
+        borderwidth: _ScreenUnits = 0,
+        class_: str = "Toplevel",
+        colormap: Literal["new", ""] | Misc = "",
+        container: bool = False,
+        cursor: _Cursor = "",
+        height: _ScreenUnits = 0,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
-        highlightthickness: _ScreenUnits = ...,
+        highlightthickness: _ScreenUnits = 0,
         menu: Menu = ...,
         name: str = ...,
-        padx: _ScreenUnits = ...,
-        pady: _ScreenUnits = ...,
-        relief: _Relief = ...,
-        screen: str = ...,  # can't be changed after creating widget
-        takefocus: _TakeFocusValue = ...,
+        padx: _ScreenUnits = 0,
+        pady: _ScreenUnits = 0,
+        relief: _Relief = "flat",
+        screen: str = "",  # can't be changed after creating widget
+        takefocus: _TakeFocusValue = 0,
         use: int = ...,
-        visual: str | tuple[str, int] = ...,
-        width: _ScreenUnits = ...,
+        visual: str | tuple[str, int] = "",
+        width: _ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         background: str = ...,
@@ -1002,54 +999,54 @@
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         activebackground: str = ...,
         activeforeground: str = ...,
-        anchor: _Anchor = ...,
+        anchor: _Anchor = "center",
         background: str = ...,
         bd: _ScreenUnits = ...,  # same as borderwidth
         bg: str = ...,  # same as background
-        bitmap: str = ...,
+        bitmap: str = "",
         border: _ScreenUnits = ...,  # same as borderwidth
         borderwidth: _ScreenUnits = ...,
-        command: _ButtonCommand = ...,
-        compound: _Compound = ...,
-        cursor: _Cursor = ...,
-        default: Literal["normal", "active", "disabled"] = ...,
+        command: _ButtonCommand = "",
+        compound: _Compound = "none",
+        cursor: _Cursor = "",
+        default: Literal["normal", "active", "disabled"] = "disabled",
         disabledforeground: str = ...,
         fg: str = ...,  # same as foreground
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkDefaultFont",
         foreground: str = ...,
         # width and height must be int for buttons containing just text, but
         # ints are also valid _ScreenUnits
-        height: _ScreenUnits = ...,
+        height: _ScreenUnits = 0,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
-        highlightthickness: _ScreenUnits = ...,
-        image: _ImageSpec = ...,
-        justify: Literal["left", "center", "right"] = ...,
+        highlightthickness: _ScreenUnits = 1,
+        image: _ImageSpec = "",
+        justify: Literal["left", "center", "right"] = "center",
         name: str = ...,
-        overrelief: _Relief = ...,
+        overrelief: _Relief | Literal[""] = "",
         padx: _ScreenUnits = ...,
         pady: _ScreenUnits = ...,
         relief: _Relief = ...,
         repeatdelay: int = ...,
         repeatinterval: int = ...,
-        state: Literal["normal", "active", "disabled"] = ...,
-        takefocus: _TakeFocusValue = ...,
-        text: float | str = ...,
+        state: Literal["normal", "active", "disabled"] = "normal",
+        takefocus: _TakeFocusValue = "",
+        text: float | str = "",
         # We allow the textvariable to be any Variable, not necessarily
         # StringVar. This is useful for e.g. a button that displays the value
         # of an IntVar.
         textvariable: Variable = ...,
-        underline: int = ...,
-        width: _ScreenUnits = ...,
-        wraplength: _ScreenUnits = ...,
+        underline: int = -1,
+        width: _ScreenUnits = 0,
+        wraplength: _ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         activebackground: str = ...,
@@ -1071,15 +1068,15 @@
         foreground: str = ...,
         height: _ScreenUnits = ...,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
         highlightthickness: _ScreenUnits = ...,
         image: _ImageSpec = ...,
         justify: Literal["left", "center", "right"] = ...,
-        overrelief: _Relief = ...,
+        overrelief: _Relief | Literal[""] = ...,
         padx: _ScreenUnits = ...,
         pady: _ScreenUnits = ...,
         relief: _Relief = ...,
         repeatdelay: int = ...,
         repeatinterval: int = ...,
         state: Literal["normal", "active", "disabled"] = ...,
         takefocus: _TakeFocusValue = ...,
@@ -1098,49 +1095,49 @@
 class Canvas(Widget, XView, YView):
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         background: str = ...,
-        bd: _ScreenUnits = ...,
+        bd: _ScreenUnits = 0,
         bg: str = ...,
-        border: _ScreenUnits = ...,
-        borderwidth: _ScreenUnits = ...,
-        closeenough: float = ...,
-        confine: bool = ...,
-        cursor: _Cursor = ...,
+        border: _ScreenUnits = 0,
+        borderwidth: _ScreenUnits = 0,
+        closeenough: float = 1.0,
+        confine: bool = True,
+        cursor: _Cursor = "",
         # canvas manual page has a section named COORDINATES, and the first
         # part of it describes _ScreenUnits.
         height: _ScreenUnits = ...,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
         highlightthickness: _ScreenUnits = ...,
         insertbackground: str = ...,
-        insertborderwidth: _ScreenUnits = ...,
-        insertofftime: int = ...,
-        insertontime: int = ...,
-        insertwidth: _ScreenUnits = ...,
+        insertborderwidth: _ScreenUnits = 0,
+        insertofftime: int = 300,
+        insertontime: int = 600,
+        insertwidth: _ScreenUnits = 2,
         name: str = ...,
         offset=...,  # undocumented
-        relief: _Relief = ...,
+        relief: _Relief = "flat",
         # Setting scrollregion to None doesn't reset it back to empty,
         # but setting it to () does.
-        scrollregion: tuple[_ScreenUnits, _ScreenUnits, _ScreenUnits, _ScreenUnits] | tuple[()] = ...,
+        scrollregion: tuple[_ScreenUnits, _ScreenUnits, _ScreenUnits, _ScreenUnits] | tuple[()] = (),
         selectbackground: str = ...,
-        selectborderwidth: _ScreenUnits = ...,
+        selectborderwidth: _ScreenUnits = 1,
         selectforeground: str = ...,
         # man page says that state can be 'hidden', but it can't
-        state: Literal["normal", "disabled"] = ...,
-        takefocus: _TakeFocusValue = ...,
+        state: Literal["normal", "disabled"] = "normal",
+        takefocus: _TakeFocusValue = "",
         width: _ScreenUnits = ...,
-        xscrollcommand: _XYScrollCommand = ...,
-        xscrollincrement: _ScreenUnits = ...,
-        yscrollcommand: _XYScrollCommand = ...,
-        yscrollincrement: _ScreenUnits = ...,
+        xscrollcommand: _XYScrollCommand = "",
+        xscrollincrement: _ScreenUnits = 0,
+        yscrollcommand: _XYScrollCommand = "",
+        yscrollincrement: _ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         background: str = ...,
@@ -1213,32 +1210,33 @@
     ) -> None: ...
     @overload
     def tag_bind(self, tagOrId: str | int, *, func: str, add: Literal["", "+"] | bool | None = None) -> None: ...
     def tag_unbind(self, tagOrId: str | int, sequence: str, funcid: str | None = None) -> None: ...
     def canvasx(self, screenx, gridspacing: Incomplete | None = None): ...
     def canvasy(self, screeny, gridspacing: Incomplete | None = None): ...
     @overload
-    def coords(self, __tagOrId: str | int) -> list[float]: ...
+    def coords(self, tagOrId: str | int, /) -> list[float]: ...
     @overload
-    def coords(self, __tagOrId: str | int, __args: list[int] | list[float] | tuple[float, ...]) -> None: ...
+    def coords(self, tagOrId: str | int, args: list[int] | list[float] | tuple[float, ...], /) -> None: ...
     @overload
-    def coords(self, __tagOrId: str | int, __x1: float, __y1: float, *args: float) -> None: ...
+    def coords(self, tagOrId: str | int, x1: float, y1: float, /, *args: float) -> None: ...
     # create_foo() methods accept coords as a list or tuple, or as separate arguments.
     # Lists and tuples can be flat as in [1, 2, 3, 4], or nested as in [(1, 2), (3, 4)].
     # Keyword arguments should be the same in all overloads of each method.
     def create_arc(self, *args, **kw) -> int: ...
     def create_bitmap(self, *args, **kw) -> int: ...
     def create_image(self, *args, **kw) -> int: ...
     @overload
     def create_line(
         self,
-        __x0: float,
-        __y0: float,
-        __x1: float,
-        __y1: float,
+        x0: float,
+        y0: float,
+        x1: float,
+        y1: float,
+        /,
         *,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
         arrow: Literal["first", "last", "both"] = ...,
         arrowshape: tuple[float, float, float] = ...,
@@ -1258,16 +1256,17 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_line(
         self,
-        __xy_pair_0: tuple[float, float],
-        __xy_pair_1: tuple[float, float],
+        xy_pair_0: tuple[float, float],
+        xy_pair_1: tuple[float, float],
+        /,
         *,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
         arrow: Literal["first", "last", "both"] = ...,
         arrowshape: tuple[float, float, float] = ...,
@@ -1287,22 +1286,23 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_line(
         self,
-        __coords: (
+        coords: (
             tuple[float, float, float, float]
             | tuple[tuple[float, float], tuple[float, float]]
             | list[int]
             | list[float]
             | list[tuple[int, int]]
             | list[tuple[float, float]]
         ),
+        /,
         *,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
         arrow: Literal["first", "last", "both"] = ...,
         arrowshape: tuple[float, float, float] = ...,
@@ -1322,18 +1322,19 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_oval(
         self,
-        __x0: float,
-        __y0: float,
-        __x1: float,
-        __y1: float,
+        x0: float,
+        y0: float,
+        x1: float,
+        y1: float,
+        /,
         *,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activeoutline: str = ...,
         activeoutlinestipple: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
@@ -1354,16 +1355,17 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_oval(
         self,
-        __xy_pair_0: tuple[float, float],
-        __xy_pair_1: tuple[float, float],
+        xy_pair_0: tuple[float, float],
+        xy_pair_1: tuple[float, float],
+        /,
         *,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activeoutline: str = ...,
         activeoutlinestipple: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
@@ -1384,22 +1386,23 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_oval(
         self,
-        __coords: (
+        coords: (
             tuple[float, float, float, float]
             | tuple[tuple[float, float], tuple[float, float]]
             | list[int]
             | list[float]
             | list[tuple[int, int]]
             | list[tuple[float, float]]
         ),
+        /,
         *,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activeoutline: str = ...,
         activeoutlinestipple: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
@@ -1420,18 +1423,19 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_polygon(
         self,
-        __x0: float,
-        __y0: float,
-        __x1: float,
-        __y1: float,
+        x0: float,
+        y0: float,
+        x1: float,
+        y1: float,
+        /,
         *xy_pairs: float,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activeoutline: str = ...,
         activeoutlinestipple: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
@@ -1455,16 +1459,17 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_polygon(
         self,
-        __xy_pair_0: tuple[float, float],
-        __xy_pair_1: tuple[float, float],
+        xy_pair_0: tuple[float, float],
+        xy_pair_1: tuple[float, float],
+        /,
         *xy_pairs: tuple[float, float],
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activeoutline: str = ...,
         activeoutlinestipple: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
@@ -1488,22 +1493,23 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_polygon(
         self,
-        __coords: (
+        coords: (
             tuple[float, ...]
             | tuple[tuple[float, float], ...]
             | list[int]
             | list[float]
             | list[tuple[int, int]]
             | list[tuple[float, float]]
         ),
+        /,
         *,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activeoutline: str = ...,
         activeoutlinestipple: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
@@ -1527,18 +1533,19 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_rectangle(
         self,
-        __x0: float,
-        __y0: float,
-        __x1: float,
-        __y1: float,
+        x0: float,
+        y0: float,
+        x1: float,
+        y1: float,
+        /,
         *,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activeoutline: str = ...,
         activeoutlinestipple: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
@@ -1559,16 +1566,17 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_rectangle(
         self,
-        __xy_pair_0: tuple[float, float],
-        __xy_pair_1: tuple[float, float],
+        xy_pair_0: tuple[float, float],
+        xy_pair_1: tuple[float, float],
+        /,
         *,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activeoutline: str = ...,
         activeoutlinestipple: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
@@ -1589,22 +1597,23 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_rectangle(
         self,
-        __coords: (
+        coords: (
             tuple[float, float, float, float]
             | tuple[tuple[float, float], tuple[float, float]]
             | list[int]
             | list[float]
             | list[tuple[int, int]]
             | list[tuple[float, float]]
         ),
+        /,
         *,
         activedash: str | int | list[int] | tuple[int, ...] = ...,
         activefill: str = ...,
         activeoutline: str = ...,
         activeoutlinestipple: str = ...,
         activestipple: str = ...,
         activewidth: _ScreenUnits = ...,
@@ -1625,16 +1634,17 @@
         stipple: str = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_text(
         self,
-        __x: float,
-        __y: float,
+        x: float,
+        y: float,
+        /,
         *,
         activefill: str = ...,
         activestipple: str = ...,
         anchor: _Anchor = ...,
         angle: float | str = ...,
         disabledfill: str = ...,
         disabledstipple: str = ...,
@@ -1647,15 +1657,16 @@
         tags: str | list[str] | tuple[str, ...] = ...,
         text: float | str = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_text(
         self,
-        __coords: tuple[float, float] | list[int] | list[float],
+        coords: tuple[float, float] | list[int] | list[float],
+        /,
         *,
         activefill: str = ...,
         activestipple: str = ...,
         anchor: _Anchor = ...,
         angle: float | str = ...,
         disabledfill: str = ...,
         disabledstipple: str = ...,
@@ -1668,44 +1679,46 @@
         tags: str | list[str] | tuple[str, ...] = ...,
         text: float | str = ...,
         width: _ScreenUnits = ...,
     ) -> int: ...
     @overload
     def create_window(
         self,
-        __x: float,
-        __y: float,
+        x: float,
+        y: float,
+        /,
         *,
         anchor: _Anchor = ...,
         height: _ScreenUnits = ...,
         state: Literal["normal", "hidden", "disabled"] = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
         window: Widget = ...,
     ) -> int: ...
     @overload
     def create_window(
         self,
-        __coords: tuple[float, float] | list[int] | list[float],
+        coords: tuple[float, float] | list[int] | list[float],
+        /,
         *,
         anchor: _Anchor = ...,
         height: _ScreenUnits = ...,
         state: Literal["normal", "hidden", "disabled"] = ...,
         tags: str | list[str] | tuple[str, ...] = ...,
         width: _ScreenUnits = ...,
         window: Widget = ...,
     ) -> int: ...
     def dchars(self, *args) -> None: ...
     def delete(self, *tagsOrCanvasIds: str | int) -> None: ...
     @overload
-    def dtag(self, __tag: str, __tag_to_delete: str | None = ...) -> None: ...
+    def dtag(self, tag: str, tag_to_delete: str | None = ..., /) -> None: ...
     @overload
-    def dtag(self, __id: int, __tag_to_delete: str) -> None: ...
+    def dtag(self, id: int, tag_to_delete: str, /) -> None: ...
     def focus(self, *args): ...
-    def gettags(self, __tagOrId: str | int) -> tuple[str, ...]: ...
+    def gettags(self, tagOrId: str | int, /) -> tuple[str, ...]: ...
     def icursor(self, *args) -> None: ...
     def index(self, *args): ...
     def insert(self, *args) -> None: ...
     def itemcget(self, tagOrId, option): ...
     # itemconfigure kwargs depend on item type, which is not known when type checking
     def itemconfigure(
         self, tagOrId: str | int, cnf: dict[str, Any] | None = None, **kw: Any
@@ -1715,88 +1728,90 @@
     def moveto(self, tagOrId: str | int, x: Literal[""] | float = "", y: Literal[""] | float = "") -> None: ...
     def postscript(self, cnf={}, **kw): ...
     # tkinter does:
     #    lower = tag_lower
     #    lift = tkraise = tag_raise
     #
     # But mypy doesn't like aliasing here (maybe because Misc defines the same names)
-    def tag_lower(self, __first: str | int, __second: str | int | None = ...) -> None: ...
-    def lower(self, __first: str | int, __second: str | int | None = ...) -> None: ...  # type: ignore[override]
-    def tag_raise(self, __first: str | int, __second: str | int | None = ...) -> None: ...
-    def tkraise(self, __first: str | int, __second: str | int | None = ...) -> None: ...  # type: ignore[override]
-    def lift(self, __first: str | int, __second: str | int | None = ...) -> None: ...  # type: ignore[override]
-    def scale(self, *args) -> None: ...
+    def tag_lower(self, first: str | int, second: str | int | None = ..., /) -> None: ...
+    def lower(self, first: str | int, second: str | int | None = ..., /) -> None: ...  # type: ignore[override]
+    def tag_raise(self, first: str | int, second: str | int | None = ..., /) -> None: ...
+    def tkraise(self, first: str | int, second: str | int | None = ..., /) -> None: ...  # type: ignore[override]
+    def lift(self, first: str | int, second: str | int | None = ..., /) -> None: ...  # type: ignore[override]
+    def scale(
+        self, tagOrId: str | int, xOrigin: _ScreenUnits, yOrigin: _ScreenUnits, xScale: float, yScale: float, /
+    ) -> None: ...
     def scan_mark(self, x, y) -> None: ...
     def scan_dragto(self, x, y, gain: int = 10) -> None: ...
     def select_adjust(self, tagOrId, index) -> None: ...
     def select_clear(self) -> None: ...
     def select_from(self, tagOrId, index) -> None: ...
     def select_item(self): ...
     def select_to(self, tagOrId, index) -> None: ...
-    def type(self, tagOrId): ...
+    def type(self, tagOrId: str | int) -> int | None: ...
 
 class Checkbutton(Widget):
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         activebackground: str = ...,
         activeforeground: str = ...,
-        anchor: _Anchor = ...,
+        anchor: _Anchor = "center",
         background: str = ...,
         bd: _ScreenUnits = ...,
         bg: str = ...,
-        bitmap: str = ...,
+        bitmap: str = "",
         border: _ScreenUnits = ...,
         borderwidth: _ScreenUnits = ...,
-        command: _ButtonCommand = ...,
-        compound: _Compound = ...,
-        cursor: _Cursor = ...,
+        command: _ButtonCommand = "",
+        compound: _Compound = "none",
+        cursor: _Cursor = "",
         disabledforeground: str = ...,
         fg: str = ...,
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkDefaultFont",
         foreground: str = ...,
-        height: _ScreenUnits = ...,
+        height: _ScreenUnits = 0,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
-        highlightthickness: _ScreenUnits = ...,
-        image: _ImageSpec = ...,
-        indicatoron: bool = ...,
-        justify: Literal["left", "center", "right"] = ...,
+        highlightthickness: _ScreenUnits = 1,
+        image: _ImageSpec = "",
+        indicatoron: bool = True,
+        justify: Literal["left", "center", "right"] = "center",
         name: str = ...,
         offrelief: _Relief = ...,
         # The checkbutton puts a value to its variable when it's checked or
         # unchecked. We don't restrict the type of that value here, so
         # Any-typing is fine.
         #
         # I think Checkbutton shouldn't be generic, because then specifying
         # "any checkbutton regardless of what variable it uses" would be
         # difficult, and we might run into issues just like how list[float]
         # and list[int] are incompatible. Also, we would need a way to
         # specify "Checkbutton not associated with any variable", which is
         # done by setting variable to empty string (the default).
-        offvalue: Any = ...,
-        onvalue: Any = ...,
-        overrelief: _Relief = ...,
-        padx: _ScreenUnits = ...,
-        pady: _ScreenUnits = ...,
-        relief: _Relief = ...,
+        offvalue: Any = 0,
+        onvalue: Any = 1,
+        overrelief: _Relief | Literal[""] = "",
+        padx: _ScreenUnits = 1,
+        pady: _ScreenUnits = 1,
+        relief: _Relief = "flat",
         selectcolor: str = ...,
-        selectimage: _ImageSpec = ...,
-        state: Literal["normal", "active", "disabled"] = ...,
-        takefocus: _TakeFocusValue = ...,
-        text: float | str = ...,
+        selectimage: _ImageSpec = "",
+        state: Literal["normal", "active", "disabled"] = "normal",
+        takefocus: _TakeFocusValue = "",
+        text: float | str = "",
         textvariable: Variable = ...,
-        tristateimage: _ImageSpec = ...,
-        tristatevalue: Any = ...,
-        underline: int = ...,
+        tristateimage: _ImageSpec = "",
+        tristatevalue: Any = "",
+        underline: int = -1,
         variable: Variable | Literal[""] = ...,
-        width: _ScreenUnits = ...,
-        wraplength: _ScreenUnits = ...,
+        width: _ScreenUnits = 0,
+        wraplength: _ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         activebackground: str = ...,
@@ -1821,15 +1836,15 @@
         highlightthickness: _ScreenUnits = ...,
         image: _ImageSpec = ...,
         indicatoron: bool = ...,
         justify: Literal["left", "center", "right"] = ...,
         offrelief: _Relief = ...,
         offvalue: Any = ...,
         onvalue: Any = ...,
-        overrelief: _Relief = ...,
+        overrelief: _Relief | Literal[""] = ...,
         padx: _ScreenUnits = ...,
         pady: _ScreenUnits = ...,
         relief: _Relief = ...,
         selectcolor: str = ...,
         selectimage: _ImageSpec = ...,
         state: Literal["normal", "active", "disabled"] = ...,
         takefocus: _TakeFocusValue = ...,
@@ -1847,60 +1862,58 @@
     config = configure
     def deselect(self) -> None: ...
     def flash(self) -> None: ...
     def invoke(self) -> Any: ...
     def select(self) -> None: ...
     def toggle(self) -> None: ...
 
-_EntryIndex: TypeAlias = str | int  # "INDICES" in manual page
-
 class Entry(Widget, XView):
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         background: str = ...,
         bd: _ScreenUnits = ...,
         bg: str = ...,
         border: _ScreenUnits = ...,
         borderwidth: _ScreenUnits = ...,
-        cursor: _Cursor = ...,
+        cursor: _Cursor = "xterm",
         disabledbackground: str = ...,
         disabledforeground: str = ...,
-        exportselection: bool = ...,
+        exportselection: bool = True,
         fg: str = ...,
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkTextFont",
         foreground: str = ...,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
         highlightthickness: _ScreenUnits = ...,
         insertbackground: str = ...,
-        insertborderwidth: _ScreenUnits = ...,
-        insertofftime: int = ...,
-        insertontime: int = ...,
+        insertborderwidth: _ScreenUnits = 0,
+        insertofftime: int = 300,
+        insertontime: int = 600,
         insertwidth: _ScreenUnits = ...,
-        invalidcommand: _EntryValidateCommand = ...,
-        invcmd: _EntryValidateCommand = ...,  # same as invalidcommand
-        justify: Literal["left", "center", "right"] = ...,
+        invalidcommand: _EntryValidateCommand = "",
+        invcmd: _EntryValidateCommand = "",  # same as invalidcommand
+        justify: Literal["left", "center", "right"] = "left",
         name: str = ...,
         readonlybackground: str = ...,
-        relief: _Relief = ...,
+        relief: _Relief = "sunken",
         selectbackground: str = ...,
         selectborderwidth: _ScreenUnits = ...,
         selectforeground: str = ...,
-        show: str = ...,
-        state: Literal["normal", "disabled", "readonly"] = ...,
-        takefocus: _TakeFocusValue = ...,
+        show: str = "",
+        state: Literal["normal", "disabled", "readonly"] = "normal",
+        takefocus: _TakeFocusValue = "",
         textvariable: Variable = ...,
-        validate: Literal["none", "focus", "focusin", "focusout", "key", "all"] = ...,
-        validatecommand: _EntryValidateCommand = ...,
-        vcmd: _EntryValidateCommand = ...,  # same as validatecommand
-        width: int = ...,
-        xscrollcommand: _XYScrollCommand = ...,
+        validate: Literal["none", "focus", "focusin", "focusout", "key", "all"] = "none",
+        validatecommand: _EntryValidateCommand = "",
+        vcmd: _EntryValidateCommand = "",  # same as validatecommand
+        width: int = 20,
+        xscrollcommand: _XYScrollCommand = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         background: str = ...,
@@ -1940,60 +1953,60 @@
         vcmd: _EntryValidateCommand = ...,
         width: int = ...,
         xscrollcommand: _XYScrollCommand = ...,
     ) -> dict[str, tuple[str, str, str, Any, Any]] | None: ...
     @overload
     def configure(self, cnf: str) -> tuple[str, str, str, Any, Any]: ...
     config = configure
-    def delete(self, first: _EntryIndex, last: _EntryIndex | None = None) -> None: ...
+    def delete(self, first: str | int, last: str | int | None = None) -> None: ...
     def get(self) -> str: ...
-    def icursor(self, index: _EntryIndex) -> None: ...
-    def index(self, index: _EntryIndex) -> int: ...
-    def insert(self, index: _EntryIndex, string: str) -> None: ...
+    def icursor(self, index: str | int) -> None: ...
+    def index(self, index: str | int) -> int: ...
+    def insert(self, index: str | int, string: str) -> None: ...
     def scan_mark(self, x) -> None: ...
     def scan_dragto(self, x) -> None: ...
-    def selection_adjust(self, index: _EntryIndex) -> None: ...
+    def selection_adjust(self, index: str | int) -> None: ...
     def selection_clear(self) -> None: ...  # type: ignore[override]
-    def selection_from(self, index: _EntryIndex) -> None: ...
+    def selection_from(self, index: str | int) -> None: ...
     def selection_present(self) -> bool: ...
-    def selection_range(self, start: _EntryIndex, end: _EntryIndex) -> None: ...
-    def selection_to(self, index: _EntryIndex) -> None: ...
+    def selection_range(self, start: str | int, end: str | int) -> None: ...
+    def selection_to(self, index: str | int) -> None: ...
     select_adjust = selection_adjust
     select_clear = selection_clear
     select_from = selection_from
     select_present = selection_present
     select_range = selection_range
     select_to = selection_to
 
 class Frame(Widget):
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         background: str = ...,
-        bd: _ScreenUnits = ...,
+        bd: _ScreenUnits = 0,
         bg: str = ...,
-        border: _ScreenUnits = ...,
-        borderwidth: _ScreenUnits = ...,
-        class_: str = ...,  # can't be changed with configure()
-        colormap: Literal["new", ""] | Misc = ...,  # can't be changed with configure()
-        container: bool = ...,  # can't be changed with configure()
-        cursor: _Cursor = ...,
-        height: _ScreenUnits = ...,
+        border: _ScreenUnits = 0,
+        borderwidth: _ScreenUnits = 0,
+        class_: str = "Frame",  # can't be changed with configure()
+        colormap: Literal["new", ""] | Misc = "",  # can't be changed with configure()
+        container: bool = False,  # can't be changed with configure()
+        cursor: _Cursor = "",
+        height: _ScreenUnits = 0,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
-        highlightthickness: _ScreenUnits = ...,
+        highlightthickness: _ScreenUnits = 0,
         name: str = ...,
-        padx: _ScreenUnits = ...,
-        pady: _ScreenUnits = ...,
-        relief: _Relief = ...,
-        takefocus: _TakeFocusValue = ...,
-        visual: str | tuple[str, int] = ...,  # can't be changed with configure()
-        width: _ScreenUnits = ...,
+        padx: _ScreenUnits = 0,
+        pady: _ScreenUnits = 0,
+        relief: _Relief = "flat",
+        takefocus: _TakeFocusValue = 0,
+        visual: str | tuple[str, int] = "",  # can't be changed with configure()
+        width: _ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         background: str = ...,
@@ -2020,44 +2033,44 @@
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         activebackground: str = ...,
         activeforeground: str = ...,
-        anchor: _Anchor = ...,
+        anchor: _Anchor = "center",
         background: str = ...,
         bd: _ScreenUnits = ...,
         bg: str = ...,
-        bitmap: str = ...,
+        bitmap: str = "",
         border: _ScreenUnits = ...,
         borderwidth: _ScreenUnits = ...,
-        compound: _Compound = ...,
-        cursor: _Cursor = ...,
+        compound: _Compound = "none",
+        cursor: _Cursor = "",
         disabledforeground: str = ...,
         fg: str = ...,
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkDefaultFont",
         foreground: str = ...,
-        height: _ScreenUnits = ...,
+        height: _ScreenUnits = 0,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
-        highlightthickness: _ScreenUnits = ...,
-        image: _ImageSpec = ...,
-        justify: Literal["left", "center", "right"] = ...,
+        highlightthickness: _ScreenUnits = 0,
+        image: _ImageSpec = "",
+        justify: Literal["left", "center", "right"] = "center",
         name: str = ...,
-        padx: _ScreenUnits = ...,
-        pady: _ScreenUnits = ...,
-        relief: _Relief = ...,
-        state: Literal["normal", "active", "disabled"] = ...,
-        takefocus: _TakeFocusValue = ...,
-        text: float | str = ...,
+        padx: _ScreenUnits = 1,
+        pady: _ScreenUnits = 1,
+        relief: _Relief = "flat",
+        state: Literal["normal", "active", "disabled"] = "normal",
+        takefocus: _TakeFocusValue = 0,
+        text: float | str = "",
         textvariable: Variable = ...,
-        underline: int = ...,
-        width: _ScreenUnits = ...,
-        wraplength: _ScreenUnits = ...,
+        underline: int = -1,
+        width: _ScreenUnits = 0,
+        wraplength: _ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         activebackground: str = ...,
@@ -2100,56 +2113,56 @@
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         activestyle: Literal["dotbox", "none", "underline"] = ...,
         background: str = ...,
-        bd: _ScreenUnits = ...,
+        bd: _ScreenUnits = 1,
         bg: str = ...,
-        border: _ScreenUnits = ...,
-        borderwidth: _ScreenUnits = ...,
-        cursor: _Cursor = ...,
+        border: _ScreenUnits = 1,
+        borderwidth: _ScreenUnits = 1,
+        cursor: _Cursor = "",
         disabledforeground: str = ...,
-        exportselection: int = ...,
+        exportselection: bool | Literal[0, 1] = 1,
         fg: str = ...,
         font: _FontDescription = ...,
         foreground: str = ...,
-        height: int = ...,
+        height: int = 10,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
         highlightthickness: _ScreenUnits = ...,
-        justify: Literal["left", "center", "right"] = ...,
+        justify: Literal["left", "center", "right"] = "left",
         # There's no tkinter.ListVar, but seems like bare tkinter.Variable
         # actually works for this:
         #
         #    >>> import tkinter
         #    >>> lb = tkinter.Listbox()
         #    >>> var = lb['listvariable'] = tkinter.Variable()
         #    >>> var.set(['foo', 'bar', 'baz'])
         #    >>> lb.get(0, 'end')
         #    ('foo', 'bar', 'baz')
         listvariable: Variable = ...,
         name: str = ...,
         relief: _Relief = ...,
         selectbackground: str = ...,
-        selectborderwidth: _ScreenUnits = ...,
+        selectborderwidth: _ScreenUnits = 0,
         selectforeground: str = ...,
         # from listbox man page: "The value of the [selectmode] option may be
         # arbitrary, but the default bindings expect it to be ..."
         #
         # I have never seen anyone setting this to something else than what
         # "the default bindings expect", but let's support it anyway.
-        selectmode: str = ...,
-        setgrid: bool = ...,
-        state: Literal["normal", "disabled"] = ...,
-        takefocus: _TakeFocusValue = ...,
-        width: int = ...,
-        xscrollcommand: _XYScrollCommand = ...,
-        yscrollcommand: _XYScrollCommand = ...,
+        selectmode: str = "browse",
+        setgrid: bool = False,
+        state: Literal["normal", "disabled"] = "normal",
+        takefocus: _TakeFocusValue = "",
+        width: int = 20,
+        xscrollcommand: _XYScrollCommand = "",
+        yscrollcommand: _XYScrollCommand = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         activestyle: Literal["dotbox", "none", "underline"] = ...,
@@ -2219,31 +2232,31 @@
         activeborderwidth: _ScreenUnits = ...,
         activeforeground: str = ...,
         background: str = ...,
         bd: _ScreenUnits = ...,
         bg: str = ...,
         border: _ScreenUnits = ...,
         borderwidth: _ScreenUnits = ...,
-        cursor: _Cursor = ...,
+        cursor: _Cursor = "arrow",
         disabledforeground: str = ...,
         fg: str = ...,
         font: _FontDescription = ...,
         foreground: str = ...,
         name: str = ...,
-        postcommand: Callable[[], object] | str = ...,
+        postcommand: Callable[[], object] | str = "",
         relief: _Relief = ...,
         selectcolor: str = ...,
-        takefocus: _TakeFocusValue = ...,
-        tearoff: int = ...,
+        takefocus: _TakeFocusValue = 0,
+        tearoff: bool | Literal[0, 1] = 1,
         # I guess tearoffcommand arguments are supposed to be widget objects,
         # but they are widget name strings. Use nametowidget() to handle the
         # arguments of tearoffcommand.
-        tearoffcommand: Callable[[str, str], object] | str = ...,
-        title: str = ...,
-        type: Literal["menubar", "tearoff", "normal"] = ...,
+        tearoffcommand: Callable[[str, str], object] | str = "",
+        title: str = "",
+        type: Literal["menubar", "tearoff", "normal"] = "normal",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         activebackground: str = ...,
@@ -2487,43 +2500,43 @@
         *,
         activebackground: str = ...,
         activeforeground: str = ...,
         anchor: _Anchor = ...,
         background: str = ...,
         bd: _ScreenUnits = ...,
         bg: str = ...,
-        bitmap: str = ...,
+        bitmap: str = "",
         border: _ScreenUnits = ...,
         borderwidth: _ScreenUnits = ...,
-        compound: _Compound = ...,
-        cursor: _Cursor = ...,
-        direction: Literal["above", "below", "left", "right", "flush"] = ...,
+        compound: _Compound = "none",
+        cursor: _Cursor = "",
+        direction: Literal["above", "below", "left", "right", "flush"] = "below",
         disabledforeground: str = ...,
         fg: str = ...,
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkDefaultFont",
         foreground: str = ...,
-        height: _ScreenUnits = ...,
+        height: _ScreenUnits = 0,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
-        highlightthickness: _ScreenUnits = ...,
-        image: _ImageSpec = ...,
+        highlightthickness: _ScreenUnits = 0,
+        image: _ImageSpec = "",
         indicatoron: bool = ...,
         justify: Literal["left", "center", "right"] = ...,
         menu: Menu = ...,
         name: str = ...,
         padx: _ScreenUnits = ...,
         pady: _ScreenUnits = ...,
-        relief: _Relief = ...,
-        state: Literal["normal", "active", "disabled"] = ...,
-        takefocus: _TakeFocusValue = ...,
-        text: float | str = ...,
+        relief: _Relief = "flat",
+        state: Literal["normal", "active", "disabled"] = "normal",
+        takefocus: _TakeFocusValue = 0,
+        text: float | str = "",
         textvariable: Variable = ...,
-        underline: int = ...,
-        width: _ScreenUnits = ...,
-        wraplength: _ScreenUnits = ...,
+        underline: int = -1,
+        width: _ScreenUnits = 0,
+        wraplength: _ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         activebackground: str = ...,
@@ -2567,38 +2580,38 @@
 
 class Message(Widget):
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
-        anchor: _Anchor = ...,
-        aspect: int = ...,
+        anchor: _Anchor = "center",
+        aspect: int = 150,
         background: str = ...,
-        bd: _ScreenUnits = ...,
+        bd: _ScreenUnits = 1,
         bg: str = ...,
-        border: _ScreenUnits = ...,
-        borderwidth: _ScreenUnits = ...,
-        cursor: _Cursor = ...,
+        border: _ScreenUnits = 1,
+        borderwidth: _ScreenUnits = 1,
+        cursor: _Cursor = "",
         fg: str = ...,
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkDefaultFont",
         foreground: str = ...,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
-        highlightthickness: _ScreenUnits = ...,
-        justify: Literal["left", "center", "right"] = ...,
+        highlightthickness: _ScreenUnits = 0,
+        justify: Literal["left", "center", "right"] = "left",
         name: str = ...,
         padx: _ScreenUnits = ...,
         pady: _ScreenUnits = ...,
-        relief: _Relief = ...,
-        takefocus: _TakeFocusValue = ...,
-        text: float | str = ...,
+        relief: _Relief = "flat",
+        takefocus: _TakeFocusValue = 0,
+        text: float | str = "",
         textvariable: Variable = ...,
         # there's width but no height
-        width: _ScreenUnits = ...,
+        width: _ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         anchor: _Anchor = ...,
@@ -2632,54 +2645,54 @@
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         activebackground: str = ...,
         activeforeground: str = ...,
-        anchor: _Anchor = ...,
+        anchor: _Anchor = "center",
         background: str = ...,
         bd: _ScreenUnits = ...,
         bg: str = ...,
-        bitmap: str = ...,
+        bitmap: str = "",
         border: _ScreenUnits = ...,
         borderwidth: _ScreenUnits = ...,
-        command: _ButtonCommand = ...,
-        compound: _Compound = ...,
-        cursor: _Cursor = ...,
+        command: _ButtonCommand = "",
+        compound: _Compound = "none",
+        cursor: _Cursor = "",
         disabledforeground: str = ...,
         fg: str = ...,
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkDefaultFont",
         foreground: str = ...,
-        height: _ScreenUnits = ...,
+        height: _ScreenUnits = 0,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
-        highlightthickness: _ScreenUnits = ...,
-        image: _ImageSpec = ...,
-        indicatoron: bool = ...,
-        justify: Literal["left", "center", "right"] = ...,
+        highlightthickness: _ScreenUnits = 1,
+        image: _ImageSpec = "",
+        indicatoron: bool = True,
+        justify: Literal["left", "center", "right"] = "center",
         name: str = ...,
         offrelief: _Relief = ...,
-        overrelief: _Relief = ...,
-        padx: _ScreenUnits = ...,
-        pady: _ScreenUnits = ...,
-        relief: _Relief = ...,
+        overrelief: _Relief | Literal[""] = "",
+        padx: _ScreenUnits = 1,
+        pady: _ScreenUnits = 1,
+        relief: _Relief = "flat",
         selectcolor: str = ...,
-        selectimage: _ImageSpec = ...,
-        state: Literal["normal", "active", "disabled"] = ...,
-        takefocus: _TakeFocusValue = ...,
-        text: float | str = ...,
+        selectimage: _ImageSpec = "",
+        state: Literal["normal", "active", "disabled"] = "normal",
+        takefocus: _TakeFocusValue = "",
+        text: float | str = "",
         textvariable: Variable = ...,
-        tristateimage: _ImageSpec = ...,
-        tristatevalue: Any = ...,
-        underline: int = ...,
-        value: Any = ...,
+        tristateimage: _ImageSpec = "",
+        tristatevalue: Any = "",
+        underline: int = -1,
+        value: Any = "",
         variable: Variable | Literal[""] = ...,
-        width: _ScreenUnits = ...,
-        wraplength: _ScreenUnits = ...,
+        width: _ScreenUnits = 0,
+        wraplength: _ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         activebackground: str = ...,
@@ -2702,15 +2715,15 @@
         highlightbackground: str = ...,
         highlightcolor: str = ...,
         highlightthickness: _ScreenUnits = ...,
         image: _ImageSpec = ...,
         indicatoron: bool = ...,
         justify: Literal["left", "center", "right"] = ...,
         offrelief: _Relief = ...,
-        overrelief: _Relief = ...,
+        overrelief: _Relief | Literal[""] = ...,
         padx: _ScreenUnits = ...,
         pady: _ScreenUnits = ...,
         relief: _Relief = ...,
         selectcolor: str = ...,
         selectimage: _ImageSpec = ...,
         state: Literal["normal", "active", "disabled"] = ...,
         takefocus: _TakeFocusValue = ...,
@@ -2736,48 +2749,48 @@
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         activebackground: str = ...,
         background: str = ...,
-        bd: _ScreenUnits = ...,
+        bd: _ScreenUnits = 1,
         bg: str = ...,
-        bigincrement: float = ...,
-        border: _ScreenUnits = ...,
-        borderwidth: _ScreenUnits = ...,
+        bigincrement: float = 0.0,
+        border: _ScreenUnits = 1,
+        borderwidth: _ScreenUnits = 1,
         # don't know why the callback gets string instead of float
-        command: str | Callable[[str], object] = ...,
-        cursor: _Cursor = ...,
-        digits: int = ...,
+        command: str | Callable[[str], object] = "",
+        cursor: _Cursor = "",
+        digits: int = 0,
         fg: str = ...,
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkDefaultFont",
         foreground: str = ...,
-        from_: float = ...,
+        from_: float = 0.0,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
         highlightthickness: _ScreenUnits = ...,
-        label: str = ...,
-        length: _ScreenUnits = ...,
+        label: str = "",
+        length: _ScreenUnits = 100,
         name: str = ...,
-        orient: Literal["horizontal", "vertical"] = ...,
-        relief: _Relief = ...,
-        repeatdelay: int = ...,
-        repeatinterval: int = ...,
-        resolution: float = ...,
-        showvalue: bool = ...,
-        sliderlength: _ScreenUnits = ...,
-        sliderrelief: _Relief = ...,
-        state: Literal["normal", "active", "disabled"] = ...,
-        takefocus: _TakeFocusValue = ...,
-        tickinterval: float = ...,
-        to: float = ...,
+        orient: Literal["horizontal", "vertical"] = "vertical",
+        relief: _Relief = "flat",
+        repeatdelay: int = 300,
+        repeatinterval: int = 100,
+        resolution: float = 1.0,
+        showvalue: bool = True,
+        sliderlength: _ScreenUnits = 30,
+        sliderrelief: _Relief = "raised",
+        state: Literal["normal", "active", "disabled"] = "normal",
+        takefocus: _TakeFocusValue = "",
+        tickinterval: float = 0.0,
+        to: float = 100.0,
         troughcolor: str = ...,
         variable: IntVar | DoubleVar = ...,
-        width: _ScreenUnits = ...,
+        width: _ScreenUnits = 15,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         activebackground: str = ...,
@@ -2826,37 +2839,37 @@
 class Scrollbar(Widget):
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         activebackground: str = ...,
-        activerelief: _Relief = ...,
+        activerelief: _Relief = "raised",
         background: str = ...,
         bd: _ScreenUnits = ...,
         bg: str = ...,
         border: _ScreenUnits = ...,
         borderwidth: _ScreenUnits = ...,
         # There are many ways how the command may get called. Search for
         # 'SCROLLING COMMANDS' in scrollbar man page. There doesn't seem to
         # be any way to specify an overloaded callback function, so we say
         # that it can take any args while it can't in reality.
-        command: Callable[..., tuple[float, float] | None] | str = ...,
-        cursor: _Cursor = ...,
-        elementborderwidth: _ScreenUnits = ...,
+        command: Callable[..., tuple[float, float] | None] | str = "",
+        cursor: _Cursor = "",
+        elementborderwidth: _ScreenUnits = -1,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
-        highlightthickness: _ScreenUnits = ...,
-        jump: bool = ...,
+        highlightthickness: _ScreenUnits = 0,
+        jump: bool = False,
         name: str = ...,
-        orient: Literal["horizontal", "vertical"] = ...,
+        orient: Literal["horizontal", "vertical"] = "vertical",
         relief: _Relief = ...,
-        repeatdelay: int = ...,
-        repeatinterval: int = ...,
-        takefocus: _TakeFocusValue = ...,
+        repeatdelay: int = 300,
+        repeatinterval: int = 100,
+        takefocus: _TakeFocusValue = "",
         troughcolor: str = ...,
         width: _ScreenUnits = ...,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
@@ -2897,64 +2910,64 @@
 
 class Text(Widget, XView, YView):
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
-        autoseparators: bool = ...,
+        autoseparators: bool = True,
         background: str = ...,
         bd: _ScreenUnits = ...,
         bg: str = ...,
-        blockcursor: bool = ...,
+        blockcursor: bool = False,
         border: _ScreenUnits = ...,
         borderwidth: _ScreenUnits = ...,
-        cursor: _Cursor = ...,
-        endline: int | Literal[""] = ...,
-        exportselection: bool = ...,
+        cursor: _Cursor = "xterm",
+        endline: int | Literal[""] = "",
+        exportselection: bool = True,
         fg: str = ...,
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkFixedFont",
         foreground: str = ...,
         # width is always int, but height is allowed to be ScreenUnits.
         # This doesn't make any sense to me, and this isn't documented.
         # The docs seem to say that both should be integers.
-        height: _ScreenUnits = ...,
+        height: _ScreenUnits = 24,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
         highlightthickness: _ScreenUnits = ...,
         inactiveselectbackground: str = ...,
         insertbackground: str = ...,
-        insertborderwidth: _ScreenUnits = ...,
-        insertofftime: int = ...,
-        insertontime: int = ...,
-        insertunfocussed: Literal["none", "hollow", "solid"] = ...,
+        insertborderwidth: _ScreenUnits = 0,
+        insertofftime: int = 300,
+        insertontime: int = 600,
+        insertunfocussed: Literal["none", "hollow", "solid"] = "none",
         insertwidth: _ScreenUnits = ...,
-        maxundo: int = ...,
+        maxundo: int = 0,
         name: str = ...,
-        padx: _ScreenUnits = ...,
-        pady: _ScreenUnits = ...,
+        padx: _ScreenUnits = 1,
+        pady: _ScreenUnits = 1,
         relief: _Relief = ...,
         selectbackground: str = ...,
         selectborderwidth: _ScreenUnits = ...,
         selectforeground: str = ...,
-        setgrid: bool = ...,
-        spacing1: _ScreenUnits = ...,
-        spacing2: _ScreenUnits = ...,
-        spacing3: _ScreenUnits = ...,
-        startline: int | Literal[""] = ...,
-        state: Literal["normal", "disabled"] = ...,
+        setgrid: bool = False,
+        spacing1: _ScreenUnits = 0,
+        spacing2: _ScreenUnits = 0,
+        spacing3: _ScreenUnits = 0,
+        startline: int | Literal[""] = "",
+        state: Literal["normal", "disabled"] = "normal",
         # Literal inside Tuple doesn't actually work
-        tabs: _ScreenUnits | str | tuple[_ScreenUnits | str, ...] = ...,
-        tabstyle: Literal["tabular", "wordprocessor"] = ...,
-        takefocus: _TakeFocusValue = ...,
-        undo: bool = ...,
-        width: int = ...,
-        wrap: Literal["none", "char", "word"] = ...,
-        xscrollcommand: _XYScrollCommand = ...,
-        yscrollcommand: _XYScrollCommand = ...,
+        tabs: _ScreenUnits | str | tuple[_ScreenUnits | str, ...] = "",
+        tabstyle: Literal["tabular", "wordprocessor"] = "tabular",
+        takefocus: _TakeFocusValue = "",
+        undo: bool = False,
+        width: int = 80,
+        wrap: Literal["none", "char", "word"] = "char",
+        xscrollcommand: _XYScrollCommand = "",
+        yscrollcommand: _XYScrollCommand = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         autoseparators: bool = ...,
@@ -3181,15 +3194,15 @@
         underline: bool = ...,
         underlinefg: str = ...,
         wrap: Literal["none", "char", "word"] = ...,  # be careful with "none" vs None
     ) -> dict[str, tuple[str, str, str, Any, Any]] | None: ...
     @overload
     def tag_configure(self, tagName: str, cnf: str) -> tuple[str, str, str, Any, Any]: ...
     tag_config = tag_configure
-    def tag_delete(self, __first_tag_name: str, *tagNames: str) -> None: ...  # error if no tag names given
+    def tag_delete(self, first_tag_name: str, /, *tagNames: str) -> None: ...  # error if no tag names given
     def tag_lower(self, tagName: str, belowThis: str | None = None) -> None: ...
     def tag_names(self, index: _TextIndex | None = None) -> tuple[str, ...]: ...
     def tag_nextrange(
         self, tagName: str, index1: _TextIndex, index2: _TextIndex | None = None
     ) -> tuple[str, str] | tuple[()]: ...
     def tag_prevrange(
         self, tagName: str, index1: _TextIndex, index2: _TextIndex | None = None
@@ -3367,59 +3380,59 @@
         activebackground: str = ...,
         background: str = ...,
         bd: _ScreenUnits = ...,
         bg: str = ...,
         border: _ScreenUnits = ...,
         borderwidth: _ScreenUnits = ...,
         buttonbackground: str = ...,
-        buttoncursor: _Cursor = ...,
+        buttoncursor: _Cursor = "",
         buttondownrelief: _Relief = ...,
         buttonuprelief: _Relief = ...,
         # percent substitutions don't seem to be supported, it's similar to Entry's validation stuff
-        command: Callable[[], object] | str | list[str] | tuple[str, ...] = ...,
-        cursor: _Cursor = ...,
+        command: Callable[[], object] | str | list[str] | tuple[str, ...] = "",
+        cursor: _Cursor = "xterm",
         disabledbackground: str = ...,
         disabledforeground: str = ...,
-        exportselection: bool = ...,
+        exportselection: bool = True,
         fg: str = ...,
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkTextFont",
         foreground: str = ...,
-        format: str = ...,
-        from_: float = ...,
+        format: str = "",
+        from_: float = 0.0,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
         highlightthickness: _ScreenUnits = ...,
-        increment: float = ...,
+        increment: float = 1.0,
         insertbackground: str = ...,
-        insertborderwidth: _ScreenUnits = ...,
-        insertofftime: int = ...,
-        insertontime: int = ...,
+        insertborderwidth: _ScreenUnits = 0,
+        insertofftime: int = 300,
+        insertontime: int = 600,
         insertwidth: _ScreenUnits = ...,
-        invalidcommand: _EntryValidateCommand = ...,
-        invcmd: _EntryValidateCommand = ...,
-        justify: Literal["left", "center", "right"] = ...,
+        invalidcommand: _EntryValidateCommand = "",
+        invcmd: _EntryValidateCommand = "",
+        justify: Literal["left", "center", "right"] = "left",
         name: str = ...,
         readonlybackground: str = ...,
-        relief: _Relief = ...,
-        repeatdelay: int = ...,
-        repeatinterval: int = ...,
+        relief: _Relief = "sunken",
+        repeatdelay: int = 400,
+        repeatinterval: int = 100,
         selectbackground: str = ...,
         selectborderwidth: _ScreenUnits = ...,
         selectforeground: str = ...,
-        state: Literal["normal", "disabled", "readonly"] = ...,
-        takefocus: _TakeFocusValue = ...,
+        state: Literal["normal", "disabled", "readonly"] = "normal",
+        takefocus: _TakeFocusValue = "",
         textvariable: Variable = ...,
-        to: float = ...,
-        validate: Literal["none", "focus", "focusin", "focusout", "key", "all"] = ...,
-        validatecommand: _EntryValidateCommand = ...,
-        vcmd: _EntryValidateCommand = ...,
+        to: float = 0.0,
+        validate: Literal["none", "focus", "focusin", "focusout", "key", "all"] = "none",
+        validatecommand: _EntryValidateCommand = "",
+        vcmd: _EntryValidateCommand = "",
         values: list[str] | tuple[str, ...] = ...,
-        width: int = ...,
-        wrap: bool = ...,
-        xscrollcommand: _XYScrollCommand = ...,
+        width: int = 20,
+        wrap: bool = False,
+        xscrollcommand: _XYScrollCommand = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         activebackground: str = ...,
@@ -3477,16 +3490,16 @@
     def configure(self, cnf: str) -> tuple[str, str, str, Any, Any]: ...
     config = configure
     def bbox(self, index) -> tuple[int, int, int, int] | None: ...  # type: ignore[override]
     def delete(self, first, last: Incomplete | None = None) -> Literal[""]: ...
     def get(self) -> str: ...
     def icursor(self, index): ...
     def identify(self, x: int, y: int) -> Literal["", "buttondown", "buttonup", "entry"]: ...
-    def index(self, index: _EntryIndex) -> int: ...
-    def insert(self, index: _EntryIndex, s: str) -> Literal[""]: ...
+    def index(self, index: str | int) -> int: ...
+    def insert(self, index: str | int, s: str) -> Literal[""]: ...
     # spinbox.invoke("asdf") gives error mentioning .invoke("none"), but it's not documented
     def invoke(self, element: Literal["none", "buttonup", "buttondown"]) -> Literal[""]: ...
     def scan(self, *args): ...
     def scan_mark(self, x): ...
     def scan_dragto(self, x): ...
     def selection(self, *args) -> tuple[int, ...]: ...
     def selection_adjust(self, index): ...
@@ -3500,40 +3513,40 @@
 class LabelFrame(Widget):
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         background: str = ...,
-        bd: _ScreenUnits = ...,
+        bd: _ScreenUnits = 2,
         bg: str = ...,
-        border: _ScreenUnits = ...,
-        borderwidth: _ScreenUnits = ...,
-        class_: str = ...,  # can't be changed with configure()
-        colormap: Literal["new", ""] | Misc = ...,  # can't be changed with configure()
-        container: bool = ...,  # undocumented, can't be changed with configure()
-        cursor: _Cursor = ...,
+        border: _ScreenUnits = 2,
+        borderwidth: _ScreenUnits = 2,
+        class_: str = "Labelframe",  # can't be changed with configure()
+        colormap: Literal["new", ""] | Misc = "",  # can't be changed with configure()
+        container: bool = False,  # undocumented, can't be changed with configure()
+        cursor: _Cursor = "",
         fg: str = ...,
-        font: _FontDescription = ...,
+        font: _FontDescription = "TkDefaultFont",
         foreground: str = ...,
-        height: _ScreenUnits = ...,
+        height: _ScreenUnits = 0,
         highlightbackground: str = ...,
         highlightcolor: str = ...,
-        highlightthickness: _ScreenUnits = ...,
+        highlightthickness: _ScreenUnits = 0,
         # 'ne' and 'en' are valid labelanchors, but only 'ne' is a valid _Anchor.
-        labelanchor: Literal["nw", "n", "ne", "en", "e", "es", "se", "s", "sw", "ws", "w", "wn"] = ...,
+        labelanchor: Literal["nw", "n", "ne", "en", "e", "es", "se", "s", "sw", "ws", "w", "wn"] = "nw",
         labelwidget: Misc = ...,
         name: str = ...,
-        padx: _ScreenUnits = ...,
-        pady: _ScreenUnits = ...,
-        relief: _Relief = ...,
-        takefocus: _TakeFocusValue = ...,
-        text: float | str = ...,
-        visual: str | tuple[str, int] = ...,  # can't be changed with configure()
-        width: _ScreenUnits = ...,
+        padx: _ScreenUnits = 0,
+        pady: _ScreenUnits = 0,
+        relief: _Relief = "groove",
+        takefocus: _TakeFocusValue = 0,
+        text: float | str = "",
+        visual: str | tuple[str, int] = "",  # can't be changed with configure()
+        width: _ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         background: str = ...,
@@ -3565,35 +3578,35 @@
 class PanedWindow(Widget):
     def __init__(
         self,
         master: Misc | None = None,
         cnf: dict[str, Any] | None = {},
         *,
         background: str = ...,
-        bd: _ScreenUnits = ...,
+        bd: _ScreenUnits = 1,
         bg: str = ...,
-        border: _ScreenUnits = ...,
-        borderwidth: _ScreenUnits = ...,
-        cursor: _Cursor = ...,
-        handlepad: _ScreenUnits = ...,
-        handlesize: _ScreenUnits = ...,
-        height: _ScreenUnits = ...,
+        border: _ScreenUnits = 1,
+        borderwidth: _ScreenUnits = 1,
+        cursor: _Cursor = "",
+        handlepad: _ScreenUnits = 8,
+        handlesize: _ScreenUnits = 8,
+        height: _ScreenUnits = "",
         name: str = ...,
-        opaqueresize: bool = ...,
-        orient: Literal["horizontal", "vertical"] = ...,
-        proxybackground: str = ...,
-        proxyborderwidth: _ScreenUnits = ...,
-        proxyrelief: _Relief = ...,
-        relief: _Relief = ...,
-        sashcursor: _Cursor = ...,
-        sashpad: _ScreenUnits = ...,
-        sashrelief: _Relief = ...,
-        sashwidth: _ScreenUnits = ...,
-        showhandle: bool = ...,
-        width: _ScreenUnits = ...,
+        opaqueresize: bool = True,
+        orient: Literal["horizontal", "vertical"] = "horizontal",
+        proxybackground: str = "",
+        proxyborderwidth: _ScreenUnits = 2,
+        proxyrelief: _Relief = "flat",
+        relief: _Relief = "flat",
+        sashcursor: _Cursor = "",
+        sashpad: _ScreenUnits = 0,
+        sashrelief: _Relief = "flat",
+        sashwidth: _ScreenUnits = 3,
+        showhandle: bool = False,
+        width: _ScreenUnits = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         background: str = ...,
```

## puya/_vendor/mypy/typeshed/stdlib/tkinter/commondialog.pyi

```diff
@@ -6,9 +6,9 @@
 if sys.version_info >= (3, 9):
     __all__ = ["Dialog"]
 
 class Dialog:
     command: ClassVar[str | None]
     master: Incomplete | None
     options: Mapping[str, Incomplete]
-    def __init__(self, master: Incomplete | None = None, **options: Incomplete) -> None: ...
-    def show(self, **options: Incomplete) -> Incomplete: ...
+    def __init__(self, master: Incomplete | None = None, **options) -> None: ...
+    def show(self, **options): ...
```

## puya/_vendor/mypy/typeshed/stdlib/tkinter/dialog.pyi

```diff
@@ -8,9 +8,9 @@
     __all__ = ["Dialog"]
 
 DIALOG_ICON: str
 
 class Dialog(Widget):
     widgetName: str
     num: int
-    def __init__(self, master: Incomplete | None = None, cnf: Mapping[str, Any] = {}, **kw: Incomplete) -> None: ...
+    def __init__(self, master: Incomplete | None = None, cnf: Mapping[str, Any] = {}, **kw) -> None: ...
     def destroy(self) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/tkinter/dnd.pyi

```diff
@@ -2,15 +2,15 @@
 from tkinter import Event, Misc, Tk, Widget
 from typing import ClassVar, Protocol
 
 if sys.version_info >= (3, 9):
     __all__ = ["dnd_start", "DndHandler"]
 
 class _DndSource(Protocol):
-    def dnd_end(self, __target: Widget | None, __event: Event[Misc] | None) -> None: ...
+    def dnd_end(self, target: Widget | None, event: Event[Misc] | None, /) -> None: ...
 
 class DndHandler:
     root: ClassVar[Tk | None]
     def __init__(self, source: _DndSource, event: Event[Misc]) -> None: ...
     def cancel(self, event: Event[Misc] | None = None) -> None: ...
     def finish(self, event: Event[Misc] | None, commit: int = 0) -> None: ...
     def on_motion(self, event: Event[Misc]) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/tkinter/font.pyi

```diff
@@ -93,17 +93,17 @@
         slant: Literal["roman", "italic"] = ...,
         underline: bool = ...,
         overstrike: bool = ...,
     ) -> _FontDict | None: ...
     configure = config
     def copy(self) -> Font: ...
     @overload
-    def metrics(self, __option: Literal["ascent", "descent", "linespace"], *, displayof: tkinter.Misc | None = ...) -> int: ...
+    def metrics(self, option: Literal["ascent", "descent", "linespace"], /, *, displayof: tkinter.Misc | None = ...) -> int: ...
     @overload
-    def metrics(self, __option: Literal["fixed"], *, displayof: tkinter.Misc | None = ...) -> bool: ...
+    def metrics(self, option: Literal["fixed"], /, *, displayof: tkinter.Misc | None = ...) -> bool: ...
     @overload
     def metrics(self, *, displayof: tkinter.Misc | None = ...) -> _MetricsDict: ...
     def measure(self, text: str, displayof: tkinter.Misc | None = None) -> int: ...
     def __eq__(self, other: object) -> bool: ...
     def __del__(self) -> None: ...
 
 def families(root: tkinter.Misc | None = None, displayof: tkinter.Misc | None = None) -> tuple[str, ...]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/tkinter/scrolledtext.pyi

```diff
@@ -1,10 +1,9 @@
-from _typeshed import Incomplete
 from tkinter import Frame, Misc, Scrollbar, Text
 
 __all__ = ["ScrolledText"]
 
 # The methods from Pack, Place, and Grid are dynamically added over the parent's impls
 class ScrolledText(Text):
     frame: Frame
     vbar: Scrollbar
-    def __init__(self, master: Misc | None = None, **kwargs: Incomplete) -> None: ...
+    def __init__(self, master: Misc | None = None, **kwargs) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/tkinter/ttk.pyi

```diff
@@ -42,15 +42,15 @@
     | tuple[tkinter._ScreenUnits]
     | tuple[tkinter._ScreenUnits, tkinter._ScreenUnits]
     | tuple[tkinter._ScreenUnits, tkinter._ScreenUnits, tkinter._ScreenUnits]
     | tuple[tkinter._ScreenUnits, tkinter._ScreenUnits, tkinter._ScreenUnits, tkinter._ScreenUnits]
 )
 
 # from ttk_widget (aka ttk::widget) manual page, differs from tkinter._Compound
-_TtkCompound: TypeAlias = Literal["text", "image", tkinter._Compound]
+_TtkCompound: TypeAlias = Literal["", "text", "image", tkinter._Compound]
 
 class Style:
     master: Incomplete
     tk: _tkinter.TkappType
     def __init__(self, master: tkinter.Misc | None = None) -> None: ...
     def configure(self, style, query_opt: Incomplete | None = None, **kw): ...
     def map(self, style, query_opt: Incomplete | None = None, **kw): ...
@@ -74,29 +74,29 @@
     def state(self, statespec: Incomplete | None = None): ...
 
 class Button(Widget):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        command: tkinter._ButtonCommand = ...,
-        compound: _TtkCompound = ...,
-        cursor: tkinter._Cursor = ...,
-        default: Literal["normal", "active", "disabled"] = ...,
-        image: tkinter._ImageSpec = ...,
+        class_: str = "",
+        command: tkinter._ButtonCommand = "",
+        compound: _TtkCompound = "",
+        cursor: tkinter._Cursor = "",
+        default: Literal["normal", "active", "disabled"] = "normal",
+        image: tkinter._ImageSpec = "",
         name: str = ...,
         padding=...,  # undocumented
-        state: str = ...,
-        style: str = ...,
+        state: str = "normal",
+        style: str = "",
         takefocus: tkinter._TakeFocusValue = ...,
-        text: float | str = ...,
+        text: float | str = "",
         textvariable: tkinter.Variable = ...,
-        underline: int = ...,
-        width: int | Literal[""] = ...,
+        underline: int = -1,
+        width: int | Literal[""] = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         command: tkinter._ButtonCommand = ...,
@@ -119,34 +119,34 @@
     def invoke(self) -> Any: ...
 
 class Checkbutton(Widget):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        command: tkinter._ButtonCommand = ...,
-        compound: _TtkCompound = ...,
-        cursor: tkinter._Cursor = ...,
-        image: tkinter._ImageSpec = ...,
+        class_: str = "",
+        command: tkinter._ButtonCommand = "",
+        compound: _TtkCompound = "",
+        cursor: tkinter._Cursor = "",
+        image: tkinter._ImageSpec = "",
         name: str = ...,
-        offvalue: Any = ...,
-        onvalue: Any = ...,
+        offvalue: Any = 0,
+        onvalue: Any = 1,
         padding=...,  # undocumented
-        state: str = ...,
-        style: str = ...,
+        state: str = "normal",
+        style: str = "",
         takefocus: tkinter._TakeFocusValue = ...,
-        text: float | str = ...,
+        text: float | str = "",
         textvariable: tkinter.Variable = ...,
-        underline: int = ...,
+        underline: int = -1,
         # Seems like variable can be empty string, but actually setting it to
         # empty string segfaults before Tcl 8.6.9. Search for ttk::checkbutton
         # here: https://sourceforge.net/projects/tcl/files/Tcl/8.6.9/tcltk-release-notes-8.6.9.txt/view
         variable: tkinter.Variable = ...,
-        width: int | Literal[""] = ...,
+        width: int | Literal[""] = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         command: tkinter._ButtonCommand = ...,
@@ -173,31 +173,31 @@
 class Entry(Widget, tkinter.Entry):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         widget: str | None = None,
         *,
         background: str = ...,  # undocumented
-        class_: str = ...,
+        class_: str = "",
         cursor: tkinter._Cursor = ...,
-        exportselection: bool = ...,
-        font: _FontDescription = ...,
-        foreground: str = ...,
-        invalidcommand: tkinter._EntryValidateCommand = ...,
-        justify: Literal["left", "center", "right"] = ...,
+        exportselection: bool = True,
+        font: _FontDescription = "TkTextFont",
+        foreground: str = "",
+        invalidcommand: tkinter._EntryValidateCommand = "",
+        justify: Literal["left", "center", "right"] = "left",
         name: str = ...,
-        show: str = ...,
-        state: str = ...,
-        style: str = ...,
+        show: str = "",
+        state: str = "normal",
+        style: str = "",
         takefocus: tkinter._TakeFocusValue = ...,
         textvariable: tkinter.Variable = ...,
-        validate: Literal["none", "focus", "focusin", "focusout", "key", "all"] = ...,
-        validatecommand: tkinter._EntryValidateCommand = ...,
-        width: int = ...,
-        xscrollcommand: tkinter._XYScrollCommand = ...,
+        validate: Literal["none", "focus", "focusin", "focusout", "key", "all"] = "none",
+        validatecommand: tkinter._EntryValidateCommand = "",
+        width: int = 20,
+        xscrollcommand: tkinter._XYScrollCommand = "",
     ) -> None: ...
     @overload  # type: ignore[override]
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         background: str = ...,
@@ -250,33 +250,33 @@
 
 class Combobox(Entry):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
         background: str = ...,  # undocumented
-        class_: str = ...,
-        cursor: tkinter._Cursor = ...,
-        exportselection: bool = ...,
+        class_: str = "",
+        cursor: tkinter._Cursor = "",
+        exportselection: bool = True,
         font: _FontDescription = ...,  # undocumented
         foreground: str = ...,  # undocumented
-        height: int = ...,
+        height: int = 10,
         invalidcommand: tkinter._EntryValidateCommand = ...,  # undocumented
-        justify: Literal["left", "center", "right"] = ...,
+        justify: Literal["left", "center", "right"] = "left",
         name: str = ...,
-        postcommand: Callable[[], object] | str = ...,
+        postcommand: Callable[[], object] | str = "",
         show=...,  # undocumented
-        state: str = ...,
-        style: str = ...,
+        state: str = "normal",
+        style: str = "",
         takefocus: tkinter._TakeFocusValue = ...,
         textvariable: tkinter.Variable = ...,
         validate: Literal["none", "focus", "focusin", "focusout", "key", "all"] = ...,  # undocumented
         validatecommand: tkinter._EntryValidateCommand = ...,  # undocumented
         values: list[str] | tuple[str, ...] = ...,
-        width: int = ...,
+        width: int = 20,
         xscrollcommand: tkinter._XYScrollCommand = ...,  # undocumented
     ) -> None: ...
     @overload  # type: ignore[override]
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
@@ -330,29 +330,31 @@
     ) -> dict[str, tuple[str, str, str, Any, Any]] | None: ...
     @overload
     def config(self, cnf: str) -> tuple[str, str, str, Any, Any]: ...
     def current(self, newindex: int | None = None) -> int: ...
     def set(self, value: Any) -> None: ...
 
 class Frame(Widget):
+    # This should be kept in sync with tkinter.ttk.LabeledScale.__init__()
+    # (all of these keyword-only arguments are also present there)
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
         border: tkinter._ScreenUnits = ...,
         borderwidth: tkinter._ScreenUnits = ...,
-        class_: str = ...,
-        cursor: tkinter._Cursor = ...,
-        height: tkinter._ScreenUnits = ...,
+        class_: str = "",
+        cursor: tkinter._Cursor = "",
+        height: tkinter._ScreenUnits = 0,
         name: str = ...,
         padding: _Padding = ...,
         relief: tkinter._Relief = ...,
-        style: str = ...,
-        takefocus: tkinter._TakeFocusValue = ...,
-        width: tkinter._ScreenUnits = ...,
+        style: str = "",
+        takefocus: tkinter._TakeFocusValue = "",
+        width: tkinter._ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         border: tkinter._ScreenUnits = ...,
@@ -371,34 +373,34 @@
 
 class Label(Widget):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
         anchor: tkinter._Anchor = ...,
-        background: str = ...,
+        background: str = "",
         border: tkinter._ScreenUnits = ...,  # alias for borderwidth
         borderwidth: tkinter._ScreenUnits = ...,  # undocumented
-        class_: str = ...,
-        compound: _TtkCompound = ...,
-        cursor: tkinter._Cursor = ...,
+        class_: str = "",
+        compound: _TtkCompound = "",
+        cursor: tkinter._Cursor = "",
         font: _FontDescription = ...,
-        foreground: str = ...,
-        image: tkinter._ImageSpec = ...,
+        foreground: str = "",
+        image: tkinter._ImageSpec = "",
         justify: Literal["left", "center", "right"] = ...,
         name: str = ...,
         padding: _Padding = ...,
         relief: tkinter._Relief = ...,
-        state: str = ...,
-        style: str = ...,
-        takefocus: tkinter._TakeFocusValue = ...,
-        text: float | str = ...,
+        state: str = "normal",
+        style: str = "",
+        takefocus: tkinter._TakeFocusValue = "",
+        text: float | str = "",
         textvariable: tkinter.Variable = ...,
-        underline: int = ...,
-        width: int | Literal[""] = ...,
+        underline: int = -1,
+        width: int | Literal[""] = "",
         wraplength: tkinter._ScreenUnits = ...,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
@@ -430,27 +432,27 @@
 class Labelframe(Widget):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
         border: tkinter._ScreenUnits = ...,
         borderwidth: tkinter._ScreenUnits = ...,  # undocumented
-        class_: str = ...,
-        cursor: tkinter._Cursor = ...,
-        height: tkinter._ScreenUnits = ...,
+        class_: str = "",
+        cursor: tkinter._Cursor = "",
+        height: tkinter._ScreenUnits = 0,
         labelanchor: Literal["nw", "n", "ne", "en", "e", "es", "se", "s", "sw", "ws", "w", "wn"] = ...,
         labelwidget: tkinter.Misc = ...,
         name: str = ...,
         padding: _Padding = ...,
         relief: tkinter._Relief = ...,  # undocumented
-        style: str = ...,
-        takefocus: tkinter._TakeFocusValue = ...,
-        text: float | str = ...,
-        underline: int = ...,
-        width: tkinter._ScreenUnits = ...,
+        style: str = "",
+        takefocus: tkinter._TakeFocusValue = "",
+        text: float | str = "",
+        underline: int = -1,
+        width: tkinter._ScreenUnits = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         border: tkinter._ScreenUnits = ...,
@@ -474,29 +476,29 @@
 LabelFrame = Labelframe
 
 class Menubutton(Widget):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        compound: _TtkCompound = ...,
-        cursor: tkinter._Cursor = ...,
-        direction: Literal["above", "below", "left", "right", "flush"] = ...,
-        image: tkinter._ImageSpec = ...,
+        class_: str = "",
+        compound: _TtkCompound = "",
+        cursor: tkinter._Cursor = "",
+        direction: Literal["above", "below", "left", "right", "flush"] = "below",
+        image: tkinter._ImageSpec = "",
         menu: tkinter.Menu = ...,
         name: str = ...,
         padding=...,  # undocumented
-        state: str = ...,
-        style: str = ...,
+        state: str = "normal",
+        style: str = "",
         takefocus: tkinter._TakeFocusValue = ...,
-        text: float | str = ...,
+        text: float | str = "",
         textvariable: tkinter.Variable = ...,
-        underline: int = ...,
-        width: int | Literal[""] = ...,
+        underline: int = -1,
+        width: int | Literal[""] = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         compound: _TtkCompound = ...,
@@ -518,22 +520,22 @@
     config = configure
 
 class Notebook(Widget):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        cursor: tkinter._Cursor = ...,
-        height: int = ...,
+        class_: str = "",
+        cursor: tkinter._Cursor = "",
+        height: int = 0,
         name: str = ...,
         padding: _Padding = ...,
-        style: str = ...,
+        style: str = "",
         takefocus: tkinter._TakeFocusValue = ...,
-        width: int = ...,
+        width: int = 0,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         cursor: tkinter._Cursor = ...,
@@ -569,23 +571,23 @@
     def enable_traversal(self) -> None: ...
 
 class Panedwindow(Widget, tkinter.PanedWindow):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        cursor: tkinter._Cursor = ...,
+        class_: str = "",
+        cursor: tkinter._Cursor = "",
         # width and height for tkinter.ttk.Panedwindow are int but for tkinter.PanedWindow they are screen units
-        height: int = ...,
+        height: int = 0,
         name: str = ...,
-        orient: Literal["vertical", "horizontal"] = ...,  # can't be changed with configure()
-        style: str = ...,
-        takefocus: tkinter._TakeFocusValue = ...,
-        width: int = ...,
+        orient: Literal["vertical", "horizontal"] = "vertical",  # can't be changed with configure()
+        style: str = "",
+        takefocus: tkinter._TakeFocusValue = "",
+        width: int = 0,
     ) -> None: ...
     def add(self, child: tkinter.Widget, *, weight: int = ..., **kw) -> None: ...
     @overload  # type: ignore[override]
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
@@ -619,25 +621,25 @@
 PanedWindow = Panedwindow
 
 class Progressbar(Widget):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        cursor: tkinter._Cursor = ...,
-        length: tkinter._ScreenUnits = ...,
-        maximum: float = ...,
-        mode: Literal["determinate", "indeterminate"] = ...,
+        class_: str = "",
+        cursor: tkinter._Cursor = "",
+        length: tkinter._ScreenUnits = 100,
+        maximum: float = 100,
+        mode: Literal["determinate", "indeterminate"] = "determinate",
         name: str = ...,
-        orient: Literal["horizontal", "vertical"] = ...,
-        phase: int = ...,  # docs say read-only but assigning int to this works
-        style: str = ...,
-        takefocus: tkinter._TakeFocusValue = ...,
-        value: float = ...,
+        orient: Literal["horizontal", "vertical"] = "horizontal",
+        phase: int = 0,  # docs say read-only but assigning int to this works
+        style: str = "",
+        takefocus: tkinter._TakeFocusValue = "",
+        value: float = 0.0,
         variable: tkinter.IntVar | tkinter.DoubleVar = ...,
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
@@ -660,30 +662,30 @@
     def stop(self) -> None: ...
 
 class Radiobutton(Widget):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        command: tkinter._ButtonCommand = ...,
-        compound: _TtkCompound = ...,
-        cursor: tkinter._Cursor = ...,
-        image: tkinter._ImageSpec = ...,
+        class_: str = "",
+        command: tkinter._ButtonCommand = "",
+        compound: _TtkCompound = "",
+        cursor: tkinter._Cursor = "",
+        image: tkinter._ImageSpec = "",
         name: str = ...,
         padding=...,  # undocumented
-        state: str = ...,
-        style: str = ...,
+        state: str = "normal",
+        style: str = "",
         takefocus: tkinter._TakeFocusValue = ...,
-        text: float | str = ...,
+        text: float | str = "",
         textvariable: tkinter.Variable = ...,
-        underline: int = ...,
-        value: Any = ...,
+        underline: int = -1,
+        value: Any = "1",
         variable: tkinter.Variable | Literal[""] = ...,
-        width: int | Literal[""] = ...,
+        width: int | Literal[""] = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         command: tkinter._ButtonCommand = ...,
@@ -708,26 +710,26 @@
 
 # type ignore, because identify() methods of Widget and tkinter.Scale are incompatible
 class Scale(Widget, tkinter.Scale):  # type: ignore[misc]
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        command: str | Callable[[str], object] = ...,
-        cursor: tkinter._Cursor = ...,
-        from_: float = ...,
-        length: tkinter._ScreenUnits = ...,
+        class_: str = "",
+        command: str | Callable[[str], object] = "",
+        cursor: tkinter._Cursor = "",
+        from_: float = 0,
+        length: tkinter._ScreenUnits = 100,
         name: str = ...,
-        orient: Literal["horizontal", "vertical"] = ...,
+        orient: Literal["horizontal", "vertical"] = "horizontal",
         state: str = ...,  # undocumented
-        style: str = ...,
+        style: str = "",
         takefocus: tkinter._TakeFocusValue = ...,
-        to: float = ...,
-        value: float = ...,
+        to: float = 1.0,
+        value: float = 0,
         variable: tkinter.IntVar | tkinter.DoubleVar = ...,
     ) -> None: ...
     @overload  # type: ignore[override]
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
@@ -769,21 +771,21 @@
 
 # type ignore, because identify() methods of Widget and tkinter.Scale are incompatible
 class Scrollbar(Widget, tkinter.Scrollbar):  # type: ignore[misc]
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        command: Callable[..., tuple[float, float] | None] | str = ...,
-        cursor: tkinter._Cursor = ...,
+        class_: str = "",
+        command: Callable[..., tuple[float, float] | None] | str = "",
+        cursor: tkinter._Cursor = "",
         name: str = ...,
-        orient: Literal["horizontal", "vertical"] = ...,
-        style: str = ...,
-        takefocus: tkinter._TakeFocusValue = ...,
+        orient: Literal["horizontal", "vertical"] = "vertical",
+        style: str = "",
+        takefocus: tkinter._TakeFocusValue = "",
     ) -> None: ...
     @overload  # type: ignore[override]
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         command: Callable[..., tuple[float, float] | None] | str = ...,
@@ -810,20 +812,20 @@
     def config(self, cnf: str) -> tuple[str, str, str, Any, Any]: ...
 
 class Separator(Widget):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        cursor: tkinter._Cursor = ...,
+        class_: str = "",
+        cursor: tkinter._Cursor = "",
         name: str = ...,
-        orient: Literal["horizontal", "vertical"] = ...,
-        style: str = ...,
-        takefocus: tkinter._TakeFocusValue = ...,
+        orient: Literal["horizontal", "vertical"] = "horizontal",
+        style: str = "",
+        takefocus: tkinter._TakeFocusValue = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         cursor: tkinter._Cursor = ...,
@@ -836,19 +838,19 @@
     config = configure
 
 class Sizegrip(Widget):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
+        class_: str = "",
         cursor: tkinter._Cursor = ...,
         name: str = ...,
-        style: str = ...,
-        takefocus: tkinter._TakeFocusValue = ...,
+        style: str = "",
+        takefocus: tkinter._TakeFocusValue = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         cursor: tkinter._Cursor = ...,
@@ -861,38 +863,38 @@
 
 class Spinbox(Entry):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
         background: str = ...,  # undocumented
-        class_: str = ...,
-        command: Callable[[], object] | str | list[str] | tuple[str, ...] = ...,
-        cursor: tkinter._Cursor = ...,
+        class_: str = "",
+        command: Callable[[], object] | str | list[str] | tuple[str, ...] = "",
+        cursor: tkinter._Cursor = "",
         exportselection: bool = ...,  # undocumented
         font: _FontDescription = ...,  # undocumented
         foreground: str = ...,  # undocumented
-        format: str = ...,
-        from_: float = ...,
-        increment: float = ...,
+        format: str = "",
+        from_: float = 0,
+        increment: float = 1,
         invalidcommand: tkinter._EntryValidateCommand = ...,  # undocumented
         justify: Literal["left", "center", "right"] = ...,  # undocumented
         name: str = ...,
         show=...,  # undocumented
-        state: str = ...,
-        style: str = ...,
+        state: str = "normal",
+        style: str = "",
         takefocus: tkinter._TakeFocusValue = ...,
         textvariable: tkinter.Variable = ...,  # undocumented
-        to: float = ...,
-        validate: Literal["none", "focus", "focusin", "focusout", "key", "all"] = ...,
-        validatecommand: tkinter._EntryValidateCommand = ...,
+        to: float = 0,
+        validate: Literal["none", "focus", "focusin", "focusout", "key", "all"] = "none",
+        validatecommand: tkinter._EntryValidateCommand = "",
         values: list[str] | tuple[str, ...] = ...,
         width: int = ...,  # undocumented
-        wrap: bool = ...,
-        xscrollcommand: tkinter._XYScrollCommand = ...,
+        wrap: bool = False,
+        xscrollcommand: tkinter._XYScrollCommand = "",
     ) -> None: ...
     @overload  # type: ignore[override]
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         background: str = ...,
@@ -953,31 +955,31 @@
     id: str
 
 class Treeview(Widget, tkinter.XView, tkinter.YView):
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         *,
-        class_: str = ...,
-        columns: str | list[str] | list[int] | list[str | int] | tuple[str | int, ...] = ...,
-        cursor: tkinter._Cursor = ...,
-        displaycolumns: str | int | list[str] | tuple[str, ...] | list[int] | tuple[int, ...] = ...,
-        height: int = ...,
+        class_: str = "",
+        columns: str | list[str] | list[int] | list[str | int] | tuple[str | int, ...] = "",
+        cursor: tkinter._Cursor = "",
+        displaycolumns: str | int | list[str] | tuple[str, ...] | list[int] | tuple[int, ...] = ("#all",),
+        height: int = 10,
         name: str = ...,
         padding: _Padding = ...,
-        selectmode: Literal["extended", "browse", "none"] = ...,
+        selectmode: Literal["extended", "browse", "none"] = "extended",
         # list/tuple of Literal don't actually work in mypy
         #
         # 'tree headings' is same as ['tree', 'headings'], and I wouldn't be
         # surprised if someone is using it.
-        show: Literal["tree", "headings", "tree headings", ""] | list[str] | tuple[str, ...] = ...,
-        style: str = ...,
+        show: Literal["tree", "headings", "tree headings", ""] | list[str] | tuple[str, ...] = ("tree", "headings"),
+        style: str = "",
         takefocus: tkinter._TakeFocusValue = ...,
-        xscrollcommand: tkinter._XYScrollCommand = ...,
-        yscrollcommand: tkinter._XYScrollCommand = ...,
+        xscrollcommand: tkinter._XYScrollCommand = "",
+        yscrollcommand: tkinter._XYScrollCommand = "",
     ) -> None: ...
     @overload
     def configure(
         self,
         cnf: dict[str, Any] | None = None,
         *,
         columns: str | list[str] | list[int] | list[str | int] | tuple[str | int, ...] = ...,
@@ -1099,27 +1101,27 @@
     reattach = move
     def next(self, item: str | int) -> str: ...  # returning empty string means last item
     def parent(self, item: str | int) -> str: ...
     def prev(self, item: str | int) -> str: ...  # returning empty string means first item
     def see(self, item: str | int) -> None: ...
     def selection(self) -> tuple[str, ...]: ...
     @overload
-    def selection_set(self, __items: list[str] | tuple[str, ...] | list[int] | tuple[int, ...]) -> None: ...
+    def selection_set(self, items: list[str] | tuple[str, ...] | list[int] | tuple[int, ...], /) -> None: ...
     @overload
     def selection_set(self, *items: str | int) -> None: ...
     @overload
-    def selection_add(self, __items: list[str] | tuple[str, ...] | list[int] | tuple[int, ...]) -> None: ...
+    def selection_add(self, items: list[str] | tuple[str, ...] | list[int] | tuple[int, ...], /) -> None: ...
     @overload
     def selection_add(self, *items: str | int) -> None: ...
     @overload
-    def selection_remove(self, __items: list[str] | tuple[str, ...] | list[int] | tuple[int, ...]) -> None: ...
+    def selection_remove(self, items: list[str] | tuple[str, ...] | list[int] | tuple[int, ...], /) -> None: ...
     @overload
     def selection_remove(self, *items: str | int) -> None: ...
     @overload
-    def selection_toggle(self, __items: list[str] | tuple[str, ...] | list[int] | tuple[int, ...]) -> None: ...
+    def selection_toggle(self, items: list[str] | tuple[str, ...] | list[int] | tuple[int, ...], /) -> None: ...
     @overload
     def selection_toggle(self, *items: str | int) -> None: ...
     @overload
     def set(self, item: str | int, column: None = None, value: None = None) -> dict[str, Any]: ...
     @overload
     def set(self, item: str | int, column: str | int, value: None = None) -> Any: ...
     @overload
@@ -1154,38 +1156,49 @@
     ) -> _TreeviewTagDict | Any: ...  # can be None but annoying to check
     @overload
     def tag_has(self, tagname: str, item: None = None) -> tuple[str, ...]: ...
     @overload
     def tag_has(self, tagname: str, item: str | int) -> bool: ...
 
 class LabeledScale(Frame):
-    label: Incomplete
-    scale: Incomplete
-    # TODO: don't any-type **kw. That goes to Frame.__init__.
+    label: Label
+    scale: Scale
+    # This should be kept in sync with tkinter.ttk.Frame.__init__()
+    # (all the keyword-only args except compound are from there)
     def __init__(
         self,
         master: tkinter.Misc | None = None,
         variable: tkinter.IntVar | tkinter.DoubleVar | None = None,
         from_: float = 0,
         to: float = 10,
         *,
-        compound: Literal["top", "bottom"] = ...,
-        **kw,
+        border: tkinter._ScreenUnits = ...,
+        borderwidth: tkinter._ScreenUnits = ...,
+        class_: str = "",
+        compound: Literal["top", "bottom"] = "top",
+        cursor: tkinter._Cursor = "",
+        height: tkinter._ScreenUnits = 0,
+        name: str = ...,
+        padding: _Padding = ...,
+        relief: tkinter._Relief = ...,
+        style: str = "",
+        takefocus: tkinter._TakeFocusValue = "",
+        width: tkinter._ScreenUnits = 0,
     ) -> None: ...
     # destroy is overridden, signature does not change
     value: Any
 
 class OptionMenu(Menubutton):
     def __init__(
         self,
-        master,
-        variable,
+        master: tkinter.Misc | None,
+        variable: tkinter.StringVar,
         default: str | None = None,
         *values: str,
         # rest of these are keyword-only because *args syntax used above
-        style: str = ...,
-        direction: Literal["above", "below", "left", "right", "flush"] = ...,
-        command: Callable[[tkinter.StringVar], object] | None = ...,
+        style: str = "",
+        direction: Literal["above", "below", "left", "right", "flush"] = "below",
+        command: Callable[[tkinter.StringVar], object] | None = None,
     ) -> None: ...
     # configure, config, cget, destroy are inherited from Menubutton
     # destroy and __setitem__ are overridden, signature does not change
-    def set_menu(self, default: Incomplete | None = None, *values) -> None: ...
+    def set_menu(self, default: str | None = None, *values: str) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/tomllib.pyi

```diff
@@ -2,9 +2,9 @@
 from collections.abc import Callable
 from typing import Any
 
 __all__ = ("loads", "load", "TOMLDecodeError")
 
 class TOMLDecodeError(ValueError): ...
 
-def load(__fp: SupportsRead[bytes], *, parse_float: Callable[[str], Any] = ...) -> dict[str, Any]: ...
-def loads(__s: str, *, parse_float: Callable[[str], Any] = ...) -> dict[str, Any]: ...
+def load(fp: SupportsRead[bytes], /, *, parse_float: Callable[[str], Any] = ...) -> dict[str, Any]: ...
+def loads(s: str, /, *, parse_float: Callable[[str], Any] = ...) -> dict[str, Any]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/trace.pyi

```diff
@@ -61,15 +61,15 @@
         timing: bool = False,
     ) -> None: ...
     def run(self, cmd: str | types.CodeType) -> None: ...
     def runctx(
         self, cmd: str | types.CodeType, globals: Mapping[str, Any] | None = None, locals: Mapping[str, Any] | None = None
     ) -> None: ...
     if sys.version_info >= (3, 9):
-        def runfunc(self, __func: Callable[_P, _T], *args: _P.args, **kw: _P.kwargs) -> _T: ...
+        def runfunc(self, func: Callable[_P, _T], /, *args: _P.args, **kw: _P.kwargs) -> _T: ...
     else:
         def runfunc(self, func: Callable[_P, _T], *args: _P.args, **kw: _P.kwargs) -> _T: ...
 
     def file_module_function_of(self, frame: types.FrameType) -> _FileModuleFunction: ...
     def globaltrace_trackcallers(self, frame: types.FrameType, why: str, arg: Any) -> None: ...
     def globaltrace_countfuncs(self, frame: types.FrameType, why: str, arg: Any) -> None: ...
     def globaltrace_lt(self, frame: types.FrameType, why: str, arg: Any) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/traceback.pyi

```diff
@@ -23,42 +23,44 @@
     "FrameSummary",
     "StackSummary",
     "TracebackException",
     "walk_stack",
     "walk_tb",
 ]
 
-_PT: TypeAlias = tuple[str, int, str, str | None]
+_FrameSummaryTuple: TypeAlias = tuple[str, int, str, str | None]
 
 def print_tb(tb: TracebackType | None, limit: int | None = None, file: SupportsWrite[str] | None = None) -> None: ...
 
 if sys.version_info >= (3, 10):
     @overload
     def print_exception(
-        __exc: type[BaseException] | None,
+        exc: type[BaseException] | None,
+        /,
         value: BaseException | None = ...,
         tb: TracebackType | None = ...,
         limit: int | None = None,
         file: SupportsWrite[str] | None = None,
         chain: bool = True,
     ) -> None: ...
     @overload
     def print_exception(
-        __exc: BaseException, *, limit: int | None = None, file: SupportsWrite[str] | None = None, chain: bool = True
+        exc: BaseException, /, *, limit: int | None = None, file: SupportsWrite[str] | None = None, chain: bool = True
     ) -> None: ...
     @overload
     def format_exception(
-        __exc: type[BaseException] | None,
+        exc: type[BaseException] | None,
+        /,
         value: BaseException | None = ...,
         tb: TracebackType | None = ...,
         limit: int | None = None,
         chain: bool = True,
     ) -> list[str]: ...
     @overload
-    def format_exception(__exc: BaseException, *, limit: int | None = None, chain: bool = True) -> list[str]: ...
+    def format_exception(exc: BaseException, /, *, limit: int | None = None, chain: bool = True) -> list[str]: ...
 
 else:
     def print_exception(
         etype: type[BaseException] | None,
         value: BaseException | None,
         tb: TracebackType | None,
         limit: int | None = None,
@@ -74,24 +76,24 @@
     ) -> list[str]: ...
 
 def print_exc(limit: int | None = None, file: SupportsWrite[str] | None = None, chain: bool = True) -> None: ...
 def print_last(limit: int | None = None, file: SupportsWrite[str] | None = None, chain: bool = True) -> None: ...
 def print_stack(f: FrameType | None = None, limit: int | None = None, file: SupportsWrite[str] | None = None) -> None: ...
 def extract_tb(tb: TracebackType | None, limit: int | None = None) -> StackSummary: ...
 def extract_stack(f: FrameType | None = None, limit: int | None = None) -> StackSummary: ...
-def format_list(extracted_list: list[FrameSummary]) -> list[str]: ...
+def format_list(extracted_list: Iterable[FrameSummary | _FrameSummaryTuple]) -> list[str]: ...
 
 # undocumented
-def print_list(extracted_list: list[FrameSummary], file: SupportsWrite[str] | None = None) -> None: ...
+def print_list(extracted_list: Iterable[FrameSummary | _FrameSummaryTuple], file: SupportsWrite[str] | None = None) -> None: ...
 
 if sys.version_info >= (3, 10):
     @overload
-    def format_exception_only(__exc: BaseException | None) -> list[str]: ...
+    def format_exception_only(exc: BaseException | None, /) -> list[str]: ...
     @overload
-    def format_exception_only(__exc: Unused, value: BaseException | None) -> list[str]: ...
+    def format_exception_only(exc: Unused, /, value: BaseException | None) -> list[str]: ...
 
 else:
     def format_exception_only(etype: type[BaseException] | None, value: BaseException | None) -> list[str]: ...
 
 def format_exc(limit: int | None = None, chain: bool = True) -> str: ...
 def format_tb(tb: TracebackType | None, limit: int | None = None) -> list[str]: ...
 def format_stack(f: FrameType | None = None, limit: int | None = None) -> list[str]: ...
@@ -249,12 +251,12 @@
         frame_gen: Iterable[tuple[FrameType, int]],
         *,
         limit: int | None = None,
         lookup_lines: bool = True,
         capture_locals: bool = False,
     ) -> StackSummary: ...
     @classmethod
-    def from_list(cls, a_list: Iterable[FrameSummary | _PT]) -> StackSummary: ...
+    def from_list(cls, a_list: Iterable[FrameSummary | _FrameSummaryTuple]) -> StackSummary: ...
     if sys.version_info >= (3, 11):
         def format_frame_summary(self, frame_summary: FrameSummary) -> str: ...
 
     def format(self) -> list[str]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/types.pyi

```diff
@@ -13,15 +13,15 @@
     MutableSequence,
     ValuesView,
 )
 from importlib.machinery import ModuleSpec
 
 # pytype crashes if types.MappingProxyType inherits from collections.abc.Mapping instead of typing.Mapping
 from typing import Any, ClassVar, Literal, Mapping, Protocol, TypeVar, final, overload  # noqa: Y022
-from typing_extensions import ParamSpec, Self, TypeVarTuple
+from typing_extensions import ParamSpec, Self, TypeVarTuple, deprecated
 
 __all__ = [
     "FunctionType",
     "LambdaType",
     "CodeType",
     "MappingProxyType",
     "SimpleNamespace",
@@ -62,16 +62,16 @@
 _T1 = TypeVar("_T1")
 _T2 = TypeVar("_T2")
 _KT = TypeVar("_KT")
 _VT_co = TypeVar("_VT_co", covariant=True)
 
 @final
 class _Cell:
-    def __new__(cls, __contents: object = ...) -> Self: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __new__(cls, contents: object = ..., /) -> Self: ...
+    def __eq__(self, value: object, /) -> bool: ...
     __hash__: ClassVar[None]  # type: ignore[assignment]
     cell_contents: Any
 
 # Make sure this class definition stays roughly in line with `builtins.function`
 @final
 class FunctionType:
     @property
@@ -98,23 +98,23 @@
         globals: dict[str, Any],
         name: str | None = ...,
         argdefs: tuple[object, ...] | None = ...,
         closure: tuple[_Cell, ...] | None = ...,
     ) -> Self: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
     @overload
-    def __get__(self, __instance: None, __owner: type) -> FunctionType: ...
+    def __get__(self, instance: None, owner: type, /) -> FunctionType: ...
     @overload
-    def __get__(self, __instance: object, __owner: type | None = None) -> MethodType: ...
+    def __get__(self, instance: object, owner: type | None = None, /) -> MethodType: ...
 
 LambdaType = FunctionType
 
 @final
 class CodeType:
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
     @property
     def co_argcount(self) -> int: ...
     @property
     def co_posonlyargcount(self) -> int: ...
     @property
     def co_kwonlyargcount(self) -> int: ...
@@ -134,16 +134,22 @@
     def co_varnames(self) -> tuple[str, ...]: ...
     @property
     def co_filename(self) -> str: ...
     @property
     def co_name(self) -> str: ...
     @property
     def co_firstlineno(self) -> int: ...
-    @property
-    def co_lnotab(self) -> bytes: ...
+    if sys.version_info >= (3, 10):
+        @property
+        @deprecated("Will be removed in Python 3.14. Use the co_lines() method instead.")
+        def co_lnotab(self) -> bytes: ...
+    else:
+        @property
+        def co_lnotab(self) -> bytes: ...
+
     @property
     def co_freevars(self) -> tuple[str, ...]: ...
     @property
     def co_cellvars(self) -> tuple[str, ...]: ...
     if sys.version_info >= (3, 10):
         @property
         def co_linetable(self) -> bytes: ...
@@ -154,72 +160,75 @@
         @property
         def co_qualname(self) -> str: ...
         def co_positions(self) -> Iterable[tuple[int | None, int | None, int | None, int | None]]: ...
 
     if sys.version_info >= (3, 11):
         def __new__(
             cls,
-            __argcount: int,
-            __posonlyargcount: int,
-            __kwonlyargcount: int,
-            __nlocals: int,
-            __stacksize: int,
-            __flags: int,
-            __codestring: bytes,
-            __constants: tuple[object, ...],
-            __names: tuple[str, ...],
-            __varnames: tuple[str, ...],
-            __filename: str,
-            __name: str,
-            __qualname: str,
-            __firstlineno: int,
-            __linetable: bytes,
-            __exceptiontable: bytes,
-            __freevars: tuple[str, ...] = ...,
-            __cellvars: tuple[str, ...] = ...,
+            argcount: int,
+            posonlyargcount: int,
+            kwonlyargcount: int,
+            nlocals: int,
+            stacksize: int,
+            flags: int,
+            codestring: bytes,
+            constants: tuple[object, ...],
+            names: tuple[str, ...],
+            varnames: tuple[str, ...],
+            filename: str,
+            name: str,
+            qualname: str,
+            firstlineno: int,
+            linetable: bytes,
+            exceptiontable: bytes,
+            freevars: tuple[str, ...] = ...,
+            cellvars: tuple[str, ...] = ...,
+            /,
         ) -> Self: ...
     elif sys.version_info >= (3, 10):
         def __new__(
             cls,
-            __argcount: int,
-            __posonlyargcount: int,
-            __kwonlyargcount: int,
-            __nlocals: int,
-            __stacksize: int,
-            __flags: int,
-            __codestring: bytes,
-            __constants: tuple[object, ...],
-            __names: tuple[str, ...],
-            __varnames: tuple[str, ...],
-            __filename: str,
-            __name: str,
-            __firstlineno: int,
-            __linetable: bytes,
-            __freevars: tuple[str, ...] = ...,
-            __cellvars: tuple[str, ...] = ...,
+            argcount: int,
+            posonlyargcount: int,
+            kwonlyargcount: int,
+            nlocals: int,
+            stacksize: int,
+            flags: int,
+            codestring: bytes,
+            constants: tuple[object, ...],
+            names: tuple[str, ...],
+            varnames: tuple[str, ...],
+            filename: str,
+            name: str,
+            firstlineno: int,
+            linetable: bytes,
+            freevars: tuple[str, ...] = ...,
+            cellvars: tuple[str, ...] = ...,
+            /,
         ) -> Self: ...
     else:
         def __new__(
             cls,
-            __argcount: int,
-            __posonlyargcount: int,
-            __kwonlyargcount: int,
-            __nlocals: int,
-            __stacksize: int,
-            __flags: int,
-            __codestring: bytes,
-            __constants: tuple[object, ...],
-            __names: tuple[str, ...],
-            __varnames: tuple[str, ...],
-            __filename: str,
-            __name: str,
-            __firstlineno: int,
-            __lnotab: bytes,
-            __freevars: tuple[str, ...] = ...,
-            __cellvars: tuple[str, ...] = ...,
+            argcount: int,
+            posonlyargcount: int,
+            kwonlyargcount: int,
+            nlocals: int,
+            stacksize: int,
+            flags: int,
+            codestring: bytes,
+            constants: tuple[object, ...],
+            names: tuple[str, ...],
+            varnames: tuple[str, ...],
+            filename: str,
+            name: str,
+            firstlineno: int,
+            lnotab: bytes,
+            freevars: tuple[str, ...] = ...,
+            cellvars: tuple[str, ...] = ...,
+            /,
         ) -> Self: ...
     if sys.version_info >= (3, 11):
         def replace(
             self,
             *,
             co_argcount: int = -1,
             co_posonlyargcount: int = -1,
@@ -283,38 +292,38 @@
             co_lnotab: bytes = ...,
         ) -> CodeType: ...
 
 @final
 class MappingProxyType(Mapping[_KT, _VT_co]):
     __hash__: ClassVar[None]  # type: ignore[assignment]
     def __new__(cls, mapping: SupportsKeysAndGetItem[_KT, _VT_co]) -> Self: ...
-    def __getitem__(self, __key: _KT) -> _VT_co: ...
+    def __getitem__(self, key: _KT, /) -> _VT_co: ...
     def __iter__(self) -> Iterator[_KT]: ...
     def __len__(self) -> int: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def copy(self) -> dict[_KT, _VT_co]: ...
     def keys(self) -> KeysView[_KT]: ...
     def values(self) -> ValuesView[_VT_co]: ...
     def items(self) -> ItemsView[_KT, _VT_co]: ...
     if sys.version_info >= (3, 9):
         def __class_getitem__(cls, item: Any) -> GenericAlias: ...
         def __reversed__(self) -> Iterator[_KT]: ...
-        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT_co | _T2]: ...
-        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT_co | _T2]: ...
+        def __or__(self, value: Mapping[_T1, _T2], /) -> dict[_KT | _T1, _VT_co | _T2]: ...
+        def __ror__(self, value: Mapping[_T1, _T2], /) -> dict[_KT | _T1, _VT_co | _T2]: ...
 
 class SimpleNamespace:
     __hash__: ClassVar[None]  # type: ignore[assignment]
     def __init__(self, **kwargs: Any) -> None: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __getattribute__(self, __name: str) -> Any: ...
-    def __setattr__(self, __name: str, __value: Any) -> None: ...
-    def __delattr__(self, __name: str) -> None: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __getattribute__(self, name: str, /) -> Any: ...
+    def __setattr__(self, name: str, value: Any, /) -> None: ...
+    def __delattr__(self, name: str, /) -> None: ...
 
 class _LoaderProtocol(Protocol):
-    def load_module(self, __fullname: str) -> ModuleType: ...
+    def load_module(self, fullname: str, /) -> ModuleType: ...
 
 class ModuleType:
     __name__: str
     __file__: str | None
     @property
     def __dict__(self) -> dict[str, Any]: ...  # type: ignore[override]
     __loader__: _LoaderProtocol | None
@@ -338,64 +347,64 @@
     if sys.version_info >= (3, 11):
         @property
         def gi_suspended(self) -> bool: ...
     __name__: str
     __qualname__: str
     def __iter__(self) -> Self: ...
     def __next__(self) -> _YieldT_co: ...
-    def send(self, __arg: _SendT_contra) -> _YieldT_co: ...
+    def send(self, arg: _SendT_contra, /) -> _YieldT_co: ...
     @overload
     def throw(
-        self, __typ: type[BaseException], __val: BaseException | object = ..., __tb: TracebackType | None = ...
+        self, typ: type[BaseException], val: BaseException | object = ..., tb: TracebackType | None = ..., /
     ) -> _YieldT_co: ...
     @overload
-    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = ...) -> _YieldT_co: ...
+    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = ..., /) -> _YieldT_co: ...
 
 @final
 class AsyncGeneratorType(AsyncGenerator[_YieldT_co, _SendT_contra]):
     @property
     def ag_await(self) -> Awaitable[Any] | None: ...
     __name__: str
     __qualname__: str
     if sys.version_info >= (3, 12):
         @property
         def ag_suspended(self) -> bool: ...
 
     def __aiter__(self) -> Self: ...
     def __anext__(self) -> Coroutine[Any, Any, _YieldT_co]: ...
-    def asend(self, __val: _SendT_contra) -> Coroutine[Any, Any, _YieldT_co]: ...
+    def asend(self, val: _SendT_contra, /) -> Coroutine[Any, Any, _YieldT_co]: ...
     @overload
     async def athrow(
-        self, __typ: type[BaseException], __val: BaseException | object = ..., __tb: TracebackType | None = ...
+        self, typ: type[BaseException], val: BaseException | object = ..., tb: TracebackType | None = ..., /
     ) -> _YieldT_co: ...
     @overload
-    async def athrow(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = ...) -> _YieldT_co: ...
+    async def athrow(self, typ: BaseException, val: None = None, tb: TracebackType | None = ..., /) -> _YieldT_co: ...
     def aclose(self) -> Coroutine[Any, Any, None]: ...
     if sys.version_info >= (3, 9):
-        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...
+        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
 
 @final
 class CoroutineType(Coroutine[_YieldT_co, _SendT_contra, _ReturnT_co]):
     __name__: str
     __qualname__: str
     @property
     def cr_origin(self) -> tuple[tuple[str, int, str], ...] | None: ...
     if sys.version_info >= (3, 11):
         @property
         def cr_suspended(self) -> bool: ...
 
     def close(self) -> None: ...
     def __await__(self) -> Generator[Any, None, _ReturnT_co]: ...
-    def send(self, __arg: _SendT_contra) -> _YieldT_co: ...
+    def send(self, arg: _SendT_contra, /) -> _YieldT_co: ...
     @overload
     def throw(
-        self, __typ: type[BaseException], __val: BaseException | object = ..., __tb: TracebackType | None = ...
+        self, typ: type[BaseException], val: BaseException | object = ..., tb: TracebackType | None = ..., /
     ) -> _YieldT_co: ...
     @overload
-    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = ...) -> _YieldT_co: ...
+    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = ..., /) -> _YieldT_co: ...
 
 @final
 class MethodType:
     @property
     def __closure__(self) -> tuple[_Cell, ...] | None: ...  # inherited from the added function
     @property
     def __defaults__(self) -> tuple[Any, ...] | None: ...  # inherited from the added function
@@ -403,80 +412,80 @@
     def __func__(self) -> Callable[..., Any]: ...
     @property
     def __self__(self) -> object: ...
     @property
     def __name__(self) -> str: ...  # inherited from the added function
     @property
     def __qualname__(self) -> str: ...  # inherited from the added function
-    def __new__(cls, __func: Callable[..., Any], __obj: object) -> Self: ...
+    def __new__(cls, func: Callable[..., Any], obj: object, /) -> Self: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
 
 @final
 class BuiltinFunctionType:
     @property
     def __self__(self) -> object | ModuleType: ...
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __eq__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
 
 BuiltinMethodType = BuiltinFunctionType
 
 @final
 class WrapperDescriptorType:
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
 
 @final
 class MethodWrapperType:
     @property
     def __self__(self) -> object: ...
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __eq__(self, __value: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
+    def __eq__(self, value: object, /) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
     def __hash__(self) -> int: ...
 
 @final
 class MethodDescriptorType:
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
 
 @final
 class ClassMethodDescriptorType:
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
     def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
 
 @final
 class TracebackType:
     def __new__(cls, tb_next: TracebackType | None, tb_frame: FrameType, tb_lasti: int, tb_lineno: int) -> Self: ...
     tb_next: TracebackType | None
     # the rest are read-only
     @property
@@ -514,43 +523,43 @@
 class GetSetDescriptorType:
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
-    def __set__(self, __instance: Any, __value: Any) -> None: ...
-    def __delete__(self, __instance: Any) -> None: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
+    def __set__(self, instance: Any, value: Any, /) -> None: ...
+    def __delete__(self, instance: Any, /) -> None: ...
 
 @final
 class MemberDescriptorType:
     @property
     def __name__(self) -> str: ...
     @property
     def __qualname__(self) -> str: ...
     @property
     def __objclass__(self) -> type: ...
-    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...
-    def __set__(self, __instance: Any, __value: Any) -> None: ...
-    def __delete__(self, __instance: Any) -> None: ...
+    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
+    def __set__(self, instance: Any, value: Any, /) -> None: ...
+    def __delete__(self, instance: Any, /) -> None: ...
 
 def new_class(
     name: str,
     bases: Iterable[object] = (),
     kwds: dict[str, Any] | None = None,
     exec_body: Callable[[dict[str, Any]], object] | None = None,
 ) -> type: ...
 def resolve_bases(bases: Iterable[object]) -> tuple[Any, ...]: ...
 def prepare_class(
     name: str, bases: tuple[type, ...] = (), kwds: dict[str, Any] | None = None
 ) -> tuple[type, dict[str, Any], dict[str, Any]]: ...
 
 if sys.version_info >= (3, 12):
-    def get_original_bases(__cls: type) -> tuple[Any, ...]: ...
+    def get_original_bases(cls: type, /) -> tuple[Any, ...]: ...
 
 # Actually a different type, but `property` is special and we want that too.
 DynamicClassAttribute = property
 
 _Fn = TypeVar("_Fn", bound=Callable[..., object])
 _R = TypeVar("_R")
 _P = ParamSpec("_P")
@@ -568,16 +577,16 @@
         @property
         def __origin__(self) -> type: ...
         @property
         def __args__(self) -> tuple[Any, ...]: ...
         @property
         def __parameters__(self) -> tuple[Any, ...]: ...
         def __new__(cls, origin: type, args: Any) -> Self: ...
-        def __getitem__(self, __typeargs: Any) -> GenericAlias: ...
-        def __eq__(self, __value: object) -> bool: ...
+        def __getitem__(self, typeargs: Any, /) -> GenericAlias: ...
+        def __eq__(self, value: object, /) -> bool: ...
         def __hash__(self) -> int: ...
         if sys.version_info >= (3, 11):
             @property
             def __unpacked__(self) -> bool: ...
             @property
             def __typing_unpacked_tuple_args__(self) -> tuple[Any, ...] | None: ...
 
@@ -595,11 +604,11 @@
     from builtins import _NotImplementedType
 
     NotImplementedType = _NotImplementedType
     @final
     class UnionType:
         @property
         def __args__(self) -> tuple[Any, ...]: ...
-        def __or__(self, __value: Any) -> UnionType: ...
-        def __ror__(self, __value: Any) -> UnionType: ...
-        def __eq__(self, __value: object) -> bool: ...
+        def __or__(self, value: Any, /) -> UnionType: ...
+        def __ror__(self, value: Any, /) -> UnionType: ...
+        def __eq__(self, value: object, /) -> bool: ...
         def __hash__(self) -> int: ...
```

## puya/_vendor/mypy/typeshed/stdlib/typing.pyi

```diff
@@ -1,14 +1,16 @@
+# Since this module defines "overload" it is not recognized by Ruff as typing.overload
+# ruff: noqa: F811
 # TODO: The collections import is required, otherwise mypy crashes.
 # https://github.com/python/mypy/issues/16744
 import collections  # noqa: F401  # pyright: ignore
 import sys
 import typing_extensions
 from _collections_abc import dict_items, dict_keys, dict_values
-from _typeshed import IdentityFunction, Incomplete, ReadableBuffer, SupportsKeysAndGetItem
+from _typeshed import IdentityFunction, ReadableBuffer, SupportsKeysAndGetItem
 from abc import ABCMeta, abstractmethod
 from contextlib import AbstractAsyncContextManager, AbstractContextManager
 from re import Match as Match, Pattern as Pattern
 from types import (
     BuiltinFunctionType,
     CodeType,
     FrameType,
@@ -164,15 +166,15 @@
         def __init__(
             self, name: str, *constraints: Any, bound: Any | None = None, covariant: bool = False, contravariant: bool = False
         ) -> None: ...
     if sys.version_info >= (3, 10):
         def __or__(self, right: Any) -> _SpecialForm: ...
         def __ror__(self, left: Any) -> _SpecialForm: ...
     if sys.version_info >= (3, 11):
-        def __typing_subst__(self, arg: Incomplete) -> Incomplete: ...
+        def __typing_subst__(self, arg: Any) -> Any: ...
 
 # Used for an undocumented mypy feature. Does not exist at runtime.
 _promote = object()
 
 # N.B. Keep this definition in sync with typing_extensions._SpecialForm
 @final
 class _SpecialForm:
@@ -215,15 +217,15 @@
     @final
     class TypeVarTuple:
         @property
         def __name__(self) -> str: ...
         def __init__(self, name: str) -> None: ...
         def __iter__(self) -> Any: ...
         def __typing_subst__(self, arg: Never) -> Never: ...
-        def __typing_prepare_subst__(self, alias: Incomplete, args: Incomplete) -> Incomplete: ...
+        def __typing_prepare_subst__(self, alias: Any, args: Any) -> tuple[Any, ...]: ...
 
 if sys.version_info >= (3, 10):
     @final
     class ParamSpecArgs:
         @property
         def __origin__(self) -> ParamSpec: ...
         def __init__(self, origin: ParamSpec) -> None: ...
@@ -264,34 +266,35 @@
             ) -> None: ...
 
         @property
         def args(self) -> ParamSpecArgs: ...
         @property
         def kwargs(self) -> ParamSpecKwargs: ...
         if sys.version_info >= (3, 11):
-            def __typing_subst__(self, arg: Incomplete) -> Incomplete: ...
-            def __typing_prepare_subst__(self, alias: Incomplete, args: Incomplete) -> Incomplete: ...
+            def __typing_subst__(self, arg: Any) -> Any: ...
+            def __typing_prepare_subst__(self, alias: Any, args: Any) -> tuple[Any, ...]: ...
 
         def __or__(self, right: Any) -> _SpecialForm: ...
         def __ror__(self, left: Any) -> _SpecialForm: ...
+
     Concatenate: _SpecialForm
     TypeAlias: _SpecialForm
     TypeGuard: _SpecialForm
 
     class NewType:
         def __init__(self, name: str, tp: Any) -> None: ...
         if sys.version_info >= (3, 11):
             @staticmethod
-            def __call__(__x: _T) -> _T: ...
+            def __call__(x: _T, /) -> _T: ...
         else:
             def __call__(self, x: _T) -> _T: ...
 
         def __or__(self, other: Any) -> _SpecialForm: ...
         def __ror__(self, other: Any) -> _SpecialForm: ...
-        __supertype__: type
+        __supertype__: type | NewType
 
 else:
     def NewType(name: str, tp: Any) -> Any: ...
 
 # These type variables are used by the container types.
 _S = TypeVar("_S")
 _KT = TypeVar("_KT")  # Key type.
@@ -367,15 +370,15 @@
 @runtime_checkable
 class SupportsRound(Protocol[_T_co]):
     @overload
     @abstractmethod
     def __round__(self) -> int: ...
     @overload
     @abstractmethod
-    def __round__(self, __ndigits: int) -> _T_co: ...
+    def __round__(self, ndigits: int, /) -> _T_co: ...
 
 @runtime_checkable
 class Sized(Protocol, metaclass=ABCMeta):
     @abstractmethod
     def __len__(self) -> int: ...
 
 @runtime_checkable
@@ -405,23 +408,23 @@
 _YieldT_co = TypeVar("_YieldT_co", covariant=True)
 _SendT_contra = TypeVar("_SendT_contra", contravariant=True)
 _ReturnT_co = TypeVar("_ReturnT_co", covariant=True)
 
 class Generator(Iterator[_YieldT_co], Generic[_YieldT_co, _SendT_contra, _ReturnT_co]):
     def __next__(self) -> _YieldT_co: ...
     @abstractmethod
-    def send(self, __value: _SendT_contra) -> _YieldT_co: ...
+    def send(self, value: _SendT_contra, /) -> _YieldT_co: ...
     @overload
     @abstractmethod
     def throw(
-        self, __typ: type[BaseException], __val: BaseException | object = None, __tb: TracebackType | None = None
+        self, typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /
     ) -> _YieldT_co: ...
     @overload
     @abstractmethod
-    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = None) -> _YieldT_co: ...
+    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = None, /) -> _YieldT_co: ...
     def close(self) -> None: ...
     def __iter__(self) -> Generator[_YieldT_co, _SendT_contra, _ReturnT_co]: ...
     @property
     def gi_code(self) -> CodeType: ...
     @property
     def gi_frame(self) -> FrameType: ...
     @property
@@ -442,23 +445,23 @@
     @property
     def cr_code(self) -> CodeType: ...
     @property
     def cr_frame(self) -> FrameType: ...
     @property
     def cr_running(self) -> bool: ...
     @abstractmethod
-    def send(self, __value: _SendT_contra) -> _YieldT_co: ...
+    def send(self, value: _SendT_contra, /) -> _YieldT_co: ...
     @overload
     @abstractmethod
     def throw(
-        self, __typ: type[BaseException], __val: BaseException | object = None, __tb: TracebackType | None = None
+        self, typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /
     ) -> _YieldT_co: ...
     @overload
     @abstractmethod
-    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = None) -> _YieldT_co: ...
+    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = None, /) -> _YieldT_co: ...
     @abstractmethod
     def close(self) -> None: ...
 
 # NOTE: This type does not exist in typing.py or PEP 484 but mypy needs it to exist.
 # The parameters correspond to Generator, but the 4th is the original type.
 @type_check_only
 class AwaitableGenerator(
@@ -478,38 +481,38 @@
     @abstractmethod
     def __anext__(self) -> Awaitable[_T_co]: ...
     def __aiter__(self) -> AsyncIterator[_T_co]: ...
 
 class AsyncGenerator(AsyncIterator[_YieldT_co], Generic[_YieldT_co, _SendT_contra]):
     def __anext__(self) -> Awaitable[_YieldT_co]: ...
     @abstractmethod
-    def asend(self, __value: _SendT_contra) -> Awaitable[_YieldT_co]: ...
+    def asend(self, value: _SendT_contra, /) -> Awaitable[_YieldT_co]: ...
     @overload
     @abstractmethod
     def athrow(
-        self, __typ: type[BaseException], __val: BaseException | object = None, __tb: TracebackType | None = None
+        self, typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /
     ) -> Awaitable[_YieldT_co]: ...
     @overload
     @abstractmethod
-    def athrow(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = None) -> Awaitable[_YieldT_co]: ...
+    def athrow(self, typ: BaseException, val: None = None, tb: TracebackType | None = None, /) -> Awaitable[_YieldT_co]: ...
     def aclose(self) -> Awaitable[None]: ...
     @property
     def ag_await(self) -> Any: ...
     @property
     def ag_code(self) -> CodeType: ...
     @property
     def ag_frame(self) -> FrameType: ...
     @property
     def ag_running(self) -> bool: ...
 
 @runtime_checkable
 class Container(Protocol[_T_co]):
     # This is generic more on vibes than anything else
     @abstractmethod
-    def __contains__(self, __x: object) -> bool: ...
+    def __contains__(self, x: object, /) -> bool: ...
 
 @runtime_checkable
 class Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):
     # Implement Sized (but don't have it as a base class).
     @abstractmethod
     def __len__(self) -> int: ...
 
@@ -625,49 +628,49 @@
     def __iter__(self) -> Iterator[_VT_co]: ...
     def __reversed__(self) -> Iterator[_VT_co]: ...
 
 class Mapping(Collection[_KT], Generic[_KT, _VT_co]):
     # TODO: We wish the key type could also be covariant, but that doesn't work,
     # see discussion in https://github.com/python/typing/pull/273.
     @abstractmethod
-    def __getitem__(self, __key: _KT) -> _VT_co: ...
+    def __getitem__(self, key: _KT, /) -> _VT_co: ...
     # Mixin methods
     @overload
-    def get(self, __key: _KT) -> _VT_co | None: ...
+    def get(self, key: _KT, /) -> _VT_co | None: ...
     @overload
-    def get(self, __key: _KT, default: _VT_co | _T) -> _VT_co | _T: ...
+    def get(self, key: _KT, /, default: _VT_co | _T) -> _VT_co | _T: ...
     def items(self) -> ItemsView[_KT, _VT_co]: ...
     def keys(self) -> KeysView[_KT]: ...
     def values(self) -> ValuesView[_VT_co]: ...
-    def __contains__(self, __key: object) -> bool: ...
-    def __eq__(self, __other: object) -> bool: ...
+    def __contains__(self, key: object, /) -> bool: ...
+    def __eq__(self, other: object, /) -> bool: ...
 
 class MutableMapping(Mapping[_KT, _VT]):
     @abstractmethod
-    def __setitem__(self, __key: _KT, __value: _VT) -> None: ...
+    def __setitem__(self, key: _KT, value: _VT, /) -> None: ...
     @abstractmethod
-    def __delitem__(self, __key: _KT) -> None: ...
+    def __delitem__(self, key: _KT, /) -> None: ...
     def clear(self) -> None: ...
     @overload
-    def pop(self, __key: _KT) -> _VT: ...
+    def pop(self, key: _KT, /) -> _VT: ...
     @overload
-    def pop(self, __key: _KT, default: _VT) -> _VT: ...
+    def pop(self, key: _KT, /, default: _VT) -> _VT: ...
     @overload
-    def pop(self, __key: _KT, default: _T) -> _VT | _T: ...
+    def pop(self, key: _KT, /, default: _T) -> _VT | _T: ...
     def popitem(self) -> tuple[_KT, _VT]: ...
     # This overload should be allowed only if the value type is compatible with None.
     #
     # Keep the following methods in line with MutableMapping.setdefault, modulo positional-only differences:
     # -- collections.OrderedDict.setdefault
     # -- collections.ChainMap.setdefault
     # -- weakref.WeakKeyDictionary.setdefault
     @overload
-    def setdefault(self: MutableMapping[_KT, _T | None], __key: _KT, __default: None = None) -> _T | None: ...
+    def setdefault(self: MutableMapping[_KT, _T | None], key: _KT, default: None = None, /) -> _T | None: ...
     @overload
-    def setdefault(self, __key: _KT, __default: _VT) -> _VT: ...
+    def setdefault(self, key: _KT, default: _VT, /) -> _VT: ...
     # 'update' used to take a Union, but using overloading is better.
     # The second overloaded type here is a bit too general, because
     # Mapping[tuple[_KT, _VT], W] is a subclass of Iterable[tuple[_KT, _VT]],
     # but will always have the behavior of the first overloaded type
     # at runtime, leading to keys of a mix of types _KT and tuple[_KT, _VT].
     # We don't currently have any way of forcing all Mappings to use
     # the first overload, but by using overloading rather than a Union,
@@ -681,17 +684,17 @@
     # -- collections.UserDict.__ior__
     # -- collections.ChainMap.__ior__
     # -- peewee.attrdict.__add__
     # -- peewee.attrdict.__iadd__
     # -- weakref.WeakValueDictionary.__ior__
     # -- weakref.WeakKeyDictionary.__ior__
     @overload
-    def update(self, __m: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT) -> None: ...
+    def update(self, m: SupportsKeysAndGetItem[_KT, _VT], /, **kwargs: _VT) -> None: ...
     @overload
-    def update(self, __m: Iterable[tuple[_KT, _VT]], **kwargs: _VT) -> None: ...
+    def update(self, m: Iterable[tuple[_KT, _VT]], /, **kwargs: _VT) -> None: ...
     @overload
     def update(self, **kwargs: _VT) -> None: ...
 
 Text = str
 
 TYPE_CHECKING: bool
 
@@ -715,58 +718,58 @@
     @abstractmethod
     def fileno(self) -> int: ...
     @abstractmethod
     def flush(self) -> None: ...
     @abstractmethod
     def isatty(self) -> bool: ...
     @abstractmethod
-    def read(self, __n: int = -1) -> AnyStr: ...
+    def read(self, n: int = -1, /) -> AnyStr: ...
     @abstractmethod
     def readable(self) -> bool: ...
     @abstractmethod
-    def readline(self, __limit: int = -1) -> AnyStr: ...
+    def readline(self, limit: int = -1, /) -> AnyStr: ...
     @abstractmethod
-    def readlines(self, __hint: int = -1) -> list[AnyStr]: ...
+    def readlines(self, hint: int = -1, /) -> list[AnyStr]: ...
     @abstractmethod
-    def seek(self, __offset: int, __whence: int = 0) -> int: ...
+    def seek(self, offset: int, whence: int = 0, /) -> int: ...
     @abstractmethod
     def seekable(self) -> bool: ...
     @abstractmethod
     def tell(self) -> int: ...
     @abstractmethod
-    def truncate(self, __size: int | None = None) -> int: ...
+    def truncate(self, size: int | None = None, /) -> int: ...
     @abstractmethod
     def writable(self) -> bool: ...
     @abstractmethod
     @overload
-    def write(self: IO[str], __s: str) -> int: ...
+    def write(self: IO[str], s: str, /) -> int: ...
     @abstractmethod
     @overload
-    def write(self: IO[bytes], __s: ReadableBuffer) -> int: ...
+    def write(self: IO[bytes], s: ReadableBuffer, /) -> int: ...
     @abstractmethod
     @overload
-    def write(self, __s: AnyStr) -> int: ...
+    def write(self, s: AnyStr, /) -> int: ...
     @abstractmethod
     @overload
-    def writelines(self: IO[str], __lines: Iterable[str]) -> None: ...
+    def writelines(self: IO[str], lines: Iterable[str], /) -> None: ...
     @abstractmethod
     @overload
-    def writelines(self: IO[bytes], __lines: Iterable[ReadableBuffer]) -> None: ...
+    def writelines(self: IO[bytes], lines: Iterable[ReadableBuffer], /) -> None: ...
     @abstractmethod
     @overload
-    def writelines(self, __lines: Iterable[AnyStr]) -> None: ...
+    def writelines(self, lines: Iterable[AnyStr], /) -> None: ...
     @abstractmethod
     def __next__(self) -> AnyStr: ...
     @abstractmethod
     def __iter__(self) -> Iterator[AnyStr]: ...
     @abstractmethod
     def __enter__(self) -> IO[AnyStr]: ...
     @abstractmethod
     def __exit__(
-        self, __type: type[BaseException] | None, __value: BaseException | None, __traceback: TracebackType | None
+        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None, /
     ) -> None: ...
 
 class BinaryIO(IO[bytes]):
     @abstractmethod
     def __enter__(self) -> BinaryIO: ...
 
 class TextIO(IO[str]):
@@ -834,17 +837,17 @@
 def cast(typ: type[_T], val: Any) -> _T: ...
 @overload
 def cast(typ: str, val: Any) -> Any: ...
 @overload
 def cast(typ: object, val: Any) -> Any: ...
 
 if sys.version_info >= (3, 11):
-    def reveal_type(__obj: _T) -> _T: ...
-    def assert_never(__arg: Never) -> Never: ...
-    def assert_type(__val: _T, __typ: Any) -> _T: ...
+    def reveal_type(obj: _T, /) -> _T: ...
+    def assert_never(arg: Never, /) -> Never: ...
+    def assert_type(val: _T, typ: Any, /) -> _T: ...
     def clear_overloads() -> None: ...
     def get_overloads(func: Callable[..., object]) -> Sequence[Callable[..., object]]: ...
     def dataclass_transform(
         *,
         eq_default: bool = True,
         order_default: bool = False,
         kw_only_default: bool = False,
@@ -860,18 +863,22 @@
         _field_types: ClassVar[dict[str, type]]
     _field_defaults: ClassVar[dict[str, Any]]
     _fields: ClassVar[tuple[str, ...]]
     # __orig_bases__ sometimes exists on <3.12, but not consistently
     # So we only add it to the stub on 3.12+.
     if sys.version_info >= (3, 12):
         __orig_bases__: ClassVar[tuple[Any, ...]]
+
     @overload
-    def __init__(self, __typename: str, __fields: Iterable[tuple[str, Any]]) -> None: ...
+    def __init__(self, typename: str, fields: Iterable[tuple[str, Any]], /) -> None: ...
     @overload
-    def __init__(self, __typename: str, __fields: None = None, **kwargs: Any) -> None: ...
+    @typing_extensions.deprecated(
+        "Creating a typing.NamedTuple using keyword arguments is deprecated and support will be removed in Python 3.15"
+    )
+    def __init__(self, typename: str, fields: None = None, /, **kwargs: Any) -> None: ...
     @classmethod
     def _make(cls, iterable: Iterable[Any]) -> typing_extensions.Self: ...
     def _asdict(self) -> dict[str, Any]: ...
     def _replace(self, **kwargs: Any) -> typing_extensions.Self: ...
 
 # Internal mypy fallback type for all typed dicts (does not exist at runtime)
 # N.B. Keep this mostly in sync with typing_extensions._TypedDict/mypy_extensions._TypedDict
@@ -881,36 +888,37 @@
     if sys.version_info >= (3, 9):
         __required_keys__: ClassVar[frozenset[str]]
         __optional_keys__: ClassVar[frozenset[str]]
     # __orig_bases__ sometimes exists on <3.12, but not consistently,
     # so we only add it to the stub on 3.12+
     if sys.version_info >= (3, 12):
         __orig_bases__: ClassVar[tuple[Any, ...]]
+
     def copy(self) -> typing_extensions.Self: ...
     # Using Never so that only calls using mypy plugin hook that specialize the signature
     # can go through.
     def setdefault(self, k: _Never, default: object) -> object: ...
     # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.
     def pop(self, k: _Never, default: _T = ...) -> object: ...  # pyright: ignore[reportInvalidTypeVarUse]
-    def update(self: _T, __m: _T) -> None: ...
+    def update(self: _T, m: _T, /) -> None: ...
     def __delitem__(self, k: _Never) -> None: ...
     def items(self) -> dict_items[str, object]: ...
     def keys(self) -> dict_keys[str, object]: ...
     def values(self) -> dict_values[str, object]: ...
     if sys.version_info >= (3, 9):
         @overload
-        def __or__(self, __value: typing_extensions.Self) -> typing_extensions.Self: ...
+        def __or__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...
         @overload
-        def __or__(self, __value: dict[str, Any]) -> dict[str, object]: ...
+        def __or__(self, value: dict[str, Any], /) -> dict[str, object]: ...
         @overload
-        def __ror__(self, __value: typing_extensions.Self) -> typing_extensions.Self: ...
+        def __ror__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...
         @overload
-        def __ror__(self, __value: dict[str, Any]) -> dict[str, object]: ...
+        def __ror__(self, value: dict[str, Any], /) -> dict[str, object]: ...
         # supposedly incompatible definitions of __or__ and __ior__
-        def __ior__(self, __value: typing_extensions.Self) -> typing_extensions.Self: ...  # type: ignore[misc]
+        def __ior__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...  # type: ignore[misc]
 
 @final
 class ForwardRef:
     __forward_arg__: str
     __forward_code__: CodeType
     __forward_evaluated__: bool
     __forward_value__: Any | None
@@ -938,15 +946,15 @@
 
 if sys.version_info >= (3, 10):
     def is_typeddict(tp: object) -> bool: ...
 
 def _type_repr(obj: object) -> str: ...
 
 if sys.version_info >= (3, 12):
-    def override(__method: _F) -> _F: ...
+    def override(method: _F, /) -> _F: ...
     @final
     class TypeAliasType:
         def __init__(
             self, name: str, value: Any, *, type_params: tuple[TypeVar | ParamSpec | TypeVarTuple, ...] = ()
         ) -> None: ...
         @property
         def __value__(self) -> Any: ...
@@ -960,9 +968,9 @@
         @property
         def __module__(self) -> str | None: ...  # type: ignore[override]
         def __getitem__(self, parameters: Any) -> Any: ...
         def __or__(self, right: Any) -> _SpecialForm: ...
         def __ror__(self, left: Any) -> _SpecialForm: ...
 
 if sys.version_info >= (3, 13):
-    def is_protocol(__tp: type) -> bool: ...
-    def get_protocol_members(__tp: type) -> frozenset[str]: ...
+    def is_protocol(tp: type, /) -> bool: ...
+    def get_protocol_members(tp: type, /) -> frozenset[str]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/typing_extensions.pyi

```diff
@@ -1,12 +1,12 @@
 import abc
 import sys
 import typing
 from _collections_abc import dict_items, dict_keys, dict_values
-from _typeshed import IdentityFunction, Incomplete
+from _typeshed import IdentityFunction
 from typing import (  # noqa: Y022,Y037,Y038,Y039
     IO as IO,
     TYPE_CHECKING as TYPE_CHECKING,
     AbstractSet as AbstractSet,
     Any as Any,
     AnyStr as AnyStr,
     AsyncContextManager as AsyncContextManager,
@@ -178,14 +178,15 @@
     "ValuesView",
     "cast",
     "get_protocol_members",
     "is_protocol",
     "no_type_check",
     "no_type_check_decorator",
     "ReadOnly",
+    "TypeIs",
 ]
 
 _T = typing.TypeVar("_T")
 _F = typing.TypeVar("_F", bound=Callable[..., Any])
 _TC = typing.TypeVar("_TC", bound=type[object])
 
 # unfortunately we have to duplicate this class definition from typing.pyi or we break pytype
@@ -216,40 +217,44 @@
 
 # Internal mypy fallback type for all typed dicts (does not exist at runtime)
 # N.B. Keep this mostly in sync with typing._TypedDict/mypy_extensions._TypedDict
 @type_check_only
 class _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):
     __required_keys__: ClassVar[frozenset[str]]
     __optional_keys__: ClassVar[frozenset[str]]
-    __readonly_keys__: ClassVar[frozenset[str]]
-    __mutable_keys__: ClassVar[frozenset[str]]
     __total__: ClassVar[bool]
     __orig_bases__: ClassVar[tuple[Any, ...]]
+    # PEP 705
+    __readonly_keys__: ClassVar[frozenset[str]]
+    __mutable_keys__: ClassVar[frozenset[str]]
+    # PEP 728
+    __closed__: ClassVar[bool]
+    __extra_items__: ClassVar[Any]
     def copy(self) -> Self: ...
     # Using Never so that only calls using mypy plugin hook that specialize the signature
     # can go through.
     def setdefault(self, k: Never, default: object) -> object: ...
     # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.
     def pop(self, k: Never, default: _T = ...) -> object: ...  # pyright: ignore[reportInvalidTypeVarUse]
-    def update(self: _T, __m: _T) -> None: ...
+    def update(self: _T, m: _T, /) -> None: ...
     def items(self) -> dict_items[str, object]: ...
     def keys(self) -> dict_keys[str, object]: ...
     def values(self) -> dict_values[str, object]: ...
     def __delitem__(self, k: Never) -> None: ...
     if sys.version_info >= (3, 9):
         @overload
-        def __or__(self, __value: Self) -> Self: ...
+        def __or__(self, value: Self, /) -> Self: ...
         @overload
-        def __or__(self, __value: dict[str, Any]) -> dict[str, object]: ...
+        def __or__(self, value: dict[str, Any], /) -> dict[str, object]: ...
         @overload
-        def __ror__(self, __value: Self) -> Self: ...
+        def __ror__(self, value: Self, /) -> Self: ...
         @overload
-        def __ror__(self, __value: dict[str, Any]) -> dict[str, object]: ...
+        def __ror__(self, value: dict[str, Any], /) -> dict[str, object]: ...
         # supposedly incompatible definitions of `__ior__` and `__or__`:
-        def __ior__(self, __value: Self) -> Self: ...  # type: ignore[misc]
+        def __ior__(self, value: Self, /) -> Self: ...  # type: ignore[misc]
 
 # TypedDict is a (non-subscriptable) special form.
 TypedDict: object
 
 OrderedDict = _Alias()
 
 def get_type_hints(
@@ -326,17 +331,17 @@
         dataclass_transform as dataclass_transform,
         get_overloads as get_overloads,
         reveal_type as reveal_type,
     )
 else:
     Self: _SpecialForm
     Never: _SpecialForm
-    def reveal_type(__obj: _T) -> _T: ...
-    def assert_never(__arg: Never) -> Never: ...
-    def assert_type(__val: _T, __typ: Any) -> _T: ...
+    def reveal_type(obj: _T, /) -> _T: ...
+    def assert_never(arg: Never, /) -> Never: ...
+    def assert_type(val: _T, typ: Any, /) -> _T: ...
     def clear_overloads() -> None: ...
     def get_overloads(func: Callable[..., object]) -> Sequence[Callable[..., object]]: ...
 
     Required: _SpecialForm
     NotRequired: _SpecialForm
     LiteralString: _SpecialForm
     Unpack: _SpecialForm
@@ -364,16 +369,16 @@
         @classmethod
         def _make(cls, iterable: Iterable[Any]) -> Self: ...
         def _asdict(self) -> dict[str, Any]: ...
         def _replace(self, **kwargs: Any) -> Self: ...
 
     class NewType:
         def __init__(self, name: str, tp: Any) -> None: ...
-        def __call__(self, __obj: _T) -> _T: ...
-        __supertype__: type
+        def __call__(self, obj: _T, /) -> _T: ...
+        __supertype__: type | NewType
         if sys.version_info >= (3, 10):
             def __or__(self, other: Any) -> _SpecialForm: ...
             def __ror__(self, other: Any) -> _SpecialForm: ...
 
 # New things in 3.xx
 # The `default` parameter was added to TypeVar, ParamSpec, and TypeVarTuple (PEP 696)
 # The `infer_variance` parameter was added to TypeVar in 3.12 (PEP 695)
@@ -404,15 +409,15 @@
         default: Any | None = None,
         infer_variance: bool = False,
     ) -> None: ...
     if sys.version_info >= (3, 10):
         def __or__(self, right: Any) -> _SpecialForm: ...
         def __ror__(self, left: Any) -> _SpecialForm: ...
     if sys.version_info >= (3, 11):
-        def __typing_subst__(self, arg: Incomplete) -> Incomplete: ...
+        def __typing_subst__(self, arg: Any) -> Any: ...
 
 @final
 class ParamSpec:
     @property
     def __name__(self) -> str: ...
     @property
     def __bound__(self) -> Any | None: ...
@@ -444,27 +449,27 @@
     def __name__(self) -> str: ...
     @property
     def __default__(self) -> Any | None: ...
     def __init__(self, name: str, *, default: Any | None = None) -> None: ...
     def __iter__(self) -> Any: ...  # Unpack[Self]
 
 class deprecated:
-    message: str
+    message: LiteralString
     category: type[Warning] | None
     stacklevel: int
-    def __init__(self, __message: str, *, category: type[Warning] | None = ..., stacklevel: int = 1) -> None: ...
-    def __call__(self, __arg: _T) -> _T: ...
+    def __init__(self, message: LiteralString, /, *, category: type[Warning] | None = ..., stacklevel: int = 1) -> None: ...
+    def __call__(self, arg: _T, /) -> _T: ...
 
 if sys.version_info >= (3, 12):
     from collections.abc import Buffer as Buffer
     from types import get_original_bases as get_original_bases
     from typing import TypeAliasType as TypeAliasType, override as override
 else:
-    def override(__arg: _F) -> _F: ...
-    def get_original_bases(__cls: type) -> tuple[Any, ...]: ...
+    def override(arg: _F, /) -> _F: ...
+    def get_original_bases(cls: type, /) -> tuple[Any, ...]: ...
     @final
     class TypeAliasType:
         def __init__(
             self, name: str, value: Any, *, type_params: tuple[TypeVar | ParamSpec | TypeVarTuple, ...] = ()
         ) -> None: ...
         @property
         def __value__(self) -> Any: ...
@@ -482,22 +487,23 @@
             def __or__(self, right: Any) -> _SpecialForm: ...
             def __ror__(self, left: Any) -> _SpecialForm: ...
 
     @runtime_checkable
     class Buffer(Protocol):
         # Not actually a Protocol at runtime; see
         # https://github.com/python/typeshed/issues/10224 for why we're defining it this way
-        def __buffer__(self, __flags: int) -> memoryview: ...
+        def __buffer__(self, flags: int, /) -> memoryview: ...
 
 if sys.version_info >= (3, 13):
     from typing import get_protocol_members as get_protocol_members, is_protocol as is_protocol
 else:
-    def is_protocol(__tp: type) -> bool: ...
-    def get_protocol_members(__tp: type) -> frozenset[str]: ...
+    def is_protocol(tp: type, /) -> bool: ...
+    def get_protocol_members(tp: type, /) -> frozenset[str]: ...
 
 class Doc:
     documentation: str
-    def __init__(self, __documentation: str) -> None: ...
+    def __init__(self, documentation: str, /) -> None: ...
     def __hash__(self) -> int: ...
     def __eq__(self, other: object) -> bool: ...
 
 ReadOnly: _SpecialForm
+TypeIs: _SpecialForm
```

## puya/_vendor/mypy/typeshed/stdlib/unicodedata.pyi

```diff
@@ -7,65 +7,67 @@
 unidata_version: str
 
 if sys.version_info < (3, 10):
     ucnhash_CAPI: Any
 
 _T = TypeVar("_T")
 
-def bidirectional(__chr: str) -> str: ...
-def category(__chr: str) -> str: ...
-def combining(__chr: str) -> int: ...
+_NormalizationForm: TypeAlias = Literal["NFC", "NFD", "NFKC", "NFKD"]
+
+def bidirectional(chr: str, /) -> str: ...
+def category(chr: str, /) -> str: ...
+def combining(chr: str, /) -> int: ...
 @overload
-def decimal(__chr: str) -> int: ...
+def decimal(chr: str, /) -> int: ...
 @overload
-def decimal(__chr: str, __default: _T) -> int | _T: ...
-def decomposition(__chr: str) -> str: ...
+def decimal(chr: str, default: _T, /) -> int | _T: ...
+def decomposition(chr: str, /) -> str: ...
 @overload
-def digit(__chr: str) -> int: ...
+def digit(chr: str, /) -> int: ...
 @overload
-def digit(__chr: str, __default: _T) -> int | _T: ...
+def digit(chr: str, default: _T, /) -> int | _T: ...
 
 _EastAsianWidth: TypeAlias = Literal["F", "H", "W", "Na", "A", "N"]
 
-def east_asian_width(__chr: str) -> _EastAsianWidth: ...
-def is_normalized(__form: str, __unistr: str) -> bool: ...
-def lookup(__name: str | ReadOnlyBuffer) -> str: ...
-def mirrored(__chr: str) -> int: ...
+def east_asian_width(chr: str, /) -> _EastAsianWidth: ...
+def is_normalized(form: _NormalizationForm, unistr: str, /) -> bool: ...
+def lookup(name: str | ReadOnlyBuffer, /) -> str: ...
+def mirrored(chr: str, /) -> int: ...
 @overload
-def name(__chr: str) -> str: ...
+def name(chr: str, /) -> str: ...
 @overload
-def name(__chr: str, __default: _T) -> str | _T: ...
-def normalize(__form: str, __unistr: str) -> str: ...
+def name(chr: str, default: _T, /) -> str | _T: ...
+def normalize(form: _NormalizationForm, unistr: str, /) -> str: ...
 @overload
-def numeric(__chr: str) -> float: ...
+def numeric(chr: str, /) -> float: ...
 @overload
-def numeric(__chr: str, __default: _T) -> float | _T: ...
+def numeric(chr: str, default: _T, /) -> float | _T: ...
 @final
 class UCD:
     # The methods below are constructed from the same array in C
     # (unicodedata_functions) and hence identical to the functions above.
     unidata_version: str
-    def bidirectional(self, __chr: str) -> str: ...
-    def category(self, __chr: str) -> str: ...
-    def combining(self, __chr: str) -> int: ...
+    def bidirectional(self, chr: str, /) -> str: ...
+    def category(self, chr: str, /) -> str: ...
+    def combining(self, chr: str, /) -> int: ...
     @overload
-    def decimal(self, __chr: str) -> int: ...
+    def decimal(self, chr: str, /) -> int: ...
     @overload
-    def decimal(self, __chr: str, __default: _T) -> int | _T: ...
-    def decomposition(self, __chr: str) -> str: ...
+    def decimal(self, chr: str, default: _T, /) -> int | _T: ...
+    def decomposition(self, chr: str, /) -> str: ...
     @overload
-    def digit(self, __chr: str) -> int: ...
+    def digit(self, chr: str, /) -> int: ...
     @overload
-    def digit(self, __chr: str, __default: _T) -> int | _T: ...
-    def east_asian_width(self, __chr: str) -> _EastAsianWidth: ...
-    def is_normalized(self, __form: str, __unistr: str) -> bool: ...
-    def lookup(self, __name: str | ReadOnlyBuffer) -> str: ...
-    def mirrored(self, __chr: str) -> int: ...
+    def digit(self, chr: str, default: _T, /) -> int | _T: ...
+    def east_asian_width(self, chr: str, /) -> _EastAsianWidth: ...
+    def is_normalized(self, form: _NormalizationForm, unistr: str, /) -> bool: ...
+    def lookup(self, name: str | ReadOnlyBuffer, /) -> str: ...
+    def mirrored(self, chr: str, /) -> int: ...
     @overload
-    def name(self, __chr: str) -> str: ...
+    def name(self, chr: str, /) -> str: ...
     @overload
-    def name(self, __chr: str, __default: _T) -> str | _T: ...
-    def normalize(self, __form: str, __unistr: str) -> str: ...
+    def name(self, chr: str, default: _T, /) -> str | _T: ...
+    def normalize(self, form: _NormalizationForm, unistr: str, /) -> str: ...
     @overload
-    def numeric(self, __chr: str) -> float: ...
+    def numeric(self, chr: str, /) -> float: ...
     @overload
-    def numeric(self, __chr: str, __default: _T) -> float | _T: ...
+    def numeric(self, chr: str, default: _T, /) -> float | _T: ...
```

## puya/_vendor/mypy/typeshed/stdlib/unittest/async_case.pyi

```diff
@@ -10,12 +10,12 @@
 
 _T = TypeVar("_T")
 _P = ParamSpec("_P")
 
 class IsolatedAsyncioTestCase(TestCase):
     async def asyncSetUp(self) -> None: ...
     async def asyncTearDown(self) -> None: ...
-    def addAsyncCleanup(self, __func: Callable[_P, Awaitable[object]], *args: _P.args, **kwargs: _P.kwargs) -> None: ...
+    def addAsyncCleanup(self, func: Callable[_P, Awaitable[object]], /, *args: _P.args, **kwargs: _P.kwargs) -> None: ...
     if sys.version_info >= (3, 11):
         async def enterAsyncContext(self, cm: AbstractAsyncContextManager[_T]) -> _T: ...
     if sys.version_info >= (3, 9):
         def __del__(self) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/unittest/case.pyi

```diff
@@ -64,15 +64,15 @@
         msg: None
         def __init__(self, test_case: TestCase, logger_name: str, level: int) -> None: ...
         def __enter__(self) -> _LoggingWatcher: ...
         def __exit__(
             self, exc_type: type[BaseException] | None, exc_value: BaseException | None, tb: TracebackType | None
         ) -> bool | None: ...
 
-def addModuleCleanup(__function: Callable[_P, object], *args: _P.args, **kwargs: _P.kwargs) -> None: ...
+def addModuleCleanup(function: Callable[_P, object], /, *args: _P.args, **kwargs: _P.kwargs) -> None: ...
 def doModuleCleanups() -> None: ...
 
 if sys.version_info >= (3, 11):
     def enterModuleContext(cm: AbstractContextManager[_T]) -> _T: ...
 
 def expectedFailure(test_item: _FT) -> _FT: ...
 def skip(reason: str) -> Callable[[_FT], _FT]: ...
@@ -269,22 +269,22 @@
     # assertDictEqual incompatible with TypedDict.
     def assertDictEqual(self, d1: Mapping[Any, object], d2: Mapping[Any, object], msg: Any = None) -> None: ...
     def fail(self, msg: Any = None) -> NoReturn: ...
     def countTestCases(self) -> int: ...
     def defaultTestResult(self) -> unittest.result.TestResult: ...
     def id(self) -> str: ...
     def shortDescription(self) -> str | None: ...
-    def addCleanup(self, __function: Callable[_P, object], *args: _P.args, **kwargs: _P.kwargs) -> None: ...
+    def addCleanup(self, function: Callable[_P, object], /, *args: _P.args, **kwargs: _P.kwargs) -> None: ...
 
     if sys.version_info >= (3, 11):
         def enterContext(self, cm: AbstractContextManager[_T]) -> _T: ...
 
     def doCleanups(self) -> None: ...
     @classmethod
-    def addClassCleanup(cls, __function: Callable[_P, object], *args: _P.args, **kwargs: _P.kwargs) -> None: ...
+    def addClassCleanup(cls, function: Callable[_P, object], /, *args: _P.args, **kwargs: _P.kwargs) -> None: ...
     @classmethod
     def doClassCleanups(cls) -> None: ...
 
     if sys.version_info >= (3, 11):
         @classmethod
         def enterClassContext(cls, cm: AbstractContextManager[_T]) -> _T: ...
```

## puya/_vendor/mypy/typeshed/stdlib/unittest/main.pyi

```diff
@@ -7,15 +7,15 @@
 from types import ModuleType
 from typing import Any, Protocol
 
 MAIN_EXAMPLES: str
 MODULE_EXAMPLES: str
 
 class _TestRunner(Protocol):
-    def run(self, __test: unittest.suite.TestSuite | unittest.case.TestCase) -> unittest.result.TestResult: ...
+    def run(self, test: unittest.suite.TestSuite | unittest.case.TestCase, /) -> unittest.result.TestResult: ...
 
 # not really documented
 class TestProgram:
     result: unittest.result.TestResult
     module: None | str | ModuleType
     verbosity: int
     failfast: bool | None
```

## puya/_vendor/mypy/typeshed/stdlib/unittest/mock.pyi

```diff
@@ -61,15 +61,15 @@
         value: _CallValue = (),
         name: str | None = None,
         parent: Any | None = None,
         two: bool = False,
         from_kall: bool = True,
     ) -> None: ...
     def __eq__(self, other: object) -> bool: ...
-    def __ne__(self, __value: object) -> bool: ...
+    def __ne__(self, value: object, /) -> bool: ...
     def __call__(self, *args: Any, **kwargs: Any) -> _Call: ...
     def __getattr__(self, attr: str) -> Any: ...
     def __getattribute__(self, attr: str) -> Any: ...
     @property
     def args(self) -> tuple[Any, ...]: ...
     @property
     def kwargs(self) -> Mapping[str, Any]: ...
@@ -99,15 +99,15 @@
             _new_parent: NonCallableMock | None = None,
             _spec_as_instance: bool = False,
             _eat_self: bool | None = None,
             unsafe: bool = False,
             **kwargs: Any,
         ) -> Self: ...
     else:
-        def __new__(__cls, *args: Any, **kw: Any) -> Self: ...
+        def __new__(cls, /, *args: Any, **kw: Any) -> Self: ...
 
     def __init__(
         self,
         spec: list[str] | object | type[object] | None = None,
         wraps: Any | None = None,
         name: str | None = None,
         spec_set: list[str] | object | type[object] | None = None,
@@ -230,15 +230,15 @@
     def decorate_async_callable(self, func: Callable[..., Awaitable[_R]]) -> Callable[..., Awaitable[_R]]: ...
     def get_original(self) -> tuple[Any, bool]: ...
     target: Any
     temp_original: Any
     is_local: bool
     def __enter__(self) -> _T: ...
     def __exit__(
-        self, __exc_type: type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None
+        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None, /
     ) -> None: ...
     def start(self) -> _T: ...
     def stop(self) -> None: ...
 
 # This class does not exist at runtime, it's a hack to make this work:
 #     @patch("foo")
 #     def bar(..., mock: MagicMock) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/unittest/result.pyi

```diff
@@ -23,14 +23,15 @@
     shouldStop: bool
     testsRun: int
     buffer: bool
     failfast: bool
     tb_locals: bool
     if sys.version_info >= (3, 12):
         collectedDurations: _DurationsType
+
     def __init__(self, stream: TextIO | None = None, descriptions: bool | None = None, verbosity: int | None = None) -> None: ...
     def printErrors(self) -> None: ...
     def wasSuccessful(self) -> bool: ...
     def stop(self) -> None: ...
     def startTest(self, test: unittest.case.TestCase) -> None: ...
     def stopTest(self, test: unittest.case.TestCase) -> None: ...
     def startTestRun(self) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/urllib/request.pyi

```diff
@@ -223,15 +223,16 @@
 class ProxyDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler):
     auth_header: ClassVar[str]  # undocumented
     def http_error_407(self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage) -> _UrlopenRet | None: ...
 
 class _HTTPConnectionProtocol(Protocol):
     def __call__(
         self,
-        __host: str,
+        host: str,
+        /,
         *,
         port: int | None = ...,
         timeout: float = ...,
         source_address: tuple[str, int] | None = ...,
         blocksize: int = ...,
     ) -> HTTPConnection: ...
```

## puya/_vendor/mypy/typeshed/stdlib/weakref.pyi

```diff
@@ -47,18 +47,18 @@
     def __ne__(self, other: object) -> bool: ...
     def __hash__(self) -> int: ...
 
 class WeakValueDictionary(MutableMapping[_KT, _VT]):
     @overload
     def __init__(self) -> None: ...
     @overload
-    def __init__(self: WeakValueDictionary[_KT, _VT], __other: Mapping[_KT, _VT] | Iterable[tuple[_KT, _VT]]) -> None: ...
+    def __init__(self: WeakValueDictionary[_KT, _VT], other: Mapping[_KT, _VT] | Iterable[tuple[_KT, _VT]], /) -> None: ...
     @overload
     def __init__(
-        self: WeakValueDictionary[str, _VT], __other: Mapping[str, _VT] | Iterable[tuple[str, _VT]] = (), **kwargs: _VT
+        self: WeakValueDictionary[str, _VT], other: Mapping[str, _VT] | Iterable[tuple[str, _VT]] = (), /, **kwargs: _VT
     ) -> None: ...
     def __len__(self) -> int: ...
     def __getitem__(self, key: _KT) -> _VT: ...
     def __setitem__(self, key: _KT, value: _VT) -> None: ...
     def __delitem__(self, key: _KT) -> None: ...
     def __contains__(self, key: object) -> bool: ...
     def __iter__(self) -> Iterator[_KT]: ...
@@ -89,15 +89,14 @@
         @overload  # type: ignore[misc]
         def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...
         @overload
         def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self: ...
 
 class KeyedRef(ref[_T], Generic[_KT, _T]):
     key: _KT
-    # This __new__ method uses a non-standard name for the "cls" parameter
     def __new__(type, ob: _T, callback: Callable[[_T], Any], key: _KT) -> Self: ...
     def __init__(self, ob: _T, callback: Callable[[_T], Any], key: _KT) -> None: ...
 
 class WeakKeyDictionary(MutableMapping[_KT, _VT]):
     @overload
     def __init__(self, dict: None = None) -> None: ...
     @overload
@@ -137,14 +136,14 @@
         # WeakKeyDictionary.__ior__ should be kept roughly in line with MutableMapping.update()
         @overload  # type: ignore[misc]
         def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...
         @overload
         def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self: ...
 
 class finalize:  # TODO: This is a good candidate for to be a `Generic[_P, _T]` class
-    def __init__(self, __obj: object, __func: Callable[_P, Any], *args: _P.args, **kwargs: _P.kwargs) -> None: ...
+    def __init__(self, obj: object, func: Callable[_P, Any], /, *args: _P.args, **kwargs: _P.kwargs) -> None: ...
     def __call__(self, _: Any = None) -> Any | None: ...
     def detach(self) -> tuple[Any, Any, tuple[Any, ...], dict[str, Any]] | None: ...
     def peek(self) -> tuple[Any, Any, tuple[Any, ...], dict[str, Any]] | None: ...
     @property
     def alive(self) -> bool: ...
     atexit: bool
```

## puya/_vendor/mypy/typeshed/stdlib/winreg.pyi

```diff
@@ -1,93 +1,122 @@
 import sys
+from _typeshed import ReadableBuffer, Unused
 from types import TracebackType
-from typing import Any, Literal, final
+from typing import Any, Final, Literal, final, overload
 from typing_extensions import Self, TypeAlias
 
 if sys.platform == "win32":
     _KeyType: TypeAlias = HKEYType | int
-    def CloseKey(__hkey: _KeyType) -> None: ...
-    def ConnectRegistry(__computer_name: str | None, __key: _KeyType) -> HKEYType: ...
-    def CreateKey(__key: _KeyType, __sub_key: str | None) -> HKEYType: ...
+    def CloseKey(hkey: _KeyType, /) -> None: ...
+    def ConnectRegistry(computer_name: str | None, key: _KeyType, /) -> HKEYType: ...
+    def CreateKey(key: _KeyType, sub_key: str | None, /) -> HKEYType: ...
     def CreateKeyEx(key: _KeyType, sub_key: str | None, reserved: int = 0, access: int = 131078) -> HKEYType: ...
-    def DeleteKey(__key: _KeyType, __sub_key: str) -> None: ...
+    def DeleteKey(key: _KeyType, sub_key: str, /) -> None: ...
     def DeleteKeyEx(key: _KeyType, sub_key: str, access: int = 256, reserved: int = 0) -> None: ...
-    def DeleteValue(__key: _KeyType, __value: str) -> None: ...
-    def EnumKey(__key: _KeyType, __index: int) -> str: ...
-    def EnumValue(__key: _KeyType, __index: int) -> tuple[str, Any, int]: ...
-    def ExpandEnvironmentStrings(__string: str) -> str: ...
-    def FlushKey(__key: _KeyType) -> None: ...
-    def LoadKey(__key: _KeyType, __sub_key: str, __file_name: str) -> None: ...
+    def DeleteValue(key: _KeyType, value: str, /) -> None: ...
+    def EnumKey(key: _KeyType, index: int, /) -> str: ...
+    def EnumValue(key: _KeyType, index: int, /) -> tuple[str, Any, int]: ...
+    def ExpandEnvironmentStrings(string: str, /) -> str: ...
+    def FlushKey(key: _KeyType, /) -> None: ...
+    def LoadKey(key: _KeyType, sub_key: str, file_name: str, /) -> None: ...
     def OpenKey(key: _KeyType, sub_key: str, reserved: int = 0, access: int = 131097) -> HKEYType: ...
     def OpenKeyEx(key: _KeyType, sub_key: str, reserved: int = 0, access: int = 131097) -> HKEYType: ...
-    def QueryInfoKey(__key: _KeyType) -> tuple[int, int, int]: ...
-    def QueryValue(__key: _KeyType, __sub_key: str | None) -> str: ...
-    def QueryValueEx(__key: _KeyType, __name: str) -> tuple[Any, int]: ...
-    def SaveKey(__key: _KeyType, __file_name: str) -> None: ...
-    def SetValue(__key: _KeyType, __sub_key: str, __type: int, __value: str) -> None: ...
+    def QueryInfoKey(key: _KeyType, /) -> tuple[int, int, int]: ...
+    def QueryValue(key: _KeyType, sub_key: str | None, /) -> str: ...
+    def QueryValueEx(key: _KeyType, name: str, /) -> tuple[Any, int]: ...
+    def SaveKey(key: _KeyType, file_name: str, /) -> None: ...
+    def SetValue(key: _KeyType, sub_key: str, type: int, value: str, /) -> None: ...
+    @overload  # type=REG_DWORD|REG_QWORD
     def SetValueEx(
-        __key: _KeyType, __value_name: str | None, __reserved: Any, __type: int, __value: str | int
-    ) -> None: ...  # reserved is ignored
-    def DisableReflectionKey(__key: _KeyType) -> None: ...
-    def EnableReflectionKey(__key: _KeyType) -> None: ...
-    def QueryReflectionKey(__key: _KeyType) -> bool: ...
+        key: _KeyType, value_name: str | None, reserved: Unused, type: Literal[4, 5], value: int | None, /
+    ) -> None: ...
+    @overload  # type=REG_SZ|REG_EXPAND_SZ
+    def SetValueEx(
+        key: _KeyType, value_name: str | None, reserved: Unused, type: Literal[1, 2], value: str | None, /
+    ) -> None: ...
+    @overload  # type=REG_MULTI_SZ
+    def SetValueEx(
+        key: _KeyType, value_name: str | None, reserved: Unused, type: Literal[7], value: list[str] | None, /
+    ) -> None: ...
+    @overload  # type=REG_BINARY and everything else
+    def SetValueEx(
+        key: _KeyType,
+        value_name: str | None,
+        reserved: Unused,
+        type: Literal[0, 3, 8, 9, 10, 11],
+        value: ReadableBuffer | None,
+        /,
+    ) -> None: ...
+    @overload  # Unknown or undocumented
+    def SetValueEx(
+        key: _KeyType,
+        value_name: str | None,
+        reserved: Unused,
+        type: int,
+        value: int | str | list[str] | ReadableBuffer | None,
+        /,
+    ) -> None: ...
+    def DisableReflectionKey(key: _KeyType, /) -> None: ...
+    def EnableReflectionKey(key: _KeyType, /) -> None: ...
+    def QueryReflectionKey(key: _KeyType, /) -> bool: ...
+
     HKEY_CLASSES_ROOT: int
     HKEY_CURRENT_USER: int
     HKEY_LOCAL_MACHINE: int
     HKEY_USERS: int
     HKEY_PERFORMANCE_DATA: int
     HKEY_CURRENT_CONFIG: int
     HKEY_DYN_DATA: int
 
-    KEY_ALL_ACCESS: Literal[983103]
-    KEY_WRITE: Literal[131078]
-    KEY_READ: Literal[131097]
-    KEY_EXECUTE: Literal[131097]
-    KEY_QUERY_VALUE: Literal[1]
-    KEY_SET_VALUE: Literal[2]
-    KEY_CREATE_SUB_KEY: Literal[4]
-    KEY_ENUMERATE_SUB_KEYS: Literal[8]
-    KEY_NOTIFY: Literal[16]
-    KEY_CREATE_LINK: Literal[32]
-
-    KEY_WOW64_64KEY: Literal[256]
-    KEY_WOW64_32KEY: Literal[512]
-
-    REG_BINARY: Literal[3]
-    REG_DWORD: Literal[4]
-    REG_DWORD_LITTLE_ENDIAN: Literal[4]
-    REG_DWORD_BIG_ENDIAN: Literal[5]
-    REG_EXPAND_SZ: Literal[2]
-    REG_LINK: Literal[6]
-    REG_MULTI_SZ: Literal[7]
-    REG_NONE: Literal[0]
-    REG_QWORD: Literal[11]
-    REG_QWORD_LITTLE_ENDIAN: Literal[11]
-    REG_RESOURCE_LIST: Literal[8]
-    REG_FULL_RESOURCE_DESCRIPTOR: Literal[9]
-    REG_RESOURCE_REQUIREMENTS_LIST: Literal[10]
-    REG_SZ: Literal[1]
-
-    REG_CREATED_NEW_KEY: int  # undocumented
-    REG_LEGAL_CHANGE_FILTER: int  # undocumented
-    REG_LEGAL_OPTION: int  # undocumented
-    REG_NOTIFY_CHANGE_ATTRIBUTES: int  # undocumented
-    REG_NOTIFY_CHANGE_LAST_SET: int  # undocumented
-    REG_NOTIFY_CHANGE_NAME: int  # undocumented
-    REG_NOTIFY_CHANGE_SECURITY: int  # undocumented
-    REG_NO_LAZY_FLUSH: int  # undocumented
-    REG_OPENED_EXISTING_KEY: int  # undocumented
-    REG_OPTION_BACKUP_RESTORE: int  # undocumented
-    REG_OPTION_CREATE_LINK: int  # undocumented
-    REG_OPTION_NON_VOLATILE: int  # undocumented
-    REG_OPTION_OPEN_LINK: int  # undocumented
-    REG_OPTION_RESERVED: int  # undocumented
-    REG_OPTION_VOLATILE: int  # undocumented
-    REG_REFRESH_HIVE: int  # undocumented
-    REG_WHOLE_HIVE_VOLATILE: int  # undocumented
+    KEY_ALL_ACCESS: Final = 983103
+    KEY_WRITE: Final = 131078
+    KEY_READ: Final = 131097
+    KEY_EXECUTE: Final = 131097
+    KEY_QUERY_VALUE: Final = 1
+    KEY_SET_VALUE: Final = 2
+    KEY_CREATE_SUB_KEY: Final = 4
+    KEY_ENUMERATE_SUB_KEYS: Final = 8
+    KEY_NOTIFY: Final = 16
+    KEY_CREATE_LINK: Final = 32
+
+    KEY_WOW64_64KEY: Final = 256
+    KEY_WOW64_32KEY: Final = 512
+
+    REG_BINARY: Final = 3
+    REG_DWORD: Final = 4
+    REG_DWORD_LITTLE_ENDIAN: Final = 4
+    REG_DWORD_BIG_ENDIAN: Final = 5
+    REG_EXPAND_SZ: Final = 2
+    REG_LINK: Final = 6
+    REG_MULTI_SZ: Final = 7
+    REG_NONE: Final = 0
+    REG_QWORD: Final = 11
+    REG_QWORD_LITTLE_ENDIAN: Final = 11
+    REG_RESOURCE_LIST: Final = 8
+    REG_FULL_RESOURCE_DESCRIPTOR: Final = 9
+    REG_RESOURCE_REQUIREMENTS_LIST: Final = 10
+    REG_SZ: Final = 1
+
+    REG_CREATED_NEW_KEY: Final = 1  # undocumented
+    REG_LEGAL_CHANGE_FILTER: Final = 268435471  # undocumented
+    REG_LEGAL_OPTION: Final = 31  # undocumented
+    REG_NOTIFY_CHANGE_ATTRIBUTES: Final = 2  # undocumented
+    REG_NOTIFY_CHANGE_LAST_SET: Final = 4  # undocumented
+    REG_NOTIFY_CHANGE_NAME: Final = 1  # undocumented
+    REG_NOTIFY_CHANGE_SECURITY: Final = 8  # undocumented
+    REG_NO_LAZY_FLUSH: Final = 4  # undocumented
+    REG_OPENED_EXISTING_KEY: Final = 2  # undocumented
+    REG_OPTION_BACKUP_RESTORE: Final = 4  # undocumented
+    REG_OPTION_CREATE_LINK: Final = 2  # undocumented
+    REG_OPTION_NON_VOLATILE: Final = 0  # undocumented
+    REG_OPTION_OPEN_LINK: Final = 8  # undocumented
+    REG_OPTION_RESERVED: Final = 0  # undocumented
+    REG_OPTION_VOLATILE: Final = 1  # undocumented
+    REG_REFRESH_HIVE: Final = 2  # undocumented
+    REG_WHOLE_HIVE_VOLATILE: Final = 1  # undocumented
 
     error = OSError
 
     # Though this class has a __name__ of PyHKEY, it's exposed as HKEYType for some reason
     @final
     class HKEYType:
         def __bool__(self) -> bool: ...
```

## puya/_vendor/mypy/typeshed/stdlib/wsgiref/types.pyi

```diff
@@ -3,30 +3,30 @@
 from typing import Any, Protocol
 from typing_extensions import TypeAlias
 
 __all__ = ["StartResponse", "WSGIEnvironment", "WSGIApplication", "InputStream", "ErrorStream", "FileWrapper"]
 
 class StartResponse(Protocol):
     def __call__(
-        self, __status: str, __headers: list[tuple[str, str]], __exc_info: _OptExcInfo | None = ...
+        self, status: str, headers: list[tuple[str, str]], exc_info: _OptExcInfo | None = ..., /
     ) -> Callable[[bytes], object]: ...
 
 WSGIEnvironment: TypeAlias = dict[str, Any]
 WSGIApplication: TypeAlias = Callable[[WSGIEnvironment, StartResponse], Iterable[bytes]]
 
 class InputStream(Protocol):
-    def read(self, __size: int = ...) -> bytes: ...
-    def readline(self, __size: int = ...) -> bytes: ...
-    def readlines(self, __hint: int = ...) -> list[bytes]: ...
+    def read(self, size: int = ..., /) -> bytes: ...
+    def readline(self, size: int = ..., /) -> bytes: ...
+    def readlines(self, hint: int = ..., /) -> list[bytes]: ...
     def __iter__(self) -> Iterator[bytes]: ...
 
 class ErrorStream(Protocol):
     def flush(self) -> object: ...
-    def write(self, __s: str) -> object: ...
-    def writelines(self, __seq: list[str]) -> object: ...
+    def write(self, s: str, /) -> object: ...
+    def writelines(self, seq: list[str], /) -> object: ...
 
 class _Readable(Protocol):
-    def read(self, __size: int = ...) -> bytes: ...
+    def read(self, size: int = ..., /) -> bytes: ...
     # Optional: def close(self) -> object: ...
 
 class FileWrapper(Protocol):
-    def __call__(self, __file: _Readable, __block_size: int = ...) -> Iterable[bytes]: ...
+    def __call__(self, file: _Readable, block_size: int = ..., /) -> Iterable[bytes]: ...
```

## puya/_vendor/mypy/typeshed/stdlib/xml/dom/minidom.pyi

```diff
@@ -252,17 +252,17 @@
     def length(self) -> int: ...
 
 class Text(CharacterData):
     nodeType: int
     nodeName: str
     attributes: Incomplete
     data: Incomplete
-    def splitText(self, offset): ...
+    def splitText(self, offset: int) -> Self: ...
     def writexml(self, writer: SupportsWrite[str], indent: str = "", addindent: str = "", newl: str = "") -> None: ...
-    def replaceWholeText(self, content): ...
+    def replaceWholeText(self, content) -> Self | None: ...
     @property
     def isWhitespaceInElementContent(self) -> bool: ...
     @property
     def wholeText(self) -> str: ...
 
 class Comment(CharacterData):
     nodeType: int
```

## puya/_vendor/mypy/typeshed/stdlib/xml/dom/xmlbuilder.pyi

```diff
@@ -56,15 +56,15 @@
     ACTION_APPEND_AS_CHILDREN: Literal[2]
     ACTION_INSERT_AFTER: Literal[3]
     ACTION_INSERT_BEFORE: Literal[4]
     def setFeature(self, name: str, state: int) -> None: ...
     def supportsFeature(self, name: str) -> bool: ...
     def canSetFeature(self, name: str, state: int) -> bool: ...
     # getFeature could return any attribute from an instance of `Options`
-    def getFeature(self, name: str) -> Incomplete: ...
+    def getFeature(self, name: str) -> Any: ...
     def parseURI(self, uri: str) -> ExpatBuilder | ExpatBuilderNS: ...
     def parse(self, input: DOMInputSource) -> ExpatBuilder | ExpatBuilderNS: ...
     # `input` and `cnode` argtypes for `parseWithContext` are unknowable
     # as the function does nothing with them, and always raises an exception.
     # But `input` is *probably* `DOMInputSource`?
     def parseWithContext(self, input: Unused, cnode: Unused, action: Literal[1, 2, 3, 4]) -> NoReturn: ...
```

## puya/_vendor/mypy/typeshed/stdlib/xml/etree/ElementTree.pyi

```diff
@@ -1,13 +1,13 @@
 import sys
 from _collections_abc import dict_keys
 from _typeshed import FileDescriptorOrPath, ReadableBuffer, SupportsRead, SupportsWrite
 from collections.abc import Callable, Generator, ItemsView, Iterable, Iterator, Mapping, Sequence
 from typing import Any, Literal, SupportsIndex, TypeVar, overload
-from typing_extensions import TypeAlias, TypeGuard
+from typing_extensions import TypeAlias, TypeGuard, deprecated
 
 __all__ = [
     "C14NWriterTarget",
     "Comment",
     "dump",
     "Element",
     "ElementTree",
@@ -80,51 +80,55 @@
 
 class Element:
     tag: str
     attrib: dict[str, str]
     text: str | None
     tail: str | None
     def __init__(self, tag: str, attrib: dict[str, str] = ..., **extra: str) -> None: ...
-    def append(self, __subelement: Element) -> None: ...
+    def append(self, subelement: Element, /) -> None: ...
     def clear(self) -> None: ...
-    def extend(self, __elements: Iterable[Element]) -> None: ...
+    def extend(self, elements: Iterable[Element], /) -> None: ...
     def find(self, path: str, namespaces: dict[str, str] | None = None) -> Element | None: ...
     def findall(self, path: str, namespaces: dict[str, str] | None = None) -> list[Element]: ...
     @overload
     def findtext(self, path: str, default: None = None, namespaces: dict[str, str] | None = None) -> str | None: ...
     @overload
     def findtext(self, path: str, default: _T, namespaces: dict[str, str] | None = None) -> _T | str: ...
     @overload
     def get(self, key: str, default: None = None) -> str | None: ...
     @overload
     def get(self, key: str, default: _T) -> str | _T: ...
-    def insert(self, __index: int, __subelement: Element) -> None: ...
+    def insert(self, index: int, subelement: Element, /) -> None: ...
     def items(self) -> ItemsView[str, str]: ...
     def iter(self, tag: str | None = None) -> Generator[Element, None, None]: ...
     def iterfind(self, path: str, namespaces: dict[str, str] | None = None) -> Generator[Element, None, None]: ...
     def itertext(self) -> Generator[str, None, None]: ...
     def keys(self) -> dict_keys[str, str]: ...
     # makeelement returns the type of self in Python impl, but not in C impl
-    def makeelement(self, __tag: str, __attrib: dict[str, str]) -> Element: ...
-    def remove(self, __subelement: Element) -> None: ...
-    def set(self, __key: str, __value: str) -> None: ...
+    def makeelement(self, tag: str, attrib: dict[str, str], /) -> Element: ...
+    def remove(self, subelement: Element, /) -> None: ...
+    def set(self, key: str, value: str, /) -> None: ...
     def __copy__(self) -> Element: ...  # returns the type of self in Python impl, but not in C impl
-    def __deepcopy__(self, __memo: Any) -> Element: ...  # Only exists in C impl
-    def __delitem__(self, __key: SupportsIndex | slice) -> None: ...
+    def __deepcopy__(self, memo: Any, /) -> Element: ...  # Only exists in C impl
+    def __delitem__(self, key: SupportsIndex | slice, /) -> None: ...
     @overload
-    def __getitem__(self, __key: SupportsIndex) -> Element: ...
+    def __getitem__(self, key: SupportsIndex, /) -> Element: ...
     @overload
-    def __getitem__(self, __key: slice) -> list[Element]: ...
+    def __getitem__(self, key: slice, /) -> list[Element]: ...
     def __len__(self) -> int: ...
     # Doesn't actually exist at runtime, but instance of the class are indeed iterable due to __getitem__.
     def __iter__(self) -> Iterator[Element]: ...
     @overload
-    def __setitem__(self, __key: SupportsIndex, __value: Element) -> None: ...
+    def __setitem__(self, key: SupportsIndex, value: Element, /) -> None: ...
     @overload
-    def __setitem__(self, __key: slice, __value: Iterable[Element]) -> None: ...
+    def __setitem__(self, key: slice, value: Iterable[Element], /) -> None: ...
+
+    # Doesn't really exist in earlier versions, where __len__ is called implicitly instead
+    @deprecated("Testing an element's truth value is deprecated.")
+    def __bool__(self) -> bool: ...
     if sys.version_info < (3, 9):
         def getchildren(self) -> list[Element]: ...
         def getiterator(self, tag: str | None = None) -> list[Element]: ...
 
 def SubElement(parent: Element, tag: str, attrib: dict[str, str] = ..., **extra: str) -> Element: ...
 def Comment(text: str | None = None) -> Element: ...
 def ProcessingInstruction(target: str, text: str | None = None) -> Element: ...
@@ -242,14 +246,15 @@
 class XMLPullParser:
     def __init__(self, events: Sequence[str] | None = None, *, _parser: XMLParser | None = None) -> None: ...
     def feed(self, data: str | ReadableBuffer) -> None: ...
     def close(self) -> None: ...
     # Second element in the tuple could be `Element`, `tuple[str, str]` or `None`.
     # Use `Any` to avoid false-positive errors.
     def read_events(self) -> Iterator[tuple[str, Any]]: ...
+    def flush(self) -> None: ...
 
 def XML(text: str | ReadableBuffer, parser: XMLParser | None = None) -> Element: ...
 def XMLID(text: str | ReadableBuffer, parser: XMLParser | None = None) -> tuple[Element, dict[str, Element]]: ...
 
 # This is aliased to XML in the source.
 fromstring = XML
 
@@ -277,22 +282,22 @@
         insert_comments: bool = ...,
         insert_pis: bool = ...,
     ) -> None: ...
     insert_comments: bool
     insert_pis: bool
 
     def close(self) -> Element: ...
-    def data(self, __data: str) -> None: ...
+    def data(self, data: str, /) -> None: ...
     # tag and attrs are passed to the element_factory, so they could be anything
     # depending on what the particular factory supports.
-    def start(self, __tag: Any, __attrs: dict[Any, Any]) -> Element: ...
-    def end(self, __tag: str) -> Element: ...
+    def start(self, tag: Any, attrs: dict[Any, Any], /) -> Element: ...
+    def end(self, tag: str, /) -> Element: ...
     # These two methods have pos-only parameters in the C implementation
-    def comment(self, __text: str | None) -> Element: ...
-    def pi(self, __target: str, __text: str | None = None) -> Element: ...
+    def comment(self, text: str | None, /) -> Element: ...
+    def pi(self, target: str, text: str | None = None, /) -> Element: ...
 
 class C14NWriterTarget:
     def __init__(
         self,
         write: Callable[[str], object],
         *,
         with_comments: bool = False,
@@ -314,8 +319,9 @@
     parser: Any
     target: Any
     # TODO-what is entity used for???
     entity: Any
     version: str
     def __init__(self, *, target: Any = ..., encoding: str | None = ...) -> None: ...
     def close(self) -> Any: ...
-    def feed(self, __data: str | ReadableBuffer) -> None: ...
+    def feed(self, data: str | ReadableBuffer, /) -> None: ...
+    def flush(self) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/xmlrpc/server.pyi

```diff
@@ -8,25 +8,25 @@
 from xmlrpc.client import Fault, _Marshallable
 
 # The dispatch accepts anywhere from 0 to N arguments, no easy way to allow this in mypy
 class _DispatchArity0(Protocol):
     def __call__(self) -> _Marshallable: ...
 
 class _DispatchArity1(Protocol):
-    def __call__(self, __arg1: _Marshallable) -> _Marshallable: ...
+    def __call__(self, arg1: _Marshallable, /) -> _Marshallable: ...
 
 class _DispatchArity2(Protocol):
-    def __call__(self, __arg1: _Marshallable, __arg2: _Marshallable) -> _Marshallable: ...
+    def __call__(self, arg1: _Marshallable, arg2: _Marshallable, /) -> _Marshallable: ...
 
 class _DispatchArity3(Protocol):
-    def __call__(self, __arg1: _Marshallable, __arg2: _Marshallable, __arg3: _Marshallable) -> _Marshallable: ...
+    def __call__(self, arg1: _Marshallable, arg2: _Marshallable, arg3: _Marshallable, /) -> _Marshallable: ...
 
 class _DispatchArity4(Protocol):
     def __call__(
-        self, __arg1: _Marshallable, __arg2: _Marshallable, __arg3: _Marshallable, __arg4: _Marshallable
+        self, arg1: _Marshallable, arg2: _Marshallable, arg3: _Marshallable, arg4: _Marshallable, /
     ) -> _Marshallable: ...
 
 class _DispatchArityN(Protocol):
     def __call__(self, *args: _Marshallable) -> _Marshallable: ...
 
 _DispatchProtocol: TypeAlias = (
     _DispatchArity0 | _DispatchArity1 | _DispatchArity2 | _DispatchArity3 | _DispatchArity4 | _DispatchArityN
```

## puya/_vendor/mypy/typeshed/stdlib/xxlimited.pyi

```diff
@@ -5,18 +5,18 @@
 
 @final
 class Xxo:
     def demo(self) -> None: ...
     if sys.version_info >= (3, 11) and sys.platform != "win32":
         x_exports: int
 
-def foo(__i: int, __j: int) -> Any: ...
+def foo(i: int, j: int, /) -> Any: ...
 def new() -> Xxo: ...
 
 if sys.version_info >= (3, 10):
     class Error(Exception): ...
 
 else:
     class error(Exception): ...
     class Null: ...
 
-    def roj(__b: Any) -> None: ...
+    def roj(b: Any, /) -> None: ...
```

## puya/_vendor/mypy/typeshed/stdlib/zipfile/__init__.pyi

```diff
@@ -36,24 +36,24 @@
 
 BadZipfile = BadZipFile
 error = BadZipfile
 
 class LargeZipFile(Exception): ...
 
 class _ZipStream(Protocol):
-    def read(self, __n: int) -> bytes: ...
+    def read(self, n: int, /) -> bytes: ...
     # The following methods are optional:
     # def seekable(self) -> bool: ...
     # def tell(self) -> int: ...
-    # def seek(self, __n: int) -> object: ...
+    # def seek(self, n: int, /) -> object: ...
 
 # Stream shape as required by _EndRecData() and _EndRecData64().
 class _SupportsReadSeekTell(Protocol):
-    def read(self, __n: int = ...) -> bytes: ...
-    def seek(self, __cookie: int, __whence: int) -> object: ...
+    def read(self, n: int = ..., /) -> bytes: ...
+    def seek(self, cookie: int, whence: int, /) -> object: ...
     def tell(self) -> int: ...
 
 class _ClosableZipStream(_ZipStream, Protocol):
     def close(self) -> object: ...
 
 class ZipExtFile(io.BufferedIOBase):
     MAX_N: int
@@ -88,15 +88,15 @@
     def read(self, n: int | None = -1) -> bytes: ...
     def readline(self, limit: int = -1) -> bytes: ...  # type: ignore[override]
     def peek(self, n: int = 1) -> bytes: ...
     def read1(self, n: int | None) -> bytes: ...  # type: ignore[override]
     def seek(self, offset: int, whence: int = 0) -> int: ...
 
 class _Writer(Protocol):
-    def write(self, __s: str) -> object: ...
+    def write(self, s: str, /) -> object: ...
 
 class ZipFile:
     filename: str | None
     debug: int
     comment: bytes
     filelist: list[ZipInfo]
     fp: IO[bytes] | None
```

## puya/_vendor/mypy/typeshed/stdlib/zlib.pyi

```diff
@@ -36,21 +36,21 @@
     unused_data: bytes
     unconsumed_tail: bytes
     eof: bool
     def decompress(self, data: ReadableBuffer, max_length: int = ...) -> bytes: ...
     def flush(self, length: int = ...) -> bytes: ...
     def copy(self) -> _Decompress: ...
 
-def adler32(__data: ReadableBuffer, __value: int = 1) -> int: ...
+def adler32(data: ReadableBuffer, value: int = 1, /) -> int: ...
 
 if sys.version_info >= (3, 11):
-    def compress(__data: ReadableBuffer, level: int = -1, wbits: int = 15) -> bytes: ...
+    def compress(data: ReadableBuffer, /, level: int = -1, wbits: int = 15) -> bytes: ...
 
 else:
-    def compress(__data: ReadableBuffer, level: int = -1) -> bytes: ...
+    def compress(data: ReadableBuffer, /, level: int = -1) -> bytes: ...
 
 def compressobj(
     level: int = -1, method: int = 8, wbits: int = 15, memLevel: int = 8, strategy: int = 0, zdict: ReadableBuffer | None = None
 ) -> _Compress: ...
-def crc32(__data: ReadableBuffer, __value: int = 0) -> int: ...
-def decompress(__data: ReadableBuffer, wbits: int = 15, bufsize: int = 16384) -> bytes: ...
+def crc32(data: ReadableBuffer, value: int = 0, /) -> int: ...
+def decompress(data: ReadableBuffer, /, wbits: int = 15, bufsize: int = 16384) -> bytes: ...
 def decompressobj(wbits: int = 15, zdict: ReadableBuffer = b"") -> _Decompress: ...
```

## puya/_vendor/mypy/typeshed/stdlib/zoneinfo/__init__.pyi

```diff
@@ -3,30 +3,30 @@
 from datetime import datetime, timedelta, tzinfo
 from typing import Any, Protocol
 from typing_extensions import Self
 
 __all__ = ["ZoneInfo", "reset_tzpath", "available_timezones", "TZPATH", "ZoneInfoNotFoundError", "InvalidTZPathWarning"]
 
 class _IOBytes(Protocol):
-    def read(self, __size: int) -> bytes: ...
-    def seek(self, __size: int, __whence: int = ...) -> Any: ...
+    def read(self, size: int, /) -> bytes: ...
+    def seek(self, size: int, whence: int = ..., /) -> Any: ...
 
 class ZoneInfo(tzinfo):
     @property
     def key(self) -> str: ...
     def __init__(self, key: str) -> None: ...
     @classmethod
     def no_cache(cls, key: str) -> Self: ...
     @classmethod
-    def from_file(cls, __fobj: _IOBytes, key: str | None = None) -> Self: ...
+    def from_file(cls, fobj: _IOBytes, /, key: str | None = None) -> Self: ...
     @classmethod
     def clear_cache(cls, *, only_keys: Iterable[str] | None = None) -> None: ...
-    def tzname(self, __dt: datetime | None) -> str | None: ...
-    def utcoffset(self, __dt: datetime | None) -> timedelta | None: ...
-    def dst(self, __dt: datetime | None) -> timedelta | None: ...
+    def tzname(self, dt: datetime | None, /) -> str | None: ...
+    def utcoffset(self, dt: datetime | None, /) -> timedelta | None: ...
+    def dst(self, dt: datetime | None, /) -> timedelta | None: ...
 
 # Note: Both here and in clear_cache, the types allow the use of `str` where
 # a sequence of strings is required. This should be remedied if a solution
 # to this typing bug is found: https://github.com/python/typing/issues/256
 def reset_tzpath(to: Sequence[StrPath] | None = None) -> None: ...
 def available_timezones() -> set[str]: ...
```

## puya/_vendor/mypy/typetraverser.py

```diff
@@ -57,24 +57,24 @@
     def visit_deleted_type(self, t: DeletedType) -> None:
         pass
 
     def visit_type_var(self, t: TypeVarType) -> None:
         # Note that type variable values and upper bound aren't treated as
         # components, since they are components of the type variable
         # definition. We want to traverse everything just once.
-        pass
+        t.default.accept(self)
 
     def visit_param_spec(self, t: ParamSpecType) -> None:
-        pass
+        t.default.accept(self)
 
     def visit_parameters(self, t: Parameters) -> None:
         self.traverse_types(t.arg_types)
 
     def visit_type_var_tuple(self, t: TypeVarTupleType) -> None:
-        pass
+        t.default.accept(self)
 
     def visit_literal_type(self, t: LiteralType) -> None:
         t.fallback.accept(self)
 
     # Composite types
 
     def visit_instance(self, t: Instance) -> None:
@@ -82,14 +82,20 @@
 
     def visit_callable_type(self, t: CallableType) -> None:
         # FIX generics
         self.traverse_types(t.arg_types)
         t.ret_type.accept(self)
         t.fallback.accept(self)
 
+        if t.type_guard is not None:
+            t.type_guard.accept(self)
+
+        if t.type_is is not None:
+            t.type_is.accept(self)
+
     def visit_tuple_type(self, t: TupleType) -> None:
         self.traverse_types(t.items)
         t.partial_fallback.accept(self)
 
     def visit_typeddict_type(self, t: TypedDictType) -> None:
         self.traverse_types(t.items.values())
         t.fallback.accept(self)
```

## puya/_vendor/mypy/util.py

```diff
@@ -294,15 +294,15 @@
                     ),
                 )
             else:
                 xml += JUNIT_TESTCASE_FAIL_TEMPLATE.format(
                     text=escape("\n".join(messages)),
                     filename="mypy",
                     time=dt,
-                    name="mypy-py{ver}-{platform}".format(ver=version, platform=platform),
+                    name=f"mypy-py{version}-{platform}",
                 )
 
     xml += JUNIT_FOOTER
 
     return xml
```

## puya/_vendor/mypy/version.py

```diff
@@ -4,15 +4,15 @@
 
 from mypy import git
 
 # Base version.
 # - Release versions have the form "1.2.3".
 # - Dev versions have the form "1.2.3+dev" (PLUS sign to conform to PEP 440).
 # - Before 1.0 we had the form "0.NNN".
-__version__ = "1.9.0"
+__version__ = "1.10.0"
 base_version = __version__
 
 mypy_dir = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
 if __version__.endswith("+dev") and git.is_git_repo(mypy_dir) and git.have_git():
     __version__ += "." + git.git_revision(mypy_dir).decode("utf-8")
     if git.is_dirty(mypy_dir):
         __version__ += ".dirty"
```

## puya/arc4_util.py

```diff
@@ -62,38 +62,66 @@
     },
     "address": wtypes.arc4_address_type,
     "byte": wtypes.arc4_byte_type,
     "byte[]": wtypes.arc4_dynamic_bytes,
 }
 
 
+def make_dynamic_array_wtype(
+    element_type: wtypes.WType, location: SourceLocation | None
+) -> wtypes.ARC4DynamicArray:
+    if not wtypes.is_arc4_encoded_type(element_type):
+        raise CodeError(f"Invalid element type for arc4.DynamicArray: {element_type}", location)
+    return wtypes.ARC4DynamicArray.from_element_type(element_type)
+
+
+def make_static_array_wtype(
+    element_type: wtypes.WType, size: int, location: SourceLocation | None
+) -> wtypes.ARC4StaticArray:
+    if not wtypes.is_arc4_encoded_type(element_type):
+        raise CodeError(f"Invalid element type for arc4.StaticArray: {element_type}", location)
+    return wtypes.ARC4StaticArray.from_element_type_and_size(element_type, int(size))
+
+
+def make_tuple_wtype(
+    types: Iterable[wtypes.WType], location: SourceLocation | None
+) -> wtypes.ARC4Tuple:
+    arc4_types = list[wtypes.ARC4Type]()
+    for typ in types:
+        if wtypes.is_arc4_encoded_type(typ):
+            arc4_types.append(typ)
+        else:
+            raise CodeError(f"Invalid type for arc4.Tuple element: {typ}", location)
+    return wtypes.ARC4Tuple.from_types(arc4_types)
+
+
 def arc4_to_wtype(typ: str, location: SourceLocation | None = None) -> wtypes.WType:
     try:
         return _ARC4_WTYPE_MAPPING[typ]
     except KeyError:
         pass
     if uint := _UINT_REGEX.match(typ):
         n = uint.group("n")
         return wtypes.ARC4UIntN.from_scale(int(n))
     if ufixed := _UFIXED_REGEX.match(typ):
         n, m = ufixed.group("n", "m")
         return wtypes.ARC4UFixedNxM.from_scale_and_precision(int(n), int(m))
     if fixed_array := _FIXED_ARRAY_REGEX.match(typ):
         arr_type, size = fixed_array.group("type", "size")
-        inner_cls = arc4_to_wtype(arr_type, location)
-        return wtypes.ARC4StaticArray.from_element_type_and_size(inner_cls, int(size))
+        element_type = arc4_to_wtype(arr_type, location)
+        return make_static_array_wtype(element_type, int(size), location)
     if dynamic_array := _DYNAMIC_ARRAY_REGEX.match(typ):
         arr_type = dynamic_array.group("type")
-        inner_cls = arc4_to_wtype(arr_type, location)
-        return wtypes.ARC4DynamicArray.from_element_type(inner_cls)
+        element_type = arc4_to_wtype(arr_type, location)
+        return make_dynamic_array_wtype(element_type, location)
     if tuple_match := _TUPLE_REGEX.match(typ):
         tuple_types = [
             arc4_to_wtype(x, location) for x in split_tuple_types(tuple_match.group("types"))
         ]
-        return wtypes.ARC4Tuple.from_types(tuple_types)
+        return make_tuple_wtype(tuple_types, location)
     raise CodeError(f"Unknown ARC4 type '{typ}'", location)
 
 
 def split_tuple_types(types: str) -> Iterable[str]:
     """Splits inner tuple types into individual elements.
 
     e.g. "uint64,(uint8,string),bool" becomes ["uint64", "(uint8,string)", "bool"]
```

## puya/awst/function_traverser.py

```diff
@@ -46,18 +46,14 @@
 
     def visit_arc4_decode(self, expr: awst_nodes.ARC4Decode) -> None:
         expr.value.accept(self)
 
     def visit_arc4_encode(self, expr: awst_nodes.ARC4Encode) -> None:
         expr.value.accept(self)
 
-    def visit_arc4_array_encode(self, expr: awst_nodes.ARC4ArrayEncode) -> None:
-        for value in expr.values:
-            value.accept(self)
-
     def visit_array_concat(self, expr: awst_nodes.ArrayConcat) -> None:
         expr.left.accept(self)
         expr.right.accept(self)
 
     def visit_array_pop(self, expr: awst_nodes.ArrayPop) -> None:
         expr.base.accept(self)
 
@@ -139,15 +135,19 @@
 
     def visit_app_account_state_expression(
         self, expr: awst_nodes.AppAccountStateExpression
     ) -> None:
         expr.account.accept(self)
 
     def visit_new_array(self, expr: awst_nodes.NewArray) -> None:
-        for element in expr.elements:
+        for element in expr.values:
+            element.accept(self)
+
+    def visit_new_struct(self, expr: awst_nodes.NewStruct) -> None:
+        for element in expr.values.values():
             element.accept(self)
 
     def visit_bytes_comparison_expression(
         self, expr: awst_nodes.BytesComparisonExpression
     ) -> None:
         expr.lhs.accept(self)
         expr.rhs.accept(self)
```

## puya/awst/nodes.py

```diff
@@ -35,25 +35,23 @@
 class Node:
     source_location: SourceLocation
 
 
 @attrs.frozen
 class Statement(Node, ABC):
     @abstractmethod
-    def accept(self, visitor: StatementVisitor[T]) -> T:
-        ...
+    def accept(self, visitor: StatementVisitor[T]) -> T: ...
 
 
 @attrs.frozen
 class Expression(Node, ABC):
     wtype: WType
 
     @abstractmethod
-    def accept(self, visitor: ExpressionVisitor[T]) -> T:
-        ...
+    def accept(self, visitor: ExpressionVisitor[T]) -> T: ...
 
 
 @attrs.frozen(init=False)
 class ExpressionStatement(Statement):
     expr: Expression
 
     def __init__(self, expr: Expression):
@@ -404,14 +402,25 @@
     def accept(self, visitor: ExpressionVisitor[T]) -> T:
         return visitor.visit_address_constant(self)
 
 
 @attrs.frozen
 class ARC4Encode(Expression):
     value: Expression
+    wtype: wtypes.ARC4Type = attrs.field(
+        validator=wtype_is_one_of(
+            wtypes.ARC4UIntN,
+            wtypes.ARC4UFixedNxM,
+            wtypes.ARC4Tuple,
+            wtypes.arc4_string_wtype,
+            wtypes.arc4_bool_wtype,
+            wtypes.arc4_dynamic_bytes,
+            wtypes.arc4_address_type,
+        )
+    )
 
     def accept(self, visitor: ExpressionVisitor[T]) -> T:
         return visitor.visit_arc4_encode(self)
 
 
 @attrs.frozen
 class Copy(Expression):
@@ -422,23 +431,14 @@
     value: Expression
 
     def accept(self, visitor: ExpressionVisitor[T]) -> T:
         return visitor.visit_copy(self)
 
 
 @attrs.frozen
-class ARC4ArrayEncode(Expression):
-    wtype: wtypes.ARC4StaticArray | wtypes.ARC4DynamicArray
-    values: Sequence[Expression] = attrs.field(default=(), converter=tuple[Expression, ...])
-
-    def accept(self, visitor: ExpressionVisitor[T]) -> T:
-        return visitor.visit_arc4_array_encode(self)
-
-
-@attrs.frozen
 class ArrayConcat(Expression):
     """
     Given 'left' or 'right' that is logically an array - concat it with the other value which is
     an iterable type with the same element type
     """
 
     left: Expression
@@ -588,14 +588,15 @@
             additional_input_wtypes=(wtypes.uint64_wtype,),
         )
 
 
 class TxnFields:
     approval_program_pages = TxnField.bytes_("ApprovalProgramPages", num_values=4)
     clear_state_program_pages = TxnField.bytes_("ClearStateProgramPages", num_values=4)
+    fee = TxnField.uint64("Fee")
     type = TxnField.uint64("TypeEnum")
     app_args = TxnField.bytes_(
         immediate="ApplicationArgs",
         num_values=16,
         additional_input_wtypes=(
             wtypes.biguint_wtype,
             wtypes.account_wtype,
@@ -606,15 +607,15 @@
     assets = TxnField.asset("Assets", num_values=8)
     apps = TxnField.application("Applications", num_values=8)
     last_log = TxnField.bytes_("LastLog", is_inner_param=False)
 
 
 TXN_FIELDS = [
     TxnField.account("Sender"),
-    TxnField.uint64("Fee"),
+    TxnFields.fee,
     TxnField.uint64("FirstValid", is_inner_param=False),
     TxnField.uint64("FirstValidTime", is_inner_param=False),
     TxnField.uint64("LastValid", is_inner_param=False),
     TxnField.bytes_("Note", additional_input_wtypes=(wtypes.string_wtype,)),
     TxnField.bytes_("Lease", is_inner_param=False),
     TxnField.account("Receiver"),
     TxnField.uint64("Amount"),
@@ -782,31 +783,31 @@
 
 @attrs.frozen(init=False)
 class TupleItemExpression(Expression):
     """Represents tuple element access.
 
     Note: this is its own item (vs IndexExpression) for two reasons:
     1. It's not a valid lvalue (tuples are immutable)
-    2. The index must always be a literal
+    2. The index must always be a literal, and can be negative
     """
 
     base: Expression
     index: int
 
     def __init__(self, base: Expression, index: int, source_location: SourceLocation) -> None:
         base_wtype = base.wtype
-        if not isinstance(base_wtype, wtypes.WTuple):
+        if not isinstance(base_wtype, wtypes.WTuple | wtypes.ARC4Tuple):
             raise InternalError(
                 f"Tuple item expression should be for a tuple type, got {base_wtype}",
                 source_location,
             )
         try:
             wtype = base_wtype.types[index]
         except IndexError as ex:
-            raise InternalError("invalid index into tuple expression", source_location) from ex
+            raise CodeError("invalid index into tuple expression", source_location) from ex
         self.__attrs_init__(
             source_location=source_location,
             base=base,
             index=index,
             wtype=wtype,
         )
 
@@ -870,33 +871,47 @@
 
     def accept(self, visitor: ExpressionVisitor[T]) -> T:
         return visitor.visit_submit_inner_transaction(self)
 
 
 @attrs.frozen
 class FieldExpression(Expression):
-    base: Expression
+    base: Expression = attrs.field(
+        validator=expression_has_wtype(wtypes.WStructType, wtypes.ARC4Struct)
+    )
     name: str
 
     def accept(self, visitor: ExpressionVisitor[T]) -> T:
         return visitor.visit_field_expression(self)
 
 
 @attrs.frozen
 class IndexExpression(Expression):
-    base: Expression
-    index: Expression
+    base: Expression = attrs.field(
+        validator=expression_has_wtype(
+            wtypes.bytes_wtype,
+            wtypes.ARC4StaticArray,
+            wtypes.ARC4DynamicArray,
+            # NOTE: tuples (native or arc4) use TupleItemExpression instead
+        )
+    )
+    index: Expression = attrs.field(validator=expression_has_wtype(wtypes.uint64_wtype))
 
     def accept(self, visitor: ExpressionVisitor[T]) -> T:
         return visitor.visit_index_expression(self)
 
 
 @attrs.frozen
 class SliceExpression(Expression):
-    base: Expression
+    base: Expression = attrs.field(
+        validator=expression_has_wtype(
+            wtypes.bytes_wtype,
+            wtypes.WTuple,
+        )
+    )
 
     begin_index: Expression | None
     end_index: Expression | None
 
     def accept(self, visitor: ExpressionVisitor[T]) -> T:
         return visitor.visit_slice_expression(self)
 
@@ -961,25 +976,24 @@
 Lvalue = (
     VarExpression
     | FieldExpression
     | IndexExpression
     | TupleExpression
     | AppStateExpression
     | AppAccountStateExpression
-    | ReinterpretCast
 )
 
 
 @attrs.frozen
 class NewArray(Expression):
-    elements: tuple[Expression, ...] = attrs.field()
-    wtype: wtypes.WArray
+    wtype: wtypes.WArray | wtypes.ARC4Array
+    values: Sequence[Expression] = attrs.field(default=(), converter=tuple[Expression, ...])
 
-    @elements.validator
-    def check(self, _attribute: object, value: tuple[Expression, ...]) -> None:
+    @values.validator
+    def _check_element_types(self, _attribute: object, value: tuple[Expression, ...]) -> None:
         if any(expr.wtype != self.wtype.element_type for expr in value):
             raise ValueError(
                 f"All array elements should have array type: {self.wtype.element_type}"
             )
 
     def accept(self, visitor: ExpressionVisitor[T]) -> T:
         return visitor.visit_new_array(self)
@@ -1532,28 +1546,36 @@
 
     def accept(self, visitor: StatementVisitor[T]) -> T:
         return visitor.visit_state_delete(self)
 
 
 @attrs.frozen
 class NewStruct(Expression):
-    args: tuple[CallArg, ...]
-    wtype: wtypes.WStructType
+    wtype: wtypes.WStructType | wtypes.ARC4Struct
+    values: Mapping[str, Expression] = attrs.field(converter=immutabledict)
+
+    @values.validator
+    def _validate_values(self, _instance: object, values: Mapping[str, Expression]) -> None:
+        if values.keys() != self.wtype.fields.keys():
+            raise CodeError("Invalid argument(s)", self.source_location)
+        for field_name, field_value in self.values.items():
+            expected_wtype = self.wtype.fields[field_name]
+            if field_value.wtype != expected_wtype:
+                raise CodeError("Invalid argument type(s)", self.source_location)
 
     def accept(self, visitor: ExpressionVisitor[T]) -> T:
         return visitor.visit_new_struct(self)
 
 
 @attrs.frozen
 class ModuleStatement(Node, ABC):
     name: str
 
     @abstractmethod
-    def accept(self, visitor: ModuleStatementVisitor[T]) -> T:
-        ...
+    def accept(self, visitor: ModuleStatementVisitor[T]) -> T: ...
 
 
 @attrs.frozen
 class ConstantDeclaration(ModuleStatement):
     value: ConstantValue
 
     def accept(self, visitor: ModuleStatementVisitor[T]) -> T:
@@ -1572,16 +1594,15 @@
     args: Sequence[SubroutineArgument] = attrs.field(converter=tuple[SubroutineArgument, ...])
     return_type: WType
     body: Block
     docstring: str | None
 
     @property
     @abstractmethod
-    def full_name(self) -> str:
-        ...
+    def full_name(self) -> str: ...
 
 
 @attrs.frozen
 class Subroutine(Function):
     @property
     def full_name(self) -> str:
         return ".".join((self.module_name, self.name))
@@ -1656,14 +1677,15 @@
 @attrs.frozen
 class ContractFragment(ModuleStatement):
     # note: it's a fragment because it needs to be stitched together with bases,
     #       assuming it's not abstract (in which case it should remain a fragment?)
     module_name: str
     name_override: str | None
     is_abstract: bool
+    is_arc4: bool
     bases: Sequence[ContractReference] = attrs.field(converter=tuple[ContractReference, ...])
     init: ContractMethod | None = attrs.field()
     approval_program: ContractMethod | None = attrs.field()
     clear_program: ContractMethod | None = attrs.field()
     subroutines: Sequence[ContractMethod] = attrs.field(converter=tuple[ContractMethod, ...])
     app_state: Mapping[str, AppStateDefinition]
     reserved_scratch_space: StableSet[int]
```

## puya/awst/to_code_visitor.py

```diff
@@ -54,18 +54,14 @@
 
     def visit_arc4_decode(self, expr: nodes.ARC4Decode) -> str:
         return f"arc4_decode({expr.value.accept(self)}, {expr.wtype})"
 
     def visit_arc4_encode(self, expr: nodes.ARC4Encode) -> str:
         return f"arc4_encode({expr.value.accept(self)}, {expr.wtype})"
 
-    def visit_arc4_array_encode(self, expr: nodes.ARC4ArrayEncode) -> str:
-        items = ", ".join([value.accept(self) for value in expr.values])
-        return f"arc4_array_encode([{items}], {expr.wtype})"
-
     def visit_contains_expression(self, expr: nodes.Contains) -> str:
         return f"{expr.item.accept(self)} IS IN {expr.sequence.accept(self)}"
 
     def visit_reinterpret_cast(self, expr: nodes.ReinterpretCast) -> str:
         return f"reinterpret_cast<{expr.wtype}>({expr.expr.accept(self)})"
 
     def visit_single_evaluation(self, expr: nodes.SingleEvaluation) -> str:
@@ -76,21 +72,19 @@
     def visit_app_state_expression(self, expr: nodes.AppStateExpression) -> str:
         return f"this.{expr.field_name}"
 
     def visit_app_account_state_expression(self, expr: nodes.AppAccountStateExpression) -> str:
         return f"this.{expr.field_name}[{expr.account.accept(self)}]"
 
     def visit_new_array(self, expr: nodes.NewArray) -> str:
-        args = ", ".join(a.accept(self) for a in expr.elements)
-        return f"new {expr.wtype.element_type}[]({args})"
+        args = ", ".join(a.accept(self) for a in expr.values)
+        return f"new {expr.wtype}({args})"
 
     def visit_new_struct(self, expr: nodes.NewStruct) -> str:
-        args = ", ".join(
-            [(f"{a.name}=" if a.name else "") + a.value.accept(self) for a in expr.args]
-        )
+        args = ", ".join([f"{name}=" + value.accept(self) for name, value in expr.values.items()])
         return f"new {expr.wtype}({args})"
 
     def visit_enumeration(self, expr: nodes.Enumeration) -> str:
         sequence = (
             self.visit_range(expr.expr)
             if isinstance(expr.expr, nodes.Range)
             else expr.expr.accept(self)
```

## puya/awst/visitors.py

```diff
@@ -7,315 +7,248 @@
     import puya.awst.nodes
 
 T = t.TypeVar("T")
 
 
 class StatementVisitor(t.Generic[T], ABC):
     @abstractmethod
-    def visit_block(self, statement: puya.awst.nodes.Block) -> T:
-        ...
+    def visit_block(self, statement: puya.awst.nodes.Block) -> T: ...
 
     @abstractmethod
-    def visit_if_else(self, statement: puya.awst.nodes.IfElse) -> T:
-        ...
+    def visit_if_else(self, statement: puya.awst.nodes.IfElse) -> T: ...
 
     @abstractmethod
-    def visit_switch(self, statement: puya.awst.nodes.Switch) -> T:
-        ...
+    def visit_switch(self, statement: puya.awst.nodes.Switch) -> T: ...
 
     @abstractmethod
-    def visit_while_loop(self, statement: puya.awst.nodes.WhileLoop) -> T:
-        ...
+    def visit_while_loop(self, statement: puya.awst.nodes.WhileLoop) -> T: ...
 
     @abstractmethod
-    def visit_break_statement(self, statement: puya.awst.nodes.BreakStatement) -> T:
-        ...
+    def visit_break_statement(self, statement: puya.awst.nodes.BreakStatement) -> T: ...
 
     @abstractmethod
-    def visit_return_statement(self, statement: puya.awst.nodes.ReturnStatement) -> T:
-        ...
+    def visit_return_statement(self, statement: puya.awst.nodes.ReturnStatement) -> T: ...
 
     @abstractmethod
-    def visit_continue_statement(self, statement: puya.awst.nodes.ContinueStatement) -> T:
-        ...
+    def visit_continue_statement(self, statement: puya.awst.nodes.ContinueStatement) -> T: ...
 
     @abstractmethod
-    def visit_expression_statement(self, statement: puya.awst.nodes.ExpressionStatement) -> T:
-        ...
+    def visit_expression_statement(self, statement: puya.awst.nodes.ExpressionStatement) -> T: ...
 
     @abstractmethod
-    def visit_assert_statement(self, statement: puya.awst.nodes.AssertStatement) -> T:
-        ...
+    def visit_assert_statement(self, statement: puya.awst.nodes.AssertStatement) -> T: ...
 
     @abstractmethod
     def visit_uint64_augmented_assignment(
         self, statement: puya.awst.nodes.UInt64AugmentedAssignment
-    ) -> T:
-        ...
+    ) -> T: ...
 
     @abstractmethod
     def visit_biguint_augmented_assignment(
         self, statement: puya.awst.nodes.BigUIntAugmentedAssignment
-    ) -> T:
-        ...
+    ) -> T: ...
 
     @abstractmethod
     def visit_bytes_augmented_assignment(
         self, statement: puya.awst.nodes.BytesAugmentedAssignment
-    ) -> T:
-        ...
+    ) -> T: ...
 
     @abstractmethod
-    def visit_for_in_loop(self, statement: puya.awst.nodes.ForInLoop) -> T:
-        ...
+    def visit_for_in_loop(self, statement: puya.awst.nodes.ForInLoop) -> T: ...
 
     @abstractmethod
-    def visit_assignment_statement(self, statement: puya.awst.nodes.AssignmentStatement) -> T:
-        ...
+    def visit_assignment_statement(self, statement: puya.awst.nodes.AssignmentStatement) -> T: ...
 
     @abstractmethod
-    def visit_state_delete(self, statement: puya.awst.nodes.StateDelete) -> T:
-        ...
+    def visit_state_delete(self, statement: puya.awst.nodes.StateDelete) -> T: ...
 
 
 class ModuleStatementVisitor(t.Generic[T], ABC):
     @abstractmethod
-    def visit_constant_declaration(self, statement: puya.awst.nodes.ConstantDeclaration) -> T:
-        ...
+    def visit_constant_declaration(self, statement: puya.awst.nodes.ConstantDeclaration) -> T: ...
 
     @abstractmethod
-    def visit_subroutine(self, statement: puya.awst.nodes.Subroutine) -> T:
-        ...
+    def visit_subroutine(self, statement: puya.awst.nodes.Subroutine) -> T: ...
 
     @abstractmethod
-    def visit_contract_fragment(self, statement: puya.awst.nodes.ContractFragment) -> T:
-        ...
+    def visit_contract_fragment(self, statement: puya.awst.nodes.ContractFragment) -> T: ...
 
     @abstractmethod
-    def visit_structure_definition(self, statement: puya.awst.nodes.StructureDefinition) -> T:
-        ...
+    def visit_structure_definition(self, statement: puya.awst.nodes.StructureDefinition) -> T: ...
 
     @abstractmethod
-    def visit_contract_method(self, statement: puya.awst.nodes.ContractMethod) -> T:
-        ...
+    def visit_contract_method(self, statement: puya.awst.nodes.ContractMethod) -> T: ...
 
     @abstractmethod
-    def visit_logic_signature(self, statement: puya.awst.nodes.LogicSignature) -> T:
-        ...
+    def visit_logic_signature(self, statement: puya.awst.nodes.LogicSignature) -> T: ...
 
 
 class ExpressionVisitor(t.Generic[T], ABC):
     @abstractmethod
-    def visit_assignment_expression(self, expr: puya.awst.nodes.AssignmentExpression) -> T:
-        ...
+    def visit_assignment_expression(self, expr: puya.awst.nodes.AssignmentExpression) -> T: ...
 
     @abstractmethod
-    def visit_uint64_binary_operation(self, expr: puya.awst.nodes.UInt64BinaryOperation) -> T:
-        ...
+    def visit_uint64_binary_operation(self, expr: puya.awst.nodes.UInt64BinaryOperation) -> T: ...
 
     @abstractmethod
-    def visit_biguint_binary_operation(self, expr: puya.awst.nodes.BigUIntBinaryOperation) -> T:
-        ...
+    def visit_biguint_binary_operation(
+        self, expr: puya.awst.nodes.BigUIntBinaryOperation
+    ) -> T: ...
 
     @abstractmethod
-    def visit_integer_constant(self, expr: puya.awst.nodes.IntegerConstant) -> T:
-        ...
+    def visit_integer_constant(self, expr: puya.awst.nodes.IntegerConstant) -> T: ...
 
     @abstractmethod
-    def visit_decimal_constant(self, expr: puya.awst.nodes.DecimalConstant) -> T:
-        ...
+    def visit_decimal_constant(self, expr: puya.awst.nodes.DecimalConstant) -> T: ...
 
     @abstractmethod
-    def visit_bool_constant(self, expr: puya.awst.nodes.BoolConstant) -> T:
-        ...
+    def visit_bool_constant(self, expr: puya.awst.nodes.BoolConstant) -> T: ...
 
     @abstractmethod
-    def visit_bytes_constant(self, expr: puya.awst.nodes.BytesConstant) -> T:
-        ...
+    def visit_bytes_constant(self, expr: puya.awst.nodes.BytesConstant) -> T: ...
 
     @abstractmethod
-    def visit_string_constant(self, expr: puya.awst.nodes.StringConstant) -> T:
-        ...
+    def visit_string_constant(self, expr: puya.awst.nodes.StringConstant) -> T: ...
 
     @abstractmethod
-    def visit_address_constant(self, expr: puya.awst.nodes.AddressConstant) -> T:
-        ...
+    def visit_address_constant(self, expr: puya.awst.nodes.AddressConstant) -> T: ...
 
     @abstractmethod
     def visit_numeric_comparison_expression(
         self, expr: puya.awst.nodes.NumericComparisonExpression
-    ) -> T:
-        ...
+    ) -> T: ...
 
     @abstractmethod
-    def visit_var_expression(self, expr: puya.awst.nodes.VarExpression) -> T:
-        ...
+    def visit_var_expression(self, expr: puya.awst.nodes.VarExpression) -> T: ...
 
     @abstractmethod
-    def visit_intrinsic_call(self, call: puya.awst.nodes.IntrinsicCall) -> T:
-        ...
+    def visit_intrinsic_call(self, call: puya.awst.nodes.IntrinsicCall) -> T: ...
 
     @abstractmethod
     def visit_create_inner_transaction(
         self, create_itxn: puya.awst.nodes.CreateInnerTransaction
-    ) -> T:
-        ...
+    ) -> T: ...
 
     @abstractmethod
     def visit_update_inner_transaction(
         self, update_itxn: puya.awst.nodes.UpdateInnerTransaction
-    ) -> T:
-        ...
+    ) -> T: ...
 
     @abstractmethod
-    def visit_submit_inner_transaction(self, submit: puya.awst.nodes.SubmitInnerTransaction) -> T:
-        ...
+    def visit_submit_inner_transaction(
+        self, submit: puya.awst.nodes.SubmitInnerTransaction
+    ) -> T: ...
 
     @abstractmethod
     def visit_inner_transaction_field(
         self, itxn_field: puya.awst.nodes.InnerTransactionField
-    ) -> T:
-        ...
+    ) -> T: ...
 
     @abstractmethod
-    def visit_checked_maybe(self, call: puya.awst.nodes.CheckedMaybe) -> T:
-        ...
+    def visit_checked_maybe(self, call: puya.awst.nodes.CheckedMaybe) -> T: ...
 
     @abstractmethod
-    def visit_arc4_decode(self, expr: puya.awst.nodes.ARC4Decode) -> T:
-        ...
+    def visit_arc4_decode(self, expr: puya.awst.nodes.ARC4Decode) -> T: ...
 
     @abstractmethod
-    def visit_arc4_encode(self, expr: puya.awst.nodes.ARC4Encode) -> T:
-        ...
+    def visit_arc4_encode(self, expr: puya.awst.nodes.ARC4Encode) -> T: ...
 
     @abstractmethod
-    def visit_arc4_array_encode(self, expr: puya.awst.nodes.ARC4ArrayEncode) -> T:
-        ...
+    def visit_array_concat(self, expr: puya.awst.nodes.ArrayConcat) -> T: ...
 
     @abstractmethod
-    def visit_array_concat(self, expr: puya.awst.nodes.ArrayConcat) -> T:
-        ...
+    def visit_array_extend(self, expr: puya.awst.nodes.ArrayExtend) -> T: ...
 
     @abstractmethod
-    def visit_array_extend(self, expr: puya.awst.nodes.ArrayExtend) -> T:
-        ...
+    def visit_tuple_expression(self, expr: puya.awst.nodes.TupleExpression) -> T: ...
 
     @abstractmethod
-    def visit_tuple_expression(self, expr: puya.awst.nodes.TupleExpression) -> T:
-        ...
+    def visit_tuple_item_expression(self, expr: puya.awst.nodes.TupleItemExpression) -> T: ...
 
     @abstractmethod
-    def visit_tuple_item_expression(self, expr: puya.awst.nodes.TupleItemExpression) -> T:
-        ...
+    def visit_field_expression(self, expr: puya.awst.nodes.FieldExpression) -> T: ...
 
     @abstractmethod
-    def visit_field_expression(self, expr: puya.awst.nodes.FieldExpression) -> T:
-        ...
+    def visit_index_expression(self, expr: puya.awst.nodes.IndexExpression) -> T: ...
 
     @abstractmethod
-    def visit_index_expression(self, expr: puya.awst.nodes.IndexExpression) -> T:
-        ...
+    def visit_slice_expression(self, expr: puya.awst.nodes.SliceExpression) -> T: ...
 
     @abstractmethod
-    def visit_slice_expression(self, expr: puya.awst.nodes.SliceExpression) -> T:
-        ...
+    def visit_conditional_expression(self, expr: puya.awst.nodes.ConditionalExpression) -> T: ...
 
     @abstractmethod
-    def visit_conditional_expression(self, expr: puya.awst.nodes.ConditionalExpression) -> T:
-        ...
+    def visit_single_evaluation(self, expr: puya.awst.nodes.SingleEvaluation) -> T: ...
 
     @abstractmethod
-    def visit_single_evaluation(self, expr: puya.awst.nodes.SingleEvaluation) -> T:
-        ...
-
-    @abstractmethod
-    def visit_app_state_expression(self, expr: puya.awst.nodes.AppStateExpression) -> T:
-        ...
+    def visit_app_state_expression(self, expr: puya.awst.nodes.AppStateExpression) -> T: ...
 
     @abstractmethod
     def visit_app_account_state_expression(
         self, expr: puya.awst.nodes.AppAccountStateExpression
-    ) -> T:
-        ...
+    ) -> T: ...
 
-    def visit_new_array(self, expr: puya.awst.nodes.NewArray) -> T:
-        raise NotImplementedError
+    @abstractmethod
+    def visit_new_array(self, expr: puya.awst.nodes.NewArray) -> T: ...
 
-    def visit_new_struct(self, expr: puya.awst.nodes.NewStruct) -> T:
-        raise NotImplementedError
+    @abstractmethod
+    def visit_new_struct(self, expr: puya.awst.nodes.NewStruct) -> T: ...
 
     @abstractmethod
     def visit_bytes_comparison_expression(
         self, expr: puya.awst.nodes.BytesComparisonExpression
-    ) -> T:
-        ...
+    ) -> T: ...
 
     @abstractmethod
     def visit_subroutine_call_expression(
         self, expr: puya.awst.nodes.SubroutineCallExpression
-    ) -> T:
-        ...
+    ) -> T: ...
 
     @abstractmethod
-    def visit_bytes_binary_operation(self, expr: puya.awst.nodes.BytesBinaryOperation) -> T:
-        ...
+    def visit_bytes_binary_operation(self, expr: puya.awst.nodes.BytesBinaryOperation) -> T: ...
 
     @abstractmethod
-    def visit_boolean_binary_operation(self, expr: puya.awst.nodes.BooleanBinaryOperation) -> T:
-        ...
+    def visit_boolean_binary_operation(
+        self, expr: puya.awst.nodes.BooleanBinaryOperation
+    ) -> T: ...
 
     @abstractmethod
-    def visit_uint64_unary_operation(self, expr: puya.awst.nodes.UInt64UnaryOperation) -> T:
-        ...
+    def visit_uint64_unary_operation(self, expr: puya.awst.nodes.UInt64UnaryOperation) -> T: ...
 
     @abstractmethod
-    def visit_bytes_unary_operation(self, expr: puya.awst.nodes.BytesUnaryOperation) -> T:
-        ...
+    def visit_bytes_unary_operation(self, expr: puya.awst.nodes.BytesUnaryOperation) -> T: ...
 
     @abstractmethod
-    def visit_not_expression(self, expr: puya.awst.nodes.Not) -> T:
-        ...
+    def visit_not_expression(self, expr: puya.awst.nodes.Not) -> T: ...
 
     @abstractmethod
-    def visit_contains_expression(self, expr: puya.awst.nodes.Contains) -> T:
-        ...
+    def visit_contains_expression(self, expr: puya.awst.nodes.Contains) -> T: ...
 
     @abstractmethod
-    def visit_reinterpret_cast(self, expr: puya.awst.nodes.ReinterpretCast) -> T:
-        ...
+    def visit_reinterpret_cast(self, expr: puya.awst.nodes.ReinterpretCast) -> T: ...
 
     @abstractmethod
-    def visit_enumeration(self, expr: puya.awst.nodes.Enumeration) -> T:
-        ...
+    def visit_enumeration(self, expr: puya.awst.nodes.Enumeration) -> T: ...
 
     @abstractmethod
-    def visit_method_constant(self, expr: puya.awst.nodes.MethodConstant) -> T:
-        ...
+    def visit_method_constant(self, expr: puya.awst.nodes.MethodConstant) -> T: ...
 
     @abstractmethod
-    def visit_array_pop(self, expr: puya.awst.nodes.ArrayPop) -> T:
-        ...
+    def visit_array_pop(self, expr: puya.awst.nodes.ArrayPop) -> T: ...
 
     @abstractmethod
-    def visit_copy(self, expr: puya.awst.nodes.Copy) -> T:
-        ...
+    def visit_copy(self, expr: puya.awst.nodes.Copy) -> T: ...
 
     @abstractmethod
-    def visit_reversed(self, expr: puya.awst.nodes.Reversed) -> T:
-        ...
+    def visit_reversed(self, expr: puya.awst.nodes.Reversed) -> T: ...
 
     @abstractmethod
-    def visit_state_get(self, expr: puya.awst.nodes.StateGet) -> T:
-        ...
+    def visit_state_get(self, expr: puya.awst.nodes.StateGet) -> T: ...
 
     @abstractmethod
-    def visit_state_get_ex(self, expr: puya.awst.nodes.StateGetEx) -> T:
-        ...
+    def visit_state_get_ex(self, expr: puya.awst.nodes.StateGetEx) -> T: ...
 
     @abstractmethod
-    def visit_state_exists(self, expr: puya.awst.nodes.StateExists) -> T:
-        ...
+    def visit_state_exists(self, expr: puya.awst.nodes.StateExists) -> T: ...
 
     @abstractmethod
-    def visit_template_var(self, expr: puya.awst.nodes.TemplateVar) -> T:
-        ...
+    def visit_template_var(self, expr: puya.awst.nodes.TemplateVar) -> T: ...
```

## puya/awst/wtypes.py

```diff
@@ -265,25 +265,23 @@
 
         return cls(n=n, name=name, stub_name=stub_name)
 
 
 @typing.final
 @attrs.frozen(str=False, kw_only=True)
 class ARC4Tuple(ARC4Type):
-    types: tuple[WType, ...] = attrs.field(validator=[attrs.validators.min_len(1)])
+    types: tuple[ARC4Type, ...] = attrs.field(validator=[attrs.validators.min_len(1)])
 
     @classmethod
-    def from_types(cls, types: Iterable[WType]) -> typing.Self:
+    def from_types(cls, types: Iterable[ARC4Type]) -> typing.Self:
         types = tuple(types)
         if not types:
             raise ValueError("arc4.Tuple needs types")
         immutable = True
         for typ in types:
-            if not is_arc4_encoded_type(typ):
-                raise ValueError(f"Invalid type for arc4.Tuple: {typ}")
             # this seems counterintuitive, but is necessary.
             # despite the overall collection remaining stable, since ARC4 types
             # are encoded as a single value, if items within the tuple can be mutated,
             # then the overall value is also mutable
             immutable = immutable and typ.immutable
         name = f"arc4.tuple<{','.join([t.name for t in types])}>"
         python_name = f"{constants.CLS_ARC4_TUPLE}[{', '.join(map(str, types))}]"
@@ -328,25 +326,23 @@
             stub_name=f"{base_cls}[typing.Literal[{n}], typing.Literal[{m}]]",
             is_valid_literal=is_valid_literal,
         )
 
 
 @attrs.frozen(str=False, kw_only=True)
 class ARC4Array(ARC4Type):
-    element_type: WType
+    element_type: ARC4Type
     immutable: bool = attrs.field(default=False, init=False)
 
 
 @typing.final
 @attrs.frozen(str=False, kw_only=True)
 class ARC4DynamicArray(ARC4Array):
     @classmethod
-    def from_element_type(cls, element_type: WType) -> typing.Self:
-        if not is_arc4_encoded_type(element_type):
-            raise ValueError(f"Invalid type for arc4.DynamicArray: {element_type}")
+    def from_element_type(cls, element_type: ARC4Type) -> typing.Self:
         name = f"arc4.dynamic_array<{element_type.name}>"
         return cls(
             name=name,
             element_type=element_type,
             stub_name=f"{constants.CLS_ARC4_DYNAMIC_ARRAY}[{element_type}]",
         )
 
@@ -354,18 +350,16 @@
 @typing.final
 @attrs.frozen(str=False, kw_only=True)
 class ARC4StaticArray(ARC4Array):
     array_size: int
 
     @classmethod
     def from_element_type_and_size(
-        cls, element_type: WType, array_size: int, alias: str | None = None
+        cls, element_type: ARC4Type, array_size: int, alias: str | None = None
     ) -> typing.Self:
-        if not is_arc4_encoded_type(element_type):
-            raise ValueError(f"Invalid type for arc4.StaticArray: {element_type}")
         name = f"arc4.static_array<{element_type.name}, {array_size}>"
         return cls(
             array_size=array_size,
             name=name,
             element_type=element_type,
             stub_name=(
                 f"{constants.CLS_ARC4_STATIC_ARRAY}["
@@ -375,36 +369,35 @@
             alias=alias,
         )
 
 
 @typing.final
 @attrs.frozen(str=False, kw_only=True)
 class ARC4Struct(ARC4Type):
-    fields: Mapping[str, WType] = attrs.field(
+    fields: Mapping[str, ARC4Type] = attrs.field(
         converter=immutabledict, validator=[attrs.validators.min_len(1)]
     )
     names: Sequence[str] = attrs.field(init=False, eq=False)
-    types: Sequence[WType] = attrs.field(init=False, eq=False)
+    types: Sequence[ARC4Type] = attrs.field(init=False, eq=False)
     immutable: bool = attrs.field(default=False, init=False)
 
     @names.default
     def _names_factory(self) -> Sequence[str]:
         return list(self.fields.keys())
 
     @types.default
     def _types_factory(self) -> Sequence[WType]:
         return list(self.fields.values())
 
     @classmethod
-    def from_name_and_fields(cls, *, python_name: str, fields: Mapping[str, WType]) -> typing.Self:
+    def from_name_and_fields(
+        cls, *, python_name: str, fields: Mapping[str, ARC4Type]
+    ) -> typing.Self:
         if not fields:
             raise ValueError("arc4.Struct needs at least one element")
-        for t in fields.values():
-            if not is_arc4_encoded_type(t):
-                raise ValueError(f"arc4.Struct should not contain non arc4 types: {t}")
         name = (
             "arc4.struct<"
             + ",".join(
                 f"{field_name}:{field_type.name}" for field_name, field_type in fields.items()
             )
             + ">"
         )
@@ -499,15 +492,15 @@
     return isinstance(wtype, WInnerTransaction)
 
 
 def is_inner_transaction_tuple_type(wtype: WType) -> typing.TypeGuard[WTuple]:
     return isinstance(wtype, WTuple) and all(is_inner_transaction_type(t) for t in wtype.types)
 
 
-def is_inner_transaction_params_type(wtype: WType) -> typing.TypeGuard[WInnerTransactionFields]:
+def is_inner_transaction_field_type(wtype: WType) -> typing.TypeGuard[WInnerTransactionFields]:
     return isinstance(wtype, WInnerTransactionFields)
 
 
 def is_reference_type(wtype: WType) -> bool:
     return wtype in (asset_wtype, account_wtype, application_wtype)
 
 
@@ -532,15 +525,15 @@
                 (has_arc4_equivalent_type(t) or is_arc4_encoded_type(t))
                 and not isinstance(t, WTuple)
                 for t in types
             )
     return False
 
 
-def avm_to_arc4_equivalent_type(wtype: WType) -> WType:
+def avm_to_arc4_equivalent_type(wtype: WType) -> ARC4Type:
     if wtype is bool_wtype:
         return arc4_bool_wtype
     if wtype is uint64_wtype:
         return ARC4UIntN.from_scale(64)
     if wtype is biguint_wtype:
         return ARC4UIntN.from_scale(512)
     if wtype is bytes_wtype:
```

## puya/awst_build/arc4_utils.py

```diff
@@ -185,15 +185,15 @@
     return ARC32StructDef(
         name=wtype.stub_name.rsplit(".", maxsplit=1)[-1],
         elements=[(n, wtype_to_arc4(t)) for n, t in wtype.fields.items()],
     )
 
 
 def arc4_encode(
-    base: awst_nodes.Expression, target_wtype: wtypes.WType, location: SourceLocation
+    base: awst_nodes.Expression, target_wtype: wtypes.ARC4Type, location: SourceLocation
 ) -> awst_nodes.Expression:
     match base.wtype:
         case wtypes.bytes_wtype:
             base_temp = awst_nodes.SingleEvaluation(base)
 
             length = awst_nodes.IntrinsicCall(
                 source_location=location,
```

## puya/awst_build/base_mypy_visitor.py

```diff
@@ -51,16 +51,15 @@
     def visit_import_from(self, o: mypy.nodes.ImportFrom) -> _TStatement:
         return self.empty_statement(o)
 
     def visit_import_all(self, o: mypy.nodes.ImportAll) -> _TStatement:
         return self.empty_statement(o)
 
     @abc.abstractmethod
-    def empty_statement(self, stmt: mypy.nodes.Statement) -> _TStatement:
-        ...
+    def empty_statement(self, stmt: mypy.nodes.Statement) -> _TStatement: ...
 
     # ~~~ simplify function (decorated, overloaded, normal) visitation ~~~ #
 
     def check_fatal_decorators(self, exprs: list[mypy.nodes.Expression]) -> None:
         for dec_expr in exprs:
             if isinstance(dec_expr, mypy.nodes.CallExpr):
                 dec_expr = dec_expr.callee
@@ -135,16 +134,15 @@
         return self.visit_function(fdef, decorator)
 
     @abc.abstractmethod
     def visit_function(
         self,
         fdef: mypy.nodes.FuncDef,
         decorator: mypy.nodes.Decorator | None,
-    ) -> _TStatement:
-        ...
+    ) -> _TStatement: ...
 
     # ~~~ unsupported scope modifiers ~~~ #
     def visit_global_decl(self, stmt: mypy.nodes.GlobalDecl) -> typing.Never:
         self._unsupported_node(stmt, "global variables must be immutable")
 
     # TODO: do we reject nonlocal here too? are nested functions in/out?
```

## puya/awst_build/constants.py

```diff
@@ -25,17 +25,17 @@
 CLS_BYTES_ALIAS = f"{ALGOPY_PREFIX}Bytes"
 CLS_STRING = f"{ALGOPY_PREFIX}_primitives.String"
 CLS_STRING_ALIAS = f"{ALGOPY_PREFIX}String"
 CLS_BIGUINT = f"{ALGOPY_PREFIX}_primitives.BigUInt"
 CLS_BIGUINT_ALIAS = f"{ALGOPY_PREFIX}BigUInt"
 CLS_TRANSACTION_BASE = f"{ALGOPY_PREFIX}gtxn.TransactionBase"
 CLS_LOCAL_STATE = f"{ALGOPY_PREFIX}_state.LocalState"
-CLS_LOCAL_STATE_ALIAS = f"{ALGOPY_PREFIX}.LocalState"
+CLS_LOCAL_STATE_ALIAS = f"{ALGOPY_PREFIX}LocalState"
 CLS_GLOBAL_STATE = f"{ALGOPY_PREFIX}_state.GlobalState"
-CLS_GLOBAL_STATE_ALIAS = f"{ALGOPY_PREFIX}.GlobalState"
+CLS_GLOBAL_STATE_ALIAS = f"{ALGOPY_PREFIX}GlobalState"
 SUBROUTINE_HINT = f"{ALGOPY_PREFIX}_hints.subroutine"
 LOGICSIG_DECORATOR = f"{ALGOPY_PREFIX}_logic_sig.logicsig"
 LOGICSIG_DECORATOR_ALIAS = f"{ALGOPY_PREFIX}.logicsig"
 SUBROUTINE_HINT_ALIAS = f"{ALGOPY_PREFIX}subroutine"
 ABIMETHOD_DECORATOR = f"{ALGOPY_PREFIX}arc4.abimethod"
 ABIMETHOD_DECORATOR_ALIAS = ABIMETHOD_DECORATOR
 BAREMETHOD_DECORATOR = f"{ALGOPY_PREFIX}arc4.baremethod"
```

## puya/awst_build/context.py

```diff
@@ -13,15 +13,15 @@
     ConstantValue,
     ContractReference,
     Literal as AWSTLiteral,
 )
 from puya.awst_build import constants
 from puya.awst_build.eb.base import TypeClassExpressionBuilder
 from puya.context import CompileContext
-from puya.errors import CodeError, InternalError, PuyaError, log_exceptions
+from puya.errors import CodeError, InternalError, log_exceptions
 from puya.parse import SourceLocation
 from puya.utils import attrs_extend
 
 logger = log.get_logger(__name__)
 
 
 @attrs.frozen(kw_only=True)
@@ -131,21 +131,14 @@
                 types = [self._type_to_builder(it, source_location=loc) for it in items]
                 tuple_builder: TupleTypeExpressionBuilder | ARC4TupleClassExpressionBuilder
                 if true_type.type.fullname != constants.CLS_ARC4_TUPLE:
                     tuple_builder = TupleTypeExpressionBuilder(loc)
                 else:
                     tuple_builder = ARC4TupleClassExpressionBuilder(loc)
                 return tuple_builder.index_multiple(types, loc)
-            case mypy.types.Instance(type=mypy.nodes.TypeInfo(is_enum=True, bases=bases)):
-                for base in bases:
-                    try:
-                        return self._type_to_builder(base, source_location=loc)
-                    except PuyaError:
-                        pass
-                raise CodeError("Cannot resolve enum type to an appropriate base type", loc)
             case mypy.types.Instance() as inst:
                 return self.resolve_type_from_name_and_args(
                     type_fullname=inst.type.fullname,
                     inst_args=inst.args,
                     loc=loc,
                 )
             case mypy.types.UninhabitedType():
@@ -187,17 +180,19 @@
                 raise CodeError(f"Missing generic type parameter(s) for {type_fullname}", loc)
             return cls_type_builder
 
         if any(isinstance(a, mypy.types.AnyType) for a in inst_args):
             raise CodeError(f"Unresolved generic type parameter for {type_fullname}", loc)
 
         type_args_resolved: list[TypeClassExpressionBuilder | AWSTLiteral] = [
-            AWSTLiteral(value=ta.value, source_location=loc)  # type: ignore[arg-type]
-            if isinstance(ta, mypy.types.LiteralType)
-            else self._type_to_builder(ta, source_location=loc)
+            (
+                AWSTLiteral(value=ta.value, source_location=loc)  # type: ignore[arg-type]
+                if isinstance(ta, mypy.types.LiteralType)
+                else self._type_to_builder(ta, source_location=loc)
+            )
             for ta in inst_args
         ]
         if len(type_args_resolved) == 1:
             indexed_type = cls_type_builder.index(type_args_resolved[0], loc)
         else:
             indexed_type = cls_type_builder.index_multiple(type_args_resolved, loc)
         if not isinstance(indexed_type, TypeClassExpressionBuilder):
```

## puya/awst_build/contract.py

```diff
@@ -83,14 +83,15 @@
                     kind=decl.kind,
                 )
 
         self.result_ = ContractFragment(
             module_name=self.cref.module_name,
             name=self.cref.class_name,
             name_override=class_options.name_override,
+            is_arc4=self._is_arc4,
             is_abstract=self._is_abstract,
             bases=_gather_bases(context, class_def),
             init=self._init_method,
             approval_program=self._approval_program,
             clear_program=self._clear_program,
             subroutines=self._subroutines,
             app_state=collected_app_state_definitions,
```

## puya/awst_build/eb/app_state.py

```diff
@@ -4,14 +4,15 @@
 
 import mypy.nodes
 
 from puya.awst import wtypes
 from puya.awst.nodes import (
     AppStateExpression,
     AppStateKind,
+    BoolConstant,
     BytesEncoding,
     Expression,
     Literal,
     Not,
     StateDelete,
     StateExists,
     StateGet,
@@ -88,14 +89,17 @@
 
         match first_arg:
             case TypeClassExpressionBuilder() as typ_class_eb:
                 storage_wtype = typ_class_eb.produces()
                 initial_value = None
             case ExpressionBuilder(value_type=wtypes.WType() as storage_wtype) as value_eb:
                 initial_value = value_eb.rvalue()
+            case Literal(value=bool(bool_value), source_location=source_location):
+                initial_value = BoolConstant(value=bool_value, source_location=source_location)
+                storage_wtype = wtypes.bool_wtype
             case _:
                 raise CodeError(
                     "First argument must be a type reference or an initial value", location
                 )
 
         if self._storage is not None and self._storage != storage_wtype:
             raise CodeError(
```

## puya/awst_build/eb/arc4/_utils.py

```diff
@@ -4,16 +4,15 @@
 import re
 import typing
 
 import attrs
 import mypy.nodes
 import mypy.types
 
-from puya import log
-from puya.arc4_util import arc4_to_wtype, split_tuple_types, wtype_to_arc4
+from puya import arc4_util, log
 from puya.awst import (
     nodes as awst_nodes,
     wtypes,
 )
 from puya.awst.nodes import DecimalConstant, Expression, Literal
 from puya.awst_build import constants
 from puya.awst_build.arc4_utils import arc4_encode, get_arc4_method_config, get_func_types
@@ -135,20 +134,21 @@
     return literal_or_expr
 
 
 @attrs.frozen
 class ARC4Signature:
     method_name: str
     arg_types: list[wtypes.WType]
-    return_type: wtypes.WType
+    return_type: wtypes.WType | None
 
     @property
     def method_selector(self) -> str:
-        args = ",".join(map(wtype_to_arc4, self.arg_types))
-        return f"{self.method_name}({args}){wtype_to_arc4(self.return_type)}"
+        args = ",".join(map(arc4_util.wtype_to_arc4, self.arg_types))
+        return_type = self.return_type or wtypes.void_wtype
+        return f"{self.method_name}({args}){arc4_util.wtype_to_arc4(return_type)}"
 
 
 def get_arc4_signature(
     context: ASTConversionModuleContext,
     type_info: mypy.nodes.TypeInfo,
     member_name: str,
     location: SourceLocation,
@@ -162,38 +162,31 @@
             arc4_method_config = get_arc4_method_config(context, abimethod_dec, func_def)
             *arg_types, return_type = get_func_types(context, func_def, location).values()
             return ARC4Signature(arc4_method_config.name, arg_types, return_type)
     raise CodeError(f"'{type_info.fullname}.{member_name}' is not a valid ARC4 method", location)
 
 
 def get_arc4_args_and_signature(
-    method_sig: str,
-    native_args: Sequence[ExpressionBuilder | Literal],
-    loc: SourceLocation,
-    *,
-    return_wtype: wtypes.WType | None,
+    method_sig: str, native_args: Sequence[ExpressionBuilder | Literal], loc: SourceLocation
 ) -> tuple[Sequence[Expression], ARC4Signature]:
-    method_name, maybe_args, maybe_return_type = _parse_method_signature(
-        method_sig, loc, is_event=return_wtype is None
-    )
+    method_name, maybe_args, maybe_return_type = _parse_method_signature(method_sig, loc)
     arg_types = list(map(_arg_to_arc4_wtype, native_args)) if maybe_args is None else maybe_args
     num_args = len(native_args)
     num_types = len(arg_types)
     if num_types != num_args:
         raise CodeError(
             f"Number of arguments ({num_args}) does not match signature ({num_types})", loc
         )
 
     arc4_args = [
         expect_arc4_operand_wtype(arg, wtype)
         for arg, wtype in zip(native_args, arg_types, strict=True)
     ]
     arc4_types = [a.wtype for a in arc4_args]
-    return_type = return_wtype or maybe_return_type or wtypes.void_wtype
-    return arc4_args, ARC4Signature(method_name, arc4_types, return_type)
+    return arc4_args, ARC4Signature(method_name, arc4_types, maybe_return_type)
 
 
 def _arg_to_arc4_wtype(
     arg: ExpressionBuilder | Literal, wtype: wtypes.WType | None = None
 ) -> wtypes.WType:
     # if wtype is known, then ensure arg can be coerced to that type
     if wtype:
@@ -215,15 +208,15 @@
 
 def arc4_tuple_from_items(
     items: Sequence[awst_nodes.Expression], source_location: SourceLocation
 ) -> awst_nodes.ARC4Encode:
     args_tuple = awst_nodes.TupleExpression.from_items(items, source_location)
     return awst_nodes.ARC4Encode(
         value=args_tuple,
-        wtype=wtypes.ARC4Tuple.from_types(args_tuple.wtype.types),
+        wtype=arc4_util.make_tuple_wtype(args_tuple.wtype.types, source_location),
         source_location=source_location,
     )
 
 
 def _split_signature(
     signature: str, location: SourceLocation | None
 ) -> tuple[str, str | None, str | None]:
@@ -268,21 +261,19 @@
                 returns = remaining
     if not name or not _VALID_NAME_PATTERN.match(name):
         raise CodeError(f"Invalid signature: {name=}", location)
     return name, args, returns
 
 
 def _parse_method_signature(
-    signature: str, location: SourceLocation, *, is_event: bool
+    signature: str, location: SourceLocation
 ) -> tuple[str, list[wtypes.WType] | None, wtypes.WType | None]:
     name, maybe_args, maybe_returns = _split_signature(signature, location)
     args: list[wtypes.WType] | None = None
     returns: wtypes.WType | None = None
     if maybe_args:
-        args = [arc4_to_wtype(a, location) for a in split_tuple_types(maybe_args)]
+        args = [
+            arc4_util.arc4_to_wtype(a, location) for a in arc4_util.split_tuple_types(maybe_args)
+        ]
     if maybe_returns:
-        if is_event:
-            raise CodeError(
-                f"Invalid signature, trailing text after args {maybe_returns!r}", location
-            )
-        returns = arc4_to_wtype(maybe_returns, location)
+        returns = arc4_util.arc4_to_wtype(maybe_returns, location)
     return name, args, returns
```

## puya/awst_build/eb/arc4/abi_call.py

```diff
@@ -23,14 +23,15 @@
     SubmitInnerTransaction,
     TupleExpression,
     TxnField,
     TxnFields,
     UInt64Constant,
 )
 from puya.awst_build import constants
+from puya.awst_build.constants import TransactionType
 from puya.awst_build.eb.arc4._utils import (
     ARC4Signature,
     arc4_tuple_from_items,
     expect_arc4_operand_wtype,
     get_arc4_args_and_signature,
     get_arc4_signature,
 )
@@ -88,49 +89,16 @@
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
-        abi_call_expr = _extract_abi_call_args(args, arg_kinds, arg_names, location)
-        method = abi_call_expr.method
-        match method:
-            case Literal(value=str(method_sig)):
-                arc4_args, signature = get_arc4_args_and_signature(
-                    method_sig, abi_call_expr.abi_args, location, return_wtype=wtypes.void_wtype
-                )
-            case (
-                ARC4ClientMethodExpressionBuilder() | BaseClassSubroutineInvokerExpressionBuilder()
-            ) as eb:
-                signature = get_arc4_signature(eb.context, eb.type_info, eb.name, location)
-                num_args = len(abi_call_expr.abi_args)
-                num_types = len(signature.arg_types)
-                if num_types != num_args:
-                    raise CodeError(
-                        f"Number of arguments ({num_args})"
-                        f" does not match signature ({num_types})",
-                        location,
-                    )
-                arc4_args = [
-                    expect_arc4_operand_wtype(arg, wtype)
-                    for arg, wtype in zip(abi_call_expr.abi_args, signature.arg_types, strict=True)
-                ]
-            case _:
-                raise CodeError(
-                    "First argument must be a reference to an ARC4 ABI method", location
-                )
-
-        return var_expression(
-            _create_abi_call_expr(
-                signature,
-                arc4_args,
-                abi_call_expr.transaction_kwargs,
-                location,
-            )
+        return ABICallClassExpressionBuilder(None, self.source_location).call(
+            args, arg_kinds, arg_names, location
         )
 
     def index_multiple(
         self, indexes: Sequence[ExpressionBuilder | Literal], location: SourceLocation
     ) -> TypeClassExpressionBuilder:
         try:
             (index,) = indexes
@@ -181,67 +149,104 @@
     ) -> ExpressionBuilder:
         raise CodeError(
             f"Can't invoke client methods directly, use {constants.CLS_ARC4_ABI_CALL}", location
         )
 
 
 class ABICallClassExpressionBuilder(TypeClassExpressionBuilder):
-    def __init__(self, wtype: wtypes.WType, source_location: SourceLocation) -> None:
+    def __init__(self, result_wtype: wtypes.WType | None, source_location: SourceLocation) -> None:
         super().__init__(source_location)
-        self.wtype = wtype
+        self.result_wtype = result_wtype
+        app_itxn_wtype = wtypes.WInnerTransaction.from_type(TransactionType.appl)
+        if _is_typed(result_wtype):
+            self.wtype: wtypes.WInnerTransaction | wtypes.WTuple = wtypes.WTuple.from_types(
+                (result_wtype, app_itxn_wtype)
+            )
+        else:
+            self.wtype = app_itxn_wtype
 
     def produces(self) -> wtypes.WType:
-        if self.wtype is None:
-            raise CodeError("ABICall must have a type parameter", self.source_location)
         return self.wtype
 
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
         abi_call_expr = _extract_abi_call_args(args, arg_kinds, arg_names, location)
         method = abi_call_expr.method
 
+        result_wtype = self.result_wtype
         match method:
             case Literal(value=str(method_str)):
                 arc4_args, signature = get_arc4_args_and_signature(
-                    method_str, abi_call_expr.abi_args, location, return_wtype=self.wtype
+                    method_str, abi_call_expr.abi_args, location
                 )
+                if result_wtype is not None:
+                    # this will be validated against signature below, by comparing
+                    # the generated method_selector against the supplied method_str
+                    signature = attrs.evolve(signature, return_type=result_wtype)
+                elif signature.return_type is None:
+                    signature = attrs.evolve(signature, return_type=wtypes.void_wtype)
+                if not signature.method_selector.startswith(method_str):
+                    raise CodeError(
+                        f"Method selector from args '{signature.method_selector}' "
+                        f"does not match provided method selector: '{method_str}'",
+                        method.source_location,
+                    )
+            case (
+                ARC4ClientMethodExpressionBuilder() | BaseClassSubroutineInvokerExpressionBuilder()
+            ) as eb:
+                signature = get_arc4_signature(eb.context, eb.type_info, eb.name, location)
+                result_wtype = signature.return_type
+                num_args = len(abi_call_expr.abi_args)
+                num_types = len(signature.arg_types)
+                if num_types != num_args:
+                    raise CodeError(
+                        f"Number of arguments ({num_args})"
+                        f" does not match signature ({num_types})",
+                        location,
+                    )
+                arc4_args = [
+                    expect_arc4_operand_wtype(arg, wtype)
+                    for arg, wtype in zip(abi_call_expr.abi_args, signature.arg_types, strict=True)
+                ]
             case _:
                 raise CodeError(
                     "First argument must be a `str` value of an ARC4 method name/selector",
                     location,
                 )
 
-        if not signature.method_selector.startswith(method_str):
-            raise CodeError(
-                f"Method selector from args '{signature.method_selector}' "
-                f"does not match provided method selector: '{method_str}'",
-                method.source_location,
-            )
-
         return var_expression(
             _create_abi_call_expr(
                 signature,
                 arc4_args,
                 abi_call_expr.transaction_kwargs,
                 location,
+                return_inner_txn_only=not _is_typed(result_wtype),
             )
         )
 
 
+def _is_typed(wtype: wtypes.WType | None) -> typing.TypeGuard[wtypes.WType]:
+    return wtype is not None and wtype is not wtypes.void_wtype
+
+
 def _create_abi_call_expr(
     signature: ARC4Signature,
     abi_args: Sequence[Expression],
     transaction_kwargs: dict[str, ExpressionBuilder | Literal],
     location: SourceLocation,
+    *,
+    return_inner_txn_only: bool,
 ) -> Expression:
+    if signature.return_type is None:
+        raise InternalError("Expected ARC4Signature.return_type to be defined", location)
     abi_arg_exprs: list[Expression] = [
         MethodConstant(
             value=signature.method_selector,
             source_location=location,
         )
     ]
     asset_exprs = list[Expression]()
@@ -277,19 +282,23 @@
                     "Transaction arguments are not supported for contract to contract calls",
                     arg_expr.source_location,
                 )
             case _:
                 raise CodeError("Invalid argument type", arg_expr.source_location)
 
     fields: dict[TxnField, Expression] = {
+        TxnFields.fee: UInt64Constant(
+            value=0,
+            source_location=location,
+        ),
         TxnFields.type: UInt64Constant(
             value=constants.TransactionType.appl.value,
             teal_alias=constants.TransactionType.appl.name,
             source_location=location,
-        )
+        ),
     }
     if len(abi_arg_exprs) > 15:
         packed_arg_slice = slice(15, None)
         args_to_pack = abi_arg_exprs[packed_arg_slice]
         abi_arg_exprs[packed_arg_slice] = [
             arc4_tuple_from_items(args_to_pack, _combine_locs(args_to_pack))
         ]
@@ -317,15 +326,15 @@
     )
     itxn = SubmitInnerTransaction(
         itxns=(create_itxn,),
         source_location=location,
         wtype=wtypes.WInnerTransaction.from_type(constants.TransactionType.appl),
     )
 
-    if signature.return_type == wtypes.void_wtype:
+    if return_inner_txn_only:
         return itxn
     itxn_tmp = SingleEvaluation(itxn)
     last_log = InnerTransactionField(
         source_location=location,
         itxn=itxn_tmp,
         field=TxnFields.last_log,
         wtype=TxnFields.last_log.wtype,
```

## puya/awst_build/eb/arc4/arrays.py

```diff
@@ -1,29 +1,29 @@
 from __future__ import annotations
 
 import typing
 from abc import ABC
 
-from puya import log
+from puya import arc4_util, log
 from puya.algo_constants import ENCODED_ADDRESS_LENGTH
 from puya.awst import wtypes
 from puya.awst.nodes import (
     AddressConstant,
-    ARC4ArrayEncode,
     ArrayConcat,
     ArrayExtend,
     ArrayPop,
     BytesComparisonExpression,
     CheckedMaybe,
     EqualityComparison,
     Expression,
     ExpressionStatement,
     IndexExpression,
     IntrinsicCall,
     Literal,
+    NewArray,
     NumericComparison,
     NumericComparisonExpression,
     ReinterpretCast,
     SingleEvaluation,
     Statement,
     TupleExpression,
     UInt64BinaryOperation,
@@ -41,15 +41,14 @@
     get_bytes_expr_builder,
     get_integer_literal_value,
 )
 from puya.awst_build.eb.base import (
     BuilderBinaryOp,
     BuilderComparisonOp,
     ExpressionBuilder,
-    GenericClassExpressionBuilder,
     IntermediateExpressionBuilder,
     Iteration,
     TypeClassExpressionBuilder,
     ValueExpressionBuilder,
 )
 from puya.awst_build.eb.bytes_backed import BytesBackedClassExpressionBuilder
 from puya.awst_build.eb.var_factory import var_expression
@@ -65,179 +64,154 @@
     import mypy.nodes
 
     from puya.parse import SourceLocation
 
 logger = log.get_logger(__name__)
 
 
-class DynamicArrayGenericClassExpressionBuilder(GenericClassExpressionBuilder):
+class DynamicArrayClassExpressionBuilder(BytesBackedClassExpressionBuilder):
+    def __init__(self, location: SourceLocation, wtype: wtypes.ARC4DynamicArray | None = None):
+        super().__init__(location)
+        self.wtype = wtype
+
+    def produces(self) -> wtypes.ARC4Type:
+        if not self.wtype:
+            raise InternalError(
+                "Cannot resolve wtype of generic EB until the index method is called with the "
+                "generic type parameter."
+            )
+        return self.wtype
+
+    def index(
+        self, index: ExpressionBuilder | Literal, location: SourceLocation
+    ) -> ExpressionBuilder:
+        return self.index_multiple([index], location)
+
     def index_multiple(
         self, indexes: Sequence[ExpressionBuilder | Literal], location: SourceLocation
-    ) -> TypeClassExpressionBuilder:
+    ) -> ExpressionBuilder:
         match indexes:
             case [TypeClassExpressionBuilder() as eb]:
                 element_wtype = eb.produces()
-                wtype = wtypes.ARC4DynamicArray.from_element_type(element_wtype)
+                self.wtype = arc4_util.make_dynamic_array_wtype(element_wtype, location)
+                return self
             case _:
                 raise CodeError("Invalid/unhandled arguments", location)
-        return DynamicArrayClassExpressionBuilder(location=location, wtype=wtype)
 
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
-        return dynamic_array_constructor(args=args, wtype=None, location=location)
-
-
-def dynamic_array_constructor(
-    args: Sequence[ExpressionBuilder | Literal],
-    wtype: wtypes.ARC4DynamicArray | None,
-    location: SourceLocation,
-) -> ExpressionBuilder:
-    non_literal_args = [
-        require_expression_builder(a, msg="Array arguments must be non literals").rvalue()
-        for a in args
-    ]
-    if wtype is None:
-        if non_literal_args:
-            element_wtype = non_literal_args[0].wtype
-            wtype = wtypes.ARC4DynamicArray.from_element_type(element_wtype)
-        else:
-            raise CodeError("Empty arrays require a type annotation to be instantiated", location)
+        non_literal_args = [
+            require_expression_builder(a, msg="Array arguments must be non literals").rvalue()
+            for a in args
+        ]
+        wtype = self.wtype
+        if wtype is None:
+            if non_literal_args:
+                element_wtype = non_literal_args[0].wtype
+                wtype = arc4_util.make_dynamic_array_wtype(element_wtype, location)
+            else:
+                raise CodeError(
+                    "Empty arrays require a type annotation to be instantiated", location
+                )
 
-    for a in non_literal_args:
-        expect_operand_wtype(a, wtype.element_type)
+        for a in non_literal_args:
+            expect_operand_wtype(a, wtype.element_type)
 
-    return var_expression(
-        ARC4ArrayEncode(
-            source_location=location,
-            values=tuple(non_literal_args),
-            wtype=wtype,
+        return var_expression(
+            NewArray(
+                source_location=location,
+                values=tuple(non_literal_args),
+                wtype=wtype,
+            )
         )
-    )
 
 
-class DynamicArrayClassExpressionBuilder(BytesBackedClassExpressionBuilder):
-    def __init__(self, location: SourceLocation, wtype: wtypes.ARC4DynamicArray | None = None):
+class StaticArrayClassExpressionBuilder(BytesBackedClassExpressionBuilder):
+    def __init__(self, location: SourceLocation, wtype: wtypes.ARC4StaticArray | None = None):
         super().__init__(location)
         self.wtype = wtype
 
-    def call(
-        self,
-        args: Sequence[ExpressionBuilder | Literal],
-        arg_kinds: list[mypy.nodes.ArgKind],
-        arg_names: list[str | None],
-        location: SourceLocation,
-    ) -> ExpressionBuilder:
-        return dynamic_array_constructor(args=args, wtype=self.wtype, location=location)
-
     def produces(self) -> wtypes.WType:
         if not self.wtype:
             raise InternalError(
                 "Cannot resolve wtype of generic EB until the index method is called with the "
                 "generic type parameter."
             )
         return self.wtype
 
+    def index(
+        self, index: ExpressionBuilder | Literal, location: SourceLocation
+    ) -> ExpressionBuilder:
+        return self.index_multiple([index], location)
 
-class StaticArrayGenericClassExpressionBuilder(GenericClassExpressionBuilder):
     def index_multiple(
         self, indexes: Sequence[ExpressionBuilder | Literal], location: SourceLocation
-    ) -> TypeClassExpressionBuilder:
+    ) -> ExpressionBuilder:
         match indexes:
             case [TypeClassExpressionBuilder() as item_type, array_size]:
                 array_size_ = get_integer_literal_value(array_size, "Array size")
                 element_wtype = item_type.produces()
-                wtype = wtypes.ARC4StaticArray.from_element_type_and_size(
-                    array_size=array_size_,
-                    element_type=element_wtype,
+                self.wtype = arc4_util.make_static_array_wtype(
+                    element_wtype, array_size_, location
                 )
-
+                return self
             case _:
                 raise CodeError(
                     "Invalid type arguments for StaticArray. "
                     "Expected StaticArray[ItemType, typing.Literal[n]]",
                     location,
                 )
-        return StaticArrayClassExpressionBuilder(location=location, wtype=wtype)
 
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
-        return static_array_constructor(args=args, wtype=None, location=location)
-
-
-def static_array_constructor(
-    args: Sequence[ExpressionBuilder | Literal],
-    wtype: wtypes.ARC4StaticArray | None,
-    location: SourceLocation,
-) -> ExpressionBuilder:
-    non_literal_args = [
-        require_expression_builder(a, msg="Array arguments must be non literals").rvalue()
-        for a in args
-    ]
-    if wtype is None:
-        if non_literal_args:
-            element_wtype = non_literal_args[0].wtype
-            array_size = len(non_literal_args)
-            wtype = wtypes.ARC4StaticArray.from_element_type_and_size(
-                array_size=array_size,
-                element_type=element_wtype,
+        non_literal_args = [
+            require_expression_builder(a, msg="Array arguments must be non literals").rvalue()
+            for a in args
+        ]
+        wtype = self.wtype
+        if wtype is None:
+            if non_literal_args:
+                element_wtype = non_literal_args[0].wtype
+                array_size = len(non_literal_args)
+                wtype = arc4_util.make_static_array_wtype(element_wtype, array_size, location)
+            else:
+                raise CodeError(
+                    "Empty arrays require a type annotation to be instantiated", location
+                )
+        elif wtype.array_size != len(non_literal_args):
+            raise CodeError(
+                f"StaticArray should be initialized with {wtype.array_size} values",
+                location,
             )
-        else:
-            raise CodeError("Empty arrays require a type annotation to be instantiated", location)
-    elif wtype.array_size != len(non_literal_args):
-        raise CodeError(
-            f"StaticArray should be initialized with {wtype.array_size} values",
-            location,
-        )
-
-    for a in non_literal_args:
-        expect_operand_wtype(a, wtype.element_type)
-
-    return var_expression(
-        ARC4ArrayEncode(
-            source_location=location,
-            values=tuple(non_literal_args),
-            wtype=wtype,
-        )
-    )
-
 
-class StaticArrayClassExpressionBuilder(BytesBackedClassExpressionBuilder):
-    def __init__(self, location: SourceLocation, wtype: wtypes.ARC4StaticArray):
-        super().__init__(location)
-        self.wtype = wtype
+        for a in non_literal_args:
+            expect_operand_wtype(a, wtype.element_type)
 
-    def call(
-        self,
-        args: Sequence[ExpressionBuilder | Literal],
-        arg_kinds: list[mypy.nodes.ArgKind],
-        arg_names: list[str | None],
-        location: SourceLocation,
-    ) -> ExpressionBuilder:
-        return static_array_constructor(args=args, wtype=self.wtype, location=location)
-
-    def produces(self) -> wtypes.WType:
-        if not self.wtype:
-            raise InternalError(
-                "Cannot resolve wtype of generic EB until the index method is called with the "
-                "generic type parameter."
+        return var_expression(
+            NewArray(
+                source_location=location,
+                values=tuple(non_literal_args),
+                wtype=wtype,
             )
-        return self.wtype
+        )
 
 
 class AddressClassExpressionBuilder(StaticArrayClassExpressionBuilder):
+    wtype: wtypes.ARC4StaticArray
+
     def __init__(self, location: SourceLocation):
         super().__init__(location=location, wtype=wtypes.arc4_address_type)
 
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
@@ -591,7 +565,20 @@
         cmp_expr = BytesComparisonExpression(
             source_location=location,
             lhs=get_bytes_expr(self.expr),
             operator=EqualityComparison(op.value),
             rhs=rhs,
         )
         return var_expression(cmp_expr)
+
+
+class AddressExpressionBuilder(StaticArrayExpressionBuilder):
+    def member_access(self, name: str, location: SourceLocation) -> ExpressionBuilder | Literal:
+        match name:
+            case "native":
+                return var_expression(
+                    ReinterpretCast(
+                        expr=self.expr, wtype=wtypes.account_wtype, source_location=location
+                    )
+                )
+            case _:
+                return super().member_access(name, location)
```

## puya/awst_build/eb/arc4/base.py

```diff
@@ -3,15 +3,14 @@
 import abc
 import typing
 
 from puya import log
 from puya.awst import wtypes
 from puya.awst.nodes import (
     ARC4Decode,
-    ARC4Encode,
     BytesComparisonExpression,
     BytesConstant,
     BytesEncoding,
     CheckedMaybe,
     Copy,
     EqualityComparison,
     Expression,
@@ -64,43 +63,14 @@
     match eb_or_literal:
         case Literal(value=int(lit_value)):
             return lit_value
         case _:
             raise CodeError(f"{purpose} must be compile time constant")
 
 
-class ARC4EncodeBuilder(IntermediateExpressionBuilder):
-    def __init__(self, location: SourceLocation, wtype: wtypes.WType):
-        super().__init__(location=location)
-        self.wtype = wtype
-
-    def call(
-        self,
-        args: Sequence[ExpressionBuilder | Literal],
-        arg_kinds: list[mypy.nodes.ArgKind],
-        arg_names: list[str | None],
-        location: SourceLocation,
-    ) -> ExpressionBuilder:
-        match args:
-            case [
-                ExpressionBuilder() as eb
-            ] if eb.rvalue().wtype == wtypes.arc4_to_avm_equivalent_wtype(self.wtype):
-                value = eb.rvalue()
-            case _:
-                raise CodeError("Invalid/unhandled arguments", location)
-
-        return var_expression(
-            ARC4Encode(
-                source_location=location,
-                value=value,
-                wtype=self.wtype,
-            )
-        )
-
-
 class ARC4FromLogBuilder(IntermediateExpressionBuilder):
     def __init__(self, location: SourceLocation, wtype: wtypes.WType):
         super().__init__(location=location)
         self.wtype = wtype
 
     @classmethod
     def abi_expr_from_log(
```

## puya/awst_build/eb/arc4/bool.py

```diff
@@ -24,15 +24,15 @@
     )
     from puya.parse import SourceLocation
 
 logger = log.get_logger(__name__)
 
 
 class ARC4BoolClassExpressionBuilder(ARC4ClassExpressionBuilder):
-    def produces(self) -> wtypes.WType:
+    def produces(self) -> wtypes.ARC4Type:
         return wtypes.arc4_bool_wtype
 
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
```

## puya/awst_build/eb/arc4/dynamic_bytes.py

```diff
@@ -1,49 +1,57 @@
 from __future__ import annotations
 
 import typing
 
 from puya.awst import wtypes
 from puya.awst.nodes import ARC4Encode, Literal, ReinterpretCast
 from puya.awst_build.eb.arc4._utils import convert_arc4_literal
-from puya.awst_build.eb.arc4.arrays import DynamicArrayExpressionBuilder, dynamic_array_constructor
-from puya.awst_build.eb.arc4.base import ARC4ClassExpressionBuilder, native_eb
+from puya.awst_build.eb.arc4.arrays import (
+    DynamicArrayClassExpressionBuilder,
+    DynamicArrayExpressionBuilder,
+)
+from puya.awst_build.eb.arc4.base import native_eb
 from puya.awst_build.eb.base import ExpressionBuilder
 from puya.awst_build.eb.var_factory import var_expression
 from puya.errors import CodeError
 
 if typing.TYPE_CHECKING:
     from collections.abc import Sequence
 
     import mypy.nodes
 
     from puya.parse import SourceLocation
 
 
-class DynamicBytesClassExpressionBuilder(ARC4ClassExpressionBuilder):
-    def produces(self) -> wtypes.ARC4DynamicArray:
-        return wtypes.arc4_dynamic_bytes
+class DynamicBytesClassExpressionBuilder(DynamicArrayClassExpressionBuilder):
+    wtype: wtypes.ARC4DynamicArray
+
+    def __init__(self, location: SourceLocation):
+        super().__init__(location=location, wtype=wtypes.arc4_dynamic_bytes)
 
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
         match args:
             case [Literal(value=bytes()) as literal]:
-                return var_expression(convert_arc4_literal(literal, self.produces(), location))
+                return var_expression(convert_arc4_literal(literal, self.wtype, location))
             case [ExpressionBuilder(value_type=wtypes.bytes_wtype) as eb]:
                 return var_expression(
                     ARC4Encode(value=eb.rvalue(), source_location=location, wtype=self.produces())
                 )
 
-        return dynamic_array_constructor(
-            args=list(map(_coerce_to_byte, args)), wtype=self.produces(), location=location
+        return super().call(
+            args=list(map(_coerce_to_byte, args)),
+            arg_kinds=arg_kinds,
+            arg_names=arg_names,
+            location=location,
         )
 
 
 def _coerce_to_byte(arg: ExpressionBuilder | Literal) -> ExpressionBuilder:
     match arg:
         case Literal(value=int()) as literal:
             return var_expression(convert_arc4_literal(literal, wtypes.arc4_byte_type))
```

## puya/awst_build/eb/arc4/emit.py

```diff
@@ -41,24 +41,20 @@
         match args:
             case [
                 ExpressionBuilder(value_type=wtypes.ARC4Struct() as struct_type) as event_arg_eb
             ]:
                 event_name = struct_type.stub_name.split(".")[-1]
                 event_arg = event_arg_eb.rvalue()
             case [Literal(value=str(event_str)), *event_args]:
-                arc4_args, signature = get_arc4_args_and_signature(
-                    event_str, event_args, location, return_wtype=None
-                )
-                # check signature does not contain a return type
-                if signature.return_type != wtypes.void_wtype or (
-                    "(" in event_str and not event_str.endswith(")")
-                ):
+                arc4_args, signature = get_arc4_args_and_signature(event_str, event_args, location)
+                if signature.return_type is not None:
                     after_args = wtype_to_arc4(signature.return_type)
                     raise CodeError(
-                        f"Invalid signature, type specified after args {after_args!r}", location
+                        f"Invalid event signature, type specified after args {after_args!r}",
+                        location,
                     )
                 event_name = signature.method_name
                 event_arg = arc4_tuple_from_items(
                     arc4_args,
                     location,
                 )
             case _:
```

## puya/awst_build/eb/arc4/numeric.py

```diff
@@ -20,15 +20,15 @@
     ARC4ClassExpressionBuilder,
     ARC4EncodedExpressionBuilder,
     arc4_bool_bytes,
     get_integer_literal_value,
 )
 from puya.awst_build.eb.base import BuilderComparisonOp, ExpressionBuilder
 from puya.awst_build.eb.var_factory import var_expression
-from puya.errors import CodeError, InternalError, TodoError
+from puya.errors import CodeError, InternalError
 
 if typing.TYPE_CHECKING:
     from collections.abc import Sequence
 
     import mypy.nodes
 
     from puya.parse import SourceLocation
@@ -80,16 +80,15 @@
             case _:
                 raise CodeError(
                     "Invalid/unhandled arguments",
                     location,
                 )
 
     @abc.abstractmethod
-    def zero_literal(self) -> ConstantValue:
-        ...
+    def zero_literal(self) -> ConstantValue: ...
 
 
 class ByteClassExpressionBuilder(NumericARC4ClassExpressionBuilder):
     def __init__(self, location: SourceLocation):
         super().__init__(location)
         self.wtype = wtypes.arc4_byte_type
 
@@ -103,16 +102,15 @@
     ) -> ExpressionBuilder:
         n = get_integer_literal_value(index, "UIntN scale")
         self.check_bitsize(n, location)
         self.wtype = wtypes.ARC4UIntN.from_scale(n)
         return self
 
     @abc.abstractmethod
-    def check_bitsize(self, n: int, location: SourceLocation) -> None:
-        ...
+    def check_bitsize(self, n: int, location: SourceLocation) -> None: ...
 
     def zero_literal(self) -> ConstantValue:
         return 0
 
 
 class UIntNClassExpressionBuilder(_UIntNClassExpressionBuilder):
     def check_bitsize(self, n: int, location: SourceLocation) -> None:
@@ -146,16 +144,15 @@
         self.check_bitsize(n, location)
         if not (1 <= m < 160):
             raise CodeError("UFixedNxM precision must be between 1 and 160.")
         self.wtype = wtypes.ARC4UFixedNxM.from_scale_and_precision(n=n, m=m)
         return self
 
     @abc.abstractmethod
-    def check_bitsize(self, n: int, location: SourceLocation) -> None:
-        ...
+    def check_bitsize(self, n: int, location: SourceLocation) -> None: ...
 
     def zero_literal(self) -> ConstantValue:
         return "0.0"
 
 
 class UFixedNxMClassExpressionBuilder(_UFixedNxMClassExpressionBuilder):
     def check_bitsize(self, n: int, location: SourceLocation) -> None:
@@ -203,16 +200,14 @@
                 other_expr = ReinterpretCast(
                     expr=other_expr,
                     wtype=wtypes.biguint_wtype,
                     source_location=other_expr.source_location,
                 )
             case wtypes.uint64_wtype:
                 other_expr = uint64_to_biguint(other, location)
-            case wtypes.bool_wtype:
-                raise TodoError(location, "TODO: support upcast from bool to arc4.UIntN")
             case _:
                 return NotImplemented
         cmp_expr = NumericComparisonExpression(
             source_location=location,
             lhs=ReinterpretCast(
                 expr=self.expr,
                 wtype=wtypes.biguint_wtype,
```

## puya/awst_build/eb/arc4/struct.py

```diff
@@ -1,40 +1,38 @@
 from __future__ import annotations
 
 import typing
 
 from puya import log
 from puya.awst import wtypes
 from puya.awst.nodes import (
-    ARC4Encode,
     Expression,
-    IndexExpression,
+    FieldExpression,
     Literal,
-    TupleExpression,
-    UInt64Constant,
+    NewStruct,
 )
 from puya.awst_build.eb._utils import bool_eval_to_constant
-from puya.awst_build.eb.arc4._utils import expect_arc4_operand_wtype
 from puya.awst_build.eb.arc4.base import CopyBuilder, arc4_compare_bytes, get_bytes_expr_builder
 from puya.awst_build.eb.base import BuilderComparisonOp, ValueExpressionBuilder
 from puya.awst_build.eb.bytes_backed import BytesBackedClassExpressionBuilder
 from puya.awst_build.eb.var_factory import var_expression
-from puya.awst_build.utils import get_arg_mapping
+from puya.awst_build.utils import get_arg_mapping, require_expression_builder
 from puya.errors import CodeError
 
 if typing.TYPE_CHECKING:
     from collections.abc import Sequence
 
     import mypy.nodes
 
     from puya.awst_build.eb.base import (
         ExpressionBuilder,
     )
     from puya.parse import SourceLocation
 
+
 logger = log.get_logger(__name__)
 
 
 class ARC4StructClassExpressionBuilder(BytesBackedClassExpressionBuilder):
     def produces(self) -> wtypes.WType:
         return self.wtype
 
@@ -56,50 +54,44 @@
         ordered_field_names = self.wtype.names
         field_mapping = get_arg_mapping(
             positional_arg_names=ordered_field_names,
             args=zip(arg_names, args, strict=True),
             location=location,
         )
 
-        args_positioned = list[Expression]()
+        values = dict[str, Expression]()
         for field_name, field_type in self.wtype.fields.items():
             field_value = field_mapping.pop(field_name, None)
             if field_value is None:
                 raise CodeError(f"Missing required argument {field_name}", location)
-            args_positioned.append(expect_arc4_operand_wtype(field_value, field_type))
+            field_expr = require_expression_builder(field_value).rvalue()
+            if field_expr.wtype != field_type:
+                raise CodeError("Invalid type for field", field_expr.source_location)
+            values[field_name] = field_expr
         if field_mapping:
             raise CodeError(f"Unexpected keyword arguments: {' '.join(field_mapping)}", location)
 
-        tuple_expr = TupleExpression(
-            items=args_positioned,
-            source_location=location,
-            wtype=wtypes.WTuple.from_types(types=self.wtype.types),
-        )
-
-        return var_expression(
-            ARC4Encode(wtype=self.wtype, value=tuple_expr, source_location=location)
-        )
+        return var_expression(NewStruct(wtype=self.wtype, values=values, source_location=location))
 
 
 class ARC4StructExpressionBuilder(ValueExpressionBuilder):
     def __init__(self, expr: Expression):
         assert isinstance(expr.wtype, wtypes.ARC4Struct)
         self.wtype: wtypes.ARC4Struct = expr.wtype
         super().__init__(expr)
 
     def member_access(self, name: str, location: SourceLocation) -> ExpressionBuilder | Literal:
         match name:
-            case tuple_field if tuple_field in self.wtype.fields:
-                index = self.wtype.names.index(tuple_field)
+            case field_name if field_name in self.wtype.fields:
                 return var_expression(
-                    IndexExpression(
+                    FieldExpression(
                         source_location=location,
                         base=self.expr,
-                        index=UInt64Constant(value=index, source_location=location),
-                        wtype=self.wtype.fields[tuple_field],
+                        name=field_name,
+                        wtype=self.wtype.fields[field_name],
                     )
                 )
             case "bytes":
                 return get_bytes_expr_builder(self.expr)
             case "copy":
                 return CopyBuilder(self.expr, location)
             case _:
```

## puya/awst_build/eb/arc4/tuple.py

```diff
@@ -1,124 +1,58 @@
 from __future__ import annotations
 
 import typing
 
-from puya import log
+from puya import arc4_util, log
 from puya.awst import wtypes
 from puya.awst.nodes import (
     ARC4Encode,
     Expression,
-    IndexExpression,
     Literal,
-    UInt64Constant,
+    TupleItemExpression,
 )
 from puya.awst_build.eb._utils import bool_eval_to_constant
-from puya.awst_build.eb.arc4.base import (
-    ARC4ClassExpressionBuilder,
-    ARC4EncodedExpressionBuilder,
-)
-from puya.awst_build.eb.base import (
-    ExpressionBuilder,
-    GenericClassExpressionBuilder,
-    TypeClassExpressionBuilder,
-)
+from puya.awst_build.eb.arc4.base import ARC4ClassExpressionBuilder, ARC4EncodedExpressionBuilder
+from puya.awst_build.eb.base import ExpressionBuilder, TypeClassExpressionBuilder
 from puya.awst_build.eb.var_factory import var_expression
-from puya.errors import CodeError, InternalError
+from puya.errors import CodeError
 
 if typing.TYPE_CHECKING:
     from collections.abc import Sequence
 
     import mypy.nodes
 
     from puya.parse import SourceLocation
 
 logger = log.get_logger(__name__)
 
 
-class ARC4TupleGenericClassExpressionBuilder(GenericClassExpressionBuilder):
-    def index_multiple(
-        self, indexes: Sequence[ExpressionBuilder | Literal], location: SourceLocation
-    ) -> TypeClassExpressionBuilder:
-        tuple_item_types = list[wtypes.WType]()
-        for index in indexes:
-            match index:
-                case TypeClassExpressionBuilder() as type_class:
-                    wtype = type_class.produces()
-                    if not wtypes.is_arc4_encoded_type(wtype):
-                        raise CodeError(
-                            "ARC4 Tuples can only contain ARC4 encoded values", location
-                        )
-                    tuple_item_types.append(wtype)
-                case _:
-                    raise CodeError("Invalid type parameter", index.source_location)
-        return ARC4TupleClassExpressionBuilder(
-            location, wtypes.ARC4Tuple.from_types(tuple_item_types)
-        )
-
-    def call(
-        self,
-        args: Sequence[ExpressionBuilder | Literal],
-        arg_kinds: list[mypy.nodes.ArgKind],
-        arg_names: list[str | None],
-        location: SourceLocation,
-    ) -> ExpressionBuilder:
-        return tuple_constructor(args, None, location)
-
-
-def tuple_constructor(
-    args: Sequence[ExpressionBuilder | Literal],
-    wtype: wtypes.ARC4Tuple | None,
-    location: SourceLocation,
-) -> ExpressionBuilder:
-    match args:
-        case [ExpressionBuilder(value_type=wtypes.WTuple() as tuple_wtype) as eb]:
-            tuple_ex = eb.rvalue()
-
-            if wtype is None:
-                wtype = wtypes.ARC4Tuple.from_types(tuple_wtype.types)
-            else:
-                expected_type = wtypes.WTuple.from_types(wtype.types)
-                if tuple_ex.wtype != expected_type:
-                    raise CodeError(
-                        f"Invalid arg type: expected {expected_type}, got {tuple_ex.wtype}",
-                        location,
-                    )
-
-            return var_expression(
-                ARC4Encode(value=tuple_ex, wtype=wtype, source_location=location)
-            )
-
-    raise CodeError("Invalid/unhandled arguments", location)
-
-
 class ARC4TupleClassExpressionBuilder(ARC4ClassExpressionBuilder):
     def __init__(self, location: SourceLocation, wtype: wtypes.ARC4Tuple | None = None):
         super().__init__(location)
         self.wtype = wtype
 
     def produces(self) -> wtypes.WType:
         if not self.wtype:
-            # TODO: make CodeError
-            raise InternalError(
-                "Cannot resolve wtype of generic EB until the index method is called with the "
-                "generic type parameter."
+            raise CodeError(
+                "Unparameterized arc4.Tuple class cannot be used as a type", self.source_location
             )
         return self.wtype
 
     def index(
         self, index: ExpressionBuilder | Literal, location: SourceLocation
     ) -> ExpressionBuilder:
         return self.index_multiple((index,), location)
 
     def index_multiple(
         self,
         indexes: Sequence[ExpressionBuilder | Literal],
         location: SourceLocation,
     ) -> TypeClassExpressionBuilder:
-        tuple_item_types = list[wtypes.WType]()
+        tuple_item_types = list[wtypes.ARC4Type]()
         for index in indexes:
             match index:
                 case TypeClassExpressionBuilder() as type_class:
                     wtype = type_class.produces()
                     if not wtypes.is_arc4_encoded_type(wtype):
                         raise CodeError(
                             "ARC4 Tuples can only contain ARC4 encoded values", location
@@ -132,38 +66,59 @@
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
-        return tuple_constructor(args, self.wtype, location)
+        wtype = self.wtype
+        match args:
+            case [ExpressionBuilder(value_type=wtypes.WTuple() as tuple_wtype) as eb]:
+                tuple_ex = eb.rvalue()
+
+                if wtype is None:
+                    wtype = arc4_util.make_tuple_wtype(tuple_wtype.types, location)
+                else:
+                    expected_type = wtypes.WTuple.from_types(wtype.types)
+                    if tuple_ex.wtype != expected_type:
+                        raise CodeError(
+                            f"Invalid arg type: expected {expected_type}, got {tuple_ex.wtype}",
+                            location,
+                        )
+
+                return var_expression(
+                    ARC4Encode(value=tuple_ex, wtype=wtype, source_location=location)
+                )
+
+        raise CodeError("Invalid/unhandled arguments", location)
 
 
 class ARC4TupleExpressionBuilder(ARC4EncodedExpressionBuilder):
     def __init__(self, expr: Expression):
         assert isinstance(expr.wtype, wtypes.ARC4Tuple)
         self.wtype: wtypes.ARC4Tuple = expr.wtype
         super().__init__(expr)
 
     def index(
         self, index: ExpressionBuilder | Literal, location: SourceLocation
     ) -> ExpressionBuilder:
-        match index:
-            case Literal(value=int(index_int), source_location=index_loc):
+        index_expr_or_literal = index
+        match index_expr_or_literal:
+            case Literal(value=int(index_value)) as index_literal:
                 try:
-                    item_wtype = self.wtype.types[index_int]
+                    self.wtype.types[index_value]
                 except IndexError as ex:
-                    raise CodeError("Tuple index out of bounds", index_loc) from ex
+                    raise CodeError(
+                        "Tuple index out of bounds", index_literal.source_location
+                    ) from ex
                 return var_expression(
-                    IndexExpression(
-                        source_location=location,
+                    TupleItemExpression(
                         base=self.expr,
-                        index=UInt64Constant(value=index_int, source_location=index_loc),
-                        wtype=item_wtype,
+                        index=index_value,
+                        source_location=location,
                     )
                 )
             case _:
-                raise CodeError(f"{self.wtype.name} can only be indexed with literal values")
+                raise CodeError("arc4.Tuple can only be indexed by int constants")
 
     def bool_eval(self, location: SourceLocation, *, negate: bool = False) -> ExpressionBuilder:
         return bool_eval_to_constant(value=True, location=location, negate=negate)
```

## puya/awst_build/eb/array.py

```diff
@@ -63,15 +63,15 @@
             expected_type = non_literal_args[0].wtype
         else:
             raise CodeError("Empy arrays require a type annotation to be instantiated", location)
         for a in non_literal_args:
             expect_operand_wtype(a, expected_type)
         array_wtype = wtypes.WArray.from_element_type(expected_type)
         array_expr = NewArray(
-            source_location=location, elements=tuple(non_literal_args), wtype=array_wtype
+            source_location=location, values=tuple(non_literal_args), wtype=array_wtype
         )
         return var_expression(array_expr)
 
 
 class ArrayExpressionBuilder(ValueExpressionBuilder):
     def __init__(self, expr: Expression):
         assert isinstance(expr.wtype, wtypes.WArray)
```

## puya/awst_build/eb/base.py

```diff
@@ -13,14 +13,15 @@
     IndexExpression,
     Literal,
     Lvalue,
     Range,
     ReinterpretCast,
     Statement,
     TupleExpression,
+    TupleItemExpression,
 )
 from puya.errors import CodeError, InternalError
 from puya.utils import coalesce
 
 if typing.TYPE_CHECKING:
     from collections.abc import Sequence
 
@@ -96,30 +97,26 @@
         # TODO: consider making a DeleteStatement which e.g. handles AppAccountStateExpression
 
     @abc.abstractmethod
     def bool_eval(self, location: SourceLocation, *, negate: bool = False) -> ExpressionBuilder:
         """Handle boolean-ness evaluation, possibly inverted (ie "not" unary operator)"""
 
     @abc.abstractmethod
-    def unary_plus(self, location: SourceLocation) -> ExpressionBuilder:
-        ...
+    def unary_plus(self, location: SourceLocation) -> ExpressionBuilder: ...
 
     @abc.abstractmethod
-    def unary_minus(self, location: SourceLocation) -> ExpressionBuilder:
-        ...
+    def unary_minus(self, location: SourceLocation) -> ExpressionBuilder: ...
 
     @abc.abstractmethod
-    def bitwise_invert(self, location: SourceLocation) -> ExpressionBuilder:
-        ...
+    def bitwise_invert(self, location: SourceLocation) -> ExpressionBuilder: ...
 
     @abc.abstractmethod
     def contains(
         self, item: ExpressionBuilder | Literal, location: SourceLocation
-    ) -> ExpressionBuilder:
-        ...
+    ) -> ExpressionBuilder: ...
 
     @property
     def value_type(self) -> wtypes.WType | None:
         return None
 
     @property
     def _type_description(self) -> str:
@@ -326,39 +323,36 @@
         )
 
 
 class TypeClassExpressionBuilder(IntermediateExpressionBuilder, abc.ABC):
     # TODO: better error messages for rvalue/lvalue/delete
 
     @abc.abstractmethod
-    def produces(self) -> wtypes.WType:
-        ...
+    def produces(self) -> wtypes.WType: ...
 
 
 class GenericClassExpressionBuilder(IntermediateExpressionBuilder, abc.ABC):
     def index(
         self, index: ExpressionBuilder | Literal, location: SourceLocation
     ) -> TypeClassExpressionBuilder:
         return self.index_multiple([index], location)
 
     @abc.abstractmethod
     def index_multiple(
         self, indexes: Sequence[ExpressionBuilder | Literal], location: SourceLocation
-    ) -> TypeClassExpressionBuilder:
-        ...
+    ) -> TypeClassExpressionBuilder: ...
 
     @abc.abstractmethod
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
-    ) -> ExpressionBuilder:
-        ...
+    ) -> ExpressionBuilder: ...
 
     def member_access(self, name: str, location: SourceLocation) -> ExpressionBuilder | Literal:
         raise CodeError(
             f"Cannot access member {name} without specifying class type parameters first",
             location,
         )
 
@@ -430,14 +424,16 @@
     def contains(
         self, item: ExpressionBuilder | Literal, location: SourceLocation
     ) -> ExpressionBuilder:
         raise CodeError(f"{self.wtype} does not support in/not in checks", location)
 
 
 def _validate_lvalue(resolved: Expression) -> Lvalue:
+    if isinstance(resolved, TupleItemExpression):
+        raise CodeError("Tuple items cannot be reassigned", resolved.source_location)
     if not (isinstance(resolved, Lvalue) and resolved.wtype.lvalue):  # type: ignore[arg-type,misc]
         raise CodeError(
             f"{resolved.wtype.stub_name} expression is not valid as assignment target",
             resolved.source_location,
         )
     if isinstance(resolved, IndexExpression | FieldExpression) and resolved.base.wtype.immutable:
         raise CodeError(
```

## puya/awst_build/eb/biguint.py

```diff
@@ -25,15 +25,15 @@
     BuilderComparisonOp,
     ExpressionBuilder,
     ValueExpressionBuilder,
 )
 from puya.awst_build.eb.bytes_backed import BytesBackedClassExpressionBuilder
 from puya.awst_build.eb.var_factory import var_expression
 from puya.awst_build.utils import convert_literal_to_expr
-from puya.errors import CodeError, TodoError
+from puya.errors import CodeError
 
 if typing.TYPE_CHECKING:
     from collections.abc import Sequence
 
     import mypy.types
 
     from puya.parse import SourceLocation
@@ -56,15 +56,17 @@
             case []:
                 value: Expression = BigUIntConstant(value=0, source_location=location)
             case [Literal(value=int(int_value))]:
                 value = BigUIntConstant(value=int_value, source_location=location)
             case [ExpressionBuilder() as eb]:
                 value = uint64_to_biguint(eb, location)
             case _:
-                raise CodeError("Invalid/unhandled arguments", location)
+                logger.error("Invalid/unhandled arguments", location=location)
+                # dummy value to continue with
+                value = BigUIntConstant(value=0, source_location=location)
         return var_expression(value)
 
 
 class BigUIntExpressionBuilder(ValueExpressionBuilder):
     wtype = wtypes.biguint_wtype
 
     def member_access(self, name: str, location: SourceLocation) -> ExpressionBuilder | Literal:
@@ -96,16 +98,14 @@
         self, other: ExpressionBuilder | Literal, op: BuilderComparisonOp, location: SourceLocation
     ) -> ExpressionBuilder:
         other_expr = convert_literal_to_expr(other, self.wtype)
         if other_expr.wtype == self.wtype:
             pass
         elif other_expr.wtype == wtypes.uint64_wtype:
             other_expr = uint64_to_biguint(other, location)
-        elif other_expr.wtype == wtypes.bool_wtype:
-            raise TodoError(location, "TODO: support upcast from bool to biguint")
         else:
             return NotImplemented
         cmp_expr = NumericComparisonExpression(
             source_location=location,
             lhs=self.expr,
             operator=NumericComparison(op.value),
             rhs=other_expr,
@@ -121,16 +121,14 @@
         reverse: bool,
     ) -> ExpressionBuilder:
         other_expr = convert_literal_to_expr(other, self.wtype)
         if other_expr.wtype == self.wtype:
             pass
         elif other_expr.wtype == wtypes.uint64_wtype:
             other_expr = uint64_to_biguint(other, location)
-        elif other_expr.wtype == wtypes.bool_wtype:
-            raise TodoError(location, "TODO: support upcast from bool to biguint")
         else:
             return NotImplemented
         lhs = self.expr
         rhs = other_expr
         if reverse:
             (lhs, rhs) = (rhs, lhs)
         biguint_op = _translate_biguint_math_operator(op, location)
@@ -143,16 +141,14 @@
         self, op: BuilderBinaryOp, rhs: ExpressionBuilder | Literal, location: SourceLocation
     ) -> Statement:
         value = convert_literal_to_expr(rhs, self.wtype)
         if value.wtype == self.wtype:
             pass
         elif value.wtype == wtypes.uint64_wtype:
             value = uint64_to_biguint(rhs, location)
-        elif value.wtype == wtypes.bool_wtype:
-            raise TodoError(location, "TODO: support upcast from bool to biguint")
         else:
             raise CodeError(
                 f"Invalid operand type {value.wtype} for {op.value}= with {self.wtype}", location
             )
         target = self.lvalue()
         biguint_op = _translate_biguint_math_operator(op, location)
         return BigUIntAugmentedAssignment(
@@ -175,8 +171,8 @@
             location=loc,
         )
         # continue traversing code to generate any further errors
         operator = BuilderBinaryOp.floor_div
     try:
         return BigUIntBinaryOperator(operator.value)
     except ValueError as ex:
-        raise CodeError(f"Unsupported BigUInt math operator {operator.value}", loc) from ex
+        raise CodeError(f"Unsupported BigUInt math operator {operator.value!r}", loc) from ex
```

## puya/awst_build/eb/bytes.py

```diff
@@ -70,20 +70,22 @@
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
         match args:
             case []:
-                const = BytesConstant(value=b"", source_location=location)
-                return var_expression(const)
+                value: Expression = BytesConstant(value=b"", source_location=location)
             case [Literal(value=bytes()) as literal]:
-                return var_expression(convert_literal(literal, wtypes.bytes_wtype))
+                value = convert_literal(literal, wtypes.bytes_wtype)
             case _:
-                raise CodeError("Invalid/unhandled arguments", location)
+                logger.error("Invalid/unhandled arguments", location=location)
+                # dummy value to continue with
+                value = BytesConstant(value=b"", source_location=location)
+        return var_expression(value)
 
     def member_access(self, name: str, location: SourceLocation) -> ExpressionBuilder:
         """Handle self.name"""
         match name:
             case "from_base32":
                 return BytesFromEncodedStrBuilder(location, BytesEncoding.base32)
             case "from_base64":
```

## puya/awst_build/eb/ensure_budget.py

```diff
@@ -62,15 +62,15 @@
             case Literal(
                 value=int(fee_source_value), source_location=fee_source_loc
             ) if 0 <= fee_source_value <= 2:
                 fee_source_expr = UInt64Constant(
                     value=fee_source_value, source_location=fee_source_loc
                 )
             case None:
-                fee_source_expr = UInt64Constant(value=2, source_location=location)
+                fee_source_expr = UInt64Constant(value=0, source_location=location)
             case _:
                 raise CodeError(f"Invalid argument value for {fee_source_arg_name}", location)
         call_args.append(
             CallArg(
                 name=fee_source_arg_name,
                 value=fee_source_expr,
             )
```

## puya/awst_build/eb/intrinsics.py

```diff
@@ -1,35 +1,24 @@
 from __future__ import annotations
 
+import abc
 import typing
 
 import mypy.nodes
 
 from puya import log
 from puya.awst import wtypes
-from puya.awst.nodes import (
-    BigUIntConstant,
-    BoolConstant,
-    BytesConstant,
-    Expression,
-    IntrinsicCall,
-    Literal,
-    MethodConstant,
-    UInt64Constant,
-)
+from puya.awst.nodes import Expression, IntrinsicCall, Literal, MethodConstant
 from puya.awst_build.constants import ARC4_SIGNATURE_ALIAS
-from puya.awst_build.eb.base import (
-    ExpressionBuilder,
-    IntermediateExpressionBuilder,
-)
+from puya.awst_build.eb.base import ExpressionBuilder, IntermediateExpressionBuilder
 from puya.awst_build.eb.var_factory import var_expression
 from puya.awst_build.intrinsic_data import ENUM_CLASSES, STUB_TO_AST_MAPPER
-from puya.awst_build.intrinsic_models import ArgMapping, FunctionOpMapping
-from puya.awst_build.utils import get_arg_mapping, require_expression_builder
-from puya.errors import CodeError, InternalError
+from puya.awst_build.intrinsic_models import FunctionOpMapping, ImmediateArgMapping
+from puya.awst_build.utils import convert_literal, get_arg_mapping
+from puya.errors import InternalError
 
 if typing.TYPE_CHECKING:
     from collections.abc import Sequence
 
     from puya.parse import SourceLocation
 
 logger = log.get_logger(__name__)
@@ -41,69 +30,84 @@
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
         match args:
             case [Literal(value=str(str_value))]:
-                return var_expression(
-                    MethodConstant(
-                        value=str_value,
-                        source_location=location,
-                    )
-                )
+                pass
             case _:
-                raise CodeError(f"Unexpected args for {ARC4_SIGNATURE_ALIAS}", location)
+                logger.error(f"Unexpected args for {ARC4_SIGNATURE_ALIAS}", location=location)
+                str_value = ""  # dummy value to keep evaluating
+        return var_expression(
+            MethodConstant(
+                value=str_value,
+                source_location=location,
+            )
+        )
 
 
-class IntrinsicEnumClassExpressionBuilder(IntermediateExpressionBuilder):
-    def __init__(self, enum_class_fullname: str, location: SourceLocation) -> None:
-        self.enum_class = enum_class_fullname
-        try:
-            self.enum_literals = ENUM_CLASSES[enum_class_fullname]
-        except KeyError as ex:
-            raise CodeError(f"Unknown enum class '{self.enum_class}'") from ex
+class _Namespace(IntermediateExpressionBuilder, abc.ABC):
+    def __init__(self, type_info: mypy.nodes.TypeInfo, location: SourceLocation) -> None:
+        self.type_info = type_info
         super().__init__(location)
 
-    def member_access(self, name: str, location: SourceLocation) -> Literal:
-        try:
-            value = self.enum_literals[name]
-        except KeyError as ex:
-            raise CodeError(f"Unknown enum value '{name}' for '{self.enum_class}'") from ex
+    def member_access(self, name: str, location: SourceLocation) -> ExpressionBuilder | Literal:
+        sym_entry = self.type_info.get(name)
+        if sym_entry is None or sym_entry.node is None:
+            raise InternalError(
+                f"Unknown algopy member: {self.type_info.fullname}.{name}", location
+            )
+        return self._member_access(name=name, node=sym_entry.node, location=location)
+
+    @abc.abstractmethod
+    def _member_access(
+        self, name: str, node: mypy.nodes.SymbolNode, location: SourceLocation
+    ) -> ExpressionBuilder | Literal: ...
+
+
+class IntrinsicEnumClassExpressionBuilder(_Namespace):
+    @typing.override
+    def _member_access(
+        self, name: str, node: mypy.nodes.SymbolNode, location: SourceLocation
+    ) -> Literal:
+        value = ENUM_CLASSES.get(self.type_info.fullname, {}).get(name)
+        if value is None:
+            raise InternalError(
+                f"Un-mapped enum value '{name}' for '{self.type_info.fullname}.{name}'", location
+            )
         return Literal(
             source_location=location,
             # this works currently because these enums are StrEnum with auto() as their value
             value=value,
         )
 
 
-class IntrinsicNamespaceClassExpressionBuilder(IntermediateExpressionBuilder):
-    def __init__(self, type_info: mypy.nodes.TypeInfo, location: SourceLocation) -> None:
-        self.type_info = type_info
-        super().__init__(location)
-
-    def member_access(self, name: str, location: SourceLocation) -> ExpressionBuilder:
-        match self.type_info.names[name]:
-            case mypy.nodes.SymbolTableNode(node=mypy.nodes.SymbolNode() as sym_node):
-                pass
-            case _:
-                raise InternalError("symbol table nodes should not be None", location)
-        # some class members in the stubs that take no arguments are typed
-        # as final class vars, for these get the intrinsic expression by explicitly
-        # mapping the member name as a call with no args
-        if isinstance(sym_node, mypy.nodes.Var):
-            intrinsic_expr = map_call(callee=sym_node.fullname, node_location=location, args={})
-            if intrinsic_expr is None:
-                raise CodeError(f"Unknown algopy member {sym_node.fullname}")
-            return var_expression(intrinsic_expr)
-        func_def = unwrap_func_def(
-            location, sym_node, num_pos_args=0  # assuming no overloads for intrinsic functions
+class IntrinsicNamespaceClassExpressionBuilder(_Namespace):
+    @typing.override
+    def _member_access(
+        self, name: str, node: mypy.nodes.SymbolNode, location: SourceLocation
+    ) -> ExpressionBuilder:
+        match node:
+            # methods are either @staticmethod or @classmethod, so will be wrapped in decorator
+            case mypy.nodes.Decorator(func=func_def):
+                return IntrinsicFunctionExpressionBuilder(func_def, location)
+            # some class members in the stubs that take no arguments are typed
+            # as final class vars, for these get the intrinsic expression by explicitly
+            # mapping the member name as a call with no args
+            case mypy.nodes.Var(fullname=classvar_fullname):
+                intrinsic_expr = _map_call(
+                    callee=classvar_fullname, node_location=location, args={}
+                )
+                return var_expression(intrinsic_expr)
+        raise InternalError(
+            f"Unhandled intrinsic-namespace node type {type(node).__name__}"
+            f" for {self.type_info.fullname}.{name}",
+            location,
         )
-        assert isinstance(func_def, mypy.nodes.FuncDef)
-        return IntrinsicFunctionExpressionBuilder(func_def, location)
 
 
 class IntrinsicFunctionExpressionBuilder(IntermediateExpressionBuilder):
     def __init__(self, func_def: mypy.nodes.FuncDef, location: SourceLocation) -> None:
         self.func_def = func_def
         super().__init__(location)
 
@@ -113,66 +117,22 @@
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
         resolved_args: list[Expression | Literal] = [
             a.rvalue() if isinstance(a, ExpressionBuilder) else a for a in args
         ]
-        arg_mapping = get_arg_mapping_funcdef(self.func_def, resolved_args, location, arg_names)
-        intrinsic_expr = map_call(
+        arg_mapping = _get_arg_mapping_funcdef(self.func_def, resolved_args, location, arg_names)
+        intrinsic_expr = _map_call(
             callee=self.func_def.fullname, node_location=location, args=arg_mapping
         )
-        if intrinsic_expr is None:
-            raise CodeError(f"Unknown algopy function {self.func_def.fullname}")
         return var_expression(intrinsic_expr)
 
 
-def unwrap_func_def(
-    location: SourceLocation, node: mypy.nodes.SymbolNode, num_pos_args: int
-) -> mypy.nodes.FuncDef:
-    match node:
-        case mypy.nodes.FuncDef() as func_def:
-            return func_def
-        case mypy.nodes.OverloadedFuncDef(impl=impl) as overloaded_func:
-            if impl is not None:
-                return unwrap_func_def(location, impl, num_pos_args)
-            funcs = [unwrap_func_def(location, f, num_pos_args) for f in overloaded_func.items]
-            possible_overloads = list[mypy.nodes.FuncDef]()
-            for func in funcs:
-                func_arg_kinds = [
-                    kind
-                    for kind, arg in zip(func.arg_kinds, func.arguments, strict=True)
-                    if not (arg.variable.is_self or arg.variable.is_cls)
-                ]
-                min_pos_args = func_arg_kinds.count(mypy.nodes.ArgKind.ARG_POS)
-                max_pos_args = min_pos_args + func_arg_kinds.count(mypy.nodes.ArgKind.ARG_OPT)
-                if min_pos_args <= num_pos_args <= max_pos_args:
-                    possible_overloads.append(func)
-            match possible_overloads:
-                case []:
-                    raise InternalError(
-                        f"Could not find valid overload for {overloaded_func.fullname} "
-                        f"with {num_pos_args} positional arg/s",
-                        location,
-                    )
-                case [single]:
-                    return single
-                case _:
-                    raise InternalError(
-                        f"Could not find exact overload for {overloaded_func.fullname} "
-                        f"with {num_pos_args} positional arg/s",
-                        location,
-                    )
-        case mypy.nodes.Decorator(func=func_def):
-            return func_def
-        case _:
-            raise InternalError("Call symbol resolved to non-callable", location)
-
-
-def get_arg_mapping_funcdef(
+def _get_arg_mapping_funcdef(
     func_def: mypy.nodes.FuncDef,
     args: Sequence[Expression | Literal],
     location: SourceLocation,
     arg_names: Sequence[str | None],
 ) -> dict[str, Expression | Literal]:
     func_pos_args = [
         arg.variable.name
@@ -181,122 +141,101 @@
         and not (arg.variable.is_cls or arg.variable.is_self)
     ]
     return get_arg_mapping(
         func_pos_args, args=zip(arg_names, args, strict=True), location=location
     )
 
 
-def _all_immediates_are_constant(
-    op_mapping: FunctionOpMapping, arg_is_constant: dict[str, bool]
-) -> bool:
-    return all(
-        arg_is_constant[immediate.arg_name] if isinstance(immediate, ArgMapping) else True
-        for immediate in op_mapping.immediates
-    )
-
-
-def _find_op_mapping(
-    op_mappings: list[FunctionOpMapping],
-    args: dict[str, Expression | Literal],
-    location: SourceLocation,
+def _best_op_mapping(
+    op_mappings: list[FunctionOpMapping], args: dict[str, Expression | Literal]
 ) -> FunctionOpMapping:
-    # find op mapping that matches as many arguments to immediate args as possible
-    arg_is_constant = {arg_name: isinstance(arg, Literal) for arg_name, arg in args.items()}
-    best_mapping: FunctionOpMapping | None = None
-    for op_mapping in op_mappings:
-        if _all_immediates_are_constant(op_mapping, arg_is_constant) and (
-            best_mapping is None or len(op_mapping.immediates) > len(best_mapping.immediates)
-        ):
-            best_mapping = op_mapping
-
-    if best_mapping is None:
-        raise CodeError(
-            "Could not find valid op mapping", location=location
-        )  # TODO: raise better error
-    return best_mapping
-
-
-def _code_error(arg: Expression | Literal, arg_mapping: ArgMapping, callee: str) -> typing.Never:
-    raise CodeError(
-        f"Invalid argument type"
-        f' "{arg.wtype if isinstance(arg, Expression) else type(arg.value).__name__}"'
-        f' for argument "{arg_mapping.arg_name}" when calling {callee}',
-        location=arg.source_location,
-    )
-
-
-def _check_stack_type(arg_mapping: ArgMapping, node: Expression, callee: str) -> None:
-    valid: bool
-    match node:
-        case Expression(wtype=wtype):
-            # TODO this is identity based, match types instead?
-            valid = wtype in arg_mapping.allowed_types
-        case _:
-            valid = False
-    if not valid:
-        _code_error(node, arg_mapping, callee)
+    """Find op mapping that matches as many arguments to immediate args as possible"""
+    literal_arg_names = {arg_name for arg_name, arg in args.items() if isinstance(arg, Literal)}
+    for op_mapping in sorted(op_mappings, key=lambda om: len(om.literal_arg_names), reverse=True):
+        if literal_arg_names.issuperset(op_mapping.literal_arg_names):
+            return op_mapping
+    # fall back to first, let argument mapping handle logging errors
+    return op_mappings[0]
 
 
 def _return_types_to_wtype(types: Sequence[wtypes.WType]) -> wtypes.WType:
     if not types:
         return wtypes.void_wtype
     elif len(types) == 1:
         return types[0]
     else:
         return wtypes.WTuple.from_types(types)
 
 
-def map_call(
+def _map_call(
     callee: str, node_location: SourceLocation, args: dict[str, Expression | Literal]
-) -> IntrinsicCall | None:
-    try:
-        ast_mapper = STUB_TO_AST_MAPPER[callee]
-    except KeyError:
-        return None
-    op_mapping = _find_op_mapping(ast_mapper, args, node_location)
+) -> IntrinsicCall:
+    ast_mapper = STUB_TO_AST_MAPPER.get(callee)
+    if not ast_mapper:
+        raise InternalError(f"Un-mapped intrinsic call for {callee}", node_location)
+    if len(ast_mapper) == 1:
+        (op_mapping,) = ast_mapper
+    else:
+        op_mapping = _best_op_mapping(ast_mapper, args)
+
+    args = args.copy()  # make a copy since we're going to mutate
 
     immediates = list[str | int]()
-    stack_args = list[Expression]()
     for immediate in op_mapping.immediates:
-        if isinstance(immediate, str):
+        if not isinstance(immediate, ImmediateArgMapping):
             immediates.append(immediate)
         else:
-            arg_in = args[immediate.arg_name]
-            if isinstance(arg_in, Literal) and immediate.is_allowed_constant(arg_in.value):
-                if not isinstance(arg_in.value, int | str):
-                    raise InternalError(
-                        f"Unexpected literal value type, value = {arg_in.value!r}", node_location
-                    )
-                immediates.append(arg_in.value)
+            arg_in = args.pop(immediate.arg_name, None)
+            if arg_in is None:
+                logger.error(
+                    f"Missing expected argument {immediate.arg_name}", location=node_location
+                )
+            elif not (
+                isinstance(arg_in, Literal)
+                and isinstance(arg_value := arg_in.value, immediate.literal_type)
+            ):
+                logger.error(
+                    f"Argument must be a literal {immediate.literal_type.__name__} value",
+                    location=arg_in.source_location,
+                )
             else:
-                _code_error(arg_in, immediate, callee)
+                assert isinstance(arg_value, int | str)
+                immediates.append(arg_value)
 
+    stack_args = list[Expression]()
     for arg_mapping in op_mapping.stack_inputs:
-        arg_in = args[arg_mapping.arg_name]
-        arg: Expression
-        match arg_in:
-            case Literal(value=bool(bool_value)) as bool_literal:
-                arg = BoolConstant(value=bool_value, source_location=bool_literal.source_location)
-            case Literal(value=int(int_value)) as int_literal:
-                if wtypes.biguint_wtype in arg_mapping.allowed_types:
-                    arg = BigUIntConstant(
-                        value=int_value, source_location=int_literal.source_location
-                    )
-                else:
-                    arg = UInt64Constant(
-                        value=int_value, source_location=int_literal.source_location
-                    )
-            case Literal(value=bytes(bytes_value)) as bytes_literal:
-                arg = BytesConstant(
-                    value=bytes_value, source_location=bytes_literal.source_location
+        arg_in = args.pop(arg_mapping.arg_name, None)
+        if arg_in is None:
+            logger.error(
+                f"Missing expected argument {arg_mapping.arg_name}", location=node_location
+            )
+        elif isinstance(arg_in, Expression):
+            # TODO this is identity based, match types instead?
+            if arg_in.wtype not in arg_mapping.allowed_types:
+                logger.error(
+                    f'Invalid argument type "{arg_in.wtype}"'
+                    f' for argument "{arg_mapping.arg_name}" when calling {callee}',
+                    location=arg_in.source_location,
                 )
-            case _:
-                arg = require_expression_builder(arg_in).rvalue()
-        _check_stack_type(arg_mapping, arg, callee)
-        stack_args.append(arg)
+            stack_args.append(arg_in)
+        else:
+            literal_value = arg_in.value
+            for allowed_type in arg_mapping.allowed_types:
+                if allowed_type.is_valid_literal(literal_value):
+                    literal_expr = convert_literal(arg_in, allowed_type)
+                    stack_args.append(literal_expr)
+                    break
+            else:
+                logger.error(
+                    f"Unhandled literal type '{type(literal_value).__name__}' for argument",
+                    location=arg_in.source_location,
+                )
+
+    for arg_node in args.values():
+        logger.error("Unexpected argument", location=arg_node.source_location)
 
     return IntrinsicCall(
         source_location=node_location,
         wtype=_return_types_to_wtype(op_mapping.stack_outputs),
         op_code=op_mapping.op_code,
         immediates=immediates,
         stack_args=stack_args,
```

## puya/awst_build/eb/log.py

```diff
@@ -81,18 +81,16 @@
                         f"Unexpected argument type: {type(lit.value).__name__}",
                         arg.source_location,
                     )
                 case _:
                     raise CodeError("Unexpected argument", arg.source_location)
             if log_value is None:
                 log_value = bytes_expr
-            elif sep:
+            else:
                 log_value = intrinsic_factory.concat(
                     intrinsic_factory.concat(log_value, sep, arg.source_location),
                     bytes_expr,
                     arg.source_location,
                 )
-            else:
-                log_value = intrinsic_factory.concat(log_value, bytes_expr, arg.source_location)
         if log_value is None:
             log_value = BytesConstant(value=b"", source_location=location)
         return var_expression(intrinsic_factory.log(log_value, location))
```

## puya/awst_build/eb/reference_types/account.py

```diff
@@ -1,13 +1,14 @@
 from __future__ import annotations
 
 import typing
 
 from immutabledict import immutabledict
 
+from puya import log
 from puya.algo_constants import ENCODED_ADDRESS_LENGTH
 from puya.awst import wtypes
 from puya.awst.nodes import (
     AddressConstant,
     BytesComparisonExpression,
     CheckedMaybe,
     EqualityComparison,
@@ -37,38 +38,39 @@
     from collections.abc import Sequence
 
     import mypy.nodes
 
     from puya.parse import SourceLocation
 
 
+logger = log.get_logger(__name__)
+
+
 class AccountClassExpressionBuilder(BytesBackedClassExpressionBuilder):
     def produces(self) -> wtypes.WType:
         return wtypes.account_wtype
 
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
         match args:
             case []:
-                const_op = intrinsic_factory.zero_address(location)
-                return var_expression(const_op)
+                value: Expression = intrinsic_factory.zero_address(location)
             case [Literal(value=str(addr_value))]:
                 if not wtypes.valid_address(addr_value):
                     raise CodeError(
                         f"Invalid address value. Address literals should be"
                         f" {ENCODED_ADDRESS_LENGTH} characters and not include base32 padding",
                         location,
                     )
-                const = AddressConstant(value=addr_value, source_location=location)
-                return var_expression(const)
+                value = AddressConstant(value=addr_value, source_location=location)
             case [ExpressionBuilder() as eb]:
                 value = expect_operand_wtype(eb, wtypes.bytes_wtype)
                 address_bytes_temp = SingleEvaluation(value)
                 is_correct_length = NumericComparisonExpression(
                     operator=NumericComparison.eq,
                     source_location=location,
                     lhs=UInt64Constant(value=32, source_location=location),
@@ -76,21 +78,22 @@
                 )
                 address_bytes = CheckedMaybe.from_tuple_items(
                     expr=address_bytes_temp,
                     check=is_correct_length,
                     source_location=location,
                     comment="Address length is 32 bytes",
                 )
-                return var_expression(
-                    ReinterpretCast(
-                        expr=address_bytes, wtype=self.produces(), source_location=location
-                    )
+                value = ReinterpretCast(
+                    expr=address_bytes, wtype=self.produces(), source_location=location
                 )
             case _:
-                raise CodeError("Invalid/unhandled arguments", location)
+                logger.error("Invalid/unhandled arguments", location=location)
+                # dummy value to continue with
+                value = intrinsic_factory.zero_address(location)
+        return var_expression(value)
 
 
 class AccountOptedInExpressionBuilder(IntermediateExpressionBuilder):
     def __init__(self, expr: Expression, source_location: SourceLocation):
         super().__init__(source_location)
         self.expr = expr
```

## puya/awst_build/eb/reference_types/application.py

```diff
@@ -1,28 +1,31 @@
 from __future__ import annotations
 
 import typing
 
 from immutabledict import immutabledict
 
+from puya import log
 from puya.awst import wtypes
 from puya.awst.nodes import Expression, Literal, UInt64Constant
 from puya.awst_build.eb.base import ExpressionBuilder, TypeClassExpressionBuilder
 from puya.awst_build.eb.reference_types.base import UInt64BackedReferenceValueExpressionBuilder
 from puya.awst_build.utils import expect_operand_wtype
-from puya.errors import CodeError
 
 if typing.TYPE_CHECKING:
     from collections.abc import Sequence
 
     import mypy.nodes
 
     from puya.parse import SourceLocation
 
 
+logger = log.get_logger(__name__)
+
+
 class ApplicationClassExpressionBuilder(TypeClassExpressionBuilder):
     def produces(self) -> wtypes.WType:
         return wtypes.application_wtype
 
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
@@ -34,15 +37,17 @@
             case []:
                 uint64_expr: Expression = UInt64Constant(value=0, source_location=location)
             case [Literal(value=int(int_value), source_location=loc)]:
                 uint64_expr = UInt64Constant(value=int_value, source_location=loc)
             case [ExpressionBuilder() as eb]:
                 uint64_expr = expect_operand_wtype(eb, wtypes.uint64_wtype)
             case _:
-                raise CodeError("Invalid/unhandled arguments", location)
+                logger.error("Invalid/unhandled arguments", location=location)
+                # dummy value to continue with
+                uint64_expr = UInt64Constant(value=0, source_location=location)
         return ApplicationExpressionBuilder(uint64_expr)
 
 
 class ApplicationExpressionBuilder(UInt64BackedReferenceValueExpressionBuilder):
     wtype = wtypes.application_wtype
     native_access_member = "id"
     field_mapping = immutabledict(
```

## puya/awst_build/eb/reference_types/asset.py

```diff
@@ -1,21 +1,16 @@
 from __future__ import annotations
 
 import typing
 
 from immutabledict import immutabledict
 
+from puya import log
 from puya.awst import wtypes
-from puya.awst.nodes import (
-    CheckedMaybe,
-    Expression,
-    IntrinsicCall,
-    Literal,
-    UInt64Constant,
-)
+from puya.awst.nodes import CheckedMaybe, Expression, IntrinsicCall, Literal, UInt64Constant
 from puya.awst_build.eb.base import (
     ExpressionBuilder,
     IntermediateExpressionBuilder,
     TypeClassExpressionBuilder,
 )
 from puya.awst_build.eb.reference_types.base import UInt64BackedReferenceValueExpressionBuilder
 from puya.awst_build.eb.var_factory import var_expression
@@ -26,34 +21,39 @@
     from collections.abc import Sequence
 
     import mypy.nodes
 
     from puya.parse import SourceLocation
 
 
+logger = log.get_logger(__name__)
+
+
 class AssetClassExpressionBuilder(TypeClassExpressionBuilder):
     def produces(self) -> wtypes.WType:
         return wtypes.asset_wtype
 
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
         match args:
             case []:
                 uint64_expr: Expression = UInt64Constant(value=0, source_location=location)
-            case [Literal(value=int(int_value), source_location=loc)]:
-                uint64_expr = UInt64Constant(value=int_value, source_location=loc)
+            case [Literal(value=int(int_value))]:
+                uint64_expr = UInt64Constant(value=int_value, source_location=location)
             case [ExpressionBuilder() as eb]:
                 uint64_expr = expect_operand_wtype(eb, wtypes.uint64_wtype)
             case _:
-                raise CodeError("Invalid/unhandled arguments", location)
+                logger.error("Invalid/unhandled arguments", location=location)
+                # dummy value to continue with
+                uint64_expr = UInt64Constant(value=0, source_location=location)
         return AssetExpressionBuilder(uint64_expr)
 
 
 ASSET_HOLDING_FIELD_MAPPING: typing.Final = {
     "balance": ("AssetBalance", wtypes.uint64_wtype),
     "frozen": ("AssetFrozen", wtypes.bool_wtype),
 }
```

## puya/awst_build/eb/string.py

```diff
@@ -30,15 +30,15 @@
     BuilderComparisonOp,
     ExpressionBuilder,
     IntermediateExpressionBuilder,
     ValueExpressionBuilder,
 )
 from puya.awst_build.eb.bytes_backed import BytesBackedClassExpressionBuilder
 from puya.awst_build.eb.var_factory import var_expression
-from puya.awst_build.utils import expect_operand_wtype
+from puya.awst_build.utils import convert_literal_to_expr, expect_operand_wtype
 from puya.errors import CodeError
 
 if typing.TYPE_CHECKING:
     from collections.abc import Sequence
 
     import mypy.nodes
 
@@ -60,15 +60,17 @@
     ) -> ExpressionBuilder:
         match args:
             case []:
                 value = ""
             case [Literal(value=str(value))]:
                 pass
             case _:
-                raise CodeError("Invalid/unhandled arguments", location)
+                logger.error("Invalid/unhandled arguments", location=location)
+                # dummy value to continue with
+                value = ""
         str_const = StringConstant(value=value, source_location=location)
         return var_expression(str_const)
 
 
 class StringExpressionBuilder(ValueExpressionBuilder):
     wtype = wtypes.string_wtype
 
@@ -126,16 +128,19 @@
                 )
             case _:
                 return NotImplemented
 
     def compare(
         self, other: ExpressionBuilder | Literal, op: BuilderComparisonOp, location: SourceLocation
     ) -> ExpressionBuilder:
-        other_expr = expect_operand_wtype(other, self.wtype)
-
+        other_expr = convert_literal_to_expr(other, self.wtype)
+        if other_expr.wtype == self.wtype:
+            pass
+        else:
+            return NotImplemented
         cmp = BytesComparisonExpression(
             source_location=location,
             lhs=self.expr,
             operator=EqualityComparison(op.value),
             rhs=other_expr,
         )
         return var_expression(cmp)
```

## puya/awst_build/eb/struct.py

```diff
@@ -1,21 +1,20 @@
 from collections.abc import Sequence
 
 import mypy.nodes
 import mypy.types
 
 from puya.awst import wtypes
-from puya.awst.nodes import CallArg, Expression, FieldExpression, Literal, NewStruct
+from puya.awst.nodes import Expression, FieldExpression, Literal
 from puya.awst_build.eb.base import (
     ExpressionBuilder,
     TypeClassExpressionBuilder,
     ValueExpressionBuilder,
 )
 from puya.awst_build.eb.var_factory import var_expression
-from puya.awst_build.utils import require_expression_builder
 from puya.errors import CodeError
 from puya.parse import SourceLocation
 
 
 class StructSubclassExpressionBuilder(TypeClassExpressionBuilder):
     def __init__(self, wtype: wtypes.WStructType, location: SourceLocation):
         super().__init__(location=location)
@@ -27,22 +26,15 @@
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
-        # TODO: validation etc
-        ctor_args = [
-            # TODO: allow literals?
-            CallArg(name=arg_name, value=require_expression_builder(a).rvalue())
-            for a, arg_name in zip(args, arg_names, strict=True)
-        ]
-        struct_expr = NewStruct(source_location=location, args=tuple(ctor_args), wtype=self.wtype)
-        return var_expression(struct_expr)
+        raise NotImplementedError
 
 
 class StructExpressionBuilder(ValueExpressionBuilder):
     def __init__(self, expr: Expression):
         assert isinstance(expr.wtype, wtypes.WStructType)
         self.wtype: wtypes.WStructType = expr.wtype
         super().__init__(expr)
```

## puya/awst_build/eb/transaction/base.py

```diff
@@ -18,20 +18,18 @@
     from puya.parse import SourceLocation
 
 _PYTHON_MEMBER_FIELD_MAP = {get_field_python_name(f): f for f in TXN_FIELDS}
 
 
 class BaseTransactionExpressionBuilder(ValueExpressionBuilder, abc.ABC):
     @abc.abstractmethod
-    def get_field_value(self, field: TxnField, location: SourceLocation) -> Expression:
-        ...
+    def get_field_value(self, field: TxnField, location: SourceLocation) -> Expression: ...
 
     @abc.abstractmethod
-    def get_array_member(self, field: TxnField, location: SourceLocation) -> ExpressionBuilder:
-        ...
+    def get_array_member(self, field: TxnField, location: SourceLocation) -> ExpressionBuilder: ...
 
     def member_access(self, name: str, location: SourceLocation) -> ExpressionBuilder | Literal:
         try:
             field = _PYTHON_MEMBER_FIELD_MAP[name]
         except KeyError:
             pass
         else:
```

## puya/awst_build/eb/transaction/inner_params.py

```diff
@@ -93,15 +93,20 @@
     def call(
         self,
         args: Sequence[ExpressionBuilder | Literal],
         arg_kinds: list[mypy.nodes.ArgKind],
         arg_names: list[str | None],
         location: SourceLocation,
     ) -> ExpressionBuilder:
-        transaction_fields = dict[TxnField, Expression]()
+        transaction_fields: dict[TxnField, Expression] = {
+            TxnFields.fee: UInt64Constant(
+                source_location=self.source_location,
+                value=0,
+            )
+        }
         transaction_type = self.wtype.transaction_type
         if transaction_type:
             transaction_fields[TxnFields.type] = UInt64Constant(
                 source_location=self.source_location,
                 value=transaction_type.value,
                 teal_alias=transaction_type.name,
             )
```

## puya/awst_build/eb/tuple.py

```diff
@@ -22,15 +22,15 @@
     TypeClassExpressionBuilder,
     ValueExpressionBuilder,
 )
 from puya.awst_build.eb.var_factory import var_expression
 from puya.awst_build.utils import require_expression_builder
 from puya.errors import CodeError
 from puya.parse import SourceLocation
-from puya.utils import clamp
+from puya.utils import clamp, positive_index
 
 logger = log.get_logger(__name__)
 
 
 class TupleTypeExpressionBuilder(TypeClassExpressionBuilder):
     def produces(self) -> wtypes.WType:
         try:
@@ -80,22 +80,22 @@
                 try:
                     self.wtype.types[index_value]
                 except IndexError as ex:
                     raise CodeError(
                         "Tuple index out of bounds", index_literal.source_location
                     ) from ex
                 item_expr = TupleItemExpression(
-                    source_location=location,
                     base=self.expr,
                     index=index_value,
+                    source_location=location,
                 )
                 return var_expression(item_expr)
             case _:
                 raise CodeError(
-                    "tuples can only be indexed by literal ints",
+                    "tuples can only be indexed by int constants",
                     index_expr_or_literal.source_location,
                 )
 
     def slice_index(
         self,
         begin_index: ExpressionBuilder | Literal | None,
         end_index: ExpressionBuilder | Literal | None,
@@ -126,15 +126,15 @@
         self, index: ExpressionBuilder | Literal | None
     ) -> tuple[IntegerConstant | None, int | None]:
         match index:
             case None:
                 expr = None
                 idx = None
             case Literal(value=int(idx), source_location=start_loc):
-                positive_idx = idx if idx >= 0 else len(self.wtype.types) + idx
+                positive_idx = positive_index(idx, self.wtype.types)
                 positive_idx_clamped = clamp(positive_idx, low=0, high=len(self.wtype.types) - 1)
                 expr = UInt64Constant(value=positive_idx_clamped, source_location=start_loc)
             case _:
                 raise CodeError(
                     "Tuples can only be indexed with literal values", index.source_location
                 )
         return expr, idx
@@ -182,16 +182,18 @@
 
             result = compare_one(get_index(self.expr, 0), get_index(other_expr, 0))
             i = 1
             while i < len(self.wtype.types):
                 result = BooleanBinaryOperation(
                     left=result,
                     right=compare_one(get_index(self.expr, i), get_index(other_expr, i)),
-                    op=BinaryBooleanOperator.and_
-                    if op == BuilderComparisonOp.eq
-                    else BinaryBooleanOperator.or_,
+                    op=(
+                        BinaryBooleanOperator.and_
+                        if op == BuilderComparisonOp.eq
+                        else BinaryBooleanOperator.or_
+                    ),
                     source_location=location,
                 )
                 i += 1
             return var_expression(result)
 
         raise CodeError(f"The {op} operator on the tuple type is not supported", location)
```

## puya/awst_build/eb/type_registry.py

```diff
@@ -52,18 +52,18 @@
     constants.CLS_LOCAL_STATE: app_account_state.AppAccountStateClassExpressionBuilder,
     constants.CLS_GLOBAL_STATE: app_state.AppStateClassExpressionBuilder,
     constants.CLS_ARC4_ADDRESS: arc4.AddressClassExpressionBuilder,
     constants.CLS_ARC4_BIG_UFIXEDNXM: arc4.BigUFixedNxMClassExpressionBuilder,
     constants.CLS_ARC4_BIG_UINTN: arc4.BigUIntNClassExpressionBuilder,
     constants.CLS_ARC4_BOOL: arc4.ARC4BoolClassExpressionBuilder,
     constants.CLS_ARC4_BYTE: arc4.ByteClassExpressionBuilder,
-    constants.CLS_ARC4_DYNAMIC_ARRAY: arc4.DynamicArrayGenericClassExpressionBuilder,
-    constants.CLS_ARC4_STATIC_ARRAY: arc4.StaticArrayGenericClassExpressionBuilder,
+    constants.CLS_ARC4_DYNAMIC_ARRAY: arc4.DynamicArrayClassExpressionBuilder,
+    constants.CLS_ARC4_STATIC_ARRAY: arc4.StaticArrayClassExpressionBuilder,
     constants.CLS_ARC4_STRING: arc4.StringClassExpressionBuilder,
-    constants.CLS_ARC4_TUPLE: arc4.ARC4TupleGenericClassExpressionBuilder,
+    constants.CLS_ARC4_TUPLE: arc4.ARC4TupleClassExpressionBuilder,
     constants.CLS_ARC4_UFIXEDNXM: arc4.UFixedNxMClassExpressionBuilder,
     constants.CLS_ARC4_UINTN: arc4.UIntNClassExpressionBuilder,
     constants.CLS_ARC4_ABI_CALL: arc4.ABICallGenericClassExpressionBuilder,
     constants.CLS_ARC4_DYNAMIC_BYTES: puya.awst_build.eb.arc4.DynamicBytesClassExpressionBuilder,
     constants.CLS_ACCOUNT: account.AccountClassExpressionBuilder,
     constants.CLS_ARRAY: array.ArrayGenericClassExpressionBuilder,
     constants.CLS_ASSET: asset.AssetClassExpressionBuilder,
@@ -124,15 +124,16 @@
     wtypes.ARC4UFixedNxM: arc4.UFixedNxMExpressionBuilder,
     wtypes.ARC4UIntN: arc4.UIntNExpressionBuilder,
     wtypes.WArray: array.ArrayExpressionBuilder,
     wtypes.WStructType: struct.StructExpressionBuilder,
     wtypes.WTuple: tuple_.TupleExpressionBuilder,
     wtypes.arc4_bool_wtype: arc4.ARC4BoolExpressionBuilder,
     wtypes.arc4_string_wtype: arc4.StringExpressionBuilder,
-    wtypes.arc4_dynamic_bytes: puya.awst_build.eb.arc4.DynamicBytesExpressionBuilder,
+    wtypes.arc4_dynamic_bytes: arc4.DynamicBytesExpressionBuilder,
+    wtypes.arc4_address_type: arc4.AddressExpressionBuilder,
     wtypes.account_wtype: account.AccountExpressionBuilder,
     wtypes.application_wtype: application.ApplicationExpressionBuilder,
     wtypes.asset_wtype: asset.AssetExpressionBuilder,
     wtypes.biguint_wtype: biguint.BigUIntExpressionBuilder,
     wtypes.bool_wtype: bool_.BoolExpressionBuilder,
     wtypes.bytes_wtype: bytes_.BytesExpressionBuilder,
     wtypes.string_wtype: string.StringExpressionBuilder,
```

## puya/awst_build/eb/uint64.py

```diff
@@ -27,15 +27,15 @@
     BuilderComparisonOp,
     ExpressionBuilder,
     TypeClassExpressionBuilder,
     ValueExpressionBuilder,
 )
 from puya.awst_build.eb.var_factory import var_expression
 from puya.awst_build.utils import convert_literal_to_expr
-from puya.errors import CodeError, TodoError
+from puya.errors import CodeError
 
 if typing.TYPE_CHECKING:
     from collections.abc import Sequence
 
     import mypy.types
 
     from puya.parse import SourceLocation
@@ -56,15 +56,17 @@
     ) -> ExpressionBuilder:
         match args:
             case []:
                 const = UInt64Constant(value=0, source_location=location)
             case [Literal(value=int(int_value))]:
                 const = UInt64Constant(value=int_value, source_location=location)
             case _:
-                raise CodeError("Invalid/unhandled arguments", location)
+                logger.error("Invalid/unhandled arguments", location=location)
+                # dummy value to continue with
+                const = UInt64Constant(value=0, source_location=location)
         return var_expression(const)
 
 
 class UInt64ExpressionBuilder(ValueExpressionBuilder):
     wtype = wtypes.uint64_wtype
 
     def bool_eval(self, location: SourceLocation, *, negate: bool = False) -> ExpressionBuilder:
@@ -95,16 +97,14 @@
 
     def compare(
         self, other: ExpressionBuilder | Literal, op: BuilderComparisonOp, location: SourceLocation
     ) -> ExpressionBuilder:
         other_expr = convert_literal_to_expr(other, self.wtype)
         if other_expr.wtype == self.wtype:
             pass
-        elif other_expr.wtype == wtypes.bool_wtype:
-            raise TodoError(location, "TODO: support upcast from bool to uint64")
         else:
             return NotImplemented
         cmp_expr = NumericComparisonExpression(
             source_location=location,
             lhs=self.expr,
             operator=NumericComparison(op.value),
             rhs=other_expr,
@@ -118,16 +118,14 @@
         location: SourceLocation,
         *,
         reverse: bool,
     ) -> ExpressionBuilder:
         other_expr = convert_literal_to_expr(other, self.wtype)
         if other_expr.wtype == self.wtype:
             pass
-        elif other_expr.wtype == wtypes.bool_wtype:
-            raise TodoError(location, "TODO: support upcast from bool to uint64")
         else:
             return NotImplemented
         lhs = self.expr
         rhs = other_expr
         if reverse:
             (lhs, rhs) = (rhs, lhs)
         uint64_op = _translate_uint64_math_operator(op, location)
@@ -138,16 +136,14 @@
 
     def augmented_assignment(
         self, op: BuilderBinaryOp, rhs: ExpressionBuilder | Literal, location: SourceLocation
     ) -> Statement:
         value = convert_literal_to_expr(rhs, self.wtype)
         if value.wtype == self.wtype:
             pass
-        elif value.wtype == wtypes.bool_wtype:
-            raise TodoError(location, "TODO: support upcast from bool to uint64")
         else:
             raise CodeError(
                 f"Invalid operand type {value.wtype} for {op.value}= with {self.wtype}", location
             )
         target = self.lvalue()
         uint64_op = _translate_uint64_math_operator(op, location)
         return UInt64AugmentedAssignment(
@@ -167,8 +163,8 @@
             location=loc,
         )
         # continue traversing code to generate any further errors
         operator = BuilderBinaryOp.floor_div
     try:
         return UInt64BinaryOperator(operator.value)
     except ValueError as ex:
-        raise CodeError(f"Unsupported UInt64 math operator {operator.value}", loc) from ex
+        raise CodeError(f"Unsupported UInt64 math operator {operator.value!r}", loc) from ex
```

## puya/awst_build/intrinsic_data.py

```diff
@@ -1,9 +1,13 @@
 from puya.awst import wtypes
-from puya.awst_build.intrinsic_models import ArgMapping, FunctionOpMapping
+from puya.awst_build.intrinsic_models import (
+    FunctionOpMapping,
+    ImmediateArgMapping,
+    StackArgMapping,
+)
 
 ENUM_CLASSES = {
     "algopy.op.Base64": {
         "URLEncoding": "URLEncoding",
         "StdEncoding": "StdEncoding",
     },
     "algopy.op.ECDSA": {
@@ -24,26 +28,24 @@
 STUB_TO_AST_MAPPER = {
     "algopy.op.addw": [
         FunctionOpMapping(
             op_code="addw",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.uint64_wtype,
             ],
@@ -51,145 +53,134 @@
     ],
     "algopy.op.app_opted_in": [
         FunctionOpMapping(
             op_code="app_opted_in",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
     ],
     "algopy.op.arg": [
         FunctionOpMapping(
             op_code="args",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="arg",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.balance": [
         FunctionOpMapping(
             op_code="balance",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.base64_decode": [
         FunctionOpMapping(
             op_code="base64_decode",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="e",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.bitlen": [
         FunctionOpMapping(
             op_code="bitlen",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.bsqrt": [
         FunctionOpMapping(
             op_code="bsqrt",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.biguint_wtype,
                     ],
                 ),
             ],
             stack_outputs=[
@@ -199,104 +190,96 @@
     ],
     "algopy.op.btoi": [
         FunctionOpMapping(
             op_code="btoi",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.bzero": [
         FunctionOpMapping(
             op_code="bzero",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.concat": [
         FunctionOpMapping(
             op_code="concat",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.divmodw": [
         FunctionOpMapping(
             op_code="divmodw",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="d",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.uint64_wtype,
                 wtypes.uint64_wtype,
@@ -306,228 +289,203 @@
     ],
     "algopy.op.divw": [
         FunctionOpMapping(
             op_code="divw",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.ecdsa_pk_decompress": [
         FunctionOpMapping(
             op_code="ecdsa_pk_decompress",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="v",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.ecdsa_pk_recover": [
         FunctionOpMapping(
             op_code="ecdsa_pk_recover",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="v",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="d",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.ecdsa_verify": [
         FunctionOpMapping(
             op_code="ecdsa_verify",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="v",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="d",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="e",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
     ],
     "algopy.op.ed25519verify": [
         FunctionOpMapping(
             op_code="ed25519verify",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
     ],
     "algopy.op.ed25519verify_bare": [
         FunctionOpMapping(
             op_code="ed25519verify_bare",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
@@ -543,69 +501,64 @@
     ],
     "algopy.op.exit": [
         FunctionOpMapping(
             op_code="return",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.exp": [
         FunctionOpMapping(
             op_code="exp",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.expw": [
         FunctionOpMapping(
             op_code="expw",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.uint64_wtype,
             ],
@@ -613,458 +566,413 @@
     ],
     "algopy.op.extract": [
         FunctionOpMapping(
             op_code="extract3",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="extract",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="c",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.extract_uint16": [
         FunctionOpMapping(
             op_code="extract_uint16",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.extract_uint32": [
         FunctionOpMapping(
             op_code="extract_uint32",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.extract_uint64": [
         FunctionOpMapping(
             op_code="extract_uint64",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.gaid": [
         FunctionOpMapping(
             op_code="gaids",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gaid",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
     ],
     "algopy.op.getbit": [
         FunctionOpMapping(
             op_code="getbit",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.getbyte": [
         FunctionOpMapping(
             op_code="getbyte",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.gload_bytes": [
         FunctionOpMapping(
             op_code="gloadss",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gload",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gloads",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.gload_uint64": [
         FunctionOpMapping(
             op_code="gloadss",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gload",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gloads",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.itob": [
         FunctionOpMapping(
             op_code="itob",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.keccak256": [
         FunctionOpMapping(
             op_code="keccak256",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.min_balance": [
         FunctionOpMapping(
             op_code="min_balance",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.mulw": [
         FunctionOpMapping(
             op_code="mulw",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.uint64_wtype,
             ],
@@ -1072,394 +980,419 @@
     ],
     "algopy.op.replace": [
         FunctionOpMapping(
             op_code="replace3",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="replace2",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
+                    literal_type=int,
+                ),
+            ],
+            stack_inputs=[
+                StackArgMapping(
+                    arg_name="a",
+                    allowed_types=[
+                        wtypes.bytes_wtype,
+                    ],
+                ),
+                StackArgMapping(
+                    arg_name="c",
                     allowed_types=[
-                        int,
+                        wtypes.bytes_wtype,
                     ],
                 ),
             ],
+            stack_outputs=[
+                wtypes.bytes_wtype,
+            ],
+        ),
+    ],
+    "algopy.op.select_bytes": [
+        FunctionOpMapping(
+            op_code="select",
+            is_property=False,
+            immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
-                    arg_name="c",
+                StackArgMapping(
+                    arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
+                    ],
+                ),
+                StackArgMapping(
+                    arg_name="c",
+                    allowed_types=[
+                        wtypes.bool_wtype,
+                        wtypes.uint64_wtype,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
+    "algopy.op.select_uint64": [
+        FunctionOpMapping(
+            op_code="select",
+            is_property=False,
+            immediates=[],
+            stack_inputs=[
+                StackArgMapping(
+                    arg_name="a",
+                    allowed_types=[
+                        wtypes.uint64_wtype,
+                    ],
+                ),
+                StackArgMapping(
+                    arg_name="b",
+                    allowed_types=[
+                        wtypes.uint64_wtype,
+                    ],
+                ),
+                StackArgMapping(
+                    arg_name="c",
+                    allowed_types=[
+                        wtypes.bool_wtype,
+                        wtypes.uint64_wtype,
+                    ],
+                ),
+            ],
+            stack_outputs=[
+                wtypes.uint64_wtype,
+            ],
+        ),
+    ],
     "algopy.op.setbit_bytes": [
         FunctionOpMapping(
             op_code="setbit",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.setbit_uint64": [
         FunctionOpMapping(
             op_code="setbit",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.setbyte": [
         FunctionOpMapping(
             op_code="setbyte",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.sha256": [
         FunctionOpMapping(
             op_code="sha256",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.sha3_256": [
         FunctionOpMapping(
             op_code="sha3_256",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.sha512_256": [
         FunctionOpMapping(
             op_code="sha512_256",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.shl": [
         FunctionOpMapping(
             op_code="shl",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.shr": [
         FunctionOpMapping(
             op_code="shr",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.sqrt": [
         FunctionOpMapping(
             op_code="sqrt",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.substring": [
         FunctionOpMapping(
             op_code="substring3",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="substring",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="c",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.vrf_verify": [
         FunctionOpMapping(
             op_code="vrf_verify",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="s",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1469,20 +1402,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctBalance",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1492,20 +1424,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctMinBalance",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1515,20 +1446,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctAuthAddr",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1538,20 +1468,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctTotalNumUint",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1561,20 +1490,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctTotalNumByteSlice",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1584,20 +1512,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctTotalExtraAppPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1607,20 +1534,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctTotalAppsCreated",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1630,20 +1556,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctTotalAppsOptedIn",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1653,20 +1578,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctTotalAssetsCreated",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1676,20 +1600,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctTotalAssets",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1699,20 +1622,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctTotalBoxes",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1722,20 +1644,19 @@
         FunctionOpMapping(
             op_code="acct_params_get",
             is_property=False,
             immediates=[
                 "AcctTotalBoxBytes",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1743,65 +1664,61 @@
     ],
     "algopy.op.AppGlobal.get_bytes": [
         FunctionOpMapping(
             op_code="app_global_get",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.AppGlobal.get_uint64": [
         FunctionOpMapping(
             op_code="app_global_get",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.AppGlobal.get_ex_bytes": [
         FunctionOpMapping(
             op_code="app_global_get_ex",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1809,27 +1726,25 @@
     ],
     "algopy.op.AppGlobal.get_ex_uint64": [
         FunctionOpMapping(
             op_code="app_global_get_ex",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1837,132 +1752,121 @@
     ],
     "algopy.op.AppGlobal.delete": [
         FunctionOpMapping(
             op_code="app_global_del",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.AppGlobal.put": [
         FunctionOpMapping(
             op_code="app_global_put",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.AppLocal.get_bytes": [
         FunctionOpMapping(
             op_code="app_local_get",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.AppLocal.get_uint64": [
         FunctionOpMapping(
             op_code="app_local_get",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.AppLocal.get_ex_bytes": [
         FunctionOpMapping(
             op_code="app_local_get_ex",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bool_wtype,
             ],
@@ -1970,35 +1874,32 @@
     ],
     "algopy.op.AppLocal.get_ex_uint64": [
         FunctionOpMapping(
             op_code="app_local_get_ex",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2006,81 +1907,74 @@
     ],
     "algopy.op.AppLocal.delete": [
         FunctionOpMapping(
             op_code="app_local_del",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.AppLocal.put": [
         FunctionOpMapping(
             op_code="app_local_put",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.AppParamsGet.app_approval_program": [
         FunctionOpMapping(
             op_code="app_params_get",
             is_property=False,
             immediates=[
                 "AppApprovalProgram",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2090,20 +1984,19 @@
         FunctionOpMapping(
             op_code="app_params_get",
             is_property=False,
             immediates=[
                 "AppClearStateProgram",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2113,20 +2006,19 @@
         FunctionOpMapping(
             op_code="app_params_get",
             is_property=False,
             immediates=[
                 "AppGlobalNumUint",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2136,20 +2028,19 @@
         FunctionOpMapping(
             op_code="app_params_get",
             is_property=False,
             immediates=[
                 "AppGlobalNumByteSlice",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2159,20 +2050,19 @@
         FunctionOpMapping(
             op_code="app_params_get",
             is_property=False,
             immediates=[
                 "AppLocalNumUint",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2182,20 +2072,19 @@
         FunctionOpMapping(
             op_code="app_params_get",
             is_property=False,
             immediates=[
                 "AppLocalNumByteSlice",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2205,20 +2094,19 @@
         FunctionOpMapping(
             op_code="app_params_get",
             is_property=False,
             immediates=[
                 "AppExtraProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2228,20 +2116,19 @@
         FunctionOpMapping(
             op_code="app_params_get",
             is_property=False,
             immediates=[
                 "AppCreator",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2251,20 +2138,19 @@
         FunctionOpMapping(
             op_code="app_params_get",
             is_property=False,
             immediates=[
                 "AppAddress",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2274,28 +2160,26 @@
         FunctionOpMapping(
             op_code="asset_holding_get",
             is_property=False,
             immediates=[
                 "AssetBalance",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2305,28 +2189,26 @@
         FunctionOpMapping(
             op_code="asset_holding_get",
             is_property=False,
             immediates=[
                 "AssetFrozen",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2336,20 +2218,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetTotal",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2359,20 +2240,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetDecimals",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2382,20 +2262,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetDefaultFrozen",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2405,20 +2284,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetUnitName",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2428,20 +2306,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetName",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2451,20 +2328,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetURL",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2474,20 +2350,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetMetadataHash",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2497,20 +2372,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetManager",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2520,20 +2394,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetReserve",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2543,20 +2416,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetFreeze",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2566,20 +2438,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetClawback",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2589,20 +2460,19 @@
         FunctionOpMapping(
             op_code="asset_params_get",
             is_property=False,
             immediates=[
                 "AssetCreator",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2612,19 +2482,18 @@
         FunctionOpMapping(
             op_code="block",
             is_property=False,
             immediates=[
                 "BlkSeed",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -2633,116 +2502,108 @@
         FunctionOpMapping(
             op_code="block",
             is_property=False,
             immediates=[
                 "BlkTimestamp",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.Box.create": [
         FunctionOpMapping(
             op_code="box_create",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
     ],
     "algopy.op.Box.delete": [
         FunctionOpMapping(
             op_code="box_del",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
     ],
     "algopy.op.Box.extract": [
         FunctionOpMapping(
             op_code="box_extract",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.Box.get": [
         FunctionOpMapping(
             op_code="box_get",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2750,19 +2611,18 @@
     ],
     "algopy.op.Box.length": [
         FunctionOpMapping(
             op_code="box_len",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
                 wtypes.bool_wtype,
             ],
@@ -2770,1809 +2630,1605 @@
     ],
     "algopy.op.Box.put": [
         FunctionOpMapping(
             op_code="box_put",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.Box.replace": [
         FunctionOpMapping(
             op_code="box_replace",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.Box.resize": [
         FunctionOpMapping(
             op_code="box_resize",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.Box.splice": [
         FunctionOpMapping(
             op_code="box_splice",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="c",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="d",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.EllipticCurve.add": [
         FunctionOpMapping(
             op_code="ec_add",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="g",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.EllipticCurve.map_to": [
         FunctionOpMapping(
             op_code="ec_map_to",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="g",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.EllipticCurve.scalar_mul_multi": [
         FunctionOpMapping(
             op_code="ec_multi_scalar_mul",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="g",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.EllipticCurve.pairing_check": [
         FunctionOpMapping(
             op_code="ec_pairing_check",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="g",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
     ],
     "algopy.op.EllipticCurve.scalar_mul": [
         FunctionOpMapping(
             op_code="ec_scalar_mul",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="g",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.EllipticCurve.subgroup_check": [
         FunctionOpMapping(
             op_code="ec_subgroup_check",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="g",
-                    allowed_types=[
-                        str,
-                    ],
+                    literal_type=str,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.sender": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Sender",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.fee": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Fee",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.first_valid": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "FirstValid",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.first_valid_time": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "FirstValidTime",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.last_valid": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "LastValid",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.note": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Note",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.lease": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Lease",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.receiver": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Receiver",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.amount": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Amount",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.close_remainder_to": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "CloseRemainderTo",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.vote_pk": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "VotePK",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.selection_pk": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "SelectionPK",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.vote_first": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "VoteFirst",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.vote_last": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "VoteLast",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.vote_key_dilution": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "VoteKeyDilution",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.type": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Type",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.type_enum": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "TypeEnum",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.xfer_asset": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "XferAsset",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.asset_amount": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "AssetAmount",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.asset_sender": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "AssetSender",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.asset_receiver": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "AssetReceiver",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.asset_close_to": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "AssetCloseTo",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.group_index": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "GroupIndex",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.tx_id": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "TxID",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.application_id": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApplicationID",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.on_completion": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "OnCompletion",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.application_args": [
         FunctionOpMapping(
             op_code="gitxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApplicationArgs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gitxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApplicationArgs",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.num_app_args": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumAppArgs",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.accounts": [
         FunctionOpMapping(
             op_code="gitxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Accounts",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gitxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Accounts",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.num_accounts": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumAccounts",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.approval_program": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApprovalProgram",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.clear_state_program": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ClearStateProgram",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.rekey_to": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "RekeyTo",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAsset",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_total": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetTotal",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_decimals": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetDecimals",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_default_frozen": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetDefaultFrozen",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_unit_name": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetUnitName",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_name": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetName",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_url": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetURL",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_metadata_hash": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetMetadataHash",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_manager": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetManager",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_reserve": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetReserve",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_freeze": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetFreeze",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.config_asset_clawback": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetClawback",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.freeze_asset": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "FreezeAsset",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.freeze_asset_account": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "FreezeAssetAccount",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.freeze_asset_frozen": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "FreezeAssetFrozen",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.assets": [
         FunctionOpMapping(
             op_code="gitxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Assets",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gitxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Assets",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.num_assets": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumAssets",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.applications": [
         FunctionOpMapping(
             op_code="gitxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Applications",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gitxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Applications",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.num_applications": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumApplications",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.global_num_uint": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "GlobalNumUint",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.global_num_byte_slice": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "GlobalNumByteSlice",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.local_num_uint": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "LocalNumUint",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.local_num_byte_slice": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "LocalNumByteSlice",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.extra_program_pages": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ExtraProgramPages",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.nonparticipation": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Nonparticipation",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.logs": [
         FunctionOpMapping(
             op_code="gitxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Logs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gitxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Logs",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.num_logs": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumLogs",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.created_asset_id": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "CreatedAssetID",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.created_application_id": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "CreatedApplicationID",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.last_log": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "LastLog",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.state_proof_pk": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "StateProofPK",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.approval_program_pages": [
         FunctionOpMapping(
             op_code="gitxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApprovalProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gitxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApprovalProgramPages",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.num_approval_program_pages": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumApprovalProgramPages",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.clear_state_program_pages": [
         FunctionOpMapping(
             op_code="gitxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ClearStateProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gitxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ClearStateProgramPages",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.GITxn.num_clear_state_program_pages": [
         FunctionOpMapping(
             op_code="gitxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="t",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumClearStateProgramPages",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -4582,35 +4238,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "Sender",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Sender",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -4620,35 +4273,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "Fee",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Fee",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -4658,35 +4308,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "FirstValid",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "FirstValid",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -4696,35 +4343,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "FirstValidTime",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "FirstValidTime",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -4734,35 +4378,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "LastValid",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "LastValid",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -4772,35 +4413,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "Note",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Note",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -4810,35 +4448,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "Lease",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Lease",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -4848,35 +4483,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "Receiver",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Receiver",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -4886,35 +4518,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "Amount",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Amount",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -4924,35 +4553,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "CloseRemainderTo",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "CloseRemainderTo",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -4962,35 +4588,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "VotePK",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "VotePK",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -5000,35 +4623,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "SelectionPK",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "SelectionPK",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -5038,35 +4658,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "VoteFirst",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "VoteFirst",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -5076,35 +4693,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "VoteLast",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "VoteLast",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -5114,35 +4728,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "VoteKeyDilution",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "VoteKeyDilution",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -5152,35 +4763,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "Type",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Type",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -5190,35 +4798,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "TypeEnum",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "TypeEnum",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -5228,35 +4833,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "XferAsset",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "XferAsset",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
@@ -5266,35 +4868,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "AssetAmount",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "AssetAmount",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -5304,35 +4903,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "AssetSender",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "AssetSender",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -5342,35 +4938,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "AssetReceiver",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "AssetReceiver",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -5380,35 +4973,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "AssetCloseTo",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "AssetCloseTo",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -5418,35 +5008,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "GroupIndex",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "GroupIndex",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -5456,35 +5043,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "TxID",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "TxID",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -5494,35 +5078,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ApplicationID",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApplicationID",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
@@ -5532,35 +5113,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "OnCompletion",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "OnCompletion",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -5570,99 +5148,87 @@
         FunctionOpMapping(
             op_code="gtxnsas",
             is_property=False,
             immediates=[
                 "ApplicationArgs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnsa",
             is_property=False,
             immediates=[
                 "ApplicationArgs",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApplicationArgs",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApplicationArgs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -5671,35 +5237,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "NumAppArgs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumAppArgs",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -5709,99 +5272,87 @@
         FunctionOpMapping(
             op_code="gtxnsas",
             is_property=False,
             immediates=[
                 "Accounts",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnsa",
             is_property=False,
             immediates=[
                 "Accounts",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Accounts",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Accounts",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
@@ -5810,35 +5361,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "NumAccounts",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumAccounts",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -5848,35 +5396,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ApprovalProgram",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApprovalProgram",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -5886,35 +5431,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ClearStateProgram",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ClearStateProgram",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -5924,35 +5466,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "RekeyTo",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "RekeyTo",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -5962,35 +5501,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAsset",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAsset",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
@@ -6000,35 +5536,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetTotal",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetTotal",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -6038,35 +5571,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetDecimals",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetDecimals",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -6076,35 +5606,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetDefaultFrozen",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetDefaultFrozen",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
@@ -6114,35 +5641,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetUnitName",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetUnitName",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -6152,35 +5676,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetName",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetName",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -6190,35 +5711,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetURL",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetURL",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -6228,35 +5746,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetMetadataHash",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetMetadataHash",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -6266,35 +5781,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetManager",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetManager",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -6304,35 +5816,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetReserve",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetReserve",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -6342,35 +5851,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetFreeze",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetFreeze",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -6380,35 +5886,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ConfigAssetClawback",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ConfigAssetClawback",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -6418,35 +5921,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "FreezeAsset",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "FreezeAsset",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
@@ -6456,35 +5956,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "FreezeAssetAccount",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "FreezeAssetAccount",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
@@ -6494,35 +5991,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "FreezeAssetFrozen",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "FreezeAssetFrozen",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
@@ -6532,99 +6026,87 @@
         FunctionOpMapping(
             op_code="gtxnsas",
             is_property=False,
             immediates=[
                 "Assets",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnsa",
             is_property=False,
             immediates=[
                 "Assets",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Assets",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Assets",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
@@ -6633,35 +6115,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "NumAssets",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumAssets",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -6671,99 +6150,87 @@
         FunctionOpMapping(
             op_code="gtxnsas",
             is_property=False,
             immediates=[
                 "Applications",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnsa",
             is_property=False,
             immediates=[
                 "Applications",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Applications",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Applications",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
@@ -6772,35 +6239,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "NumApplications",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumApplications",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -6810,35 +6274,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "GlobalNumUint",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "GlobalNumUint",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -6848,35 +6309,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "GlobalNumByteSlice",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "GlobalNumByteSlice",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -6886,35 +6344,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "LocalNumUint",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "LocalNumUint",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -6924,35 +6379,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "LocalNumByteSlice",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "LocalNumByteSlice",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -6962,35 +6414,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "ExtraProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ExtraProgramPages",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -7000,35 +6449,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "Nonparticipation",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Nonparticipation",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bool_wtype,
             ],
@@ -7038,99 +6484,87 @@
         FunctionOpMapping(
             op_code="gtxnsas",
             is_property=False,
             immediates=[
                 "Logs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnsa",
             is_property=False,
             immediates=[
                 "Logs",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Logs",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "Logs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -7139,35 +6573,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "NumLogs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumLogs",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -7177,35 +6608,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "CreatedAssetID",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "CreatedAssetID",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
@@ -7215,35 +6643,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "CreatedApplicationID",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "CreatedApplicationID",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
@@ -7253,35 +6678,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "LastLog",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "LastLog",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -7291,35 +6713,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "StateProofPK",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "StateProofPK",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
@@ -7329,99 +6748,87 @@
         FunctionOpMapping(
             op_code="gtxnsas",
             is_property=False,
             immediates=[
                 "ApprovalProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnsa",
             is_property=False,
             immediates=[
                 "ApprovalProgramPages",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApprovalProgramPages",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ApprovalProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -7430,35 +6837,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "NumApprovalProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumApprovalProgramPages",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -7468,99 +6872,87 @@
         FunctionOpMapping(
             op_code="gtxnsas",
             is_property=False,
             immediates=[
                 "ClearStateProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnsa",
             is_property=False,
             immediates=[
                 "ClearStateProgramPages",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxna",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ClearStateProgramPages",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="b",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxnas",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "ClearStateProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -7569,35 +6961,32 @@
         FunctionOpMapping(
             op_code="gtxns",
             is_property=False,
             immediates=[
                 "NumClearStateProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="gtxn",
             is_property=False,
             immediates=[
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
                 "NumClearStateProgramPages",
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
@@ -8179,36 +7568,33 @@
         FunctionOpMapping(
             op_code="itxnas",
             is_property=False,
             immediates=[
                 "ApplicationArgs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="itxna",
             is_property=False,
             immediates=[
                 "ApplicationArgs",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -8230,36 +7616,33 @@
         FunctionOpMapping(
             op_code="itxnas",
             is_property=False,
             immediates=[
                 "Accounts",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="itxna",
             is_property=False,
             immediates=[
                 "Accounts",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
@@ -8515,36 +7898,33 @@
         FunctionOpMapping(
             op_code="itxnas",
             is_property=False,
             immediates=[
                 "Assets",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="itxna",
             is_property=False,
             immediates=[
                 "Assets",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
@@ -8566,36 +7946,33 @@
         FunctionOpMapping(
             op_code="itxnas",
             is_property=False,
             immediates=[
                 "Applications",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="itxna",
             is_property=False,
             immediates=[
                 "Applications",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
@@ -8695,36 +8072,33 @@
         FunctionOpMapping(
             op_code="itxnas",
             is_property=False,
             immediates=[
                 "Logs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="itxna",
             is_property=False,
             immediates=[
                 "Logs",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -8798,36 +8172,33 @@
         FunctionOpMapping(
             op_code="itxnas",
             is_property=False,
             immediates=[
                 "ApprovalProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="itxna",
             is_property=False,
             immediates=[
                 "ApprovalProgramPages",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -8849,36 +8220,33 @@
         FunctionOpMapping(
             op_code="itxnas",
             is_property=False,
             immediates=[
                 "ClearStateProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="itxna",
             is_property=False,
             immediates=[
                 "ClearStateProgramPages",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -8927,15 +8295,15 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "Sender",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -8945,53 +8313,51 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "Fee",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_note": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "Note",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_receiver": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "Receiver",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9001,34 +8367,33 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "Amount",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_close_remainder_to": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "CloseRemainderTo",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9038,187 +8403,178 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "VotePK",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_selection_pk": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "SelectionPK",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_vote_first": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "VoteFirst",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_vote_last": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "VoteLast",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_vote_key_dilution": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "VoteKeyDilution",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_type": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "Type",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_type_enum": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "TypeEnum",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_xfer_asset": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "XferAsset",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_asset_amount": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "AssetAmount",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_asset_sender": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "AssetSender",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9228,15 +8584,15 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "AssetReceiver",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9246,15 +8602,15 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "AssetCloseTo",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9264,73 +8620,70 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ApplicationID",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.application_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_on_completion": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "OnCompletion",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_application_args": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ApplicationArgs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_accounts": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "Accounts",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9340,53 +8693,51 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ApprovalProgram",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_clear_state_program": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ClearStateProgram",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_rekey_to": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "RekeyTo",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9396,169 +8747,161 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAsset",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_config_asset_total": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetTotal",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_config_asset_decimals": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetDecimals",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_config_asset_default_frozen": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetDefaultFrozen",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bool_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_config_asset_unit_name": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetUnitName",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_config_asset_name": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetName",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_config_asset_url": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetURL",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_config_asset_metadata_hash": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetMetadataHash",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_config_asset_manager": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetManager",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9568,15 +8911,15 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetReserve",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9586,15 +8929,15 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetFreeze",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9604,15 +8947,15 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ConfigAssetClawback",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9622,35 +8965,34 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "FreezeAsset",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.asset_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_freeze_asset_account": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "FreezeAssetAccount",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.account_wtype,
                     ],
                 ),
             ],
             stack_outputs=[],
@@ -9660,256 +9002,242 @@
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "FreezeAssetFrozen",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bool_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_assets": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "Assets",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_applications": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "Applications",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_global_num_uint": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "GlobalNumUint",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_global_num_byte_slice": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "GlobalNumByteSlice",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_local_num_uint": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "LocalNumUint",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_local_num_byte_slice": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "LocalNumByteSlice",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_extra_program_pages": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ExtraProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_nonparticipation": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "Nonparticipation",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bool_wtype,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_state_proof_pk": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "StateProofPK",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_approval_program_pages": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ApprovalProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.ITxnCreate.set_clear_state_program_pages": [
         FunctionOpMapping(
             op_code="itxn_field",
             is_property=False,
             immediates=[
                 "ClearStateProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.JsonRef.json_string": [
         FunctionOpMapping(
             op_code="json_ref",
             is_property=False,
             immediates=[
                 "JSONString",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -9918,26 +9246,24 @@
         FunctionOpMapping(
             op_code="json_ref",
             is_property=False,
             immediates=[
                 "JSONUint64",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
@@ -9946,92 +9272,85 @@
         FunctionOpMapping(
             op_code="json_ref",
             is_property=False,
             immediates=[
                 "JSONObject",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.Scratch.load_bytes": [
         FunctionOpMapping(
             op_code="loads",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
     ],
     "algopy.op.Scratch.load_uint64": [
         FunctionOpMapping(
             op_code="loads",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.uint64_wtype,
             ],
         ),
     ],
     "algopy.op.Scratch.store": [
         FunctionOpMapping(
             op_code="stores",
             is_property=False,
             immediates=[],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
-                ArgMapping(
+                StackArgMapping(
                     arg_name="b",
                     allowed_types=[
                         wtypes.bytes_wtype,
-                        bytes,
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[],
         ),
     ],
     "algopy.op.Txn.sender": [
@@ -10376,36 +9695,33 @@
         FunctionOpMapping(
             op_code="txnas",
             is_property=False,
             immediates=[
                 "ApplicationArgs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="txna",
             is_property=False,
             immediates=[
                 "ApplicationArgs",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -10427,36 +9743,33 @@
         FunctionOpMapping(
             op_code="txnas",
             is_property=False,
             immediates=[
                 "Accounts",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="txna",
             is_property=False,
             immediates=[
                 "Accounts",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.account_wtype,
             ],
         ),
@@ -10712,36 +10025,33 @@
         FunctionOpMapping(
             op_code="txnas",
             is_property=False,
             immediates=[
                 "Assets",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="txna",
             is_property=False,
             immediates=[
                 "Assets",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.asset_wtype,
             ],
         ),
@@ -10763,36 +10073,33 @@
         FunctionOpMapping(
             op_code="txnas",
             is_property=False,
             immediates=[
                 "Applications",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="txna",
             is_property=False,
             immediates=[
                 "Applications",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.application_wtype,
             ],
         ),
@@ -10892,36 +10199,33 @@
         FunctionOpMapping(
             op_code="txnas",
             is_property=False,
             immediates=[
                 "Logs",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="txna",
             is_property=False,
             immediates=[
                 "Logs",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -10995,36 +10299,33 @@
         FunctionOpMapping(
             op_code="txnas",
             is_property=False,
             immediates=[
                 "ApprovalProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="txna",
             is_property=False,
             immediates=[
                 "ApprovalProgramPages",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
@@ -11046,36 +10347,33 @@
         FunctionOpMapping(
             op_code="txnas",
             is_property=False,
             immediates=[
                 "ClearStateProgramPages",
             ],
             stack_inputs=[
-                ArgMapping(
+                StackArgMapping(
                     arg_name="a",
                     allowed_types=[
                         wtypes.uint64_wtype,
-                        int,
                     ],
                 ),
             ],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
         FunctionOpMapping(
             op_code="txna",
             is_property=False,
             immediates=[
                 "ClearStateProgramPages",
-                ArgMapping(
+                ImmediateArgMapping(
                     arg_name="a",
-                    allowed_types=[
-                        int,
-                    ],
+                    literal_type=int,
                 ),
             ],
             stack_inputs=[],
             stack_outputs=[
                 wtypes.bytes_wtype,
             ],
         ),
```

## puya/awst_build/intrinsic_models.py

```diff
@@ -1,43 +1,48 @@
 from collections.abc import Sequence
+from functools import cached_property
 
 import attrs
 
 from puya.awst import wtypes
 
 # used to map algopy/_gen.pyi stubs to awst
 # referenced by both scripts/generate_stubs.py and src/puya/awst_build/eb/intrinsics.py
 
 
-@attrs.define
-class ArgMapping:
+@attrs.frozen
+class StackArgMapping:
     arg_name: str
     """Name of algopy argument to obtain value from"""
-    allowed_types: Sequence[wtypes.WType | type] = attrs.field(factory=tuple)
-    """Valid types for this argument"""
+    allowed_types: Sequence[wtypes.WType] = attrs.field()
+    """Valid types for this argument, in descending priority for literal conversions"""
 
     @allowed_types.validator
-    def check(self, _attribute: object, value: Sequence[wtypes.WType | type]) -> None:
+    def check(self, _attribute: object, value: Sequence[wtypes.WType]) -> None:
         if wtypes.biguint_wtype in value and wtypes.uint64_wtype in value:
             raise ValueError("overlap in integral types")
 
-    def is_allowed_constant(self, constant: object) -> bool:
-        if type(constant) in self.allowed_types:
-            return True
-        for allowed_type in self.allowed_types:
-            if isinstance(allowed_type, wtypes.WType) and allowed_type.is_valid_literal(constant):
-                return True
-        return False
 
+@attrs.frozen
+class ImmediateArgMapping:
+    arg_name: str
+    """Name of algopy argument to obtain value from"""
+    literal_type: type[str | int]
+    """Literal type for the argument"""
 
-@attrs.define
+
+@attrs.frozen
 class FunctionOpMapping:
     op_code: str
     """TEAL op code for this mapping"""
-    immediates: Sequence[str | ArgMapping] = attrs.field(factory=tuple)
+    immediates: Sequence[str | ImmediateArgMapping] = attrs.field(factory=tuple)
     """A list of constant values or references to an algopy argument to include in immediate"""
-    stack_inputs: Sequence[ArgMapping] = attrs.field(factory=tuple)
+    stack_inputs: Sequence[StackArgMapping] = attrs.field(factory=tuple)
     """References to an algopy argument"""
     stack_outputs: Sequence[wtypes.WType] = attrs.field(factory=tuple)
     """Types output by TEAL op"""
     is_property: bool = False
     """Is this function represented as a property"""
+
+    @cached_property
+    def literal_arg_names(self) -> set[str]:
+        return {im.arg_name for im in self.immediates if not isinstance(im, str)}
```

## puya/awst_build/module.py

```diff
@@ -225,16 +225,17 @@
                 )
             # TODO: other checks above?
             else:
                 class_options = _process_contract_class_options(self.context, self, cdef)
                 return [lambda ctx: ContractASTConverter.convert(ctx, cdef, class_options)]
         else:
             self._error(
-                f"not a subclass of {constants.CONTRACT_BASE_ALIAS}"
-                f" or a direct subclass of {constants.STRUCT_BASE_ALIAS}",
+                f"Unsupported class declaration."
+                f" Contract classes must inherit either directly"
+                f" or indirectly from {constants.CONTRACT_BASE_ALIAS}.",
                 location=cdef,
             )
         return []
 
     def visit_operator_assignment_stmt(
         self, stmt: mypy.nodes.OperatorAssignmentStmt
     ) -> StatementResult:
@@ -654,15 +655,15 @@
         )
     ]
 
 
 def _process_arc4_struct(
     context: ASTConversionModuleContext, cdef: mypy.nodes.ClassDef
 ) -> StatementResult:
-    field_types = dict[str, wtypes.WType]()
+    field_types = dict[str, wtypes.ARC4Type]()
     field_decls = list[StructureField]()
     docstring = cdef.docstring
 
     has_error = False
     for stmt in cdef.defs.body:
         match stmt:
             case mypy.nodes.ExpressionStmt(expr=mypy.nodes.StrExpr()):
```

## puya/awst_build/subroutine.py

```diff
@@ -42,29 +42,29 @@
     SubroutineArgument,
     Switch,
     TupleExpression,
     VarExpression,
     WhileLoop,
 )
 from puya.awst.wtypes import WType
-from puya.awst_build import constants, intrinsic_data
+from puya.awst_build import constants
 from puya.awst_build.base_mypy_visitor import BaseMyPyVisitor
 from puya.awst_build.context import ASTConversionModuleContext
 from puya.awst_build.contract_data import AppStateDeclaration
 from puya.awst_build.eb.arc4 import (
+    ARC4BoolClassExpressionBuilder,
     ARC4ClientClassExpressionBuilder,
     ARC4StructClassExpressionBuilder,
 )
 from puya.awst_build.eb.base import (
     BuilderBinaryOp,
     BuilderComparisonOp,
     ExpressionBuilder,
     StateProxyDefinitionBuilder,
     StateProxyMemberBuilder,
-    TypeClassExpressionBuilder,
 )
 from puya.awst_build.eb.bool import BoolClassExpressionBuilder
 from puya.awst_build.eb.contracts import (
     ContractSelfExpressionBuilder,
     ContractTypeExpressionBuilder,
 )
 from puya.awst_build.eb.intrinsics import (
@@ -206,27 +206,25 @@
     @classmethod
     @typing.overload
     def convert(
         cls,
         context: ASTConversionModuleContext,
         func_def: mypy.nodes.FuncDef,
         source_location: SourceLocation,
-    ) -> Subroutine:
-        ...
+    ) -> Subroutine: ...
 
     @classmethod
     @typing.overload
     def convert(
         cls,
         context: ASTConversionModuleContext,
         func_def: mypy.nodes.FuncDef,
         source_location: SourceLocation,
         contract_method_info: ContractMethodInfo,
-    ) -> ContractMethod:
-        ...
+    ) -> ContractMethod: ...
 
     @classmethod
     def convert(
         cls,
         context: ASTConversionModuleContext,
         func_def: mypy.nodes.FuncDef,
         source_location: SourceLocation,
@@ -343,14 +341,19 @@
         lvalues: list[mypy.nodes.Expression],
         stmt_loc: SourceLocation,
     ) -> Sequence[Statement]:
         if self.contract_method_info is None:
             raise CodeError(
                 f"{rvalue.python_name} should only be used inside a contract class", stmt_loc
             )
+        if self.func_def.name != "__init__":
+            raise CodeError(
+                f"{rvalue.python_name} can only be used in the __init__ method",
+                stmt_loc,
+            )
         if len(lvalues) != 1:
             raise CodeError(
                 f"{rvalue.python_name} can only be assigned to a single member variable",
                 stmt_loc,
             )
         # note: we don't use resolve_lvalue here, because
         # these types shouldn't be a valid lvalue target in any other instance
@@ -466,23 +469,22 @@
     def visit_break_stmt(self, stmt: mypy.nodes.BreakStmt) -> BreakStatement:
         return BreakStatement(self._location(stmt))
 
     def visit_continue_stmt(self, stmt: mypy.nodes.ContinueStmt) -> ContinueStatement:
         return ContinueStatement(self._location(stmt))
 
     def visit_assert_stmt(self, stmt: mypy.nodes.AssertStmt) -> AssertStatement:
-        comment: str | None
-        match stmt.msg:
-            case mypy.nodes.StrExpr() as str_expr:
-                comment = str_expr.value
-            case None:
-                comment = None
-            case _:
-                self._error("only literal strings are supported as assertion messages", stmt)
-                comment = None
+        comment: str | None = None
+        if stmt.msg is not None:
+            msg = stmt.msg.accept(self)
+            match msg:
+                case Literal(value=str(comment)):
+                    pass
+                case _:
+                    self._error("only literal strings are supported as assertion messages", stmt)
         condition = self._eval_condition(stmt.expr)
         return AssertStatement(
             source_location=self._location(stmt),
             condition=condition,
             comment=comment,
         )
 
@@ -524,18 +526,21 @@
                     case_block_map[case_value] = case_block
                 case mypy.patterns.SingletonPattern(value=bool() as bool_literal), None:
                     case_value = BoolConstant(
                         value=bool_literal, source_location=self._location(pattern)
                     )
                     case_block = self.visit_block(block)
                     case_block_map[case_value] = case_block
-                case mypy.patterns.ClassPattern(
-                    positionals=[mypy.patterns.ValuePattern(expr=inner_literal_expr)],
-                    class_ref=mypy.nodes.RefExpr(fullname=fullname),
-                ), None if fullname in (
+                case (
+                    mypy.patterns.ClassPattern(
+                        positionals=[mypy.patterns.ValuePattern(expr=inner_literal_expr)],
+                        class_ref=mypy.nodes.RefExpr(fullname=fullname),
+                    ),
+                    None,
+                ) if fullname in (
                     constants.CLS_UINT64,
                     constants.CLS_BIGUINT,
                     constants.CLS_BYTES,
                     constants.CLS_STRING,
                     constants.CLS_ACCOUNT,
                 ):
                     case_value_builder_or_literal = inner_literal_expr.accept(self)
@@ -689,19 +694,17 @@
                     constant_value = self.context.constants[expr.fullname]
                 except KeyError as ex:
                     raise CodeError(
                         "Unable to resolve global constant reference", expr_loc
                     ) from ex
                 else:
                     return Literal(source_location=expr_loc, value=constant_value)
-            case (
-                mypy.nodes.NameExpr(
-                    kind=mypy.nodes.LDEF, node=mypy.nodes.Var(), name=var_name
-                ) as name_expr
-            ):
+            case mypy.nodes.NameExpr(
+                kind=mypy.nodes.LDEF, node=mypy.nodes.Var(), name=var_name
+            ) as name_expr:
                 self._precondition(
                     not name_expr.is_special_form,
                     "special form lvalues should only appear"
                     " as a singular lvalue in an assignment statement",
                     expr_loc,
                 )
                 if var_name == "_":
@@ -716,17 +719,17 @@
                 return var_expression(var_expr)
         scope = {
             mypy.nodes.LDEF: "local",
             mypy.nodes.MDEF: "member",
             mypy.nodes.GDEF: "global",
             None: "unknown",
         }.get(expr.kind)
-        raise InternalError(
-            f'Unable to resolve reference to "{fullname}" with scope "{scope}"'
-            f" (node = {expr.node})",
+        # this can happen in otherwise well-formed code that is just missing a reference
+        raise CodeError(
+            f"Unable to resolve reference to {fullname or expr.name!r}, {scope=}",
             expr_loc,
         )
 
     @staticmethod
     def _visit_ref_expr_of_builtins(
         fullname: str, location: SourceLocation
     ) -> ExpressionBuilder | Literal:
@@ -763,17 +766,17 @@
     ) -> ExpressionBuilder:
         if fullname.startswith(constants.ALGOPY_OP_PREFIX):
             if isinstance(node, mypy.nodes.TypeAlias):
                 t = mypy.types.get_proper_type(node.target)
                 if isinstance(t, mypy.types.Instance):
                     node = t.type
             match node:
-                case mypy.nodes.TypeInfo() if fullname in intrinsic_data.ENUM_CLASSES:
-                    return IntrinsicEnumClassExpressionBuilder(fullname, location=location)
                 case mypy.nodes.TypeInfo() as type_info:
+                    if type_info.has_base("builtins.str"):
+                        return IntrinsicEnumClassExpressionBuilder(type_info, location=location)
                     return IntrinsicNamespaceClassExpressionBuilder(type_info, location=location)
                 case mypy.nodes.FuncDef() as func_def:
                     return IntrinsicFunctionExpressionBuilder(func_def, location=location)
                 case _:
                     raise InternalError(f"Unhandled algopy name: {fullname}", location)
         if (
             fullname in (constants.CLS_LOCAL_STATE, constants.CLS_GLOBAL_STATE)
@@ -793,15 +796,15 @@
     ) -> ExpressionBuilder | Literal:
         match mypy_type:
             case mypy.types.Instance() as instance:
                 fullname = instance.type.fullname
                 if fullname.startswith("builtins."):
                     return self._visit_ref_expr_of_builtins(fullname, location)
                 if fullname.startswith(constants.ALGOPY_PREFIX):
-                    return self._visit_ref_expr_of_algopy(fullname, location, None)
+                    return get_type_builder(fullname, location)
                 raise InternalError("Cannot handle instance of this type: " + fullname)
             case mypy.types.LiteralType(value=literal_value):
                 if isinstance(literal_value, float):
                     raise CodeError("Float literals are not supported", location)
                 return Literal(value=literal_value, source_location=location)
             case mypy.types.TypeAliasType() as ta:
                 typ = mypy.types.get_proper_type(ta)
@@ -830,18 +833,15 @@
 
     def visit_call_expr(self, call: mypy.nodes.CallExpr) -> ExpressionBuilder | Literal:
         if call.analyzed is not None:
             return self._visit_special_call_expr(call, analyzed=call.analyzed)
 
         callee = call.callee.accept(self)
         callee_builder = require_expression_builder(callee)
-        if (
-            isinstance(callee_builder, TypeClassExpressionBuilder)
-            and callee_builder.produces() == wtypes.bool_wtype
-        ):
+        if isinstance(callee_builder, BoolClassExpressionBuilder | ARC4BoolClassExpressionBuilder):
             args_context: typing.Any = self._enter_bool_context
         else:
             args_context = contextlib.nullcontext
         with args_context():
             args = [arg.accept(self) for arg in call.args]
         return callee_builder.call(
             args=args,
@@ -1071,18 +1071,14 @@
         #   a < b < c
         # becomes:
         #   (a < (tmp := b)) AND (tmp < c)
         # TODO: what about comparing different types that can never be equal? according to Python
         #       type signatures that should be possible, and we can always know it's value at
         #       compile time, but it would always result in a constant ...
 
-        expr_wtype = self.context.mypy_expr_node_type(expr)
-        if expr_wtype is not wtypes.bool_wtype:
-            raise CodeError("Result of comparison must be a boolean type", expr_loc)
-
         operands = [o.accept(self) for o in expr.operands]
         operands[1:-1] = [temporary_assignment_if_required(operand) for operand in operands[1:-1]]
 
         comparisons = [
             self._build_compare(operator=operator, lhs=lhs, rhs=rhs)
             for operator, lhs, rhs in zip(expr.operators, operands, operands[1:], strict=False)
         ]
@@ -1124,15 +1120,15 @@
         if isinstance(lhs, ExpressionBuilder):
             op = BuilderComparisonOp(operator)
             result = lhs.compare(other=rhs, op=op, location=cmp_loc)
         if result is NotImplemented and isinstance(rhs, ExpressionBuilder):
             op = BuilderComparisonOp(invert_ordered_binary_op(operator))
             result = rhs.compare(other=lhs, op=op, location=cmp_loc)
         if result is NotImplemented:
-            raise CodeError(f"Unsupported comparison {operator} between types", cmp_loc)
+            raise CodeError(f"Unsupported comparison {operator!r} between types", cmp_loc)
         return result.rvalue()
 
     def visit_int_expr(self, expr: mypy.nodes.IntExpr) -> Literal:
         return Literal(self._location(expr), value=expr.value)
 
     def visit_str_expr(self, expr: mypy.nodes.StrExpr) -> Literal:
         return Literal(self._location(expr), value=expr.value)
@@ -1231,28 +1227,25 @@
         raise CodeError("ellipsis expressions are not supported", self._location(expr))
 
     def visit_list_expr(self, expr: mypy.nodes.ListExpr) -> ExpressionBuilder:
         raise CodeError("Python lists are not supported", self._location(expr))
 
 
 @typing.overload
-def temporary_assignment_if_required(operand: Literal) -> Literal:
-    ...
+def temporary_assignment_if_required(operand: Literal) -> Literal: ...
 
 
 @typing.overload
-def temporary_assignment_if_required(operand: Expression) -> ExpressionBuilder:
-    ...
+def temporary_assignment_if_required(operand: Expression) -> ExpressionBuilder: ...
 
 
 @typing.overload
 def temporary_assignment_if_required(
     operand: ExpressionBuilder,
-) -> ExpressionBuilder:
-    ...
+) -> ExpressionBuilder: ...
 
 
 def temporary_assignment_if_required(
     operand: ExpressionBuilder | Expression | Literal,
 ) -> ExpressionBuilder | Literal:
     if isinstance(operand, Literal):
         return operand
```

## puya/awst_build/utils.py

```diff
@@ -180,23 +180,21 @@
     else:
         return convert_literal(literal_or_expr, target_wtype)
 
 
 @typing.overload
 def convert_literal(
     literal_or_expr: Literal | Expression, target_wtype: wtypes.WType
-) -> Expression:
-    ...
+) -> Expression: ...
 
 
 @typing.overload
 def convert_literal(
     literal_or_expr: ExpressionBuilder, target_wtype: wtypes.WType
-) -> ExpressionBuilder:
-    ...
+) -> ExpressionBuilder: ...
 
 
 def convert_literal(
     literal_or_expr: Literal | Expression | ExpressionBuilder, target_wtype: wtypes.WType
 ) -> Expression | ExpressionBuilder:
     if not isinstance(literal_or_expr, Literal):
         return literal_or_expr
@@ -294,22 +292,28 @@
 
 def get_arg_mapping(
     positional_arg_names: Sequence[str],
     args: Iterable[tuple[str | None, T]],
     location: SourceLocation,
 ) -> dict[str, T]:
     arg_mapping = dict[str, T]()
+    has_too_many_error = False
     for arg_idx, (supplied_arg_name, arg) in enumerate(args):
         if supplied_arg_name is not None:
             arg_name = supplied_arg_name
         else:
             try:
                 arg_name = positional_arg_names[arg_idx]
-            except IndexError as ex:
-                raise CodeError("Too many positional arguments", location) from ex
+            except IndexError:
+                if not has_too_many_error:
+                    logger.error(  # noqa: TRY400
+                        "Too many positional arguments", location=location
+                    )
+                    has_too_many_error = True
+                continue
         arg_mapping[arg_name] = arg
     return arg_mapping
 
 
 def snake_case(s: str) -> str:
     s = s.replace("-", " ")
     s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", s)
```

## puya/awst_build/validation/arc4_copy.py

```diff
@@ -13,118 +13,118 @@
 class ARC4CopyValidator(AWSTTraverser):
     @classmethod
     def validate(cls, module: awst_nodes.Module) -> None:
         validator = cls()
         for module_statement in module.body:
             module_statement.accept(validator)
 
+    def __init__(self) -> None:
+        super().__init__()
+        self._for_items: awst_nodes.Lvalue | None = None
+
     def visit_assignment_statement(self, statement: awst_nodes.AssignmentStatement) -> None:
-        self._check_for_arc4_tuple_destructure(statement.target, statement.value)
+        _check_assignment(statement.target, statement.value)
         statement.value.accept(self)
-        self._check_for_arc4_copy(statement.value, "being assigned to another variable")
 
     def visit_tuple_expression(self, expr: awst_nodes.TupleExpression) -> None:
         super().visit_tuple_expression(expr)
-        for item in expr.items:
-            self._check_for_arc4_copy(item, "being passed to a tuple expression")
-
-    @staticmethod
-    def _is_referable_expression(expr: awst_nodes.Expression) -> bool:
-        """
-        Returns True if expr represents something that can be referenced multiple times.
-        """
-        match expr:
-            case (
-                awst_nodes.VarExpression()
-                | awst_nodes.AppStateExpression()
-                | awst_nodes.AppAccountStateExpression()
-            ):
-                return True
-        return False
-
-    @staticmethod
-    def _is_arc4_mutable(wtype: wtypes.WType) -> bool:
-        """
-        Returns True if expr represents an arc4 type that is mutable
-        """
-        match wtype:
-            case wtypes.ARC4Type(immutable=False):
-                return True
-        return False
-
-    def _check_for_arc4_tuple_destructure(
-        self, target: awst_nodes.Expression, value: awst_nodes.Expression
-    ) -> None:
-        if not isinstance(target, awst_nodes.TupleExpression):
-            return
-        match value.wtype:
-            case wtypes.WTuple(types=item_types):
-                if self._is_referable_expression(value):
-                    problem_type = next((i for i in item_types if self._is_arc4_mutable(i)), None)
-                    if problem_type:
-                        logger.error(
-                            f"Tuple cannot be destructured as it contains an item of type"
-                            f" {problem_type} which requires copying. Use index access instead",
-                            location=value.source_location,
-                        )
-
-    def _check_for_arc4_copy(self, expr: awst_nodes.Expression, context_desc: str) -> None:
-        if self._is_arc4_mutable(expr.wtype):
-            match expr:
-                case (
-                    awst_nodes.ARC4ArrayEncode()
-                    | awst_nodes.ARC4Encode()
-                    | awst_nodes.Copy()
-                    | awst_nodes.ArrayConcat()
-                    | awst_nodes.SubroutineCallExpression()
-                    | awst_nodes.ReinterpretCast()
-                ):
-                    return
-
-            logger.error(
-                f"{expr.wtype} must be copied using .copy() when {context_desc}",
-                location=expr.source_location,
-            )
-
-    @staticmethod
-    def _expand_tuple_items(expr: awst_nodes.Expression) -> Iterator[awst_nodes.Expression]:
-        match expr:
-            case awst_nodes.TupleExpression(items=items):
-                yield from items
-            case _:
-                yield expr
+        if expr is not self._for_items:
+            for item in expr.items:
+                _check_for_arc4_copy(item, "being passed to a tuple expression")
 
     def visit_for_in_loop(self, statement: awst_nodes.ForInLoop) -> None:
-        if not isinstance(statement.sequence, awst_nodes.Range):
-            statement.sequence.accept(self)
-        statement.loop_body.accept(self)
+        self._for_items = statement.items
+        super().visit_for_in_loop(statement)
+        self._for_items = None
 
     def visit_assignment_expression(self, expr: awst_nodes.AssignmentExpression) -> None:
-        self._check_for_arc4_tuple_destructure(expr.target, expr.value)
-
+        _check_assignment(expr.target, expr.value)
         expr.value.accept(self)
-        self._check_for_arc4_copy(expr.value, "being assigned to another variable")
 
     def visit_subroutine_call_expression(self, expr: awst_nodes.SubroutineCallExpression) -> None:
         super().visit_subroutine_call_expression(expr)
         for arg in expr.args:
             match arg.value:
                 case awst_nodes.VarExpression():
                     # Var expressions don't need copy as we implicitly return the latest value and
                     # update the var
                     continue
-                case (awst_nodes.AppStateExpression() | awst_nodes.AppAccountStateExpression()):
+                case awst_nodes.AppStateExpression() | awst_nodes.AppAccountStateExpression():
                     message = "being passed to a subroutine from state"
                 case _:
                     message = "being passed to a subroutine"
-            self._check_for_arc4_copy(arg.value, message)
+            _check_for_arc4_copy(arg.value, message)
 
-    def visit_arc4_array_encode(self, expr: awst_nodes.ARC4ArrayEncode) -> None:
-        super().visit_arc4_array_encode(expr)
-        for v in expr.values:
-            self._check_for_arc4_copy(v, "being passed to an array constructor")
+    def visit_new_array(self, expr: awst_nodes.NewArray) -> None:
+        super().visit_new_array(expr)
+        if isinstance(expr.wtype, wtypes.ARC4Array):
+            for v in expr.values:
+                _check_for_arc4_copy(v, "being passed to an array constructor")
 
     def visit_arc4_encode(self, expr: awst_nodes.ARC4Encode) -> None:
         super().visit_arc4_encode(expr)
 
-        for item in self._expand_tuple_items(expr.value):
-            self._check_for_arc4_copy(item, "being passed to a constructor")
+        for item in _expand_tuple_items(expr.value):
+            _check_for_arc4_copy(item, "being passed to a constructor")
+
+
+def _is_referable_expression(expr: awst_nodes.Expression) -> bool:
+    """
+    Returns True if expr represents something that can be referenced multiple times.
+    """
+    match expr:
+        case (
+            awst_nodes.VarExpression()
+            | awst_nodes.AppStateExpression()
+            | awst_nodes.AppAccountStateExpression()
+            | awst_nodes.StateGet()
+            | awst_nodes.StateGetEx()
+        ):
+            return True
+        case (
+            awst_nodes.IndexExpression(base=base_expr)
+            | awst_nodes.TupleItemExpression(base=base_expr)
+            | awst_nodes.FieldExpression(base=base_expr)
+        ):
+            return _is_referable_expression(base_expr)
+    return False
+
+
+def _check_assignment(target: awst_nodes.Expression, value: awst_nodes.Expression) -> None:
+    if not isinstance(target, awst_nodes.TupleExpression):
+        _check_for_arc4_copy(value, "being assigned to another variable")
+    elif _is_referable_expression(value):
+        problem_type = next((i for i in target.wtype.types if _is_arc4_mutable(i)), None)
+        if problem_type:
+            logger.error(
+                f"Tuple cannot be destructured as it contains an item of type"
+                f" {problem_type} which requires copying. Use index access instead",
+                location=value.source_location,
+            )
+
+
+def _check_for_arc4_copy(expr: awst_nodes.Expression, context_desc: str) -> None:
+    if _is_arc4_mutable(expr.wtype) and _is_referable_expression(expr):
+        logger.error(
+            f"{expr.wtype} must be copied using .copy() when {context_desc}",
+            location=expr.source_location,
+        )
+
+
+def _expand_tuple_items(expr: awst_nodes.Expression) -> Iterator[awst_nodes.Expression]:
+    match expr:
+        case awst_nodes.TupleExpression(items=items):
+            yield from items
+        case _:
+            yield expr
+
+
+def _is_arc4_mutable(wtype: wtypes.WType) -> bool:
+    """
+    Returns True if expr represents an arc4 type that is mutable
+    """
+    match wtype:
+        case wtypes.ARC4Type(immutable=False):
+            return True
+        case wtypes.WTuple(types=types):
+            return any(_is_arc4_mutable(t) for t in types)
+    return False
```

## puya/awst_build/validation/inner_transactions.py

```diff
@@ -85,21 +85,21 @@
     ) -> None:
         value = stmt.value
         match value:
             case awst_nodes.CreateInnerTransaction() | awst_nodes.Copy():
                 self._check_itxn_params_not_submitted_in_loop(stmt.target)
             case awst_nodes.VarExpression(
                 name=var_name, wtype=wtype
-            ) if wtypes.is_inner_transaction_params_type(wtype):
+            ) if wtypes.is_inner_transaction_field_type(wtype):
                 logger.error(
                     f"{value.wtype} must be copied using .copy() when "
                     f"assigning to a new local: {var_name}",
                     location=value.source_location,
                 )
-            case awst_nodes.Expression(wtype=wtype) if wtypes.is_inner_transaction_params_type(
+            case awst_nodes.Expression(wtype=wtype) if wtypes.is_inner_transaction_field_type(
                 wtype
             ):
                 logger.error(
                     f"{value.wtype} cannot be aliased",
                     location=value.source_location,
                 )
 
@@ -112,34 +112,183 @@
             logger.error(
                 f"'{expr.name}' cannot be modified after submission while in a loop ",
                 location=expr.source_location,
             )
 
     def _check_inner_transaction_assignment(self, stmt: awst_nodes.AssignmentStatement) -> None:
         match stmt.value:
-            case awst_nodes.SubmitInnerTransaction() as submit:
-                match stmt.target:
-                    case awst_nodes.VarExpression() if len(submit.itxns) > 1:
-                        pass
-                    case awst_nodes.TupleExpression(items=items) if len(items) != len(
-                        submit.itxns
+            case awst_nodes.SubmitInnerTransaction():
+                return
+            case awst_nodes.TupleExpression(items=items) if (
+                len([item for item in items if wtypes.is_inner_transaction_type(item.wtype)]) == 1
+            ):
+                return
+            case awst_nodes.Expression(wtype=wtype) if not wtypes.is_inner_transaction_type(wtype):
+                return
+        logger.error(
+            f"{stmt.value.wtype} cannot be reassigned",
+            location=stmt.value.source_location,
+        )
+
+    def visit_assignment_expression(self, expr: awst_nodes.AssignmentExpression) -> None:
+        super().visit_assignment_expression(expr)
+        if _is_itxn_wtype(expr.wtype):
+            logger.error(
+                f"{expr.wtype} cannot be used in assignment expressions",
+                location=expr.source_location,
+            )
+
+    def visit_subroutine_call_expression(self, expr: awst_nodes.SubroutineCallExpression) -> None:
+        super().visit_subroutine_call_expression(expr)
+        for arg in expr.args:
+            arg_wtype = arg.value.wtype
+            if _is_itxn_wtype(arg_wtype) or wtypes.is_inner_transaction_tuple_type(arg_wtype):
+                logger.error(
+                    f"{arg.value.wtype} cannot be passed to a subroutine",
+                    location=expr.source_location,
+                )
+
+    def _check_method_types(
+        self,
+        args: Sequence[awst_nodes.SubroutineArgument],
+        return_type: wtypes.WType,
+        return_loc: SourceLocation,
+    ) -> None:
+        for arg in args:
+            if _is_itxn_wtype(arg.wtype):
+                logger.error(
+                    f"{arg.wtype} cannot be used as a subroutine argument type: {arg.name}",
+                    location=arg.source_location,
+                )
+        if _is_itxn_wtype(return_type):
+            logger.error(
+                f"{return_type} cannot be used as a subroutine return type",
+                location=return_loc,
+            )
+
+
+class InnerTransactionFieldsValidator(AWSTTraverser):
+    """
+    Validates that inner transaction fields are only used in the ways currently
+    supported. Emits errors for:
+
+    Reassigning inner transaction fields without a copy()
+    Modifying inner transaction fields after submission while in a loop
+    Using inner transactions fields in a subroutine
+    """
+
+    @classmethod
+    def validate(cls, module: awst_nodes.Module) -> None:
+        for module_statement in module.body:
+            validator = cls()
+            module_statement.accept(validator)
+
+    def __init__(self) -> None:
+        super().__init__()
+        self._current_itxn_var_stack = list[list[str]]()
+
+    @property
+    def _current_loop_itxn_vars(self) -> list[str] | None:
+        return self._current_itxn_var_stack[-1] if self._current_itxn_var_stack else None
+
+    def visit_contract_method(self, statement: awst_nodes.ContractMethod) -> None:
+        self._check_method_types(statement.args, statement.return_type, statement.source_location)
+        super().visit_contract_method(statement)
+
+    def visit_subroutine(self, statement: awst_nodes.Subroutine) -> None:
+        self._check_method_types(statement.args, statement.return_type, statement.source_location)
+        super().visit_subroutine(statement)
+
+    def visit_assignment_statement(self, statement: awst_nodes.AssignmentStatement) -> None:
+        self._check_inner_transaction_params_assignment(statement)
+        super().visit_assignment_statement(statement)
+
+    def visit_for_in_loop(self, statement: awst_nodes.ForInLoop) -> None:
+        with self._enter_loop():
+            super().visit_for_in_loop(statement)
+
+    def visit_while_loop(self, statement: awst_nodes.WhileLoop) -> None:
+        with self._enter_loop():
+            super().visit_while_loop(statement)
+
+    def visit_submit_inner_transaction(self, call: awst_nodes.SubmitInnerTransaction) -> None:
+        if self._current_loop_itxn_vars is not None:
+            for itxn_params in call.itxns:
+                match itxn_params:
+                    case awst_nodes.TupleItemExpression(
+                        base=awst_nodes.VarExpression(name=var_name)
                     ):
-                        pass
-                    case _:
-                        return
+                        self._current_loop_itxn_vars.append(var_name)
+                    case awst_nodes.VarExpression(name=var_name):
+                        self._current_loop_itxn_vars.append(var_name)
+        super().visit_submit_inner_transaction(call)
+
+    def visit_update_inner_transaction(self, call: awst_nodes.UpdateInnerTransaction) -> None:
+        super().visit_update_inner_transaction(call)
+        self._check_itxn_params_not_submitted_in_loop(call.itxn)
+
+    @contextlib.contextmanager
+    def _enter_loop(self) -> Iterator[None]:
+        try:
+            self._current_itxn_var_stack.append(
+                self._current_loop_itxn_vars.copy() if self._current_loop_itxn_vars else []
+            )
+            yield
+        finally:
+            self._current_itxn_var_stack.pop()
+
+    def _check_inner_transaction_params_assignment(
+        self, stmt: awst_nodes.AssignmentStatement
+    ) -> None:
+        value = stmt.value
+        match value:
+            case awst_nodes.CreateInnerTransaction() | awst_nodes.Copy():
+                self._check_itxn_params_not_submitted_in_loop(stmt.target)
+            case awst_nodes.VarExpression(wtype=wtype) | awst_nodes.TupleItemExpression(
+                wtype=wtype
+            ) if wtypes.is_inner_transaction_field_type(wtype):
                 logger.error(
-                    f"Inner Transactions cannot be part of an unpacked tuple: {stmt.value.wtype}",
-                    location=stmt.value.source_location,
+                    f"{value.wtype} must be copied using .copy() when "
+                    f"assigning to a new local",
+                    location=value.source_location,
                 )
-            case awst_nodes.Expression(wtype=wtype) if wtypes.is_inner_transaction_type(wtype):
+            case awst_nodes.Expression(wtype=wtype) if (
+                wtypes.is_inner_transaction_field_type(wtype)
+            ):
                 logger.error(
-                    f"{stmt.value.wtype} cannot be reassigned",
-                    location=stmt.value.source_location,
+                    f"{value.wtype} can only be assigned to local variables",
+                    location=value.source_location,
                 )
 
+    def _check_itxn_params_not_submitted_in_loop(self, expr: awst_nodes.Expression) -> None:
+        if (
+            self._current_loop_itxn_vars
+            and isinstance(expr, awst_nodes.VarExpression)
+            and expr.name in self._current_loop_itxn_vars
+        ):
+            logger.error(
+                f"'{expr.name}' cannot be modified after submission while in a loop ",
+                location=expr.source_location,
+            )
+
+    def _check_inner_transaction_assignment(self, stmt: awst_nodes.AssignmentStatement) -> None:
+        match stmt.value:
+            case awst_nodes.SubmitInnerTransaction():
+                return
+            case awst_nodes.TupleExpression(items=items) if (
+                len([item for item in items if wtypes.is_inner_transaction_type(item.wtype)]) == 1
+            ):
+                return
+            case awst_nodes.Expression(wtype=wtype) if not wtypes.is_inner_transaction_type(wtype):
+                return
+        logger.error(
+            f"{stmt.value.wtype} cannot be reassigned",
+            location=stmt.value.source_location,
+        )
+
     def visit_assignment_expression(self, expr: awst_nodes.AssignmentExpression) -> None:
         super().visit_assignment_expression(expr)
         if _is_itxn_wtype(expr.wtype):
             logger.error(
                 f"{expr.wtype} cannot be used in assignment expressions",
                 location=expr.source_location,
             )
@@ -170,10 +319,90 @@
             logger.error(
                 f"{return_type} cannot be used as a subroutine return type",
                 location=return_loc,
             )
 
 
 def _is_itxn_wtype(wtype: wtypes.WType) -> bool:
-    return wtypes.is_inner_transaction_params_type(wtype) or wtypes.is_inner_transaction_type(
-        wtype
-    )
+    return wtypes.is_inner_transaction_field_type(wtype) or wtypes.is_inner_transaction_type(wtype)
+
+
+class StaleInnerTransactionsValidator(AWSTTraverser):
+    """Validates that inner transaction array access are not stale"""
+
+    @classmethod
+    def validate(cls, module: awst_nodes.Module) -> None:
+        for module_statement in module.body:
+            validator = cls()
+            module_statement.accept(validator)
+
+    def __init__(self) -> None:
+        super().__init__()
+        self._maybe_stale_itxn_vars = dict[str, SourceLocation]()
+        self._active_itxn_vars = list[str]()
+
+    def visit_assignment_statement(self, stmt: awst_nodes.AssignmentStatement) -> None:
+        super().visit_assignment_statement(stmt)
+        match stmt.value:
+            case awst_nodes.SubmitInnerTransaction():
+                new_itxn_var_names = self._get_var_names(stmt.target)
+                self._update_active_var_names(new_itxn_var_names)
+            case awst_nodes.TupleExpression(items=items) if any(
+                wtypes.is_inner_transaction_type(item.wtype) for item in items
+            ):
+                var_names = self._get_var_names(stmt.target)
+                self._update_active_var_names(var_names)
+
+    def visit_intrinsic_call(self, call: awst_nodes.IntrinsicCall) -> None:
+        super().visit_intrinsic_call(call)
+        if call.op_code == "itxn_submit":
+            self._update_maybe_stale_itxn_vars(call.source_location)
+
+    def visit_submit_inner_transaction(self, call: awst_nodes.SubmitInnerTransaction) -> None:
+        super().visit_submit_inner_transaction(call)
+        self._update_maybe_stale_itxn_vars(call.source_location)
+
+    def visit_inner_transaction_field(self, itxn_field: awst_nodes.InnerTransactionField) -> None:
+        super().visit_inner_transaction_field(itxn_field)
+        match itxn_field.itxn:
+            case awst_nodes.VarExpression(name=var_name):
+                pass
+            case awst_nodes.TupleItemExpression(base=awst_nodes.VarExpression(name=var_name)):
+                pass
+            case _:
+                return
+        if itxn_field.field.is_array and var_name in self._maybe_stale_itxn_vars:
+            logger.error(
+                f"Inner Transaction referred to by {var_name!r} may no longer be valid due"
+                " to other inner transaction submissions, or subroutine calls."
+                " This means array field access may not give expected results,"
+                f" move array field access after {var_name!r} definition and before expression"
+                f" indicated.",
+                location=itxn_field.itxn.source_location,
+            )
+            var_name_loc = self._maybe_stale_itxn_vars[var_name]
+            logger.warning(f"{var_name!r} becomes potentially stale here", location=var_name_loc)
+
+    def visit_subroutine_call_expression(self, expr: awst_nodes.SubroutineCallExpression) -> None:
+        super().visit_subroutine_call_expression(expr)
+        self._update_maybe_stale_itxn_vars(expr.source_location)
+
+    def _get_var_names(self, expr: awst_nodes.Expression) -> list[str]:
+        match expr:
+            case awst_nodes.VarExpression(name=name):
+                return [name]
+            case awst_nodes.TupleExpression(items=items):
+                return [self._get_var_names(item)[0] for item in items]
+            case _:
+                return []
+
+    def _update_active_var_names(self, var_names: list[str]) -> None:
+        self._active_itxn_vars = var_names
+        # if a var_name is reassigned then it is not considered stale
+        for var_name in self._active_itxn_vars:
+            with contextlib.suppress(KeyError):
+                del self._maybe_stale_itxn_vars[var_name]
+
+    def _update_maybe_stale_itxn_vars(self, staling_expr_loc: SourceLocation) -> None:
+        for stale_var_name in self._active_itxn_vars:
+            self._maybe_stale_itxn_vars[stale_var_name] = staling_expr_loc
+        self._active_itxn_vars = []
```

## puya/awst_build/validation/main.py

```diff
@@ -1,12 +1,16 @@
 from puya.awst import nodes as awst_nodes
 from puya.awst_build.validation.arc4_copy import ARC4CopyValidator
 from puya.awst_build.validation.base_invoker import BaseInvokerValidator
-from puya.awst_build.validation.inner_transactions import InnerTransactionsValidator
+from puya.awst_build.validation.inner_transactions import (
+    InnerTransactionsValidator,
+    StaleInnerTransactionsValidator,
+)
 from puya.awst_build.validation.scratch_slots import ScratchSlotReservationValidator
 
 
 def validate_awst(module: awst_nodes.Module) -> None:
     ARC4CopyValidator.validate(module)
     ScratchSlotReservationValidator.validate(module)
     InnerTransactionsValidator.validate(module)
+    StaleInnerTransactionsValidator.validate(module)
     BaseInvokerValidator.validate(module)
```

## puya/compile.py

```diff
@@ -16,15 +16,15 @@
 import mypy.util
 from packaging import version
 
 from puya import log
 from puya.arc32 import create_arc32_json, write_arc32_client
 from puya.awst_build.main import transform_ast
 from puya.context import CompileContext
-from puya.errors import CodeError, InternalError, log_exceptions
+from puya.errors import InternalError, log_exceptions
 from puya.ir.main import build_module_irs, optimize_and_destructure_ir
 from puya.ir.models import (
     Contract as ContractIR,
     LogicSignature,
     ModuleArtifact,
 )
 from puya.mir.main import program_ir_to_mir
@@ -34,31 +34,35 @@
     TYPESHED_PATH,
     ParseSource,
     parse_and_typecheck,
 )
 from puya.teal.main import mir_to_teal
 from puya.utils import determine_out_dir, make_path_relative_to_cwd
 
-MAX_SUPPORTED_ALGOPY_VERSION = version.parse("1.0.1")
-MIN_SUPPORTED_ALGOPY_VERSION = version.parse(f"{MAX_SUPPORTED_ALGOPY_VERSION.major}.0.0")
+# this should contain the lowest version number that this compiler does NOT support
+# i.e. the next minor version after what is defined in stubs/pyproject.toml:tool.poetry.version
+MAX_SUPPORTED_ALGOPY_VERSION_EX = version.parse("1.2.0")
+MIN_SUPPORTED_ALGOPY_VERSION = version.parse(f"{MAX_SUPPORTED_ALGOPY_VERSION_EX.major}.0.0")
 
 logger = log.get_logger(__name__)
 
 
 def compile_to_teal(puya_options: PuyaOptions) -> None:
     """Drive the actual core compilation step."""
     with log.logging_context() as log_ctx, log_exceptions():
         logger.debug(puya_options)
         context = parse_with_mypy(puya_options)
         log_ctx.exit_if_errors()
         awst = transform_ast(context)
         log_ctx.exit_if_errors()
         module_irs = build_module_irs(context, awst)
         log_ctx.exit_if_errors()
-        compiled_contracts_by_source_path = module_irs_to_teal(context, module_irs)
+        module_irs_destructured = optimize_and_destructure_module_irs(context, module_irs)
+        log_ctx.exit_if_errors()
+        compiled_contracts_by_source_path = module_irs_to_teal(context, module_irs_destructured)
         log_ctx.exit_if_errors()
         write_artifacts(context, compiled_contracts_by_source_path)
     log_ctx.exit_if_errors()
 
 
 def parse_with_mypy(puya_options: PuyaOptions) -> CompileContext:
     mypy_options = get_mypy_options()
@@ -116,20 +120,19 @@
     mypy_opts.disallow_any_explicit = True
 
     mypy_opts.pretty = True  # show source in output
 
     return mypy_opts
 
 
-def module_irs_to_teal(
+def optimize_and_destructure_module_irs(
     context: CompileContext, module_irs: dict[str, list[ModuleArtifact]]
-) -> dict[ParseSource, list[CompilationArtifact]]:
-    result = dict[ParseSource, list[CompilationArtifact]]()
-    # used to check for conflicts that would occur on output
-    artifacts_by_output_base = dict[Path, ModuleArtifact]()
+) -> dict[ParseSource, list[ModuleArtifact]]:
+    result = dict[ParseSource, list[ModuleArtifact]]()
+
     for src in context.parse_result.sources:
         module_ir = module_irs.get(src.module_name)
         if module_ir is None:
             raise InternalError(f"Could not find IR for {src.path}")
 
         if not module_ir:
             if src.is_explicit:
@@ -138,39 +141,53 @@
                     f" {make_path_relative_to_cwd(src.path)}"
                 )
         else:
             for artifact_ir in module_ir:
                 out_dir = determine_out_dir(src.path.parent, context.options)
                 name = artifact_ir.metadata.name
                 artifact_ir_base_path = out_dir / name
-                if existing := artifacts_by_output_base.get(artifact_ir_base_path):
-                    logger.error(
-                        f"Duplicate contract name {name}", location=artifact_ir.source_location
-                    )
-                    logger.info(
-                        f"Contract name {name} first seen here", location=existing.source_location
-                    )
-                else:
-                    artifacts_by_output_base[artifact_ir_base_path] = artifact_ir
-
                 artifact_ir = optimize_and_destructure_ir(
                     context, artifact_ir, artifact_ir_base_path
                 )
 
-                match artifact_ir:
-                    case ContractIR() as contract:
-                        compiled: CompilationArtifact = _contract_ir_to_teal(
-                            context, contract, artifact_ir_base_path
-                        )
-                    case LogicSignature() as logic_sig:
-                        compiled = _logic_sig_to_teal(context, logic_sig, artifact_ir_base_path)
-                    case _:
-                        typing.assert_never(artifact_ir)
+                result.setdefault(src, []).append(artifact_ir)
+    return result
+
 
-                result.setdefault(src, []).append(compiled)
+def module_irs_to_teal(
+    context: CompileContext, module_irs: dict[ParseSource, list[ModuleArtifact]]
+) -> dict[ParseSource, list[CompilationArtifact]]:
+    result = dict[ParseSource, list[CompilationArtifact]]()
+    # used to check for conflicts that would occur on output
+    artifacts_by_output_base = dict[Path, ModuleArtifact]()
+    for src, artifact_irs in module_irs.items():
+        for artifact_ir in artifact_irs:
+            out_dir = determine_out_dir(src.path.parent, context.options)
+            name = artifact_ir.metadata.name
+            artifact_ir_base_path = out_dir / name
+            if existing := artifacts_by_output_base.get(artifact_ir_base_path):
+                logger.error(
+                    f"Duplicate contract name {name}", location=artifact_ir.source_location
+                )
+                logger.info(
+                    f"Contract name {name} first seen here", location=existing.source_location
+                )
+            else:
+                artifacts_by_output_base[artifact_ir_base_path] = artifact_ir
+            match artifact_ir:
+                case ContractIR() as contract:
+                    compiled: CompilationArtifact = _contract_ir_to_teal(
+                        context, contract, artifact_ir_base_path
+                    )
+                case LogicSignature() as logic_sig:
+                    compiled = _logic_sig_to_teal(context, logic_sig, artifact_ir_base_path)
+                case _:
+                    typing.assert_never(artifact_ir)
+
+            result.setdefault(src, []).append(compiled)
     return result
 
 
 def _get_python_executable() -> str | None:
     prefix = _get_prefix()
     if not prefix:
         logger.warning("Could not determine python prefix or algopy version")
@@ -219,28 +236,36 @@
             check=False,
         )
         if prefix_result.returncode == 0 and (maybe_prefix := prefix_result.stdout.strip()):
             return maybe_prefix
     return None
 
 
+_STUBS_PACKAGE_NAME = "algorand-python"
+
+
 def _check_algopy_version(site_packages: Path) -> None:
-    pkgs = metadata.Distribution.discover(name="algorand-python", path=[str(site_packages)])
+    pkgs = metadata.Distribution.discover(name=_STUBS_PACKAGE_NAME, path=[str(site_packages)])
     try:
         (algopy,) = pkgs
     except ValueError:
         logger.warning("Could not determine algopy version")
         return
     algopy_version = version.parse(algopy.version)
     logger.debug(f"Found algopy: {algopy_version}")
 
-    if not (MIN_SUPPORTED_ALGOPY_VERSION <= algopy_version <= MAX_SUPPORTED_ALGOPY_VERSION):
-        raise CodeError(
-            f"algopy version {algopy_version} is outside the supported range:"
-            f" >={MIN_SUPPORTED_ALGOPY_VERSION}, <={MAX_SUPPORTED_ALGOPY_VERSION}"
+    if not (MIN_SUPPORTED_ALGOPY_VERSION <= algopy_version < MAX_SUPPORTED_ALGOPY_VERSION_EX):
+        logger.warning(
+            f"{_STUBS_PACKAGE_NAME} version {algopy_version} is outside the supported range:"
+            f" >={MIN_SUPPORTED_ALGOPY_VERSION}, <{MAX_SUPPORTED_ALGOPY_VERSION_EX}",
+            important=True,
+            related_lines=[
+                "This will cause typing errors if there are incompatibilities in the API used.",
+                "Please update your algorand-python package to be in the supported range.",
+            ],
         )
 
 
 def _contract_ir_to_teal(
     context: CompileContext, contract_ir: ContractIR, contract_ir_base_path: Path
 ) -> CompiledContract:
     approval_mir = program_ir_to_mir(
```

## puya/errors.py

```diff
@@ -34,21 +34,14 @@
     """Base class for all exceptions that indicate a fault in the compiler."""
 
 
 class CodeError(PuyaError):
     """Base class for all exceptions that indicate a fault in the code being compiled."""
 
 
-class TodoError(CodeError):
-    """Not a code error but it's not a crash either"""
-
-    def __init__(self, location: SourceLocation | None, msg: str | None = None):
-        super().__init__(msg or "TODO: support this thing", location=location)
-
-
 def _crash_report() -> None:
     # Adapted from report_internal_error in mypy
     tb = traceback.extract_stack()[:-4]
     # Excise all the traceback from the test runner
     for i, x in enumerate(tb):
         if x.name == "pytest_runtest_call":
             tb = tb[i + 1 :]
```

## puya/ir/arc4_router.py

```diff
@@ -1,10 +1,10 @@
 from collections.abc import Iterable, Mapping, Sequence
 
-from puya.arc4_util import get_abi_signature, wtype_to_arc4
+from puya import arc4_util
 from puya.avm_type import AVMType
 from puya.awst import (
     nodes as awst_nodes,
     wtypes,
 )
 from puya.awst_build import intrinsic_factory
 from puya.awst_build.arc4_utils import arc4_decode, arc4_encode
@@ -214,17 +214,19 @@
     config: ARC4MethodConfig, location: SourceLocation
 ) -> Sequence[awst_nodes.AssertStatement]:
     if config.allow_create:  # if create is allowed, we don't need to check anything
         return ()
     existing_app = has_app_id(location)
     return (
         awst_nodes.AssertStatement(
-            condition=awst_nodes.Not(expr=existing_app, source_location=location)
-            if config.require_create
-            else existing_app,
+            condition=(
+                awst_nodes.Not(expr=existing_app, source_location=location)
+                if config.require_create
+                else existing_app
+            ),
             comment="is creating" if config.require_create else "is not creating",
             source_location=location,
         ),
     )
 
 
 def constant(value: int, location: SourceLocation) -> awst_nodes.Expression:
@@ -371,32 +373,21 @@
     )
 
 
 def current_group_index(location: SourceLocation) -> awst_nodes.Expression:
     return intrinsic_factory.txn("GroupIndex", wtypes.uint64_wtype, location)
 
 
-def tuple_item(
-    tuple_expression: awst_nodes.Expression, index: int, location: SourceLocation
-) -> awst_nodes.Expression:
-    return awst_nodes.TupleItemExpression(
-        source_location=location, base=tuple_expression, index=index
-    )
-
-
 def arc4_tuple_index(
     arc4_tuple_expression: awst_nodes.Expression, index: int, location: SourceLocation
 ) -> awst_nodes.Expression:
     assert isinstance(arc4_tuple_expression.wtype, wtypes.ARC4Tuple)
 
-    return awst_nodes.IndexExpression(
-        source_location=location,
-        index=awst_nodes.UInt64Constant(value=index, source_location=location),
-        wtype=arc4_tuple_expression.wtype.types[index],
-        base=arc4_tuple_expression,
+    return awst_nodes.TupleItemExpression(
+        base=arc4_tuple_expression, index=index, source_location=location
     )
 
 
 def map_abi_args(
     args: Sequence[awst_nodes.SubroutineArgument], location: SourceLocation
 ) -> Iterable[awst_nodes.Expression]:
     abi_arg_index = 1  # 0th arg is for method selector
@@ -410,16 +401,17 @@
             if wtypes.has_arc4_equivalent_type(wtype):
                 return wtypes.avm_to_arc4_equivalent_type(wtype)
             elif wtypes.is_reference_type(wtype):
                 return wtypes.arc4_byte_type
             else:
                 return wtype
 
-        args_overflow_wtype = wtypes.ARC4Tuple.from_types(
-            [map_param_wtype_to_arc4_tuple_type(a.wtype) for a in non_transaction_args[14:]]
+        args_overflow_wtype = arc4_util.make_tuple_wtype(
+            [map_param_wtype_to_arc4_tuple_type(a.wtype) for a in non_transaction_args[14:]],
+            location,
         )
         last_arg = app_arg(15, args_overflow_wtype, location)
 
     def get_arg(index: int, arg_wtype: wtypes.WType) -> awst_nodes.Expression:
         if index < 15:
             return app_arg(index, arg_wtype, location)
         else:
@@ -472,14 +464,16 @@
                 yield abi_arg
                 abi_arg_index += 1
 
 
 def route_abi_methods(
     location: SourceLocation, methods: dict[awst_nodes.ContractMethod, ARC4MethodConfig]
 ) -> awst_nodes.Block:
+    if not methods:
+        return create_block(location, "reject_abi_methods", reject(location))
     method_routing_cases = dict[awst_nodes.Expression, awst_nodes.Block]()
     seen_signatures = set[str]()
     for method, config in methods.items():
         abi_loc = config.source_location or location
         method_result = call(abi_loc, method, *map_abi_args(method.args, location))
         match method.return_type:
             case wtypes.void_wtype:
@@ -497,15 +491,15 @@
             abi_loc,
             f"{config.name}_route",
             *check_allowed_oca(config.allowed_completion_types, abi_loc),
             *assert_create_state(config, config.source_location or abi_loc),
             call_and_maybe_log,
             approve(abi_loc),
         )
-        arc4_signature = get_abi_signature(method, config)
+        arc4_signature = arc4_util.get_abi_signature(method, config)
         if arc4_signature in seen_signatures:
             raise CodeError(
                 f"Cannot have duplicate ARC4 method signatures: {arc4_signature}", abi_loc
             )
         seen_signatures.add(arc4_signature)
         method_selector_value = awst_nodes.MethodConstant(
             source_location=location, value=arc4_signature
@@ -516,28 +510,29 @@
         "abi_routing",
         awst_nodes.Switch(
             source_location=location,
             value=method_selector(location),
             cases=method_routing_cases,
             default_case=None,
         ),
+        reject(location),
     )
 
 
 def _validate_default_args(
     arc4_methods: Iterable[awst_nodes.ContractMethod],
     known_sources: dict[str, ContractState | awst_nodes.ContractMethod],
 ) -> None:
     for method in arc4_methods:
         assert method.abimethod_config
         args_by_name = {a.name: a for a in method.args}
         for parameter_name, source_name in method.abimethod_config.default_args.items():
             # any invalid parameter matches should have been caught earlier
             parameter = args_by_name[parameter_name]
-            param_arc4_type = wtype_to_arc4(parameter.wtype)
+            param_arc4_type = arc4_util.wtype_to_arc4(parameter.wtype)
             # special handling for reference types
             match param_arc4_type:
                 case "asset" | "application":
                     param_arc4_type = "uint64"
                 case "account":
                     param_arc4_type = "address"
 
@@ -576,15 +571,15 @@
                             method.source_location,
                         )
                     if return_type is wtypes.void_wtype:
                         raise CodeError(
                             f"'{source_name}' does not provide a value",
                             method.source_location,
                         )
-                    if wtype_to_arc4(return_type) != param_arc4_type:
+                    if arc4_util.wtype_to_arc4(return_type) != param_arc4_type:
                         raise CodeError(
                             f"'{source_name}' does not provide '{param_arc4_type}' type",
                             method.source_location,
                         )
                 case ContractState(storage_type=storage_type):
                     if (
                         storage_type is AVMType.uint64
@@ -658,22 +653,22 @@
     arc4_method_metadata = [
         ARC4Method(
             name=m.name,
             desc=docs[m].description,
             args=[
                 ARC4MethodArg(
                     name=a.name,
-                    type_=wtype_to_arc4(a.wtype),
+                    type_=arc4_util.wtype_to_arc4(a.wtype),
                     desc=docs[m].args.get(a.name),
                 )
                 for a in m.args
             ],
             returns=ARC4Returns(
                 desc=docs[m].returns,
-                type_=wtype_to_arc4(m.return_type),
+                type_=arc4_util.wtype_to_arc4(m.return_type),
             ),
             config=abi_config,
         )
         for m, abi_config in arc4_methods_with_configs.items()
     ]
     if not has_create:
         arc4_method_metadata.append(
@@ -694,20 +689,15 @@
     approval_program = awst_nodes.ContractMethod(
         module_name=contract.module_name,
         class_name=contract.name,
         name="approval_program",
         source_location=router_location,
         args=[],
         return_type=wtypes.bool_wtype,
-        body=create_block(
-            router_location,
-            "abi_bare_routing",
-            *router,
-            reject(contract.source_location),
-        ),
+        body=create_block(router_location, "abi_bare_routing", *router),
         docstring=None,
         abimethod_config=None,
     )
     return approval_program, arc4_method_metadata
 
 
 def create_default_clear_state(contract: awst_nodes.ContractFragment) -> awst_nodes.ContractMethod:
```

## puya/ir/avm_ops.py

```diff
@@ -4093,15 +4093,15 @@
     """
     0 if A is equal to B, else 1. A and B are interpreted as big-endian unsigned integers
     """
 
     not_ = AVMOpData(
         op_code="!",
         variants=Variant(
-            signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
+            signature=OpSignature(args=[StackType.uint64], returns=[StackType.bool]),
             supported_modes=RunMode.any,
         ),
         immediate_types=(),
         cost=1,
         min_avm_version=1,
         supported_modes=RunMode.any,
     )
@@ -4167,15 +4167,15 @@
     `replace3` can be called using `replace` with no immediates.
     """
 
     select = AVMOpData(
         op_code="select",
         variants=Variant(
             signature=OpSignature(
-                args=[StackType.any, StackType.any, StackType.uint64], returns=[StackType.any]
+                args=[StackType.any, StackType.any, StackType.bool], returns=[StackType.any]
             ),
             supported_modes=RunMode.any,
         ),
         immediate_types=(),
         cost=1,
         min_avm_version=3,
         supported_modes=RunMode.any,
```

## puya/ir/builder/_utils.py

```diff
@@ -1,11 +1,12 @@
 import typing
 from collections.abc import Iterator, Sequence
 
-from puya.avm_type import AVMType
+import attrs
+
 from puya.awst import nodes as awst_nodes
 from puya.errors import InternalError
 from puya.ir.avm_ops import AVMOp
 from puya.ir.context import IRFunctionBuildContext
 from puya.ir.models import (
     Assignment,
     BasicBlock,
@@ -13,39 +14,37 @@
     Intrinsic,
     InvokeSubroutine,
     Register,
     UInt64Constant,
     Value,
     ValueProvider,
 )
-from puya.ir.types_ import AVMBytesEncoding
+from puya.ir.types_ import AVMBytesEncoding, IRType
 from puya.ir.utils import format_tuple_index
 from puya.parse import SourceLocation
 
 
 @typing.overload
 def assign(
     context: IRFunctionBuildContext,
     source: ValueProvider,
     *,
     names: Sequence[tuple[str, SourceLocation | None]],
     source_location: SourceLocation | None,
-) -> Sequence[Register]:
-    ...
+) -> Sequence[Register]: ...
 
 
 @typing.overload
 def assign(
     context: IRFunctionBuildContext,
     source: ValueProvider,
     *,
     temp_description: str | Sequence[str],
     source_location: SourceLocation | None,
-) -> Sequence[Register]:
-    ...
+) -> Sequence[Register]: ...
 
 
 def assign(
     context: IRFunctionBuildContext,
     source: ValueProvider,
     *,
     names: Sequence[tuple[str, SourceLocation | None]] | None = None,
@@ -59,16 +58,16 @@
         )
 
     if temp_description is not None:
         assert names is None, "One and only one of names and temp_description should be supplied"
         if isinstance(temp_description, str):
             temp_description = [temp_description] * len(atypes)
         targets = [
-            mktemp(context, atype, source_location, description=descr)
-            for atype, descr in zip(atypes, temp_description, strict=True)
+            mktemp(context, ir_type, source_location, description=descr)
+            for ir_type, descr in zip(atypes, temp_description, strict=True)
         ]
     else:
         assert (
             names is not None
         ), "One and only one of names and temp_description should be supplied"
         # non-temporary assignment, so in the case of a multi-valued returning source/provider,
         # names should either be a single value (ie a tuple var name),
@@ -78,16 +77,16 @@
                 ((name, var_loc),) = names
             except ValueError as ex:
                 raise InternalError(
                     "Incompatible multi-assignment lengths", source_location
                 ) from ex
             names = [(format_tuple_index(name, idx), var_loc) for idx, _ in enumerate(atypes)]
         targets = [
-            context.ssa.new_register(name, atype, var_loc)
-            for (name, var_loc), atype in zip(names, atypes, strict=True)
+            context.ssa.new_register(name, ir_type, var_loc)
+            for (name, var_loc), ir_type in zip(names, atypes, strict=True)
         ]
 
     assign_targets(
         context=context,
         source=source,
         targets=targets,
         assignment_location=source_location,
@@ -123,72 +122,74 @@
     context.block_builder.add(
         Assignment(targets=targets, source=source, source_location=assignment_location)
     )
 
 
 def mktemp(
     context: IRFunctionBuildContext,
-    atype: AVMType,
+    ir_type: IRType,
     source_location: SourceLocation | None,
     *,
     description: str,
 ) -> Register:
     register = context.ssa.new_register(
         name=context.next_tmp_name(description),
-        atype=atype,
+        ir_type=ir_type,
         location=source_location,
     )
     return register
 
 
 def assign_intrinsic_op(
     context: IRFunctionBuildContext,
     *,
     target: str | Register,
     op: AVMOp,
     args: Sequence[int | bytes | Value],
     source_location: SourceLocation | None,
     immediates: list[int | str] | None = None,
+    return_type: Sequence[IRType] | None = None,
 ) -> Sequence[Register]:
     def map_arg(arg: int | bytes | Value) -> Value:
         match arg:
             case int(val):
                 return UInt64Constant(value=val, source_location=source_location)
             case bytes(b_val):
                 return BytesConstant(
                     value=b_val,
-                    source_location=source_location,
                     encoding=AVMBytesEncoding.base16,
+                    source_location=source_location,
                 )
             case _:
                 return arg
 
+    intrinsic = Intrinsic(
+        op=op,
+        immediates=immediates or [],
+        args=[map_arg(a) for a in args],
+        types=(
+            return_type
+            if return_type is not None
+            else typing.cast(Sequence[IRType], attrs.NOTHING)
+        ),
+        source_location=source_location,
+    )
     if isinstance(target, str):
         return assign(
             context,
             temp_description=target,
+            source=intrinsic,
             source_location=source_location,
-            source=Intrinsic(
-                op=op,
-                immediates=immediates or list[int | str](),
-                args=[map_arg(a) for a in args],
-                source_location=source_location,
-            ),
         )
     else:
         return assign(
             context,
             names=[(target.name, source_location)],
+            source=intrinsic,
             source_location=source_location,
-            source=Intrinsic(
-                op=op,
-                immediates=immediates or list[int | str](),
-                args=[map_arg(a) for a in args],
-                source_location=source_location,
-            ),
         )
 
 
 def invoke_puya_lib_subroutine(
     context: IRFunctionBuildContext,
     *,
     method_name: str,
```

## puya/ir/builder/arc4.py

```diff
@@ -1,7 +1,8 @@
+import typing
 from collections.abc import Callable, Sequence
 
 import attrs
 
 from puya.arc4_util import (
     determine_arc4_tuple_head_size,
     get_arc4_fixed_bit_size,
@@ -29,15 +30,15 @@
     Intrinsic,
     Register,
     UInt64Constant,
     Value,
     ValueProvider,
     ValueTuple,
 )
-from puya.ir.types_ import AVMBytesEncoding
+from puya.ir.types_ import AVMBytesEncoding, IRType
 from puya.ir.utils import format_tuple_index
 from puya.parse import SourceLocation
 from puya.utils import bits_to_bytes
 
 
 @attrs.frozen
 class ArrayIterator:
@@ -86,44 +87,55 @@
     wtype: wtypes.ARC4Tuple | wtypes.ARC4Struct,
     value: Value,
     source_location: SourceLocation,
 ) -> ValueProvider:
     items = list[Value]()
 
     for index in range(len(wtype.types)):
-        index_const = UInt64Constant(value=index, source_location=source_location)
         item_value = _read_nth_item_of_arc4_heterogeneous_container(
             context,
             array_bytes_sans_length_header=value,
             tuple_type=wtype,
-            index=index_const,
+            index=index,
             source_location=source_location,
         )
         (item,) = assign(
             context,
             temp_description=f"item{index}",
             source=item_value,
             source_location=source_location,
         )
 
         items.append(item)
     return ValueTuple(source_location=source_location, values=items)
 
 
+def encode_arc4_struct(
+    context: IRFunctionBuildContext, expr: awst_nodes.NewStruct, wtype: wtypes.ARC4Struct
+) -> ValueProvider:
+    assert expr.wtype == wtype
+    elements = [
+        context.visitor.visit_and_materialise_single(expr.values[field_name])
+        for field_name in expr.wtype.fields
+    ]
+    return _visit_arc4_tuple_encode(context, elements, wtype.types, expr.source_location)
+
+
 def encode_expr(context: IRFunctionBuildContext, expr: awst_nodes.ARC4Encode) -> ValueProvider:
     match expr.wtype:
         case wtypes.arc4_bool_wtype:
             value = context.visitor.visit_and_materialise_single(expr.value)
             return encode_arc4_bool(value, expr.source_location)
         case wtypes.ARC4UIntN() | wtypes.ARC4UFixedNxM() as wt:
             value = context.visitor.visit_and_materialise_single(expr.value)
             num_bytes = wt.n // 8
             return _itob_fixed(context, value, num_bytes, expr.source_location)
-        case wtypes.ARC4Tuple(types=item_types) | wtypes.ARC4Struct(types=item_types):
-            return _visit_arc4_tuple_encode(context, expr, item_types)
+        case wtypes.ARC4Tuple(types=item_types):
+            elements = context.visitor.visit_and_materialise(expr.value)
+            return _visit_arc4_tuple_encode(context, elements, item_types, expr.source_location)
         case wtypes.arc4_string_wtype | wtypes.arc4_dynamic_bytes:
             if isinstance(expr.value, awst_nodes.BytesConstant):
                 ir_const = context.visitor.visit_expr(expr.value)
                 if not isinstance(ir_const, BytesConstant):
                     raise InternalError("Expected BytesConstant", expr.value.source_location)
                 prefix = len(ir_const.value).to_bytes(2, "big")
                 value_prefixed = prefix + ir_const.value
@@ -156,81 +168,92 @@
         case _:
             raise InternalError(
                 f"Unsupported wtype for ARC4Encode: {expr.wtype}",
                 location=expr.source_location,
             )
 
 
-def maybe_arc4_index_expr(
-    context: IRFunctionBuildContext, expr: awst_nodes.IndexExpression, base: Value, index: Value
-) -> ValueProvider | None:
+def arc4_array_index(
+    context: IRFunctionBuildContext,
+    wtype: wtypes.ARC4StaticArray | wtypes.ARC4DynamicArray,
+    base: Value,
+    index: Value,
+    source_location: SourceLocation,
+) -> ValueProvider:
     """
     If expr is an ARC4 index expression will return the resulting ValueProvider.
     Returns None if not an ARC4 expression
     """
 
-    match expr.base.wtype:
+    match wtype:
         case wtypes.ARC4StaticArray(array_size=array_size, element_type=element_type):
             _assert_index_in_bounds(
                 context,
                 index=index,
-                length=UInt64Constant(value=array_size, source_location=expr.source_location),
-                source_location=expr.source_location,
+                length=UInt64Constant(value=array_size, source_location=source_location),
+                source_location=source_location,
             )
             return _read_nth_item_of_arc4_homogeneous_container(
                 context,
-                source_location=expr.source_location,
+                source_location=source_location,
                 array_bytes_sans_length_header=base,
                 index=index,
                 item_wtype=element_type,
             )
 
         case wtypes.ARC4DynamicArray(element_type=element_type):
             _assert_index_in_bounds(
                 context,
                 index=index,
                 length=Intrinsic(
                     op=AVMOp.extract_uint16,
                     args=[
                         base,
-                        UInt64Constant(value=0, source_location=expr.source_location),
+                        UInt64Constant(value=0, source_location=source_location),
                     ],
-                    source_location=expr.source_location,
+                    source_location=source_location,
                 ),
-                source_location=expr.source_location,
+                source_location=source_location,
             )
             (array_data_sans_header,) = assign(
                 context,
-                source_location=expr.source_location,
+                source_location=source_location,
                 temp_description="array_data_sans_header",
                 source=Intrinsic(
                     op=AVMOp.extract,
                     args=[base],
                     immediates=[2, 0],
-                    source_location=expr.source_location,
+                    source_location=source_location,
                 ),
             )
             return _read_nth_item_of_arc4_homogeneous_container(
                 context,
-                source_location=expr.source_location,
+                source_location=source_location,
                 array_bytes_sans_length_header=array_data_sans_header,
                 index=index,
                 item_wtype=element_type,
             )
-        case wtypes.ARC4Tuple() | wtypes.ARC4Struct() as tuple_type:
-            if not isinstance(index, UInt64Constant):
-                raise InternalError("Tuples must be index with a constant value")
-            return _read_nth_item_of_arc4_heterogeneous_container(
-                context,
-                source_location=expr.source_location,
-                array_bytes_sans_length_header=base,
-                index=index,
-                tuple_type=tuple_type,
-            )
-    return None
+        case _:
+            typing.assert_never(wtype)
+
+
+def arc4_tuple_index(
+    context: IRFunctionBuildContext,
+    base: Value,
+    index: int,
+    wtype: wtypes.ARC4Tuple | wtypes.ARC4Struct,
+    source_location: SourceLocation,
+) -> ValueProvider:
+    return _read_nth_item_of_arc4_heterogeneous_container(
+        context,
+        array_bytes_sans_length_header=base,
+        index=index,
+        tuple_type=wtype,
+        source_location=source_location,
+    )
 
 
 def _value_as_uint16(
     context: IRFunctionBuildContext, value: Value, source_location: SourceLocation | None = None
 ) -> Value:
     source_location = source_location or value.source_location
     (value_as_bytes,) = assign(
@@ -251,20 +274,19 @@
         temp_description="value_as_uint16",
     )
     return value_as_uint16
 
 
 def _visit_arc4_tuple_encode(
     context: IRFunctionBuildContext,
-    expr: awst_nodes.ARC4Encode,
+    elements: Sequence[Value],
     tuple_items: Sequence[wtypes.WType],
+    expr_loc: SourceLocation,
 ) -> ValueProvider:
-    elements = context.visitor.visit_and_materialise(expr.value)
     header_size = determine_arc4_tuple_head_size(tuple_items, round_end_result=True)
-    expr_loc = expr.source_location
 
     (current_tail_offset,) = assign(
         context,
         temp_description="current_tail_offset",
         source=UInt64Constant(value=header_size // 8, source_location=expr_loc),
         source_location=expr_loc,
     )
@@ -304,21 +326,18 @@
                         args=[element, UInt64Constant(value=0, source_location=None)],
                         source_location=expr_loc,
                     ),
                     source_location=expr_loc,
                 )
 
                 assign_buffer(
-                    Intrinsic(
-                        op=AVMOp.setbit,
-                        args=[
-                            encoded_tuple_buffer,
-                            UInt64Constant(value=before_header, source_location=expr_loc),
-                            is_true,
-                        ],
+                    _set_bit(
+                        value=encoded_tuple_buffer,
+                        index=before_header,
+                        bit=is_true,
                         source_location=expr_loc,
                     )
                 )
         elif not is_arc4_dynamic_size(el_wtype):
             # Append value
             append_to_buffer(element)
         else:
@@ -343,17 +362,27 @@
 
     for element, el_wtype in zip(elements, tuple_items, strict=True):
         if is_arc4_dynamic_size(el_wtype):
             append_to_buffer(element)
     return encoded_tuple_buffer
 
 
-def encode_arc4_array(
-    context: IRFunctionBuildContext, expr: awst_nodes.ARC4ArrayEncode
-) -> ValueProvider:
+def _set_bit(
+    *, value: Value, index: int, bit: Value, source_location: SourceLocation | None
+) -> Intrinsic:
+    index_const = UInt64Constant(value=index, source_location=source_location)
+    return Intrinsic(
+        op=AVMOp.setbit,
+        args=[value, index_const, bit],
+        types=[value.ir_type],
+        source_location=source_location,
+    )
+
+
+def encode_arc4_array(context: IRFunctionBuildContext, expr: awst_nodes.NewArray) -> ValueProvider:
     len_prefix = (
         len(expr.values).to_bytes(2, "big")
         if isinstance(expr.wtype, wtypes.ARC4DynamicArray)
         else b""
     )
 
     expr_loc = expr.source_location
@@ -386,24 +415,18 @@
                     source=Intrinsic(
                         op=AVMOp.getbit,
                         args=[el, UInt64Constant(value=0, source_location=None)],
                         source_location=expr_loc,
                     ),
                     source_location=expr_loc,
                 )
-                new_array_data_value = Intrinsic(
-                    op=AVMOp.setbit,
-                    args=[
-                        array_data,
-                        UInt64Constant(
-                            value=index + (len(len_prefix) * 8),
-                            source_location=expr_loc,
-                        ),
-                        is_true,
-                    ],
+                new_array_data_value = _set_bit(
+                    value=array_data,
+                    index=index + 8 * len(len_prefix),
+                    bit=is_true,
                     source_location=expr_loc,
                 )
             array_data = reassign(context, array_data, new_array_data_value, expr_loc)
 
         return array_data
 
     if is_arc4_dynamic_size(element_type):
@@ -439,36 +462,33 @@
         array_data = reassign(context, array_data, array_data_value, expr_loc)
     return array_data
 
 
 def _arc4_replace_struct_item(
     context: IRFunctionBuildContext,
     base_expr: awst_nodes.Expression,
-    index_value_expr: awst_nodes.Expression,
+    field_name: str,
     wtype: wtypes.ARC4Struct,
     value: ValueProvider,
     source_location: SourceLocation,
 ) -> Value:
     if not isinstance(wtype, wtypes.ARC4Struct):
         raise InternalError("Unsupported indexed assignment target", source_location)
 
     base = context.visitor.visit_and_materialise_single(base_expr)
     (value,) = assign(
         context,
         source_location=source_location,
         temp_description="assigned_value",
         source=value,
     )
-    if isinstance(index_value_expr, awst_nodes.IntegerConstant):
-        index_int = index_value_expr.value
-        if index_int >= len(wtype.types):
-            raise CodeError("Index access is out of bounds", source_location)
-        element_type = wtype.types[index_int]
-    else:
-        raise CodeError("arc4.Structs cannot be dynamically indexed", source_location)
+    element_type = wtype.fields.get(field_name)
+    if element_type is None:
+        raise CodeError(f"Invalid arc4.Struct field name {field_name}", source_location)
+    index_int = wtype.names.index(field_name)
 
     element_size = get_arc4_fixed_bit_size(element_type)
     header_up_to_item = determine_arc4_tuple_head_size(
         wtype.types[0:index_int],
         round_end_result=element_size != 1,
     )
     if not element_size:
@@ -652,15 +672,16 @@
             args=[value, 0],
         )
         (updated_data,) = assign_intrinsic_op(
             context,
             target="updated_data",
             source_location=source_location,
             op=AVMOp.setbit,
-            args=[base, header_up_to_item, is_true],
+            args=(base, header_up_to_item, is_true),
+            return_type=[base.ir_type],
         )
         return updated_data
     else:
         (updated_data,) = assign_intrinsic_op(
             context,
             target="updated_data",
             source_location=source_location,
@@ -672,23 +693,23 @@
 
 
 def _read_nth_item_of_arc4_heterogeneous_container(
     context: IRFunctionBuildContext,
     *,
     array_bytes_sans_length_header: Value,
     tuple_type: wtypes.ARC4Tuple | wtypes.ARC4Struct,
-    index: UInt64Constant,
+    index: int,
     source_location: SourceLocation,
 ) -> ValueProvider:
     tuple_item_types = tuple_type.types
 
-    item_wtype = tuple_item_types[index.value]
+    item_wtype = tuple_item_types[index]
     item_bit_size = get_arc4_fixed_bit_size(item_wtype)
     head_up_to_item = determine_arc4_tuple_head_size(
-        tuple_item_types[0 : index.value], round_end_result=False
+        tuple_item_types[:index], round_end_result=False
     )
     if item_bit_size is not None:
         item_index: Value = UInt64Constant(
             value=(
                 head_up_to_item
                 if item_wtype == wtypes.arc4_bool_wtype
                 else bits_to_bytes(head_up_to_item)
@@ -733,17 +754,19 @@
     item_bit_size = get_arc4_fixed_bit_size(item_wtype)
     if item_bit_size is not None:
         item_index_value = Intrinsic(
             op=AVMOp.mul,
             args=[
                 index,
                 UInt64Constant(
-                    value=item_bit_size
-                    if item_wtype == wtypes.arc4_bool_wtype
-                    else (item_bit_size // 8),
+                    value=(
+                        item_bit_size
+                        if item_wtype == wtypes.arc4_bool_wtype
+                        else (item_bit_size // 8)
+                    ),
                     source_location=source_location,
                 ),
             ],
             source_location=source_location,
         )
     else:
         (item_index_index,) = assign(
@@ -1160,25 +1183,25 @@
                     index_value_expr=index_value,
                     wtype=array_wtype,
                     value=value,
                     source_location=source_location,
                 ),
                 source_location=source_location,
             )
-        case awst_nodes.IndexExpression(
+        case awst_nodes.FieldExpression(
             base=awst_nodes.Expression(wtype=wtypes.ARC4Struct() as struct_wtype) as base_expr,
-            index=index_value,
+            name=field_name,
         ):
             return handle_arc4_assign(
                 context,
                 target=base_expr,
                 value=_arc4_replace_struct_item(
                     context,
                     base_expr=base_expr,
-                    index_value_expr=index_value,
+                    field_name=field_name,
                     wtype=struct_wtype,
                     value=value,
                     source_location=source_location,
                 ),
                 source_location=source_location,
             )
         case awst_nodes.TupleItemExpression(
@@ -1313,19 +1336,16 @@
             args=[value, 0],
         )
         (updated_target,) = assign_intrinsic_op(
             context,
             target="updated_target",
             source_location=source_location,
             op=AVMOp.setbit,
-            args=[
-                base,
-                write_offset,
-                is_true,
-            ],
+            args=(base, write_offset, is_true),
+            return_type=[base.ir_type],
         )
     else:
         (updated_target,) = assign_intrinsic_op(
             context,
             target="updated_target",
             source_location=source_location,
             op=AVMOp.replace3,
@@ -1542,16 +1562,16 @@
 def pop_arc4_array(
     context: IRFunctionBuildContext,
     expr: awst_nodes.ArrayPop,
     array_wtype: wtypes.ARC4DynamicArray,
 ) -> ValueProvider:
     source_location = expr.source_location
     element_size = get_arc4_fixed_bit_size(array_wtype.element_type)
-    popped = mktemp(context, AVMType.bytes, source_location, description="popped")
-    data = mktemp(context, AVMType.bytes, source_location, description="data")
+    popped = mktemp(context, IRType.bytes, source_location, description="popped")
+    data = mktemp(context, IRType.bytes, source_location, description="data")
     base = context.visitor.visit_and_materialise_single(expr.base)
     match element_size:
         case 1:
             method_name = "dynamic_array_pop_bit"
             args: list[Value] = [base]
 
         case int(fixed_size):
@@ -1619,21 +1639,14 @@
         context,
         index_is_in_bounds,
         source_location=source_location,
         comment="Index access is out of bounds",
     )
 
 
-def encode_arc4_bool(value: Value, source_location: SourceLocation) -> ValueProvider:
-    return Intrinsic(
-        op=AVMOp.setbit,
-        args=[
-            BytesConstant(
-                value=0x00.to_bytes(1, "big"),
-                source_location=source_location,
-                encoding=AVMBytesEncoding.base16,
-            ),
-            UInt64Constant(value=0, source_location=None),
-            value,
-        ],
+def encode_arc4_bool(bit: Value, source_location: SourceLocation) -> ValueProvider:
+    value = BytesConstant(
+        value=0x00.to_bytes(1, "big"),
         source_location=source_location,
+        encoding=AVMBytesEncoding.base16,
     )
+    return _set_bit(value=value, index=0, bit=bit, source_location=source_location)
```

## puya/ir/builder/assignment.py

```diff
@@ -1,48 +1,50 @@
+import typing
 from collections.abc import Sequence
 
 from puya import log
 from puya.awst import (
     nodes as awst_nodes,
     wtypes,
 )
-from puya.errors import CodeError, TodoError
+from puya.errors import CodeError, InternalError
 from puya.ir.avm_ops import AVMOp
 from puya.ir.builder import arc4
 from puya.ir.builder._utils import assign
 from puya.ir.context import IRFunctionBuildContext
 from puya.ir.models import (
     BytesConstant,
     Intrinsic,
     Value,
     ValueProvider,
 )
 from puya.ir.types_ import (
     bytes_enc_to_avm_bytes_enc,
 )
+from puya.ir.utils import lvalue_items
 from puya.parse import SourceLocation
 
 logger = log.get_logger(__name__)
 
 
 def handle_assignment_expr(
     context: IRFunctionBuildContext,
-    target: awst_nodes.Expression,
+    target: awst_nodes.Lvalue,
     value: awst_nodes.Expression,
     assignment_location: SourceLocation,
 ) -> Sequence[Value]:
     expr_values = context.visitor.visit_expr(value)
     return handle_assignment(
         context, target=target, value=expr_values, assignment_location=assignment_location
     )
 
 
 def handle_assignment(
     context: IRFunctionBuildContext,
-    target: awst_nodes.Expression,
+    target: awst_nodes.Lvalue,
     value: ValueProvider,
     assignment_location: SourceLocation,
 ) -> Sequence[Value]:
     match target:
         case awst_nodes.VarExpression(name=var_name, source_location=var_loc):
             if var_name in (p.name for p in context.subroutine.parameters if p.implicit_return):
                 raise CodeError(
@@ -52,28 +54,26 @@
                 )
             return assign(
                 context,
                 source=value,
                 names=[(var_name, var_loc)],
                 source_location=assignment_location,
             )
-        case awst_nodes.TupleExpression(items=items):
+        case awst_nodes.TupleExpression() as tup_expr:
             source = context.visitor.materialise_value_provider(
                 value, description="tuple_assignment"
             )
+            items = lvalue_items(tup_expr)
             if len(source) != len(items):
                 raise CodeError("unpacking vs result length mismatch", assignment_location)
             return [
                 val
                 for dst, src in zip(items, source, strict=True)
                 for val in handle_assignment(
-                    context,
-                    target=dst,
-                    value=src,
-                    assignment_location=assignment_location,
+                    context, target=dst, value=src, assignment_location=assignment_location
                 )
             ]
         case awst_nodes.AppStateExpression(field_name=field_name, source_location=key_loc):
             source = context.visitor.materialise_value_provider(
                 value, description="new_state_value"
             )
             if len(source) != 1:
@@ -118,26 +118,45 @@
                         ),
                         source[0],
                     ],
                     source_location=assignment_location,
                 )
             )
             return source
-        case awst_nodes.IndexExpression(
-            base=awst_nodes.Expression(
-                wtype=wtypes.ARC4DynamicArray() | wtypes.ARC4StaticArray() | wtypes.ARC4Struct()
-            )
-        ) as ix_expr:
-            return (
-                arc4.handle_arc4_assign(
-                    context,
-                    target=ix_expr,
-                    value=value,
-                    source_location=assignment_location,
-                ),
-            )
+        case awst_nodes.IndexExpression() as ix_expr:
+            if isinstance(ix_expr.base.wtype, wtypes.WArray):
+                raise NotImplementedError
+            elif isinstance(ix_expr.base.wtype, wtypes.ARC4Type):  # noqa: RET506
+                return (
+                    arc4.handle_arc4_assign(
+                        context,
+                        target=ix_expr,
+                        value=value,
+                        source_location=assignment_location,
+                    ),
+                )
+            else:
+                raise InternalError(
+                    f"Indexed assignment operation IR lowering"
+                    f" not implemented for base type {ix_expr.base.wtype.name}",
+                    assignment_location,
+                )
+        case awst_nodes.FieldExpression() as field_expr:
+            if isinstance(field_expr.base.wtype, wtypes.WStructType):
+                raise NotImplementedError
+            elif isinstance(field_expr.base.wtype, wtypes.ARC4Struct):  # noqa: RET506
+                return (
+                    arc4.handle_arc4_assign(
+                        context,
+                        target=field_expr,
+                        value=value,
+                        source_location=assignment_location,
+                    ),
+                )
+            else:
+                raise InternalError(
+                    f"Field assignment operation IR lowering"
+                    f" not implemented for base type {field_expr.base.wtype.name}",
+                    assignment_location,
+                )
         case _:
-            raise TodoError(
-                assignment_location,
-                "TODO: explicitly handle or reject assignment target type:"
-                f" {type(target).__name__}",
-            )
+            typing.assert_never(target)
```

## puya/ir/builder/blocks.py

```diff
@@ -129,15 +129,15 @@
         self.activate_block(block)
 
     def maybe_add_implicit_subroutine_return(self, params: Sequence[Parameter]) -> None:
         if not self._blocks[-1].terminated:
             self.terminate(
                 SubroutineReturn(
                     result=[
-                        self.ssa.read_variable(p.name, p.atype, self._blocks[-1])
+                        self.ssa.read_variable(p.name, p.ir_type, self._blocks[-1])
                         for p in params
                         if p.implicit_return
                     ],
                     source_location=None,
                 )
             )
```

## puya/ir/builder/flow_control.py

```diff
@@ -10,15 +10,15 @@
     BasicBlock,
     ConditionalBranch,
     Goto,
     Register,
     Switch,
     Value,
 )
-from puya.ir.types_ import wtype_to_avm_type
+from puya.ir.types_ import wtype_to_ir_type
 from puya.parse import SourceLocation
 from puya.utils import lazy_setdefault
 
 logger = log.get_logger(__name__)
 
 
 def handle_if_else(context: IRFunctionBuildContext, stmt: awst_nodes.IfElse) -> None:
@@ -236,10 +236,10 @@
         source=false_vp,
         names=[(tmp_var_name, expr.false_expr.source_location)],
         source_location=expr.source_location,
     )
     context.block_builder.goto_and_activate(merge_block)
     context.ssa.seal_block(merge_block)
     result = context.ssa.read_variable(
-        variable=tmp_var_name, atype=wtype_to_avm_type(expr), block=merge_block
+        variable=tmp_var_name, ir_type=wtype_to_ir_type(expr), block=merge_block
     )
     return result
```

## puya/ir/builder/iteration.py

```diff
@@ -1,12 +1,11 @@
 import typing
 from collections.abc import Sequence
 
 from puya import log
-from puya.avm_type import AVMType
 from puya.awst import (
     nodes as awst_nodes,
     wtypes,
 )
 from puya.awst.nodes import (
     Expression,
 )
@@ -23,14 +22,16 @@
     GotoNth,
     Intrinsic,
     Register,
     UInt64Constant,
     Value,
     ValueProvider,
 )
+from puya.ir.types_ import IRType
+from puya.ir.utils import lvalue_items
 from puya.parse import SourceLocation
 
 logger = log.get_logger(__name__)
 
 
 def handle_for_in_loop(context: IRFunctionBuildContext, statement: awst_nodes.ForInLoop) -> None:
     sequence = statement.sequence
@@ -52,28 +53,28 @@
                 sequence = sequence.expr
                 reverse_items = not reverse_items
                 if not has_enumerate:
                     reverse_index = not reverse_index
             case _:
                 break
 
-    if has_enumerate:
+    if not has_enumerate:
+        index_var = None
+        item_var = statement.items
+    else:
         if not (
             isinstance(statement.items, awst_nodes.TupleExpression)
             and len(statement.items.items) == 2
         ):
             # TODO: fix this
             raise CodeError(
                 "when using uenumerate(), loop variables must be an unpacked two item tuple",
                 statement.sequence.source_location,
             )
-        index_var, item_var = statement.items.items
-    else:
-        index_var = None
-        item_var = statement.items
+        index_var, item_var = lvalue_items(statement.items)
 
     match sequence:
         case awst_nodes.Range(
             start=range_start, stop=range_stop, step=range_step, source_location=range_loc
         ):
             _iterate_urange(
                 context,
@@ -211,16 +212,16 @@
     context.ssa.seal_block(preamble)
 
 
 def _iterate_urange(
     context: IRFunctionBuildContext,
     *,
     loop_body: awst_nodes.Block,
-    item_var: Expression,
-    index_var: Expression | None,
+    item_var: awst_nodes.Lvalue,
+    index_var: awst_nodes.Lvalue | None,
     statement_loc: SourceLocation,
     range_start: Expression,
     range_stop: Expression,
     range_step: Expression,
     range_loc: SourceLocation,
     reverse_items: bool,
     reverse_index: bool,
@@ -480,16 +481,16 @@
     context.block_builder.activate_block(next_block)
 
 
 def _iterate_indexable(
     context: IRFunctionBuildContext,
     *,
     loop_body: awst_nodes.Block,
-    item_var: Expression,
-    index_var: Expression | None,
+    item_var: awst_nodes.Lvalue,
+    index_var: awst_nodes.Lvalue | None,
     statement_loc: SourceLocation,
     indexable_size: Value,
     get_value_at_index: typing.Callable[[Register], ValueProvider],
     reverse_items: bool,
     reverse_index: bool,
 ) -> None:
     header, body, footer, next_block = mkblocks(
@@ -600,16 +601,16 @@
     context.block_builder.activate_block(next_block)
 
 
 def _iterate_tuple(
     context: IRFunctionBuildContext,
     *,
     loop_body: awst_nodes.Block,
-    item_var: awst_nodes.Expression,
-    index_var: awst_nodes.Expression | None,
+    item_var: awst_nodes.Lvalue,
+    index_var: awst_nodes.Lvalue | None,
     tuple_items: Sequence[Value],
     statement_loc: SourceLocation,
     reverse_index: bool,
     reverse_items: bool,
 ) -> None:
     headers = [
         BasicBlock(comment=f"for_header_{index}", source_location=statement_loc)
@@ -656,37 +657,37 @@
             (reversed_index,) = assign_intrinsic_op(
                 context,
                 target="reversed_index",
                 source_location=None,
                 op=AVMOp.sub,
                 args=[
                     len(tuple_items) - 1,
-                    context.ssa.read_variable(tuple_index, AVMType.uint64, body),
+                    context.ssa.read_variable(tuple_index, IRType.uint64, body),
                 ],
             )
             handle_assignment(
                 context,
                 target=index_var,
                 value=reversed_index,
                 assignment_location=index_var.source_location,
             )
         else:
             handle_assignment(
                 context,
                 target=index_var,
-                value=context.ssa.read_variable(tuple_index, AVMType.uint64, body),
+                value=context.ssa.read_variable(tuple_index, IRType.uint64, body),
                 assignment_location=index_var.source_location,
             )
 
     with context.block_builder.enter_loop(on_continue=footer, on_break=next_block):
         loop_body.accept(context.visitor)
 
     context.block_builder.goto_and_activate(footer)
     context.ssa.seal_block(footer)
-    curr_index_internal = context.ssa.read_variable(tuple_index, AVMType.uint64, footer)
+    curr_index_internal = context.ssa.read_variable(tuple_index, IRType.uint64, footer)
     (_updated_r,) = assign(
         context,
         source=Intrinsic(
             op=AVMOp("+"),
             args=[curr_index_internal, UInt64Constant(value=1, source_location=None)],
             source_location=None,
         ),
@@ -715,8 +716,8 @@
     do an SSA read in the current block.
 
     This is *only* required when there is control flow involved in the generated IR,
     if it's only the builder that needs to loop then it should usually have an updated
     reference to the most recent assigned register which will still be valid because it's
     within the same block.
     """
-    return context.ssa.read_variable(reg.name, reg.atype, context.block_builder.active_block)
+    return context.ssa.read_variable(reg.name, reg.ir_type, context.block_builder.active_block)
```

## puya/ir/builder/itxn.py

```diff
@@ -1,50 +1,45 @@
 import typing
 from collections.abc import Mapping, Sequence
 
 import attrs
 
-from puya.avm_type import AVMType
 from puya.awst import (
     nodes as awst_nodes,
     wtypes,
 )
 from puya.awst.to_code_visitor import ToCodeVisitor
+from puya.awst.wtypes import is_inner_transaction_field_type
 from puya.errors import CodeError, InternalError
 from puya.ir.avm_ops import AVMOp
 from puya.ir.builder._utils import assign, assign_intrinsic_op
-from puya.ir.builder.assignment import handle_assignment
 from puya.ir.builder.blocks import BlocksBuilder
 from puya.ir.context import IRFunctionBuildContext
 from puya.ir.models import (
     BasicBlock,
     ConditionalBranch,
+    InnerTransactionField,
     Intrinsic,
+    ITxnConstant,
     Register,
     UInt64Constant,
+    Value,
     ValueProvider,
     ValueTuple,
 )
 from puya.ir.ssa import BraunSSA
-from puya.ir.types_ import wtype_to_avm_type
+from puya.ir.types_ import IRType, wtype_to_ir_type
+from puya.ir.utils import format_tuple_index
 from puya.parse import SourceLocation
 from puya.utils import StableSet
 
 _INNER_TRANSACTION_NON_ARRAY_FIELDS = [f for f in awst_nodes.TXN_FIELDS if not f.is_array]
 
 
 @attrs.frozen(kw_only=True)
-class SubmitInnerTransactionData:
-    group_index: int
-    is_last_in_group: bool
-    submit_id: int
-    var_name: str
-
-
-@attrs.frozen(kw_only=True)
 class CreateInnerTransactionFieldData:
     var_name: str
     field: awst_nodes.TxnField
     field_counts: set[int] = attrs.field(factory=set)
     """The observed number of values for this field
     For non-array fields this will be either 0 or 1
     For array fields this will be 0 -> N
@@ -75,261 +70,356 @@
                 var_name=self.var_name,
                 field=field,
                 field_count_register_name=f"{self.var_name}%%{field.immediate}_length",
             )
         return field_data
 
 
-INNER_TRANSACTION_SUBMIT_ID_NAME = "%%inner_txn_submit_id"
-
-
 class InnerTransactionBuilder:
     def __init__(self, context: IRFunctionBuildContext):
         self.context = context
-        self._inner_txn_params_data = dict[str, CreateInnerTransactionData]()
-        self._inner_txn_submit_data = dict[str, SubmitInnerTransactionData]()
-        self._evaluated_itxn_expr = dict[awst_nodes.SingleEvaluation, str]()
-        self._last_submit_id = 0
+        self._inner_txn_fields_data = dict[str, CreateInnerTransactionData]()
+        self._create_itxn_counter = iter(range(2**64 - 1))
 
     @property
     def ssa(self) -> BraunSSA:
         return self.context.block_builder.ssa
 
     @property
     def block_builder(self) -> BlocksBuilder:
         return self.context.block_builder
 
-    def handle_inner_transaction_assignments(
+    def handle_inner_transaction_field_assignments(
+        self, stmt: awst_nodes.AssignmentStatement
+    ) -> bool:
+        value = stmt.value
+        source_location = stmt.source_location
+        target = stmt.target
+        match value:
+            case awst_nodes.CreateInnerTransaction(fields=fields):
+                ((var_name, var_loc),) = _get_assignment_target_local_names(target, 1)
+                self._set_inner_transaction_fields(var_name, fields, var_loc)
+                return True
+            case awst_nodes.Copy(
+                value=awst_nodes.Expression(wtype=wtypes.WInnerTransactionFields()) as copy_source
+            ):
+                ((var_name, var_loc),) = _get_assignment_target_local_names(target, 1)
+                src_var_name = self._resolve_inner_txn_params_var_name(copy_source)
+                self._copy_inner_transaction_fields(var_name, src_var_name, var_loc)
+                return True
+            case awst_nodes.TupleExpression(items=tuple_items) as tuple_source if any(
+                map(is_inner_transaction_field_type, tuple_source.wtype.types)
+            ):
+                names = _get_assignment_target_local_names(target, len(tuple_items))
+                for (item_name, item_loc), item_value in zip(names, tuple_items, strict=True):
+                    match item_value:
+                        case awst_nodes.CreateInnerTransaction(fields=fields):
+                            self._set_inner_transaction_fields(item_name, fields, item_loc)
+                        case awst_nodes.Copy(
+                            value=awst_nodes.Expression(
+                                wtype=wtypes.WInnerTransactionFields()
+                            ) as copy_source
+                        ):
+                            src_var_name = self._resolve_inner_txn_params_var_name(copy_source)
+                            self._copy_inner_transaction_fields(item_name, src_var_name, item_loc)
+                        case awst_nodes.Expression(wtype=wtypes.WInnerTransactionFields()):
+                            raise CodeError(
+                                "Unexpected Inner Transaction encountered in tuple", item_loc
+                            )
+                        case _:
+                            value_provider = self.context.visitor.visit_expr(item_value)
+                            assign(
+                                self.context,
+                                value_provider,
+                                names=[(item_name, item_loc)],
+                                source_location=source_location,
+                            )
+                return True
+            case awst_nodes.Expression(wtype=wtypes.WInnerTransactionFields()):
+                raise CodeError(
+                    "Inner Transaction params can only be reassigned using copy()",
+                    source_location,
+                )
+            case _:
+                return False
+
+    def _visit_submit_expr(self, expr: awst_nodes.Expression) -> Sequence[Value]:
+        value_provider = self.context.visitor.visit_expr(expr)
+        match value_provider:
+            case ValueTuple(values=values):
+                return values
+            case Value() as value:
+                return (value,)
+        raise InternalError(
+            "Unexpected result for SubmitInnerTransaction expr", expr.source_location
+        )
+
+    def handle_inner_transaction_submit_assignments(
         self,
         target: awst_nodes.Expression,
         value: awst_nodes.Expression,
         source_location: SourceLocation,
-    ) -> bool:
+    ) -> Sequence[Register] | None:
         """Performs special handling for inner transaction related assignments
 
         Returns True if assignment was handled, False otherwise"""
         # assign submit to unpacked tuples
-        if isinstance(value, awst_nodes.SubmitInnerTransaction):
-            num_inner_txns = len(value.itxns)
-            names = self._get_expression_names(target, num_inner_txns)
-            self.handle_submit_inner_transaction(value, names)
-        # assign a tuple expression containing inner transaction results
-        elif (
-            isinstance(target, awst_nodes.TupleExpression)
-            and isinstance(value, awst_nodes.TupleExpression)
-            and any(isinstance(i.wtype, wtypes.WInnerTransaction) for i in value.items)
-        ):
-            for item_target, item_value in zip(target.items, value.items, strict=True):
-                if isinstance(item_value, awst_nodes.SubmitInnerTransaction):
-                    names = self._get_expression_names(item_target, 1)
-                    self.handle_submit_inner_transaction(item_value, names)
-                elif isinstance(item_value.wtype, wtypes.WInnerTransaction) and isinstance(
-                    item_value, awst_nodes.SingleEvaluation
-                ):
-                    (dst_name,) = self._get_expression_names(item_target, 1)
-                    src_name = self._get_itxn_var_name(item_value)
-                    self._inner_txn_submit_data[dst_name] = self._inner_txn_submit_data[src_name]
-                else:
-                    value_provider = self.context.visitor.visit_expr(item_value)
-                    handle_assignment(self.context, item_target, value_provider, source_location)
-        # assign itxn fields to local temporaries
-        elif isinstance(value.wtype, wtypes.WInnerTransactionFields):
-            match target:
-                case awst_nodes.VarExpression(name=var_name, source_location=var_loc):
-                    pass
-                case _:
-                    raise CodeError(
-                        "Inner Transaction params can only be assigned to (non-tuple) variables",
-                        source_location,
-                    )
-            match value:
-                case awst_nodes.CreateInnerTransaction(fields=fields):
-                    self._set_inner_transaction_fields(var_name, fields, var_loc)
-                case awst_nodes.Copy(value=value):
-                    src_var_name = self._resolve_inner_txn_params_var_name(value)
-                    self._copy_inner_transaction_fields(var_name, src_var_name, var_loc)
-                case _:
-                    raise CodeError(
-                        "Inner Transaction params can only be reassigned using copy()",
-                        source_location,
-                    )
-        # reassigning itxn results is not allowed
-        elif isinstance(value.wtype, wtypes.WInnerTransaction):
-            if isinstance(value, awst_nodes.SingleEvaluation):
-                (dst_name,) = self._get_expression_names(target, 1)
-                src_name = self._get_itxn_var_name(value)
-                self._inner_txn_submit_data[dst_name] = self._inner_txn_submit_data[src_name]
-            else:
+        match value:
+            case awst_nodes.SingleEvaluation(source=single_eval):
+                return self.handle_inner_transaction_submit_assignments(
+                    target, single_eval, source_location
+                )
+            case awst_nodes.SubmitInnerTransaction() as submit_expr:
+                names = _get_assignment_target_local_names(target, len(submit_expr.itxns))
+                submit = self._visit_submit_expr(submit_expr)
+                return self._assign_submit_inner_transaction_fields(names, submit, source_location)
+            case awst_nodes.TupleExpression(items=tuple_items) if any(
+                isinstance(i.wtype, wtypes.WInnerTransaction) for i in tuple_items
+            ):
+                names = _get_assignment_target_local_names(target, len(tuple_items))
+                result = []
+                for (item_name, item_loc), item_value in zip(names, tuple_items, strict=True):
+                    # check for a nested SubmitInnerTransaction with >1 transaction
+                    if (
+                        isinstance(item_value.wtype, wtypes.WTuple)
+                        and len(item_value.wtype.types) != 1
+                    ):
+                        raise CodeError(
+                            f"Unsupported nested/compound type encountered: {item_value.wtype}",
+                            item_loc,
+                        )
+                    if isinstance(item_value.wtype, wtypes.WInnerTransaction):
+                        submit = self._visit_submit_expr(item_value)
+                        (item,) = self._assign_submit_inner_transaction_fields(
+                            [(item_name, item_loc)], submit, item_loc
+                        )
+                    else:
+                        value_provider = self.context.visitor.visit_expr(item_value)
+                        (item,) = assign(
+                            self.context,
+                            value_provider,
+                            names=[(item_name, item_loc)],
+                            source_location=source_location,
+                        )
+                    result.append(item)
+                return result
+            case awst_nodes.Expression(wtype=wtypes.WInnerTransaction()):
                 raise CodeError(
                     "Inner Transactions cannot be reassigned",
                     source_location,
                 )
-        else:
-            # not a itxn scenario
-            return False
-        return True
+        return None
 
     def handle_update_inner_transaction(self, call: awst_nodes.UpdateInnerTransaction) -> None:
         var_name = self._resolve_inner_txn_params_var_name(call.itxn)
         self._set_inner_transaction_fields(
             var_name, call.fields, call.source_location, update=True
         )
 
     def handle_inner_transaction_field(
         self, itxn_field: awst_nodes.InnerTransactionField
     ) -> ValueProvider:
         src_loc = itxn_field.source_location
         field = itxn_field.field
-        submit_data = self._resolve_itxn_group_index(itxn_field.itxn)
-        var_name = submit_data.var_name
-        group_txn_index = submit_data.group_index
-
-        if field.is_array:
-            if itxn_field.array_index is None:
-                raise InternalError("expected array_index expression", itxn_field.source_location)
-            self._assert_submit_id_is_correct(var_name, submit_data.submit_id, src_loc)
-            array_index = self.context.visitor.visit_and_materialise_single(itxn_field.array_index)
-            return (
-                Intrinsic(
-                    op=AVMOp.itxnas,
-                    immediates=[field.immediate],
-                    args=[array_index],
-                    source_location=src_loc,
+        if field.is_array != bool(itxn_field.array_index):
+            raise InternalError(
+                "inconsistent array_index for inner transaction field",
+                src_loc,
+            )
+
+        itxn = self.context.visitor.visit_expr(itxn_field.itxn)
+        if not isinstance(itxn, Register | ITxnConstant):
+            itxn_field_desc = {itxn_field.itxn.accept(ToCodeVisitor())}
+            raise CodeError(
+                f"Could not resolve inner transaction group index for {itxn_field_desc}",
+                src_loc,
+            )
+
+        # use cached field if available
+        if isinstance(itxn, Register):
+            field_var_name = _get_txn_field_var_name(itxn.name, field.immediate)
+            if self.ssa.has_version(field_var_name):
+                return self.ssa.read_variable(
+                    field_var_name, wtype_to_ir_type(field.wtype), self.block_builder.active_block
+                )
+
+        match itxn:
+            # use is_last register if it is defined
+            case Register(name=itxn_name) if self.ssa.has_version(_get_txn_is_last(itxn_name)):
+                is_last_in_group: Value = self.ssa.read_variable(
+                    _get_txn_is_last(itxn_name),
+                    IRType.bool,
+                    self.block_builder.active_block,
                 )
-                if submit_data.is_last_in_group
-                else Intrinsic(
-                    op=AVMOp.gitxnas,
-                    immediates=[group_txn_index, field.immediate],
-                    args=[array_index],
+            # otherwise infer based on itxn expr
+            case _:
+                is_last_in_group = UInt64Constant(
+                    value=int(_is_single_submit_expr(itxn_field.itxn)),
+                    ir_type=IRType.bool,
                     source_location=src_loc,
                 )
-            )
-        field_var_name = get_inner_txn_field_name(var_name, field.immediate)
-        return self.ssa.read_variable(
-            field_var_name, wtype_to_avm_type(field.wtype), self.block_builder.active_block
+
+        return InnerTransactionField(
+            group_index=itxn,
+            is_last_in_group=is_last_in_group,
+            array_index=(
+                self.context.visitor.visit_and_materialise_single(itxn_field.array_index)
+                if itxn_field.array_index
+                else None
+            ),
+            field=field.immediate,
+            type=wtype_to_ir_type(field.wtype),
+            source_location=src_loc,
         )
 
     def handle_submit_inner_transaction(
-        self,
-        submit: awst_nodes.SubmitInnerTransaction,
-        submit_var_names: Sequence[str] | None = None,
-    ) -> tuple[SubmitInnerTransactionData, ...]:
+        self, submit: awst_nodes.SubmitInnerTransaction
+    ) -> Sequence[ITxnConstant]:
         src_loc = submit.source_location
+
         self.block_builder.add(
             Intrinsic(
                 op=AVMOp.itxn_begin,
                 source_location=src_loc,
             )
         )
-        self._last_submit_id += 1
-        result = list[SubmitInnerTransactionData]()
-        num_inner_txns = len(submit.itxns)
-        last_group_index = num_inner_txns - 1
-        if submit_var_names is None:
-            submit_var_names = [
-                self.context.next_tmp_name(f"submit_result_{i}") for i in range(num_inner_txns)
-            ]
-        for group_index, (submit_var_name, param) in enumerate(
-            zip(submit_var_names, submit.itxns, strict=True)
-        ):
+
+        group_indexes = []
+        for group_index, param in enumerate(submit.itxns):
+            submit_var_loc = param.source_location
             if group_index > 0:
                 self.block_builder.add(
                     Intrinsic(
                         op=AVMOp.itxn_next,
-                        source_location=src_loc,
+                        source_location=submit_var_loc,
                     )
                 )
             param_var_name = self._resolve_inner_txn_params_var_name(param)
-            next_txn = BasicBlock(comment="next_txn", source_location=submit.source_location)
-            param_data = self._inner_txn_params_data[param_var_name]
+            next_txn = BasicBlock(comment="next_txn", source_location=submit_var_loc)
+            param_data = self._inner_txn_fields_data[param_var_name]
 
             # with the current implementation, reversing the order itxn_field is called
             # results in less stack manipulations as most values are naturally in the
             # required order when stack allocation occurs
             for field, field_data in reversed(param_data.fields.items()):
                 field_value_counts = sorted(field_data.field_counts)
                 if not field_value_counts or field_value_counts == [0]:
                     # nothing to do
                     continue
 
                 min_num_values, *remaining_values = field_value_counts
                 # values 0 -> min_num_values do not need to test
                 # values min_num_values -> max_num_values need to check if they are set
-                next_field = BasicBlock(comment="next_field", source_location=src_loc)
+                next_field = BasicBlock(comment="next_field", source_location=submit_var_loc)
                 self._set_field_values(field_data, 0, min_num_values)
 
                 if remaining_values:
                     last_num_values = min_num_values
                     for next_num_values in remaining_values:
                         set_fields_blk = BasicBlock(
-                            comment=f"set_{field.immediate}_{last_num_values}_to_{next_num_values-1}",
-                            source_location=src_loc,
+                            comment=(
+                                f"set_{field.immediate}_{last_num_values}_to_{next_num_values - 1}"
+                            ),
+                            source_location=submit_var_loc,
                         )
                         self.block_builder.terminate(
                             ConditionalBranch(
                                 condition=self._get_is_field_count_gte(
                                     field_data, next_num_values
                                 ),
                                 non_zero=set_fields_blk,
                                 zero=next_field,
-                                source_location=None,
+                                source_location=submit_var_loc,
                             )
                         )
                         self.ssa.seal_block(set_fields_blk)
 
                         self.block_builder.activate_block(set_fields_blk)
                         self._set_field_values(field_data, last_num_values, next_num_values)
                         last_num_values = next_num_values
 
                     self.block_builder.goto_and_activate(next_field)
                     self.ssa.seal_block(next_field)
-            submit_data = SubmitInnerTransactionData(
-                group_index=group_index,
-                is_last_in_group=group_index == last_group_index,
-                submit_id=self._last_submit_id,
-                var_name=submit_var_name,
+
+            group_indexes.append(
+                ITxnConstant(
+                    value=group_index,
+                    source_location=submit_var_loc,
+                    ir_type=IRType.itxn_group_idx,
+                )
             )
-            self._inner_txn_submit_data[submit_var_name] = submit_data
-            result.append(submit_data)
 
             self.block_builder.goto_and_activate(next_txn)
             self.ssa.seal_block(next_txn)
 
         self.block_builder.add(
             Intrinsic(
                 op=AVMOp.itxn_submit,
                 source_location=src_loc,
             )
         )
 
-        assign(
-            context=self.context,
-            source=UInt64Constant(
-                value=self._last_submit_id, source_location=submit.source_location
-            ),
-            names=[(INNER_TRANSACTION_SUBMIT_ID_NAME, submit.source_location)],
-            source_location=submit.source_location,
-        )
-        for data in result:
-            self._assign_inner_txn_fields(data, submit.source_location)
+        return group_indexes
 
-        return tuple(result)
+    def _assign_submit_inner_transaction_fields(
+        self,
+        submit_var_names: Sequence[tuple[str, SourceLocation | None]],
+        group_indexes: Sequence[Value],
+        src_loc: SourceLocation,
+    ) -> Sequence[Register]:
+        group_registers = []
+        last_index = group_indexes[-1]
+        for (var_name, var_loc), group_index in zip(submit_var_names, group_indexes, strict=True):
+            (group_index_reg,) = assign(
+                self.context,
+                source=group_index,
+                names=[(var_name, var_loc)],
+                source_location=src_loc,
+            )
+            (is_last_in_group,) = assign(
+                self.context,
+                source=UInt64Constant(
+                    value=int(group_index == last_index),
+                    ir_type=IRType.bool,
+                    source_location=var_loc,
+                ),
+                names=[(_get_txn_is_last(var_name), var_loc)],
+                source_location=src_loc,
+            )
+            for field in _INNER_TRANSACTION_NON_ARRAY_FIELDS:
+                field_reg = _get_txn_field_var_name(group_index_reg.name, field.immediate)
+                assign(
+                    context=self.context,
+                    source=InnerTransactionField(
+                        field=field.immediate,
+                        group_index=group_index_reg,
+                        is_last_in_group=is_last_in_group,
+                        type=wtype_to_ir_type(field.wtype),
+                        array_index=None,
+                        source_location=group_index.source_location,
+                    ),
+                    names=[(field_reg, group_index.source_location)],
+                    source_location=group_index.source_location,
+                )
+            group_registers.append(group_index_reg)
+
+        return group_registers
 
     def _set_field_values(
         self,
         field_data: CreateInnerTransactionFieldData,
         idx_from: int,
         idx_to: int,
     ) -> None:
         field = field_data.field
-        field_atype = wtype_to_avm_type(field.wtype)
+        field_ir_type = wtype_to_ir_type(field.wtype)
         for idx in range(idx_from, idx_to):
             field_value = self.ssa.read_variable(
                 field_data.get_value_register_name(idx),
-                field_atype,
+                field_ir_type,
                 self.block_builder.active_block,
             )
             self.block_builder.add(
                 Intrinsic(
                     op=AVMOp.itxn_field,
                     source_location=None,
                     immediates=[field.immediate],
@@ -339,15 +429,15 @@
 
     def _get_is_field_count_gte(
         self, field_data: CreateInnerTransactionFieldData, count: int
     ) -> Register:
         field = field_data.field
         len_register = self.ssa.read_variable(
             field_data.field_count_register_name,
-            AVMType.uint64,
+            IRType.uint64,
             self.block_builder.active_block,
         )
 
         (is_field_count_gte,) = assign_intrinsic_op(
             self.context,
             target=f"is_{field.immediate}_count_gte_{count}",
             op=AVMOp.gte,
@@ -360,17 +450,29 @@
         self,
         var_name: str,
         inner_txn_fields: Mapping[awst_nodes.TxnField, awst_nodes.Expression],
         var_loc: SourceLocation,
         *,
         update: bool = False,
     ) -> None:
-        param_data = self._inner_txn_params_data.setdefault(
+        param_data = self._inner_txn_fields_data.setdefault(
             var_name, CreateInnerTransactionData(var_name=var_name)
         )
+        # assign a unique constant to var_name, not used for anything directly, but prevents
+        # an undefined variable warning
+        assign(
+            context=self.context,
+            source=ITxnConstant(
+                value=next(self._create_itxn_counter),
+                source_location=var_loc,
+                ir_type=IRType.itxn_field_set,
+            ),
+            names=[(var_name, var_loc)],
+            source_location=var_loc,
+        )
         fields = StableSet.from_iter(inner_txn_fields)
         if not update:
             # add missing fields to end
             for field in awst_nodes.INNER_PARAM_TXN_FIELDS:
                 if field not in fields:
                     fields.add(field)
         for field in fields:
@@ -402,168 +504,102 @@
                 names=[(field_data.field_count_register_name, var_loc)],
                 source_location=count_loc,
             )
 
     def _copy_inner_transaction_fields(
         self, dest_var_name: str, src_var_name: str, var_loc: SourceLocation
     ) -> None:
-        src_params_data = self._inner_txn_params_data[src_var_name]
-        dest_params_data = self._inner_txn_params_data.setdefault(
+        src_params_data = self._inner_txn_fields_data[src_var_name]
+        dest_params_data = self._inner_txn_fields_data.setdefault(
             dest_var_name, CreateInnerTransactionData(var_name=dest_var_name)
         )
         for field in awst_nodes.INNER_PARAM_TXN_FIELDS:
             src_field_data = src_params_data.get_or_add_field_data(field)
 
             dest_field_data = dest_params_data.get_or_add_field_data(field)
             dest_field_data.field_counts.update(src_field_data.field_counts)
             for idx, src_field_register in src_field_data.value_registers.items():
                 dest_field_register = dest_field_data.get_value_register_name(idx)
                 assign(
                     context=self.context,
                     source=self.ssa.read_variable(
                         src_field_register,
-                        wtype_to_avm_type(field.wtype),
+                        wtype_to_ir_type(field.wtype),
                         self.block_builder.active_block,
                     ),
                     names=[(dest_field_register, var_loc)],
                     source_location=var_loc,
                 )
             assign(
                 context=self.context,
                 source=self.ssa.read_variable(
                     src_field_data.field_count_register_name,
-                    AVMType.uint64,
+                    IRType.uint64,
                     self.block_builder.active_block,
                 ),
                 names=[(dest_field_data.field_count_register_name, var_loc)],
                 source_location=var_loc,
             )
 
-    def _assert_submit_id_is_correct(
-        self, var_name: str, submit_id: int, loc: SourceLocation
-    ) -> None:
-        current_submit_id = self.ssa.read_variable(
-            INNER_TRANSACTION_SUBMIT_ID_NAME, AVMType.uint64, self.block_builder.active_block
-        )
-        (submit_id_eq,) = assign_intrinsic_op(
-            context=self.context,
-            target=f"submit_id_is_{submit_id}",
-            op=AVMOp.eq,
-            args=[current_submit_id, submit_id],
-            source_location=loc,
-        )
-        self.block_builder.add(
-            Intrinsic(
-                op=AVMOp.assert_,
-                args=[submit_id_eq],
-                comment=f"'{var_name}' can still be accessed",
-                source_location=loc,
-            )
-        )
-
-    def _resolve_itxn_group_index(self, expr: awst_nodes.Expression) -> SubmitInnerTransactionData:
-        match expr:
-            case awst_nodes.VarExpression(name=var_name):
-                try:
-                    return self._inner_txn_submit_data[var_name]
-                except KeyError:
-                    pass
-            case awst_nodes.SingleEvaluation() as itxn_var:
-                var_name = self._get_itxn_var_name(itxn_var)
-                try:
-                    return self._inner_txn_submit_data[var_name]
-                except KeyError:
-                    pass
-            case awst_nodes.SubmitInnerTransaction() as submit:
-                submit_data = self.handle_submit_inner_transaction(submit)
-                try:
-                    (first_submit,) = submit_data
-                except ValueError as ex:
-                    raise InternalError(
-                        f"Expected 1 inner transaction when submitting "
-                        f"got: {len(submit_data)}",
-                        expr.source_location,
-                    ) from ex
-                return first_submit
-        raise CodeError(
-            f"Could not resolve inner transaction group index for {expr.accept(ToCodeVisitor())}",
-            expr.source_location,
-        )
-
-    def _get_itxn_var_name(self, expr: awst_nodes.SingleEvaluation) -> str:
-        try:
-            return self._evaluated_itxn_expr[expr]
-        except KeyError:
-            pass
-        if not isinstance(expr.source, awst_nodes.SubmitInnerTransaction):
-            raise CodeError("Could not resolve inner transaction", expr.source_location)
-        var_name = f"tmp_itxn_{len(self._evaluated_itxn_expr)}"
-        self._evaluated_itxn_expr[expr] = var_name
-        self.handle_submit_inner_transaction(expr.source, (var_name,))
-        return var_name
-
     def _resolve_inner_txn_params_var_name(self, params: awst_nodes.Expression) -> str:
         match params:
             case awst_nodes.CreateInnerTransaction() as itxn:
                 var_name = self.context.next_tmp_name(description="inner_txn_params")
                 self._set_inner_transaction_fields(
                     var_name=var_name, inner_txn_fields=itxn.fields, var_loc=itxn.source_location
                 )
             case awst_nodes.VarExpression(name=var_name):
                 pass
+            case awst_nodes.TupleItemExpression(
+                base=awst_nodes.VarExpression(name=name), index=index
+            ):
+                return format_tuple_index(name, index)
             case awst_nodes.Copy(value=value):
                 return self._resolve_inner_txn_params_var_name(value)
             case _:
                 raise InternalError(
                     "Could not resolve var_name for inner transaction params",
                     params.source_location,
                 )
         return var_name
 
-    def _assign_inner_txn_fields(
-        self, submit_data: SubmitInnerTransactionData, source_location: SourceLocation
-    ) -> None:
-        for field in _INNER_TRANSACTION_NON_ARRAY_FIELDS:
-            register_name = get_inner_txn_field_name(submit_data.var_name, field.immediate)
-            value = (
-                Intrinsic(
-                    op=AVMOp.itxn,
-                    immediates=[field.immediate],
-                    source_location=source_location,
-                )
-                if submit_data.is_last_in_group
-                else Intrinsic(
-                    op=AVMOp.gitxn,
-                    immediates=[submit_data.group_index, field.immediate],
-                    source_location=source_location,
-                )
-            )
-            assign(
-                context=self.context,
-                source=value,
-                names=[(register_name, source_location)],
-                source_location=source_location,
-            )
 
-    def _get_expression_names(
-        self, expr: awst_nodes.Expression, expected_number: int
-    ) -> list[str]:
-        match expr:
-            case awst_nodes.VarExpression(name=var_name) if expected_number == 1:
-                names = [var_name]
-            case awst_nodes.TupleExpression(items=items) if expected_number == len(items) and all(
-                isinstance(i, awst_nodes.VarExpression) for i in items
-            ):
-                items = typing.cast(Sequence[awst_nodes.VarExpression], items)
-                names = [expr.name for expr in items]
-            case awst_nodes.SingleEvaluation() as itxn:
-                names = [self._get_itxn_var_name(itxn)]
-            case _:
-                raise CodeError(
-                    "Inner Transactions can only be assigned to local variables",
-                    expr.source_location,
-                )
-        return names
+def _get_assignment_target_local_names(
+    target: awst_nodes.Expression, expected_number: int
+) -> Sequence[tuple[str, SourceLocation]]:
+    match target:
+        case awst_nodes.VarExpression(name=var_name) if expected_number == 1:
+            names = [(var_name, target.source_location)]
+        case awst_nodes.VarExpression(name=var_name):
+            names = [
+                (format_tuple_index(var_name, idx), target.source_location)
+                for idx in range(expected_number)
+            ]
+        case awst_nodes.TupleExpression(items=items) if expected_number == len(items) and all(
+            isinstance(i, awst_nodes.VarExpression) for i in items
+        ):
+            items = typing.cast(Sequence[awst_nodes.VarExpression], items)
+            names = [(expr.name, expr.source_location) for expr in items]
+        case _:
+            raise CodeError(
+                "Inner Transactions can only be assigned to local variables",
+                target.source_location,
+            )
+    return names
+
+
+def _is_single_submit_expr(expr: awst_nodes.Expression) -> bool:
+    match expr:
+        case awst_nodes.SubmitInnerTransaction(itxns=itxns) if len(itxns) == 1:
+            return True
+        case awst_nodes.SingleEvaluation(source=source):
+            return _is_single_submit_expr(source)
+        case _:
+            return False
+
+
+def _get_txn_field_var_name(var_name: str, field: str) -> str:
+    return f"{var_name}.{field}"
 
 
-def get_inner_txn_field_name(var_name: str, field: str) -> str:
-    return f"{var_name}%%{field}"
+def _get_txn_is_last(var_name: str) -> str:
+    return f"{var_name}._is_last"
```

## puya/ir/builder/main.py

```diff
@@ -4,26 +4,19 @@
 import puya.awst.visitors
 from puya import log
 from puya.avm_type import AVMType
 from puya.awst import (
     nodes as awst_nodes,
     wtypes,
 )
-from puya.awst.nodes import (
-    BigUIntBinaryOperator,
-    UInt64BinaryOperator,
-)
-from puya.errors import CodeError, InternalError, TodoError
+from puya.awst.nodes import BigUIntBinaryOperator, UInt64BinaryOperator
+from puya.errors import CodeError, InternalError
 from puya.ir.avm_ops import AVMOp
 from puya.ir.builder import arc4, flow_control, state
-from puya.ir.builder._utils import (
-    assert_value,
-    assign,
-    mkblocks,
-)
+from puya.ir.builder._utils import assert_value, assign, mkblocks
 from puya.ir.builder.assignment import handle_assignment, handle_assignment_expr
 from puya.ir.builder.callsub import visit_subroutine_call_expression
 from puya.ir.builder.iteration import handle_for_in_loop
 from puya.ir.builder.itxn import InnerTransactionBuilder
 from puya.ir.context import IRBuildContext, IRFunctionBuildContext
 from puya.ir.models import (
     AddressConstant,
@@ -42,17 +35,18 @@
     UInt64Constant,
     Value,
     ValueProvider,
     ValueTuple,
 )
 from puya.ir.types_ import (
     AVMBytesEncoding,
+    IRType,
     bytes_enc_to_avm_bytes_enc,
-    wtype_to_avm_type,
-    wtype_to_avm_types,
+    wtype_to_ir_type,
+    wtype_to_ir_types,
 )
 from puya.ir.utils import format_tuple_index
 from puya.parse import SourceLocation
 
 TExpression: typing.TypeAlias = ValueProvider | None
 TStatement: typing.TypeAlias = None
 
@@ -88,17 +82,19 @@
                 func_ctx.block_builder.maybe_add_implicit_subroutine_return(subroutine.parameters)
             func_ctx.ssa.verify_complete()
             func_ctx.block_builder.validate_block_predecessors()
             result = list(func_ctx.block_builder.blocks)
             if not result[-1].terminated:
                 raise CodeError(
                     "Expected a return statement",
-                    function.body.body[-1].source_location
-                    if function.body.body
-                    else function.source_location,
+                    (
+                        function.body.body[-1].source_location
+                        if function.body.body
+                        else function.source_location
+                    ),
                 )
             subroutine.body = result
             subroutine.validate_with_ssa()
 
     def visit_copy(self, expr: puya.awst.nodes.Copy) -> TExpression:
         # For reference types, we need to clone the data
         # For value types, we can just visit the expression and the resulting read
@@ -122,30 +118,30 @@
     def visit_arc4_decode(self, expr: awst_nodes.ARC4Decode) -> TExpression:
         return arc4.decode_expr(self.context, expr)
 
     def visit_arc4_encode(self, expr: awst_nodes.ARC4Encode) -> TExpression:
         return arc4.encode_expr(self.context, expr)
 
     def visit_assignment_statement(self, stmt: awst_nodes.AssignmentStatement) -> TStatement:
-        if not self._itxn.handle_inner_transaction_assignments(
+        if self._itxn.handle_inner_transaction_field_assignments(stmt):  # noqa: SIM114
+            pass
+        elif self._itxn.handle_inner_transaction_submit_assignments(
             stmt.target, stmt.value, stmt.source_location
         ):
+            pass
+        else:
             handle_assignment_expr(
                 self.context,
                 target=stmt.target,
                 value=stmt.value,
                 assignment_location=stmt.source_location,
             )
         return None
 
     def visit_assignment_expression(self, expr: awst_nodes.AssignmentExpression) -> TExpression:
-        if self._itxn.handle_inner_transaction_assignments(
-            expr.target, expr.value, expr.source_location
-        ):
-            return None
         result = handle_assignment_expr(
             self.context,
             target=expr.target,
             value=expr.value,
             assignment_location=expr.source_location,
         )
         if not result:
@@ -219,15 +215,17 @@
             case _:
                 raise InternalError(
                     f"Unhandled wtype {expr.wtype} for decimal constant {expr.value}",
                     expr.source_location,
                 )
 
     def visit_bool_constant(self, expr: awst_nodes.BoolConstant) -> TExpression:
-        return UInt64Constant(value=int(expr.value), source_location=expr.source_location)
+        return UInt64Constant(
+            value=int(expr.value), ir_type=IRType.bool, source_location=expr.source_location
+        )
 
     def visit_bytes_constant(self, expr: awst_nodes.BytesConstant) -> BytesConstant:
         return BytesConstant(
             value=expr.value,
             encoding=bytes_enc_to_avm_bytes_enc(expr.encoding),
             source_location=expr.source_location,
         )
@@ -246,26 +244,20 @@
         )
 
     def visit_numeric_comparison_expression(
         self, expr: awst_nodes.NumericComparisonExpression
     ) -> TExpression:
         left = self.visit_and_materialise_single(expr.lhs)
         right = self.visit_and_materialise_single(expr.rhs)
-        if not (left.atype & right.atype):
+        if left.atype != right.atype:
             raise InternalError(
                 "Numeric comparison between different numeric types", expr.source_location
             )
-        if left.atype != AVMType.any:
-            atype = left.atype
-        elif right.atype != AVMType.any:
-            atype = right.atype
-        else:
-            raise InternalError("Numeric comparison mapped to any type", expr.source_location)
         op_code = expr.operator.value
-        if atype == AVMType.bytes:
+        if left.atype == AVMType.bytes:
             op_code = "b" + op_code
 
         try:
             avm_op = AVMOp(op_code)
         except ValueError as ex:
             raise InternalError(
                 f"Unmapped numeric comparison operator {expr.operator}", expr.source_location
@@ -296,23 +288,23 @@
     def visit_var_expression(self, expr: awst_nodes.VarExpression) -> TExpression:
         if isinstance(expr.wtype, wtypes.WTuple):
             return ValueTuple(
                 source_location=expr.source_location,
                 values=[
                     self.context.ssa.read_variable(
                         variable=format_tuple_index(expr.name, idx),
-                        atype=wtype_to_avm_type(wt, expr.source_location),
+                        ir_type=wtype_to_ir_type(wt, expr.source_location),
                         block=self.context.block_builder.active_block,
                     )
                     for idx, wt in enumerate(expr.wtype.types)
                 ],
             )
-        atype = wtype_to_avm_type(expr)
+        ir_type = wtype_to_ir_type(expr)
         variable = self.context.ssa.read_variable(
-            expr.name, atype, self.context.block_builder.active_block
+            expr.name, ir_type, self.context.block_builder.active_block
         )
         return variable
 
     def visit_intrinsic_call(self, call: awst_nodes.IntrinsicCall) -> TExpression:
         match call.op_code:
             case "err":
                 self.context.block_builder.terminate(
@@ -330,28 +322,35 @@
             case _:
                 args = [self.visit_and_materialise_single(arg) for arg in call.stack_args]
                 return Intrinsic(
                     op=AVMOp(call.op_code),
                     source_location=call.source_location,
                     args=args,
                     immediates=list(call.immediates),
-                    types=wtype_to_avm_types(call.wtype),
+                    types=wtype_to_ir_types(call.wtype),
                 )
 
     def visit_create_inner_transaction(self, call: awst_nodes.CreateInnerTransaction) -> None:
-        raise InternalError(
-            "Inner transaction parameters can only be assigned to local variables",
-            call.source_location,
+        # for semantic compatibility, this is an error, since we don't evaluate the args
+        # here (there would be no point, if we hit this node on its own and not as part
+        # of a submit or an assigment, it does nothing)
+        logger.error(
+            "statement has no effect, did you forget to submit?", location=call.source_location
         )
 
     def visit_submit_inner_transaction(
         self, submit: awst_nodes.SubmitInnerTransaction
     ) -> TExpression:
-        self._itxn.handle_submit_inner_transaction(submit)
-        return None
+        result = self._itxn.handle_submit_inner_transaction(submit)
+        if len(result) == 1:
+            return result[0]
+        return ValueTuple(
+            values=list(result),
+            source_location=submit.source_location,
+        )
 
     def visit_update_inner_transaction(self, call: awst_nodes.UpdateInnerTransaction) -> None:
         self._itxn.handle_update_inner_transaction(call)
 
     def visit_inner_transaction_field(
         self, itxn_field: awst_nodes.InnerTransactionField
     ) -> TExpression:
@@ -360,27 +359,60 @@
     def visit_method_constant(self, expr: puya.awst.nodes.MethodConstant) -> TExpression:
         return MethodConstant(value=expr.value, source_location=expr.source_location)
 
     def visit_tuple_expression(self, expr: awst_nodes.TupleExpression) -> TExpression:
         items = []
         for item in expr.items:
             # TODO: don't rely on a pure function's side effects (raising) for validation
-            wtype_to_avm_type(item)
+            wtype_to_ir_type(item)
             items.append(self.visit_and_materialise_single(item))
         return ValueTuple(
             source_location=expr.source_location,
             values=items,
         )
 
     def visit_tuple_item_expression(self, expr: awst_nodes.TupleItemExpression) -> TExpression:
-        tup = self.visit_and_materialise(expr.base)
-        return tup[expr.index]
+        if isinstance(expr.base.wtype, wtypes.WTuple):
+            tup = self.visit_and_materialise(expr.base)
+            return tup[expr.index]
+        elif isinstance(expr.base.wtype, wtypes.ARC4Tuple):
+            base = self.visit_and_materialise_single(expr.base)
+            return arc4.arc4_tuple_index(
+                self.context,
+                base=base,
+                index=expr.index,
+                wtype=expr.base.wtype,
+                source_location=expr.source_location,
+            )
+        else:
+            raise InternalError(
+                f"Tuple indexing operation IR lowering"
+                f" not implemented for base type {expr.base.wtype.name}",
+                expr.source_location,
+            )
 
     def visit_field_expression(self, expr: awst_nodes.FieldExpression) -> TExpression:
-        raise TodoError(expr.source_location, "TODO: IR building: visit_field_expression")
+        if isinstance(expr.base.wtype, wtypes.WStructType):
+            raise NotImplementedError
+        elif isinstance(expr.base.wtype, wtypes.ARC4Struct):  # noqa: RET506
+            base = self.visit_and_materialise_single(expr.base)
+            index = expr.base.wtype.names.index(expr.name)
+            return arc4.arc4_tuple_index(
+                self.context,
+                base=base,
+                index=index,
+                wtype=expr.base.wtype,
+                source_location=expr.source_location,
+            )
+        else:
+            raise InternalError(
+                f"Field access IR lowering"
+                f" not implemented for base type {expr.base.wtype.name}",
+                expr.source_location,
+            )
 
     def visit_slice_expression(self, expr: awst_nodes.SliceExpression) -> TExpression:
         """Slices an enumerable type."""
         if isinstance(expr.wtype, wtypes.WTuple):
             values = list(self.visit_and_materialise(expr.base))
             start_i = extract_const_int(expr.begin_index)
             end_i = extract_const_int(expr.end_index)
@@ -422,24 +454,23 @@
                 )
                 return Intrinsic(
                     op=AVMOp.substring3,
                     args=[base, start_value, base_length],
                     source_location=expr.source_location,
                 )
         else:
-            raise TodoError(expr.source_location, f"TODO: IR Slice {expr.wtype}")
+            raise InternalError(
+                f"Slice operation IR lowering not implemented for {expr.wtype.name}",
+                expr.source_location,
+            )
 
     def visit_index_expression(self, expr: awst_nodes.IndexExpression) -> TExpression:
         index = self.visit_and_materialise_single(expr.index)
         base = self.visit_and_materialise_single(expr.base)
 
-        if expr.index.wtype != wtypes.uint64_wtype:
-            raise CodeError(
-                f"Only {wtypes.uint64_wtype} indexes are supported", expr.index.source_location
-            )
         if expr.base.wtype == wtypes.bytes_wtype:
             # note: the below works because Bytes is immutable, so this index expression
             # can never appear as an assignment target
             if isinstance(index, UInt64Constant):
                 return Intrinsic(
                     op=AVMOp.extract,
                     args=[base],
@@ -460,18 +491,29 @@
                 source_location=expr.source_location,
             )
             return Intrinsic(
                 op=AVMOp.substring3,
                 args=[base, index, index_plus_1],
                 source_location=expr.source_location,
             )
-        elif value_provider := arc4.maybe_arc4_index_expr(self.context, expr, base, index):
-            return value_provider
+        elif isinstance(expr.base.wtype, wtypes.WArray):
+            raise NotImplementedError
+        elif isinstance(expr.base.wtype, wtypes.ARC4StaticArray | wtypes.ARC4DynamicArray):
+            return arc4.arc4_array_index(
+                self.context,
+                expr.base.wtype,
+                base=base,
+                index=index,
+                source_location=expr.source_location,
+            )
         else:
-            raise CodeError(f"Indexing {expr.base.wtype} is not support", expr.source_location)
+            raise InternalError(
+                f"Indexing operation IR lowering not implemented for {expr.wtype.name}",
+                expr.source_location,
+            )
 
     def visit_conditional_expression(self, expr: awst_nodes.ConditionalExpression) -> TExpression:
         return flow_control.handle_conditional_expression(self.context, expr)
 
     def visit_single_evaluation(self, expr: awst_nodes.SingleEvaluation) -> TExpression:
         try:
             return self._single_eval_registers[expr]
@@ -514,18 +556,21 @@
     def visit_state_get(self, expr: awst_nodes.StateGet) -> TExpression:
         return state.visit_state_get(self.context, expr)
 
     def visit_state_exists(self, expr: awst_nodes.StateExists) -> TExpression:
         return state.visit_state_exists(self.context, expr)
 
     def visit_new_array(self, expr: awst_nodes.NewArray) -> TExpression:
-        raise TodoError(expr.source_location, "TODO: visit_new_array")
-
-    def visit_arc4_array_encode(self, expr: awst_nodes.ARC4ArrayEncode) -> TExpression:
-        return arc4.encode_arc4_array(self.context, expr)
+        match expr.wtype:
+            case wtypes.ARC4Array():
+                return arc4.encode_arc4_array(self.context, expr)
+            case wtypes.WArray():
+                raise NotImplementedError
+            case _:
+                typing.assert_never(expr.wtype)
 
     def visit_bytes_comparison_expression(
         self, expr: awst_nodes.BytesComparisonExpression
     ) -> TExpression:
         left = self.visit_and_materialise_single(expr.lhs)
         right = self.visit_and_materialise_single(expr.rhs)
         op_code = expr.operator.value
@@ -566,31 +611,31 @@
             self.context.ssa.seal_block(true_block)
             self.context.ssa.seal_block(false_block)
 
             tmp_name = self.context.next_tmp_name(f"{expr.op}_result")
             self.context.block_builder.activate_block(true_block)
             assign(
                 self.context,
-                UInt64Constant(value=1, source_location=None),
+                UInt64Constant(value=1, ir_type=IRType.bool, source_location=None),
                 names=[(tmp_name, None)],
                 source_location=None,
             )
             self.context.block_builder.goto(merge_block)
 
             self.context.block_builder.activate_block(false_block)
             assign(
                 self.context,
-                UInt64Constant(value=0, source_location=None),
+                UInt64Constant(value=0, ir_type=IRType.bool, source_location=None),
                 names=[(tmp_name, None)],
                 source_location=None,
             )
             self.context.block_builder.goto_and_activate(merge_block)
             self.context.ssa.seal_block(merge_block)
             return self.context.ssa.read_variable(
-                variable=tmp_name, atype=AVMType.uint64, block=merge_block
+                variable=tmp_name, ir_type=IRType.bool, block=merge_block
             )
 
         left = self.visit_and_materialise_single(expr.left)
         right = self.visit_and_materialise_single(expr.right)
         match expr.op:
             case "and":
                 op = AVMOp.and_
@@ -615,17 +660,18 @@
             source_location=expr.source_location,
         )
 
     def visit_contains_expression(self, expr: awst_nodes.Contains) -> TExpression:
         item_register = self.visit_and_materialise_single(expr.item)
 
         if not isinstance(expr.sequence.wtype, wtypes.WTuple):
-            raise TodoError(
+            raise InternalError(
+                f"Containment operation IR lowering"
+                f" not implemented for sequence type {expr.sequence.wtype.name}",
                 expr.source_location,
-                "TODO: IR building: visit_contains_expression handle non tuple contains",
             )
         items_sequence = [
             item
             for item, item_wtype in zip(
                 self.visit_and_materialise(expr.sequence), expr.sequence.wtype.types, strict=True
             )
             if item_wtype == expr.item.wtype
@@ -660,16 +706,16 @@
                 op=AVMOp.or_, args=[left_var, right_var], source_location=expr.source_location
             )
 
         return condition or UInt64Constant(source_location=expr.source_location, value=0)
 
     def visit_reinterpret_cast(self, expr: awst_nodes.ReinterpretCast) -> TExpression:
         # should be a no-op for us, but we validate the cast here too
-        inner_avm_type = wtype_to_avm_type(expr.expr)
-        outer_avm_type = wtype_to_avm_type(expr)
+        inner_avm_type = wtype_to_ir_type(expr.expr).avm_type
+        outer_avm_type = wtype_to_ir_type(expr).avm_type
         if inner_avm_type != outer_avm_type:
             raise InternalError(
                 f"Tried to reinterpret {expr.expr.wtype} as {expr.wtype},"
                 " but resulting AVM types are incompatible:"
                 f" {inner_avm_type} and {outer_avm_type}, respectively",
                 expr.source_location,
             )
@@ -698,56 +744,53 @@
             result = []
 
         for param in self.context.subroutine.parameters:
             if param.implicit_return:
                 result.append(
                     self.context.ssa.read_variable(
                         param.name,
-                        param.atype,
+                        param.ir_type,
                         self.context.block_builder.active_block,
                     )
                 )
-        return_types = [r.atype for r in result]
-        if not (
-            len(return_types) == len(self.context.subroutine.returns)
-            and all(
-                a & b for a, b in zip(return_types, self.context.subroutine.returns, strict=True)
-            )
-        ):
+        return_types = [r.ir_type for r in result]
+        if return_types != self.context.subroutine.returns:
             raise CodeError(
                 f"Invalid return type {return_types} in {self.context.function.full_name},"
                 f" should be {self.context.subroutine.returns}",
                 statement.source_location,
             )
         self.context.block_builder.terminate(
             SubroutineReturn(
                 source_location=statement.source_location,
                 result=result,
             )
         )
 
     def visit_template_var(self, expr: puya.awst.nodes.TemplateVar) -> TExpression:
-        atype = wtype_to_avm_type(expr.wtype)
-        typing.assert_type(atype, typing.Literal[AVMType.uint64, AVMType.bytes])
-        return TemplateVar(name=expr.name, atype=atype, source_location=expr.source_location)
+        return TemplateVar(
+            name=expr.name,
+            ir_type=wtype_to_ir_type(expr.wtype),
+            source_location=expr.source_location,
+        )
 
     def visit_continue_statement(self, statement: awst_nodes.ContinueStatement) -> TStatement:
         self.context.block_builder.loop_continue(statement.source_location)
 
     def visit_expression_statement(self, statement: awst_nodes.ExpressionStatement) -> TStatement:
         # NOTE: popping of ignored return values should happen at code gen time
         result = statement.expr.accept(self)
         if result is None:
             wtype = statement.expr.wtype
             match wtype:
                 case wtypes.void_wtype:
                     pass
                 case _ if (
                     wtypes.is_inner_transaction_type(wtype)
-                    or wtypes.is_inner_transaction_params_type(wtype)
+                    or wtypes.is_inner_transaction_field_type(wtype)
                     or wtypes.is_inner_transaction_tuple_type(wtype)
                 ):
                     # inner transaction wtypes aren't true expressions
                     pass
                 case _:
                     raise InternalError(
                         f"Expression statement with type {statement.expr.wtype} "
@@ -829,15 +872,21 @@
     def visit_reversed(self, expr: puya.awst.nodes.Reversed) -> TExpression:
         raise CodeError("Reversed is not valid outside of an enumeration", expr.source_location)
 
     def visit_for_in_loop(self, statement: awst_nodes.ForInLoop) -> TStatement:
         handle_for_in_loop(self.context, statement)
 
     def visit_new_struct(self, expr: awst_nodes.NewStruct) -> TExpression:
-        raise TodoError(expr.source_location, "TODO: visit_new_struct")
+        match expr.wtype:
+            case wtypes.WStructType():
+                raise NotImplementedError
+            case wtypes.ARC4Struct() as arc4_struct_wtype:
+                return arc4.encode_arc4_struct(self.context, expr, arc4_struct_wtype)
+            case _:
+                typing.assert_never(expr.wtype)
 
     def visit_array_pop(self, expr: puya.awst.nodes.ArrayPop) -> TExpression:
         source_location = expr.source_location
         match expr.base.wtype:
             case wtypes.ARC4DynamicArray() as array_wtype:
                 return arc4.pop_arc4_array(self.context, expr, array_wtype)
             case _:
```

## puya/ir/builder/state.py

```diff
@@ -1,14 +1,13 @@
-from puya.avm_type import AVMType
 from puya.awst import nodes as awst_nodes
 from puya.ir.avm_ops import AVMOp
 from puya.ir.builder._utils import assert_value, assign_targets, mktemp
 from puya.ir.context import IRFunctionBuildContext
 from puya.ir.models import BytesConstant, Intrinsic, UInt64Constant, Value, ValueProvider
-from puya.ir.types_ import bytes_enc_to_avm_bytes_enc, wtype_to_avm_type
+from puya.ir.types_ import IRType, bytes_enc_to_avm_bytes_enc, wtype_to_ir_type
 from puya.parse import SourceLocation
 
 
 def visit_app_state_expression(
     context: IRFunctionBuildContext, expr: awst_nodes.AppStateExpression
 ) -> ValueProvider:
     # TODO: add specific (unsafe) optimisation flag to allow skipping this check
@@ -59,14 +58,15 @@
     get_ex = _build_state_get_ex(context, expr.field, expr.source_location)
     maybe_value, exists = context.visitor.materialise_value_provider(
         get_ex, description=f"{expr.field.field_name}_get_ex"
     )
     return Intrinsic(
         op=AVMOp.select,
         args=[default, maybe_value, exists],
+        types=[wtype_to_ir_type(expr.wtype)],
         source_location=expr.source_location,
     )
 
 
 def visit_state_exists(
     context: IRFunctionBuildContext, expr: awst_nodes.StateExists
 ) -> ValueProvider:
@@ -79,26 +79,26 @@
 
 def _checked_state_access(
     context: IRFunctionBuildContext,
     expr: awst_nodes.AppAccountStateExpression | awst_nodes.AppStateExpression,
     assert_comment: str,
 ) -> ValueProvider:
     get = _build_state_get_ex(context, expr, expr.source_location)
-    # note: we manually construct temporary targets here since atype is any,
+    # note: we manually construct temporary targets here since ir_type is any,
     #       but we "know" the type from the expression
-    value_atype = wtype_to_avm_type(expr.wtype)
+    value_ir_type = wtype_to_ir_type(expr.wtype)
     value_tmp = mktemp(
         context,
-        atype=value_atype,
+        ir_type=value_ir_type,
         description=f"{expr.field_name}_value",
         source_location=expr.source_location,
     )
     did_exist_tmp = mktemp(
         context,
-        atype=AVMType.uint64,
+        ir_type=IRType.bool,
         description=f"{expr.field_name}_exists",
         source_location=expr.source_location,
     )
     assign_targets(
         context,
         source=get,
         targets=[value_tmp, did_exist_tmp],
@@ -128,8 +128,16 @@
     args: list[Value] = [current_app_offset, key]
     if isinstance(expr, awst_nodes.AppStateExpression):
         op = AVMOp.app_global_get_ex
     else:
         op = AVMOp.app_local_get_ex
         account = context.visitor.visit_and_materialise_single(expr.account)
         args.insert(0, account)
-    return Intrinsic(op=op, args=args, source_location=source_location)
+    return Intrinsic(
+        op=op,
+        args=args,
+        source_location=source_location,
+        types=[
+            wtype_to_ir_type(state_def.storage_wtype),
+            IRType.bool,
+        ],
+    )
```

## puya/ir/destructure/coalesce_locals.py

```diff
@@ -1,17 +1,20 @@
 import itertools
+import typing
 import typing as t
 from collections.abc import Iterable
 from copy import deepcopy
 
 import attrs
 
 from puya import log
+from puya.avm_type import AVMType
 from puya.context import CompileContext
 from puya.ir import models
+from puya.ir.types_ import IRType
 from puya.ir.visitor_mem_replacer import MemoryReplacer
 from puya.ir.vla import VariableLifetimeAnalysis
 from puya.options import LocalsCoalescingStrategy
 from puya.utils import StableSet
 
 logger = log.get_logger(__name__)
 
@@ -25,19 +28,17 @@
                 targets=[target], source=models.Register() as source
             ) if target == source:
                 return None
         return ass
 
 
 class CoalesceGroupStrategy(t.Protocol):
-    def get_group_key(self, reg: models.Register) -> object:
-        ...
+    def get_group_key(self, reg: models.Register) -> object: ...
 
-    def determine_group_replacement(self, regs: Iterable[models.Register]) -> models.Register:
-        ...
+    def determine_group_replacement(self, regs: Iterable[models.Register]) -> models.Register: ...
 
 
 def coalesce_registers(group_strategy: CoalesceGroupStrategy, sub: models.Subroutine) -> int:
     """
     A local can be merged with another local if they are never live at the same time.
 
     For each local that is being defined, check to see what the live-out locals are.
@@ -132,18 +133,25 @@
             return reg
         else:
             return reg.atype
 
     def determine_group_replacement(self, regs: Iterable[models.Register]) -> models.Register:
         next_id = next(self._counter)
         (atype,) = {r.atype for r in regs}
+        match atype:
+            case AVMType.uint64:
+                ir_type = IRType.uint64
+            case AVMType.bytes:
+                ir_type = IRType.bytes
+            case _:
+                typing.assert_never(atype)
         return models.Register(
             name="",
             version=next_id,
-            atype=atype,
+            ir_type=ir_type,
             source_location=None,
         )
 
 
 def coalesce_locals(
     context: CompileContext, contract: models.ModuleArtifact
 ) -> models.ModuleArtifact:
```

## puya/ir/destructure/parcopy.py

```diff
@@ -104,15 +104,15 @@
         ),
         default=-1,
     )
     next_tmp_id = itertools.count(max_tmp_id + 1)
 
     def make_temp(x: models.Value | models.Register) -> models.Register:
         return models.Register(
-            atype=x.atype,
+            ir_type=x.ir_type,
             name=f"{our_tmp_prefix}{next(next_tmp_id)}",
             version=0,
             source_location=x.source_location,
         )
 
     for block in sub.body:
         ops = list[models.Op]()
```

## puya/ir/destructure/remove_phi.py

```diff
@@ -13,15 +13,15 @@
     for reg in sub.get_assigned_registers():
         max_versions[reg.name] = max(max_versions.get(reg.name, 0), reg.version)
 
     def make_prime(mem: models.Register) -> models.Register:
         max_versions[mem.name] += 1
         return models.Register(
             source_location=mem.source_location,
-            atype=mem.atype,
+            ir_type=mem.ir_type,
             name=mem.name,
             version=max_versions[mem.name],
         )
 
     block_exit_copies = dict[models.BasicBlock, list[tuple[models.Register, models.Register]]]()
     undefined = set[models.Register]()
     for phi_block in sub.body:
```

## puya/ir/main.py

```diff
@@ -28,15 +28,15 @@
     Parameter,
     Program,
     Subroutine,
 )
 from puya.ir.optimize.dead_code_elimination import remove_unused_subroutines
 from puya.ir.optimize.main import optimize_contract_ir
 from puya.ir.to_text_visitor import output_artifact_ir_to_path
-from puya.ir.types_ import wtype_to_avm_type, wtype_to_avm_types
+from puya.ir.types_ import wtype_to_avm_type, wtype_to_ir_type, wtype_to_ir_types
 from puya.ir.utils import format_tuple_index
 from puya.ir.validation.main import validate_module_artifact
 from puya.models import (
     ARC4Method,
     ARC4MethodConfig,
     ContractMetaData,
     ContractState,
@@ -113,15 +113,15 @@
         artifact_ir_base_path if context.options.output_optimization_ir else None,
     )
     artifact_ir = destructure_ssa(context, artifact_ir)
     if context.options.output_destructured_ir:
         output_artifact_ir_to_path(
             artifact_ir, artifact_ir_base_path.with_suffix(".destructured.ir")
         )
-    # re-run validation post everything, in case we've accidentally inserted something,
+    # validation is run as the last step, in case we've accidentally inserted something,
     # and in particular post subroutine removal, because some things that are "linked"
     # are not necessarily used from the current artifact
     validate_module_artifact(context, artifact_ir)
     return artifact_ir
 
 
 def _build_embedded_ir(ctx: IRBuildContext) -> None:
@@ -240,24 +240,24 @@
     for arg in args:
         if isinstance(arg.wtype, wtypes.WTuple):
             for tup_idx, tup_type in enumerate(arg.wtype.types):
                 yield Parameter(
                     source_location=arg.source_location,
                     version=0,
                     name=format_tuple_index(arg.name, tup_idx),
-                    atype=wtype_to_avm_type(tup_type),
+                    ir_type=wtype_to_ir_type(tup_type),
                     implicit_return=allow_implicits and not tup_type.immutable,
                 )
         else:
             yield (
                 Parameter(
                     source_location=arg.source_location,
                     version=0,
                     name=arg.name,
-                    atype=wtype_to_avm_type(arg.wtype),
+                    ir_type=wtype_to_ir_type(arg.wtype),
                     implicit_return=allow_implicits and not arg.wtype.immutable,
                 )
             )
 
 
 def _should_include_implicit_returns(
     func: awst_nodes.Function,
@@ -280,15 +280,15 @@
 
 
 def _make_subroutine(func: awst_nodes.Function, *, allow_implicits: bool) -> Subroutine:
     """Pre-construct subroutine with an empty body"""
 
     parameters = list(_build_parameter_list(func.args, allow_implicits=allow_implicits))
 
-    returns = wtype_to_avm_types(func.return_type)
+    returns = wtype_to_ir_types(func.return_type)
 
     return Subroutine(
         source_location=func.source_location,
         module_name=func.module_name,
         class_name=func.class_name if isinstance(func, awst_nodes.ContractMethod) else None,
         method_name=func.name,
         parameters=parameters,
@@ -301,23 +301,24 @@
     ctx: IRBuildContext,
     main: awst_nodes.Function,
     references: Iterable[awst_nodes.Function],
     on_create: awst_nodes.Function | None,
 ) -> Program:
     if main.args:
         raise InternalError("main method should not have args")
-    if wtype_to_avm_type(main.return_type) != AVMType.uint64:
-        raise InternalError("main method should return uint64 stack type")
+    return_type = wtype_to_ir_type(main.return_type)
+    if return_type.avm_type != AVMType.uint64:
+        raise InternalError("main method should return uint64 backed type")
     main_sub = Subroutine(
         source_location=main.source_location,
         module_name=main.module_name,
         class_name=main.class_name if isinstance(main, awst_nodes.ContractMethod) else None,
         method_name=main.name,
         parameters=[],
-        returns=[AVMType.uint64],
+        returns=[return_type],
         body=[],
     )
     on_create_sub: Subroutine | None = None
     if on_create is not None:
         on_create_sub = ctx.subroutines[on_create]
     FunctionIRBuilder.build_body(ctx, function=main, subroutine=main_sub, on_create=on_create_sub)
     return Program(
@@ -416,15 +417,21 @@
             if cm.abimethod_config:
                 maybe_arc4_method_refs.setdefault(cm.name, (cm, cm.abimethod_config))
             else:
                 maybe_arc4_method_refs.setdefault(cm.name, None)
     if not (c.init and c.init.body.body):
         result.init = None
     arc4_method_refs = dict(filter(None, maybe_arc4_method_refs.values()))
-    if arc4_method_refs:
+    if arc4_method_refs and not contract.is_arc4:
+        raise InternalError(
+            "Contracts making use of the @abimethod decorator "
+            "should extend the ARC4Contract class",
+            contract.source_location,
+        )
+    if contract.is_arc4:
         if result.approval_program:
             raise CodeError(
                 "approval_program should not be defined for ARC4 contracts",
                 contract.source_location,
             )
         result.approval_program, result.arc4_methods = create_abi_router(
             contract,
```

## puya/ir/models.py

```diff
@@ -1,52 +1,37 @@
 import abc
+import typing
 import typing as t
 from collections.abc import Iterable, Iterator, Sequence
 
 import attrs
 
+from puya import log
 from puya.avm_type import AVMType
 from puya.errors import CodeError, InternalError
 from puya.ir.avm_ops import AVMOp
-from puya.ir.avm_ops_models import OpSignature, Variant
-from puya.ir.types_ import AVMBytesEncoding, stack_type_to_avm_type
+from puya.ir.avm_ops_models import OpSignature, StackType, Variant
+from puya.ir.types_ import AVMBytesEncoding, IRType, stack_type_to_avm_type, stack_type_to_ir_type
 from puya.ir.visitor import IRVisitor
 from puya.models import ContractMetaData, LogicSignatureMetaData
 from puya.parse import SourceLocation
 from puya.utils import unique
 
-T = t.TypeVar("T")
-
+logger = log.get_logger(__name__)
 
-def _check_stack_types(
-    error_format: str,
-    target_types: Sequence[AVMType],
-    source_types: Sequence[AVMType],
-    source_location: SourceLocation | None,
-) -> None:
-    if len(target_types) != len(source_types) or not all(
-        a & b for a, b in zip(target_types, source_types, strict=True)
-    ):
-        raise CodeError(
-            error_format.format(
-                source_types=f"({', '.join(map(str, source_types))})",
-                target_types=f"({', '.join(map(str, target_types))})",
-            ),
-            source_location,
-        )
+T = t.TypeVar("T")
 
 
 class Context(t.Protocol):
     source_location: SourceLocation | None
 
 
 class IRVisitable(Context, abc.ABC):
     @abc.abstractmethod
-    def accept(self, visitor: IRVisitor[T]) -> T:
-        ...
+    def accept(self, visitor: IRVisitor[T]) -> T: ...
 
     def __str__(self) -> str:
         from puya.ir.to_text_visitor import ToTextVisitor
 
         return self.accept(ToTextVisitor())
 
 
@@ -55,47 +40,55 @@
         data = self._frozen_data()
         hash(data)  # check we can hash
         if data is self:
             return data
         return self.__class__, data
 
     @abc.abstractmethod
-    def _frozen_data(self) -> object:
-        ...
+    def _frozen_data(self) -> object: ...
 
 
 # NOTE! we don't want structural equality in the IR, everything needs to have eq=False
 #       the workaround to do this (trivial in Python to extend a decorator) AND have mypy
 #       not complain is ... well, see for yourself:
 #       https://www.attrs.org/en/stable/extending.html#wrapping-the-decorator
 @attrs.define(eq=False)
 class ValueProvider(IRVisitable, _Freezable, abc.ABC):
     """A node that provides/produces a value"""
 
     source_location: SourceLocation | None = attrs.field(eq=False)
 
     @property
     @abc.abstractmethod
-    def types(self) -> Sequence[AVMType]:
-        ...
+    def types(self) -> Sequence[IRType]: ...
+
+    @property
+    @t.final
+    def atypes(self) -> Sequence[AVMType]:
+        return tuple(t.avm_type for t in self.types)
 
 
 @attrs.frozen
 class Value(ValueProvider, abc.ABC):
     """Base class for value types.
 
     This is anything that *is* a value, so excludes
     value *producers* such as subroutine invocations
     """
 
-    atype: AVMType = attrs.field(repr=lambda x: x.name)
+    ir_type: IRType = attrs.field(repr=lambda x: x.name)
+
+    @property
+    @t.final
+    def atype(self) -> typing.Literal[AVMType.uint64, AVMType.bytes]:
+        return self.ir_type.avm_type
 
     @property
-    def types(self) -> Sequence[AVMType]:
-        return (self.atype,)
+    def types(self) -> Sequence[IRType]:
+        return (self.ir_type,)
 
     def _frozen_data(self) -> object:
         return self
 
 
 class Constant(Value, abc.ABC):
     """Base class for value constants - any value that is known at compile time"""
@@ -171,175 +164,237 @@
 
     register: Register
     args: list[PhiArgument] = attrs.field(factory=list)
     source_location: None = attrs.field(default=None, init=False)
     undefined_predecessors: list["BasicBlock"] = attrs.field(factory=list)
 
     @property
+    def ir_type(self) -> IRType:
+        return self.register.ir_type
+
+    @property
     def atype(self) -> AVMType:
-        return self.register.atype
+        return self.ir_type.avm_type
 
     @property
     def non_self_args(self) -> Sequence[PhiArgument]:
         return tuple(a for a in self.args if a.value != self.register)
 
     def _frozen_data(self) -> object:
         return (
             self.register.freeze(),
             tuple((arg.through.id, arg.value.freeze()) for arg in self.args),
             (b.id for b in self.undefined_predecessors),
         )
 
     @args.validator
     def check_args(self, _attribute: object, args: Sequence[PhiArgument]) -> None:
-        bad_args = [arg for arg in args if not (arg.value.atype & self.atype)]
+        bad_args = [
+            arg for arg in args if arg.value.ir_type.maybe_avm_type != self.ir_type.maybe_avm_type
+        ]
         if bad_args:
-            raise InternalError(f"Phi node received arguments with unexpected type(s): {bad_args}")
+            raise InternalError(
+                f"Phi node (register={self.register}) received arguments with unexpected type(s):"
+                f" {', '.join(map(str, bad_args))}, "
+            )
         seen_blocks = set[BasicBlock]()
         for arg in args:
             if arg.through in seen_blocks:
                 raise InternalError(f"Duplicate source to phi node: {arg.through}")
             seen_blocks.add(arg.through)
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_phi(self)
 
 
-@attrs.frozen
+@attrs.frozen(kw_only=True)
 class UInt64Constant(Constant):
     value: int
-    atype: AVMType = attrs.field(default=AVMType.uint64, init=False)
+    ir_type: IRType = attrs.field(default=IRType.uint64)
     teal_alias: str | None = None
+    source_location: SourceLocation | None = attrs.field(eq=False)
+
+    @ir_type.validator
+    def _validate_ir_type(self, _attribute: object, ir_type: IRType) -> None:
+        if ir_type.avm_type is not AVMType.uint64:
+            raise InternalError(
+                f"Invalid type for UInt64Constant: {ir_type}", self.source_location
+            )
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_uint64_constant(self)
 
 
+@attrs.frozen(kw_only=True)
+class ITxnConstant(Constant):
+    value: int
+    ir_type: IRType = attrs.field()
+    source_location: SourceLocation | None = attrs.field(eq=False)
+
+    @ir_type.validator
+    def _validate_ir_type(self, _attribute: object, ir_type: IRType) -> None:
+        if ir_type not in (IRType.itxn_group_idx, IRType.itxn_field_set):
+            raise InternalError(f"Invalid type for ITxnConstant: {ir_type}", self.source_location)
+
+    def accept(self, visitor: IRVisitor[T]) -> T:
+        return visitor.visit_itxn_constant(self)
+
+
 @attrs.frozen
 class BigUIntConstant(Constant):
     value: int
-    atype: AVMType = attrs.field(default=AVMType.bytes, init=False)
+    ir_type: IRType = attrs.field(default=IRType.biguint, init=False)
+    source_location: SourceLocation | None = attrs.field(eq=False)
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_biguint_constant(self)
 
 
 @attrs.frozen
 class TemplateVar(Value):
     name: str
-    atype: AVMType
+    ir_type: IRType
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_template_var(self)
 
 
 @attrs.frozen
 class BytesConstant(Constant):
     """Constant for types that are logically bytes"""
 
-    atype: AVMType = attrs.field(default=AVMType.bytes, init=False)
+    ir_type: IRType = attrs.field(default=IRType.bytes, init=False)
 
     encoding: AVMBytesEncoding
-
     value: bytes
+    source_location: SourceLocation | None = attrs.field(eq=False)
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_bytes_constant(self)
 
 
 @attrs.frozen
 class AddressConstant(Constant):
     """Constant for address literals"""
 
-    atype: AVMType = attrs.field(default=AVMType.bytes, init=False)
-
+    ir_type: IRType = attrs.field(default=IRType.bytes, init=False)
     value: str
+    source_location: SourceLocation | None = attrs.field(eq=False)
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_address_constant(self)
 
 
 @attrs.frozen
 class MethodConstant(Constant):
     """Constant for method literals"""
 
-    atype: AVMType = attrs.field(default=AVMType.bytes, init=False)
-
+    ir_type: IRType = attrs.field(default=IRType.bytes, init=False)
     value: str
+    source_location: SourceLocation | None = attrs.field(eq=False)
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_method_constant(self)
 
 
 @attrs.define(eq=False)
+class InnerTransactionField(Op, ValueProvider):
+    field: str
+    group_index: Value
+    is_last_in_group: Value
+    array_index: Value | None
+    type: IRType
+
+    def _frozen_data(self) -> object:
+        return self.field, self.group_index, self.is_last_in_group, self.array_index, self.type
+
+    def accept(self, visitor: IRVisitor[T]) -> T:
+        return visitor.visit_inner_transaction_field(self)
+
+    @property
+    def types(self) -> Sequence[IRType]:
+        return (self.type,)
+
+
+@attrs.define(eq=False)
 class Intrinsic(Op, ValueProvider):
     """Any TEAL op (or pseudo-op) that doesn't interrupt control flow, in the "basic block" sense.
 
     refs:
     - https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/
     - https://developer.algorand.org/docs/get-details/dapps/avm/teal/specification/#assembler-syntax
     """
 
     op: AVMOp
     # TODO: consider treating ops with no args (only immediates) as Value types
     #       e.g. `txn NumAppArgs` or `txna ApplicationArgs 0`
     immediates: list[str | int] = attrs.field(factory=list)
     args: list[Value] = attrs.field(factory=list)
     comment: str | None = None  # used e.g. for asserts
-    _types: Sequence[AVMType] = attrs.field(converter=tuple[AVMType, ...])
+    _types: Sequence[IRType] = attrs.field(converter=tuple[IRType, ...])
 
     @_types.default
-    def _default_types(self) -> tuple[AVMType, ...]:
-        return tuple(map(stack_type_to_avm_type, self.op_signature.returns))
-
-    @_types.validator
-    def _validate_types(self, _attribute: object, types: Sequence[AVMType]) -> None:
-        expected_types = self._default_types()
-        received_types = tuple(types)
-        desc = f"({self.op} {' '.join(map(str, self.immediates))}): "
-        _check_stack_types(
-            "Incompatible return types on Intrinsic"
-            + desc
-            + " received = {source_types}, expected = {target_types}",
-            expected_types,
-            received_types,
-            self.source_location,
-        )
+    def _default_types(self) -> tuple[IRType, ...]:
+        types = list[IRType]()
+        for stack_type in self.op_signature.returns:
+            ir_type = stack_type_to_ir_type(stack_type)
+            if ir_type is None:
+                raise InternalError(
+                    f"Intrinsic op {self.op.name} requires return type information",
+                    self.source_location,
+                )
+            types.append(ir_type)
+        return tuple(types)
 
     def _frozen_data(self) -> object:
         return self.op, tuple(self.immediates), tuple(self.args), self.comment
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_intrinsic_op(self)
 
     @property
-    def types(self) -> Sequence[AVMType]:
+    def types(self) -> Sequence[IRType]:
         return self._types
 
     @property
     def op_signature(self) -> OpSignature:
         return self.op_variant.signature
 
     @property
     def op_variant(self) -> Variant:
         return self.op.get_variant(self.immediates)
 
+    @_types.validator
+    def _validate_types(self, _attribute: object, types: Sequence[IRType]) -> None:
+        self._check_stack_types("return", self.op_signature.returns, types)
+
     @args.validator
     def _validate_args(self, _attribute: object, args: list[Value]) -> None:
-        expected_args = [stack_type_to_avm_type(a) for a in self.op_signature.args]
-        received_args = [a.atype for a in args]
-        desc = f"({self.op} {' '.join(map(str, self.immediates))}): "
-        _check_stack_types(
-            "Incompatible argument types on Intrinsic"
-            + desc
-            + " received = {source_types}, expected = {target_types}",
-            expected_args,
-            received_args,
-            self.source_location,
-        )
+        arg_types = [a.ir_type for a in args]
+        self._check_stack_types("argument", self.op_signature.args, arg_types)
+
+    def _check_stack_types(
+        self,
+        context: str,
+        expected_types: Sequence[StackType],
+        source_types: Sequence[IRType],
+    ) -> None:
+        target_types = [stack_type_to_avm_type(a) for a in expected_types]
+        if len(target_types) != len(source_types) or not all(
+            tt & st.avm_type for tt, st in zip(target_types, source_types, strict=True)
+        ):
+            logger.error(
+                (
+                    f"Incompatible {context} types on Intrinsic"
+                    f"({self.op} {' '.join(map(str, self.immediates))}): "
+                    f" received = ({', '.join(map(str, source_types))}),"
+                    f" expected = ({', '.join(map(str, target_types))})"
+                ),
+                location=self.source_location,
+            )
 
 
 @attrs.define(eq=False)
 class InvokeSubroutine(Op, ValueProvider):
     """Subroutine invocation
 
     opcode: callsub"""
@@ -351,28 +406,28 @@
     def _frozen_data(self) -> object:
         return self.target.full_name, tuple(self.args)
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_invoke_subroutine(self)
 
     @property
-    def types(self) -> Sequence[AVMType]:
+    def types(self) -> Sequence[IRType]:
         return self.target.returns
 
 
 @attrs.define(eq=False)
 class ValueTuple(ValueProvider):
     values: list[Value]
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_value_tuple(self)
 
     @property
-    def types(self) -> Sequence[AVMType]:
-        return [val.atype for val in self.values]
+    def types(self) -> Sequence[IRType]:
+        return [val.ir_type for val in self.values]
 
     def _frozen_data(self) -> object:
         return tuple(self.values)
 
 
 @attrs.define(eq=False)
 class Assignment(Op):
@@ -385,21 +440,29 @@
     source: ValueProvider = attrs.field()
 
     def _frozen_data(self) -> object:
         return tuple(self.targets), self.source.freeze()
 
     @source.validator
     def _check_types(self, _attribute: object, source: ValueProvider) -> None:
-        _check_stack_types(
-            "Incompatible types on assignment: "
-            "source = {source_types}, target = {target_types}",
-            [target.atype for target in self.targets],
-            list(source.types),
-            self.source_location,
-        )
+        target_ir_types = [target.ir_type for target in self.targets]
+        source_ir_types = list(source.types)
+        if target_ir_types != source_ir_types:
+            # TODO: need to update some optimiser code and/or
+            #       introduce ReinterpretCast ValueProvider
+            #       here before we can remove this fallback to AVMType here
+            target_atypes = [tt.maybe_avm_type for tt in target_ir_types]
+            source_atypes = [st.maybe_avm_type for st in source_ir_types]
+            if target_atypes != source_atypes:
+                raise CodeError(
+                    f"Incompatible types on assignment:"
+                    f" source = ({', '.join(map(str, source_ir_types))}),"
+                    f" target = ({', '.join(map(str, target_ir_types))})",
+                    self.source_location,
+                )
 
     def accept(self, visitor: IRVisitor[T]) -> T:
         return visitor.visit_assignment(self)
 
 
 @attrs.define(eq=False, str=False, kw_only=True)
 class BasicBlock(Context):
@@ -484,15 +547,15 @@
     def _frozen_data(self) -> object:
         return self.condition.freeze(), self.non_zero.id, self.zero.id
 
     @condition.validator
     def check(self, _attribute: object, result: Value) -> None:
         if result.atype != AVMType.uint64:
             raise CodeError(
-                "Branch condition can only be uint64 typed value", self.source_location
+                "Branch condition can only be uint64 backed value", self.source_location
             )
 
     def targets(self) -> Sequence[BasicBlock]:
         return self.zero, self.non_zero
 
     @property
     def can_exit(self) -> bool:
@@ -562,15 +625,15 @@
 
     value: Value
     cases: dict[Value, BasicBlock] = attrs.field()
     default: ControlOp
 
     @cases.validator
     def _check_cases(self, _attribute: object, cases: dict[Value, BasicBlock]) -> None:
-        if not all(case.atype & self.value.atype for case in cases):
+        if any(case.atype != self.value.atype for case in cases):
             raise CodeError(
                 "Switch cases types mismatch with value to match", self.source_location
             )
 
     def _frozen_data(self) -> object:
         return (
             self.value,
@@ -620,15 +683,15 @@
     """
 
     result: Value = attrs.field()
 
     @result.validator
     def check(self, _attribute: object, result: Value) -> None:
         if result.atype != AVMType.uint64:
-            raise CodeError("Can only exit with uint64 typed value", self.source_location)
+            raise CodeError("Can only exit with uint64 backed value", self.source_location)
 
     def _frozen_data(self) -> object:
         return self.result
 
     def targets(self) -> Sequence[BasicBlock]:
         return ()
 
@@ -676,20 +739,20 @@
 class Subroutine(Context):
     # source_location might be None if it was synthesized e.g. ARC4 approval method
     source_location: SourceLocation | None
     module_name: str
     class_name: str | None  # None if a function (vs a method)
     method_name: str
     parameters: Sequence[Parameter]
-    _returns: Sequence[AVMType]
+    _returns: Sequence[IRType]
     body: list[BasicBlock] = attrs.field()
 
     @property
-    def returns(self) -> Sequence[AVMType]:
-        return [*self._returns, *(p.atype for p in self.parameters if p.implicit_return)]
+    def returns(self) -> list[IRType]:
+        return [*self._returns, *(p.ir_type for p in self.parameters if p.implicit_return)]
 
     @body.validator
     def _check_blocks(self, _attribute: object, body: list[BasicBlock]) -> None:
         blocks = frozenset(body)
         for block in body:
             attrs.validate(block)
             if block.terminator is None:
```

## puya/ir/optimize/control_op_simplification.py

```diff
@@ -5,14 +5,15 @@
 from puya.context import CompileContext
 from puya.errors import InternalError
 from puya.ir import models
 from puya.ir.avm_ops import AVMOp
 from puya.ir.models import PhiArgument
 from puya.ir.optimize._utils import get_definition
 from puya.ir.ssa import TrivialPhiRemover
+from puya.ir.types_ import IRType
 from puya.utils import unique
 
 logger = log.get_logger(__name__)
 
 
 # the ratio of default cases to all cases when a match of constant values
 # can be simplified to a goto-nth
@@ -82,15 +83,15 @@
                 ) as err_block,
                 zero=zero,
                 source_location=source_location,
             ):
                 logger.debug("inlining condition branch to err block into an assert false")
                 not_condition = models.Register(
                     name=f"not%{condition.name}",
-                    atype=AVMType.uint64,
+                    ir_type=IRType.bool,
                     version=condition.version,
                     source_location=source_location,
                 )
                 if get_definition(subroutine, not_condition, should_exist=False) is None:
                     block.ops.append(
                         models.Assignment(
                             targets=[not_condition],
```

## puya/ir/optimize/dead_code_elimination.py

```diff
@@ -211,15 +211,15 @@
             block.phis.remove(op)
             logger.debug(f"Removing unused variable {register.local_id}")
             modified += 1
 
     for (block, ass), registers in assignments.items():
         if registers.symmetric_difference(ass.targets):
             pass  # some registers still used
-        elif isinstance(ass.source, models.Value) or (
+        elif isinstance(ass.source, models.Value | models.InnerTransactionField) or (
             isinstance(ass.source, models.Intrinsic)
             and ass.source.op.code in SIDE_EFFECT_FREE_AVM_OPS
         ):
             for reg in registers:
                 logger.debug(f"Removing unused variable {reg.local_id}")
             block.ops.remove(ass)
             modified += 1
@@ -229,17 +229,17 @@
             )
     return modified > 0
 
 
 @attrs.define
 class UnusedRegisterCollector(visitor.IRTraverser):
     used: set[models.Register] = attrs.field(factory=set)
-    assigned: dict[
-        models.Register, tuple[models.BasicBlock, models.Assignment | models.Phi]
-    ] = attrs.field(factory=dict)
+    assigned: dict[models.Register, tuple[models.BasicBlock, models.Assignment | models.Phi]] = (
+        attrs.field(factory=dict)
+    )
 
     @classmethod
     def collect(
         cls, sub: models.Subroutine
     ) -> Iterable[tuple[models.BasicBlock, models.Assignment | models.Phi, models.Register]]:
         collector = cls()
         collector.visit_all_blocks(sub.body)
```

## puya/ir/optimize/intrinsic_simplification.py

```diff
@@ -1,8 +1,9 @@
 import base64
+import math
 import operator
 import typing
 from collections.abc import Callable
 from itertools import zip_longest
 
 import attrs
 
@@ -182,15 +183,17 @@
             return attrs.evolve(intrinsic, op=AVMOp.arg, immediates=[idx], args=[])
     return None
 
 
 def _try_fold_intrinsic(
     subroutine: models.Subroutine, intrinsic: models.Intrinsic
 ) -> models.ValueProvider | None:
-    if intrinsic.op in (AVMOp.loads, AVMOp.gloads) or (intrinsic.op.code.startswith("box_")):
+    if intrinsic.op in (AVMOp.loads, AVMOp.gloads) or (
+        intrinsic.op.code.startswith(("box_", "app_global_", "app_local_"))
+    ):
         # can't simplify these
         return None
     elif intrinsic.op in (AVMOp.itob, AVMOp.bzero):
         # we deliberately don't simplify these unless they're part of something else,
         # since they can drastically increase program size
         return None
 
@@ -268,54 +271,52 @@
                 )
                 return result
         elif right_const is not None:
             if right_const.value == b"":
                 return left_arg
     elif intrinsic.op.code.startswith("extract"):
         match intrinsic:
-            case (
-                models.Intrinsic(
-                    immediates=[int(S), int(L)],
-                    args=[byte_arg],
-                )
-                | models.Intrinsic(
-                    immediates=[],
-                    args=[
-                        byte_arg,
-                        models.UInt64Constant(value=S),
-                        models.UInt64Constant(value=L),
-                    ],
-                )
-            ) if (byte_const := _get_byte_constant(subroutine, byte_arg)) is not None:
+            case models.Intrinsic(
+                immediates=[int(S), int(L)],
+                args=[byte_arg],
+            ) | models.Intrinsic(
+                immediates=[],
+                args=[
+                    byte_arg,
+                    models.UInt64Constant(value=S),
+                    models.UInt64Constant(value=L),
+                ],
+            ) if (
+                byte_const := _get_byte_constant(subroutine, byte_arg)
+            ) is not None:
                 # note there is a difference of behaviour between extract with stack args
                 # and with immediates - zero is to the end with immediates,
                 # and zero length with stacks
                 if intrinsic.immediates and L == 0:
                     extracted = byte_const.value[S:]
                 else:
                     extracted = byte_const.value[S : S + L]
                 return models.BytesConstant(
                     source_location=op_loc, encoding=byte_const.encoding, value=extracted
                 )
     elif intrinsic.op.code.startswith("substring"):
         match intrinsic:
-            case (
-                models.Intrinsic(
-                    immediates=[int(S), int(E)],
-                    args=[byte_arg],
-                )
-                | models.Intrinsic(
-                    immediates=[],
-                    args=[
-                        byte_arg,
-                        models.UInt64Constant(value=S),
-                        models.UInt64Constant(value=E),
-                    ],
-                )
-            ) if (byte_const := _get_byte_constant(subroutine, byte_arg)) is not None:
+            case models.Intrinsic(
+                immediates=[int(S), int(E)],
+                args=[byte_arg],
+            ) | models.Intrinsic(
+                immediates=[],
+                args=[
+                    byte_arg,
+                    models.UInt64Constant(value=S),
+                    models.UInt64Constant(value=E),
+                ],
+            ) if (
+                byte_const := _get_byte_constant(subroutine, byte_arg)
+            ) is not None:
                 if E < S:
                     return None  # would fail at runtime, lets hope this is unreachable 😬
                 extracted = byte_const.value[S:E]
                 return models.BytesConstant(
                     source_location=op_loc, encoding=byte_const.encoding, value=extracted
                 )
     elif not intrinsic.immediates:
@@ -443,38 +444,47 @@
     if x is not None:
         if intrinsic.op is AVMOp.not_:
             not_x = 0 if x else 1
             return models.UInt64Constant(value=not_x, source_location=op_loc)
         elif intrinsic.op is AVMOp.bitwise_not:
             inverted = x ^ 0xFFFFFFFFFFFFFFFF
             return models.UInt64Constant(value=inverted, source_location=op_loc)
+        elif intrinsic.op is AVMOp.sqrt:
+            value = math.isqrt(x)
+            return models.UInt64Constant(value=value, source_location=op_loc)
         else:
             logger.debug(f"Don't know how to simplify {intrinsic.op.code} of {x}")
     return None
 
 
 def _try_simplify_bytes_unary_op(
     subroutine: models.Subroutine, intrinsic: models.Intrinsic, arg: models.Value
 ) -> models.ValueProvider | None:
     op_loc = intrinsic.source_location
-    byte_const = _get_byte_constant(subroutine, arg)
-    if byte_const is not None:
-        if intrinsic.op is AVMOp.bitwise_not_bytes:
-            inverted = bytes([x ^ 0xFF for x in byte_const.value])
-            return models.BytesConstant(
-                value=inverted, encoding=byte_const.encoding, source_location=op_loc
-            )
-        elif intrinsic.op is AVMOp.btoi:
-            converted = int.from_bytes(byte_const.value, byteorder="big", signed=False)
-            return models.UInt64Constant(value=converted, source_location=op_loc)
-        elif intrinsic.op is AVMOp.len_:
-            length = len(byte_const.value)
-            return models.UInt64Constant(value=length, source_location=op_loc)
-        else:
-            logger.debug(f"Don't know how to simplify {intrinsic.op.code} of {byte_const}")
+    if intrinsic.op is AVMOp.bsqrt:
+        biguint_const, _, _ = _get_biguint_constant(subroutine, arg)
+        if biguint_const is not None:
+            value = math.isqrt(biguint_const)
+            return models.BigUIntConstant(value=value, source_location=op_loc)
+    else:
+        byte_const = _get_byte_constant(subroutine, arg)
+        if byte_const is not None:
+            if intrinsic.op is AVMOp.bitwise_not_bytes:
+                inverted = bytes([x ^ 0xFF for x in byte_const.value])
+                return models.BytesConstant(
+                    value=inverted, encoding=byte_const.encoding, source_location=op_loc
+                )
+            elif intrinsic.op is AVMOp.btoi:
+                converted = int.from_bytes(byte_const.value, byteorder="big", signed=False)
+                return models.UInt64Constant(value=converted, source_location=op_loc)
+            elif intrinsic.op is AVMOp.len_:
+                length = len(byte_const.value)
+                return models.UInt64Constant(value=length, source_location=op_loc)
+            else:
+                logger.debug(f"Don't know how to simplify {intrinsic.op.code} of {byte_const}")
     return None
 
 
 def _try_simplify_uint64_binary_op(
     intrinsic: models.Intrinsic, a: models.Value, b: models.Value, *, bool_context: bool = False
 ) -> models.ValueProvider | None:
     op = intrinsic.op
@@ -628,14 +638,16 @@
                     c = a_const + b_const
                 case AVMOp.sub_bytes:
                     c = a_const - b_const
                 case AVMOp.mul_bytes:
                     c = a_const * b_const
                 case AVMOp.div_floor_bytes:
                     c = a_const // b_const
+                case AVMOp.mod_bytes if b_const != 0:
+                    c = a_const % b_const
                 case AVMOp.lt_bytes:
                     c = 1 if a_const < b_const else 0
                 case AVMOp.lte_bytes:
                     c = 1 if a_const <= b_const else 0
                 case AVMOp.gt_bytes:
                     c = 1 if a_const > b_const else 0
                 case AVMOp.gte_bytes:
```

## puya/ir/optimize/main.py

```diff
@@ -12,14 +12,15 @@
 from puya.ir.optimize.constant_propagation import constant_replacer
 from puya.ir.optimize.control_op_simplification import simplify_control_ops
 from puya.ir.optimize.dead_code_elimination import (
     remove_unreachable_blocks,
     remove_unused_subroutines,
     remove_unused_variables,
 )
+from puya.ir.optimize.inner_txn import inner_txn_field_replacer
 from puya.ir.optimize.intrinsic_simplification import intrinsic_simplifier
 from puya.ir.optimize.repeated_code_elimination import repeated_expression_elimination
 from puya.ir.to_text_visitor import output_artifact_ir_to_path
 
 MAX_PASSES = 100
 SubroutineOptimizerCallable = Callable[[CompileContext, models.Subroutine], bool]
 logger = log.get_logger(__name__)
@@ -51,23 +52,27 @@
 def get_subroutine_optimizations(optimization_level: int) -> Iterable[SubroutineOptimization]:
     if optimization_level:
         return [
             SubroutineOptimization.from_function(constant_replacer, loop=True),
             SubroutineOptimization.from_function(copy_propagation),
             SubroutineOptimization.from_function(intrinsic_simplifier, loop=True),
             SubroutineOptimization.from_function(remove_unused_variables),
+            SubroutineOptimization.from_function(inner_txn_field_replacer),
             SubroutineOptimization.from_function(simplify_control_ops, loop=True),
             SubroutineOptimization.from_function(remove_linear_jump),
             SubroutineOptimization.from_function(remove_empty_blocks),
             SubroutineOptimization.from_function(remove_unreachable_blocks),
             SubroutineOptimization.from_function(repeated_expression_elimination),
         ]
-    return [
-        SubroutineOptimization.from_function(remove_unused_variables),
-    ]
+    else:
+        return [
+            SubroutineOptimization.from_function(constant_replacer, loop=True),
+            SubroutineOptimization.from_function(remove_unused_variables),
+            SubroutineOptimization.from_function(inner_txn_field_replacer),
+        ]
 
 
 def _split_parallel_copies(sub: models.Subroutine) -> None:
     any_modified = False
     for block in sub.body:
         ops = list[models.Op]()
         modified = False
```

## puya/ir/ssa.py

```diff
@@ -1,15 +1,15 @@
 from collections.abc import Sequence
 
 import attrs
 
 from puya import log
-from puya.avm_type import AVMType
 from puya.errors import InternalError
 from puya.ir import models as ir
+from puya.ir.types_ import IRType
 from puya.ir.visitor_mem_replacer import MemoryReplacer
 from puya.parse import SourceLocation
 
 logger = log.get_logger(__name__)
 
 
 class BraunSSA:
@@ -49,50 +49,50 @@
         try:
             self._current_def[variable][block]
         except KeyError:
             return False
         else:
             return True
 
-    def read_variable(self, variable: str, atype: AVMType, block: ir.BasicBlock) -> ir.Register:
+    def read_variable(self, variable: str, ir_type: IRType, block: ir.BasicBlock) -> ir.Register:
         try:
             result = self._current_def[variable][block]
         except KeyError:
-            result = self._read_variable_recursive(variable, atype, block)
+            result = self._read_variable_recursive(variable, ir_type, block)
         return result
 
     def _read_variable_recursive(
-        self, variable: str, atype: AVMType, block: ir.BasicBlock
+        self, variable: str, ir_type: IRType, block: ir.BasicBlock
     ) -> ir.Register:
         value: ir.Register
         if not self.is_sealed(block):
             logger.debug(
                 f"Looking for '{variable}' in an unsealed block creating an incomplete "
                 f"Phi: {block}"
             )
             # incomplete CFG
-            phi = self._new_phi(block, variable, atype)
+            phi = self._new_phi(block, variable, ir_type)
             self._incomplete_phis.setdefault(block, []).append(phi)
             value = phi.register
         elif len(block.predecessors) == 1:
-            value = self.read_variable(variable, atype, block.predecessors[0])
+            value = self.read_variable(variable, ir_type, block.predecessors[0])
         else:
             # break any potential cycles with empty Phi
-            phi = self._new_phi(block, variable, atype)
+            phi = self._new_phi(block, variable, ir_type)
             self.write_variable(variable, block, phi.register)
             value = self._add_phi_operands(phi, block)
         self.write_variable(variable, block, value)
         return value
 
     def new_register(
-        self, name: str, atype: AVMType, location: SourceLocation | None
+        self, name: str, ir_type: IRType, location: SourceLocation | None
     ) -> ir.Register:
         version = self._variable_versions.get(name, 0)
         self._variable_versions[name] = version + 1
-        return ir.Register(source_location=location, name=name, version=version, atype=atype)
+        return ir.Register(source_location=location, name=name, version=version, ir_type=ir_type)
 
     def is_sealed(self, block: ir.BasicBlock) -> bool:
         return block in self._sealed_blocks
 
     def verify_complete(self) -> None:
         unsealed = [b for b in self._all_blocks if not self.is_sealed(b)]
         if unsealed:
@@ -103,28 +103,28 @@
         if incomplete_phis:
             # if we get here, there is a bug in this algorithm itself
             raise InternalError(
                 f"{len(incomplete_phis)} phi node/s are incomplete: "
                 ", ".join(map(str, incomplete_phis))
             )
 
-    def _new_phi(self, block: ir.BasicBlock, variable: str, atype: AVMType) -> ir.Phi:
-        reg = self.new_register(variable, atype, location=None)
+    def _new_phi(self, block: ir.BasicBlock, variable: str, ir_type: IRType) -> ir.Phi:
+        reg = self.new_register(variable, ir_type, location=None)
         phi = ir.Phi(register=reg)
         block.phis.append(phi)
 
         logger.debug(
             f"Created Phi assignment: {phi} while trying to resolve '{variable}' in {block}"
         )
         return phi
 
     def _add_phi_operands(self, phi: ir.Phi, block: ir.BasicBlock) -> ir.Register:
         variable = phi.register.name
         for block_pred in block.predecessors:
-            pred_variable = self.read_variable(variable, phi.atype, block_pred)
+            pred_variable = self.read_variable(variable, phi.ir_type, block_pred)
             phi.args.append(
                 ir.PhiArgument(
                     value=pred_variable,
                     through=block_pred,
                 )
             )
             logger.debug(f"Added {pred_variable} to Phi node: {phi} in {block_pred}")
```

## puya/ir/to_text_visitor.py

```diff
@@ -1,25 +1,25 @@
 import contextlib
 import typing
 from collections.abc import Iterator, Sequence
 from pathlib import Path
 
 from puya import log
-from puya.avm_type import AVMType
 from puya.ir import models
+from puya.ir.types_ import IRType
 from puya.ir.utils import format_bytes
 from puya.ir.visitor import IRVisitor
 from puya.utils import make_path_relative_to_cwd
 
 logger = log.get_logger(__name__)
 
 
 class ToTextVisitor(IRVisitor[str]):
     def visit_assignment(self, op: models.Assignment) -> str:
-        targets = ", ".join(f"{r.accept(self)}: {r.atype.name}" for r in op.targets)
+        targets = ", ".join(f"{r.accept(self)}: {r.ir_type.name}" for r in op.targets)
         if len(op.targets) > 1:
             targets = f"({targets})"
         source = op.source.accept(self)
         return f"let {targets} = {source}"
 
     def visit_register(self, op: models.Register) -> str:
         return op.local_id
@@ -35,26 +35,34 @@
 
     def visit_address_constant(self, op: models.AddressConstant) -> str:
         return f"addr {op.value}"
 
     def visit_method_constant(self, op: models.MethodConstant) -> str:
         return f'method "{op.value}"'
 
+    def visit_itxn_constant(self, op: models.ITxnConstant) -> str:
+        return f"{op.ir_type.name}({op.value})"
+
     def visit_intrinsic_op(self, intrinsic: models.Intrinsic) -> str:
         callee = intrinsic.op.code
         immediates = list(map(str, intrinsic.immediates))
         if immediates:
             callee = f"({' '.join((callee, *immediates))})"
         args = " ".join(arg.accept(self) for arg in intrinsic.args)
         if args:
             callee = f"({callee} {args})"
         if intrinsic.comment:
             callee += f" // {intrinsic.comment}"
         return callee
 
+    def visit_inner_transaction_field(self, field: models.InnerTransactionField) -> str:
+        group = field.group_index.accept(self)
+        array_access = f"[{field.array_index.accept(self)}]" if field.array_index else ""
+        return f"itxn[{group}].{field.field}{array_access}"
+
     def visit_invoke_subroutine(self, op: models.InvokeSubroutine) -> str:
         args = ", ".join(a.accept(self) for a in op.args)
         return f"{op.target.full_name}({args})"
 
     def visit_conditional_branch(self, op: models.ConditionalBranch) -> str:
         return f"goto {op.condition.accept(self)} ? block@{op.non_zero.id} : block@{op.zero.id}"
 
@@ -75,27 +83,27 @@
         return f"switch {op.value.accept(self)} {{{map_}}}"
 
     def visit_subroutine_return(self, op: models.SubroutineReturn) -> str:
         results = " ".join(r.accept(self) for r in op.result)
         return f"return {results}"
 
     def visit_template_var(self, deploy_var: models.TemplateVar) -> str:
-        return f"TemplateVar[{deploy_var.atype}]({deploy_var.name})"
+        return f"TemplateVar[{deploy_var.ir_type.name}]({deploy_var.name})"
 
     def visit_program_exit(self, op: models.ProgramExit) -> str:
         return f"exit {op.result.accept(self)}"
 
     def visit_fail(self, op: models.Fail) -> str:
         if op.comment:
             return f"fail // {op.comment}"
         return "fail"
 
     def visit_phi(self, op: models.Phi) -> str:
         r = op.register
-        target = f"{r.accept(self)}: {r.atype.name}"
+        target = f"{r.accept(self)}: {r.ir_type.name}"
         if op.args:
             args = ", ".join(a.accept(self) for a in op.args)
             source = f"φ({args})"
         else:
             source = "undefined"
         return f"let {target} = {source}"
 
@@ -135,22 +143,22 @@
 
 def render_program(emitter: TextEmitter, name: str, program: models.Program) -> None:
     emitter.append(f"program {name}:")
     with emitter.indent():
         for idx, sub in enumerate(program.all_subroutines):
             if idx > 0:
                 emitter.append("")
-            args = ", ".join(f"{r.name}: {r.atype.name}" for r in sub.parameters)
+            args = ", ".join(f"{r.name}: {r.ir_type.name}" for r in sub.parameters)
             match sub.returns:
                 case []:
                     returns = "void"
-                case [AVMType(name=returns)]:
+                case [IRType(name=returns)]:
                     pass
-                case _ as atypes:
-                    returns = f"<{', '.join(t.name for t in atypes)}>"  # type: ignore[misc]
+                case _ as ir_types:
+                    returns = f"<{', '.join(t.name for t in ir_types)}>"
             emitter.append(f"subroutine {sub.full_name}({args}) -> {returns}:")
             with emitter.indent():
                 render_body(emitter, sub.body)
 
 
 def render_contract(emitter: TextEmitter, contract: models.Contract) -> None:
     emitter.append(f"contract {contract.metadata.full_name}:")
```

## puya/ir/types_.py

```diff
@@ -17,21 +17,103 @@
     unknown = enum.auto()
     base16 = enum.auto()
     base32 = enum.auto()
     base64 = enum.auto()
     utf8 = enum.auto()
 
 
+@enum.unique
+class IRType(enum.StrEnum):
+    bytes = enum.auto()
+    uint64 = enum.auto()
+    bool = enum.auto()
+    biguint = enum.auto()
+    itxn_group_idx = enum.auto()  # the group index of the result
+    itxn_field_set = enum.auto()  # a collection of fields for a pending itxn submit
+
+    @property
+    def avm_type(self) -> typing.Literal[AVMType.uint64, AVMType.bytes]:
+        maybe_result = self.maybe_avm_type
+        if not isinstance(maybe_result, AVMType):
+            raise InternalError(f"{maybe_result} cannot be mapped to AVM stack type")
+        return maybe_result
+
+    @property
+    def maybe_avm_type(self) -> typing.Literal[AVMType.uint64, AVMType.bytes] | str:
+        match self:
+            case IRType.uint64 | IRType.bool:
+                return AVMType.uint64
+            case IRType.bytes | IRType.biguint:
+                return AVMType.bytes
+            case IRType.itxn_group_idx | IRType.itxn_field_set:
+                return self.name
+            case _:
+                typing.assert_never(self)
+
+
 def bytes_enc_to_avm_bytes_enc(bytes_encoding: BytesEncoding) -> AVMBytesEncoding:
     try:
         return AVMBytesEncoding(bytes_encoding.value)
     except ValueError as ex:
         raise InternalError(f"Unhandled BytesEncoding: {bytes_encoding}") from ex
 
 
+def wtype_to_ir_type(
+    expr_or_wtype: wtypes.WType | awst_nodes.Expression,
+    source_location: SourceLocation | None = None,
+) -> IRType:
+    if isinstance(expr_or_wtype, awst_nodes.Expression):
+        return wtype_to_ir_type(
+            expr_or_wtype.wtype, source_location=source_location or expr_or_wtype.source_location
+        )
+    else:
+        wtype = expr_or_wtype
+    match wtype:
+        case wtypes.bool_wtype:
+            return IRType.bool
+        case (
+            wtypes.uint64_wtype
+            | wtypes.asset_wtype
+            | wtypes.application_wtype
+            | wtypes.WGroupTransaction()
+        ):
+            return IRType.uint64
+        case wtypes.WInnerTransaction():
+            return IRType.itxn_group_idx
+        case wtypes.WInnerTransactionFields():
+            return IRType.itxn_field_set
+        case wtypes.biguint_wtype:
+            return IRType.biguint
+        case wtypes.bytes_wtype | wtypes.account_wtype | wtypes.string_wtype | wtypes.ARC4Type():
+            return IRType.bytes
+        case wtypes.void_wtype:
+            raise InternalError("Can't translate void WType to IRType", source_location)
+        case _:
+            raise CodeError(
+                f"Unsupported nested/compound type encountered: {wtype}",
+                source_location,
+            )
+
+
+def wtype_to_ir_types(
+    expr_or_wtype: wtypes.WType | awst_nodes.Expression,
+    source_location: SourceLocation | None = None,
+) -> list[IRType]:
+    if isinstance(expr_or_wtype, awst_nodes.Expression):
+        wtype = expr_or_wtype.wtype
+    else:
+        wtype = expr_or_wtype
+    if wtype == wtypes.void_wtype:
+        return []
+    elif isinstance(wtype, wtypes.WTuple):
+        return [wtype_to_ir_type(t, source_location) for t in wtype.types]
+    else:
+        return [wtype_to_ir_type(wtype, source_location)]
+
+
 def wtype_to_avm_type(
     expr_or_wtype: wtypes.WType | awst_nodes.Expression,
     source_location: SourceLocation | None = None,
 ) -> typing.Literal[AVMType.bytes, AVMType.uint64]:
     if isinstance(expr_or_wtype, awst_nodes.Expression):
         return wtype_to_avm_type(
             expr_or_wtype.wtype, source_location=source_location or expr_or_wtype.source_location
@@ -41,14 +123,16 @@
     match wtype:
         case (
             wtypes.uint64_wtype
             | wtypes.bool_wtype
             | wtypes.asset_wtype
             | wtypes.application_wtype
             | wtypes.WGroupTransaction()
+            | wtypes.WInnerTransaction()
+            | wtypes.WInnerTransactionFields()
         ):
             return AVMType.uint64
         case (
             wtypes.bytes_wtype
             | wtypes.biguint_wtype
             | wtypes.account_wtype
             | wtypes.ARC4Type()
@@ -60,37 +144,37 @@
         case _:
             raise CodeError(
                 f"Unsupported nested/compound type encountered: {wtype}",
                 source_location,
             )
 
 
-def wtype_to_avm_types(
-    expr_or_wtype: wtypes.WType | awst_nodes.Expression,
-    source_location: SourceLocation | None = None,
-) -> list[AVMType]:
-    if isinstance(expr_or_wtype, awst_nodes.Expression):
-        wtype = expr_or_wtype.wtype
-    else:
-        wtype = expr_or_wtype
-    if wtype == wtypes.void_wtype:
-        return []
-    elif isinstance(wtype, wtypes.WTuple):
-        return [wtype_to_avm_type(t, source_location) for t in wtype.types]
-    else:
-        return [wtype_to_avm_type(wtype, source_location)]
-
-
 def stack_type_to_avm_type(stack_type: StackType) -> AVMType:
     match stack_type:
         case StackType.uint64 | StackType.bool | StackType.asset | StackType.application:
             return AVMType.uint64
         case (
             StackType.bytes
             | StackType.bigint
             | StackType.box_name
             | StackType.address
             | StackType.state_key
         ):
             return AVMType.bytes
         case StackType.any | StackType.address_or_index:
             return AVMType.any
+
+
+def stack_type_to_ir_type(stack_type: StackType) -> IRType | None:
+    match stack_type:
+        case StackType.bool:
+            return IRType.bool
+        case StackType.bigint:
+            return IRType.biguint
+        case StackType.uint64 | StackType.asset | StackType.application:
+            return IRType.uint64
+        case StackType.bytes | StackType.box_name | StackType.address | StackType.state_key:
+            return IRType.bytes
+        case StackType.any | StackType.address_or_index:
+            return None
+        case _:
+            typing.assert_never(stack_type)
```

## puya/ir/utils.py

```diff
@@ -1,9 +1,12 @@
 import base64
+import typing
+from collections.abc import Sequence
 
+from puya.awst import nodes as awst_nodes
 from puya.ir.types_ import AVMBytesEncoding
 
 
 def escape_utf8_string(s: str) -> str:
     """Escape a UTF-8 string for use in TEAL assembly.
 
     Args:
@@ -48,7 +51,15 @@
             return base64.b64encode(b).decode("ascii")
         case AVMBytesEncoding.base16 | AVMBytesEncoding.unknown:
             return f"0x{b.hex()}"
 
 
 def format_tuple_index(var_name: str, index: int | str) -> str:
     return f"{var_name}.{index}"
+
+
+def lvalue_items(tup: awst_nodes.TupleExpression) -> Sequence[awst_nodes.Lvalue]:
+    items = list[awst_nodes.Lvalue]()
+    for item in tup.items:
+        assert isinstance(item, awst_nodes.Lvalue)  # type: ignore[arg-type]
+        items.append(typing.cast(awst_nodes.Lvalue, item))
+    return items
```

## puya/ir/validation/main.py

```diff
@@ -1,9 +1,17 @@
+import attrs
+
 from puya.context import CompileContext
 from puya.ir.models import ModuleArtifact
+from puya.ir.validation.itxn_result_field_validator import ITxnResultFieldValidator
 from puya.ir.validation.min_avm_version_validator import MinAvmVersionValidator
 from puya.ir.validation.op_run_mode_validator import OpRunModeValidator
 
 
 def validate_module_artifact(context: CompileContext, artifact: ModuleArtifact) -> None:
-    OpRunModeValidator.validate(artifact)
-    MinAvmVersionValidator.validate(context, artifact)
+    attrs.validate(artifact)
+    for validator_cls in (
+        OpRunModeValidator,
+        MinAvmVersionValidator,
+        ITxnResultFieldValidator,
+    ):
+        validator_cls.validate(context, artifact)
```

## puya/ir/validation/min_avm_version_validator.py

```diff
@@ -1,43 +1,20 @@
 import typing
 
 from puya import log
-from puya.context import CompileContext
-from puya.ir.models import Contract, Intrinsic, LogicSignature, ModuleArtifact
-from puya.ir.visitor import IRTraverser
+from puya.ir.models import Intrinsic
+from puya.ir.validation._base import DestructuredIRValidator
 
 logger = log.get_logger(__name__)
 
 
-class MinAvmVersionValidator(IRTraverser):
-    def __init__(self, target_avm_version: int) -> None:
-        self.target_avm_version = target_avm_version
-
-    @staticmethod
-    def validate(context: CompileContext, artifact: ModuleArtifact) -> None:
-        validator = MinAvmVersionValidator(context.options.target_avm_version)
-
-        match artifact:
-            case LogicSignature() as l_sig:
-                validator.validate_logic_sig(l_sig)
-            case Contract() as contract:
-                validator.validate_contract(contract)
-            case _:
-                typing.assert_never(artifact)
-
-    def validate_logic_sig(self, logic_sig: LogicSignature) -> None:
-        for sub in logic_sig.program.all_subroutines:
-            self.visit_all_blocks(sub.body)
-
-    def validate_contract(self, contract: Contract) -> None:
-        subs = (sub for program in contract.all_programs() for sub in program.all_subroutines)
-        for sub in subs:
-            self.visit_all_blocks(sub.body)
-
+class MinAvmVersionValidator(DestructuredIRValidator):
+    @typing.override
     def visit_intrinsic_op(self, intrinsic: Intrinsic) -> None:
-        if intrinsic.op.min_avm_version > self.target_avm_version:
+        target_avm_version = self.context.options.target_avm_version
+        if intrinsic.op.min_avm_version > target_avm_version:
             logger.warning(
                 f"Opcode {intrinsic.op} requires a min AVM version of "
                 f"{intrinsic.op.min_avm_version} but the target AVM version is"
-                f" {self.target_avm_version}",
+                f" {target_avm_version}",
                 intrinsic.source_location,
             )
```

## puya/ir/validation/op_run_mode_validator.py

```diff
@@ -1,55 +1,30 @@
 import typing
 
 from puya import log
 from puya.ir.avm_ops_models import RunMode
-from puya.ir.models import Contract, Intrinsic, LogicSignature, ModuleArtifact
-from puya.ir.visitor import IRTraverser
+from puya.ir.models import Intrinsic
+from puya.ir.validation._base import DestructuredIRValidator
 
 logger = log.get_logger(__name__)
 
 
-class OpRunModeValidator(IRTraverser):
-    def __init__(self, run_mode: typing.Literal[RunMode.app, RunMode.lsig]) -> None:
-        self._current_run_mode = run_mode
-
-    @classmethod
-    def validate(cls, artifact: ModuleArtifact) -> None:
-        match artifact:
-            case LogicSignature() as l_sig:
-                cls.validate_logic_sig(l_sig)
-            case Contract() as contract:
-                cls.validate_contract(contract)
-            case _:
-                typing.assert_never(artifact)
-
-    @classmethod
-    def validate_logic_sig(cls, logic_sig: LogicSignature) -> None:
-        validator = cls(RunMode.lsig)
-        for sub in logic_sig.program.all_subroutines:
-            validator.visit_all_blocks(sub.body)
-
-    @classmethod
-    def validate_contract(cls, contract: Contract) -> None:
-        validator = cls(RunMode.app)
-        subs = (sub for program in contract.all_programs() for sub in program.all_subroutines)
-        for sub in subs:
-            validator.visit_all_blocks(sub.body)
-
+class OpRunModeValidator(DestructuredIRValidator):
+    @typing.override
     def visit_intrinsic_op(self, intrinsic: Intrinsic) -> None:
         match intrinsic.op_variant.supported_modes:
             case RunMode.any:
                 pass
             case RunMode.app:
-                if self._current_run_mode != RunMode.app:
+                if self.current_run_mode != RunMode.app:
                     logger.warning(
                         f"The operation {intrinsic} is only allowed in smart contracts",
                         location=intrinsic.source_location,
                     )
             case RunMode.lsig:
-                if self._current_run_mode != RunMode.lsig:
+                if self.current_run_mode != RunMode.lsig:
                     logger.warning(
                         f"The operation {intrinsic} is only allowed in logic signatures",
                         location=intrinsic.source_location,
                     )
             case _:
                 typing.assert_never(intrinsic.op_variant.supported_modes)
```

## puya/ir/visitor.py

```diff
@@ -12,92 +12,80 @@
     import puya.ir.models
 
 T = t.TypeVar("T")
 
 
 class IRVisitor(t.Generic[T], ABC):
     @abstractmethod
-    def visit_assignment(self, ass: puya.ir.models.Assignment) -> T:
-        ...
+    def visit_assignment(self, ass: puya.ir.models.Assignment) -> T: ...
 
     @abstractmethod
-    def visit_register(self, reg: puya.ir.models.Register) -> T:
-        ...
+    def visit_register(self, reg: puya.ir.models.Register) -> T: ...
 
     @abstractmethod
-    def visit_uint64_constant(self, const: puya.ir.models.UInt64Constant) -> T:
-        ...
+    def visit_uint64_constant(self, const: puya.ir.models.UInt64Constant) -> T: ...
 
     @abstractmethod
-    def visit_biguint_constant(self, const: puya.ir.models.BigUIntConstant) -> T:
-        ...
+    def visit_biguint_constant(self, const: puya.ir.models.BigUIntConstant) -> T: ...
 
     @abstractmethod
-    def visit_bytes_constant(self, const: puya.ir.models.BytesConstant) -> T:
-        ...
+    def visit_bytes_constant(self, const: puya.ir.models.BytesConstant) -> T: ...
 
     @abstractmethod
-    def visit_address_constant(self, const: puya.ir.models.AddressConstant) -> T:
-        ...
+    def visit_address_constant(self, const: puya.ir.models.AddressConstant) -> T: ...
 
     @abstractmethod
-    def visit_method_constant(self, const: puya.ir.models.MethodConstant) -> T:
-        ...
+    def visit_method_constant(self, const: puya.ir.models.MethodConstant) -> T: ...
 
     @abstractmethod
-    def visit_phi(self, phi: puya.ir.models.Phi) -> T:
-        ...
+    def visit_itxn_constant(self, const: puya.ir.models.ITxnConstant) -> T: ...
 
     @abstractmethod
-    def visit_phi_argument(self, arg: puya.ir.models.PhiArgument) -> T:
-        ...
+    def visit_phi(self, phi: puya.ir.models.Phi) -> T: ...
 
     @abstractmethod
-    def visit_intrinsic_op(self, intrinsic: puya.ir.models.Intrinsic) -> T:
-        ...
+    def visit_phi_argument(self, arg: puya.ir.models.PhiArgument) -> T: ...
 
     @abstractmethod
-    def visit_invoke_subroutine(self, callsub: puya.ir.models.InvokeSubroutine) -> T:
-        ...
+    def visit_intrinsic_op(self, intrinsic: puya.ir.models.Intrinsic) -> T: ...
 
     @abstractmethod
-    def visit_value_tuple(self, tup: puya.ir.models.ValueTuple) -> T:
-        ...
+    def visit_inner_transaction_field(
+        self, intrinsic: puya.ir.models.InnerTransactionField
+    ) -> T: ...
 
     @abstractmethod
-    def visit_conditional_branch(self, branch: puya.ir.models.ConditionalBranch) -> T:
-        ...
+    def visit_invoke_subroutine(self, callsub: puya.ir.models.InvokeSubroutine) -> T: ...
 
     @abstractmethod
-    def visit_goto(self, goto: puya.ir.models.Goto) -> T:
-        ...
+    def visit_value_tuple(self, tup: puya.ir.models.ValueTuple) -> T: ...
 
     @abstractmethod
-    def visit_goto_nth(self, goto_nth: puya.ir.models.GotoNth) -> T:
-        ...
+    def visit_conditional_branch(self, branch: puya.ir.models.ConditionalBranch) -> T: ...
 
     @abstractmethod
-    def visit_switch(self, switch: puya.ir.models.Switch) -> T:
-        ...
+    def visit_goto(self, goto: puya.ir.models.Goto) -> T: ...
 
     @abstractmethod
-    def visit_subroutine_return(self, retsub: puya.ir.models.SubroutineReturn) -> T:
-        ...
+    def visit_goto_nth(self, goto_nth: puya.ir.models.GotoNth) -> T: ...
 
     @abstractmethod
-    def visit_program_exit(self, exit_: puya.ir.models.ProgramExit) -> T:
-        ...
+    def visit_switch(self, switch: puya.ir.models.Switch) -> T: ...
 
     @abstractmethod
-    def visit_fail(self, fail: puya.ir.models.Fail) -> T:
-        ...
+    def visit_subroutine_return(self, retsub: puya.ir.models.SubroutineReturn) -> T: ...
 
     @abstractmethod
-    def visit_template_var(self, deploy_var: puya.ir.models.TemplateVar) -> T:
-        ...
+    def visit_program_exit(self, exit_: puya.ir.models.ProgramExit) -> T: ...
+
+    @abstractmethod
+    def visit_fail(self, fail: puya.ir.models.Fail) -> T: ...
+
+    @abstractmethod
+    def visit_template_var(self, deploy_var: puya.ir.models.TemplateVar) -> T: ...
 
 
 class IRTraverser(IRVisitor[None]):
     active_block: puya.ir.models.BasicBlock
 
     def visit_all_blocks(self, blocks: Iterable[puya.ir.models.BasicBlock]) -> None:
         for block in blocks:
@@ -130,26 +118,35 @@
 
     def visit_template_var(self, deploy_var: puya.ir.models.TemplateVar) -> None:
         pass
 
     def visit_method_constant(self, const: puya.ir.models.MethodConstant) -> None:
         pass
 
+    def visit_itxn_constant(self, const: puya.ir.models.ITxnConstant) -> None:
+        pass
+
     def visit_phi(self, phi: puya.ir.models.Phi) -> None:
         phi.register.accept(self)
         for arg in phi.args:
             arg.accept(self)
 
     def visit_phi_argument(self, arg: puya.ir.models.PhiArgument) -> None:
         arg.value.accept(self)
 
     def visit_intrinsic_op(self, intrinsic: puya.ir.models.Intrinsic) -> None:
         for arg in intrinsic.args:
             arg.accept(self)
 
+    def visit_inner_transaction_field(self, field: puya.ir.models.InnerTransactionField) -> None:
+        field.group_index.accept(self)
+        field.is_last_in_group.accept(self)
+        if field.array_index:
+            field.array_index.accept(self)
+
     def visit_invoke_subroutine(self, callsub: puya.ir.models.InvokeSubroutine) -> None:
         for arg in callsub.args:
             arg.accept(self)
 
     def visit_conditional_branch(self, branch: puya.ir.models.ConditionalBranch) -> None:
         branch.condition.accept(self)
 
@@ -199,26 +196,34 @@
 
     def visit_address_constant(self, const: puya.ir.models.AddressConstant) -> T | None:
         return None
 
     def visit_method_constant(self, const: puya.ir.models.MethodConstant) -> T | None:
         return None
 
+    def visit_itxn_constant(self, const: puya.ir.models.ITxnConstant) -> T | None:
+        return None
+
     def visit_phi(self, phi: puya.ir.models.Phi) -> T | None:
         return None
 
     def visit_template_var(self, deploy_var: puya.ir.models.TemplateVar) -> T | None:
         return None
 
     def visit_phi_argument(self, arg: puya.ir.models.PhiArgument) -> T | None:
         return None
 
     def visit_intrinsic_op(self, intrinsic: puya.ir.models.Intrinsic) -> T | None:
         return None
 
+    def visit_inner_transaction_field(
+        self, field: puya.ir.models.InnerTransactionField
+    ) -> T | None:
+        return None
+
     def visit_invoke_subroutine(self, callsub: puya.ir.models.InvokeSubroutine) -> T | None:
         return None
 
     def visit_value_tuple(self, tup: puya.ir.models.ValueTuple) -> T | None:
         return None
 
     def visit_conditional_branch(self, branch: puya.ir.models.ConditionalBranch) -> T | None:
```

## puya/ir/visitor_mutator.py

```diff
@@ -11,16 +11,18 @@
     BigUIntConstant,
     BytesConstant,
     ConditionalBranch,
     ControlOp,
     Fail,
     Goto,
     GotoNth,
+    InnerTransactionField,
     Intrinsic,
     InvokeSubroutine,
+    ITxnConstant,
     MethodConstant,
     Op,
     Phi,
     PhiArgument,
     ProgramExit,
     Register,
     SubroutineReturn,
@@ -90,28 +92,40 @@
 
     def visit_address_constant(self, const: AddressConstant) -> AddressConstant:
         return const
 
     def visit_method_constant(self, const: MethodConstant) -> MethodConstant:
         return const
 
+    def visit_itxn_constant(self, const: ITxnConstant) -> ITxnConstant:
+        return const
+
     def visit_phi(self, phi: Phi) -> Phi | None:
         with self._enter_target_context():
             phi.register = self.visit_register(phi.register)
         phi.args = [self.visit_phi_argument(a) for a in phi.args]
         return phi
 
     def visit_phi_argument(self, arg: PhiArgument) -> PhiArgument:
         arg.value = arg.value.accept(self)
         return arg
 
     def visit_intrinsic_op(self, intrinsic: Intrinsic) -> Intrinsic | None:
         intrinsic.args = [a.accept(self) for a in intrinsic.args]
         return intrinsic
 
+    def visit_inner_transaction_field(
+        self, field: InnerTransactionField
+    ) -> InnerTransactionField | Intrinsic:
+        field.group_index = field.group_index.accept(self)
+        field.is_last_in_group = field.is_last_in_group.accept(self)
+        if field.array_index:
+            field.array_index = field.array_index.accept(self)
+        return field
+
     def visit_invoke_subroutine(self, callsub: InvokeSubroutine) -> InvokeSubroutine:
         callsub.args = [a.accept(self) for a in callsub.args]
         return callsub
 
     def visit_conditional_branch(self, branch: ConditionalBranch) -> ControlOp:
         branch.condition = branch.condition.accept(self)
         return branch
```

## puya/log.py

```diff
@@ -110,38 +110,43 @@
         if not isinstance(event, str):
             event = str(event)
         lines = [event]
         related_errors = event_dict.pop("related_lines", None)
         if related_errors:
             assert isinstance(related_errors, list)
             lines.extend(related_errors)
+        important: bool = event_dict.pop("important", False)
         location: SourceLocation | None = event_dict.pop("location", None)
         location_as_link = self._location_as_link(location) if location else ""
-        level = event_dict.pop("level", "")
+        level = event_dict.pop("level", "info")
 
         align_related_lines = " " * (len(location_as_link) + 1 + len(level) + 1)
         sio = StringIO()
+        reset_colour = self._styles.reset
+        if important:
+            sio.write(self._styles.bright)
+            reset_colour += self._styles.bright
         for idx, line in enumerate(lines):
             if idx:
                 sio.write("\n")
                 sio.write(align_related_lines)
             else:
                 if location:
                     sio.write(self._styles.logger_name)
                     location_link = self._location_as_link(location)
                     sio.write(location_link)
                     sio.write(" ")
-                    sio.write(self._styles.reset)
+                    sio.write(reset_colour)
 
-                if level:
-                    sio.write(self.level_to_color.get(level, ""))
-                    sio.write(level)
-                    sio.write(": ")
-                    sio.write(self._styles.reset)
+                sio.write(self.level_to_color.get(level, ""))
+                sio.write(level)
+                sio.write(": ")
+                sio.write(reset_colour)
             sio.write(line)
+        sio.write(self._styles.reset)
 
         stack = event_dict.pop("stack", None)
         exc = event_dict.pop("exception", None)
         exc_info = event_dict.pop("exc_info", None)
 
         event_dict_keys: typing.Iterable[str] = event_dict.keys()
         if self._sort_keys:
```

## puya/mir/annotaters.py

```diff
@@ -90,20 +90,18 @@
             line if isinstance(line, str) else self._join_columns(line, widths)
             for line in all_lines
         ]
 
 
 class OpAnnotater(abc.ABC):
     @abc.abstractmethod
-    def annotate(self, writer: AlignedWriter, op: models.BaseOp) -> None:
-        ...
+    def annotate(self, writer: AlignedWriter, op: models.BaseOp) -> None: ...
 
     @abc.abstractmethod
-    def begin_block(self, writer: AlignedWriter, block: models.MemoryBasicBlock) -> None:
-        ...
+    def begin_block(self, writer: AlignedWriter, block: models.MemoryBasicBlock) -> None: ...
 
 
 @attrs.frozen
 class SimpleOpAnnotater(OpAnnotater):
     _annotate: Callable[[AlignedWriter, models.BaseOp], None]
 
     def annotate(self, writer: AlignedWriter, op: models.BaseOp) -> None:
@@ -127,20 +125,18 @@
 @attrs.frozen(kw_only=True)
 class EmitSubroutineContext(EmitProgramContext):
     subroutine: models.MemorySubroutine
 
 
 class MIRAnnotater(abc.ABC):
     @abc.abstractmethod
-    def header(self, writer: AlignedWriter) -> None:
-        ...
+    def header(self, writer: AlignedWriter) -> None: ...
 
     @abc.abstractmethod
-    def create_op_annotater(self, context: EmitSubroutineContext) -> OpAnnotater:
-        ...
+    def create_op_annotater(self, context: EmitSubroutineContext) -> OpAnnotater: ...
 
 
 class BeginCommentsAnnotater(MIRAnnotater):
     def header(self, writer: AlignedWriter) -> None:
         writer.add_header("//")
 
     def create_op_annotater(self, _context: EmitSubroutineContext) -> OpAnnotater:
```

## puya/mir/builder.py

```diff
@@ -1,7 +1,9 @@
+import typing
+
 import attrs
 
 from puya import log
 from puya.errors import InternalError
 from puya.ir import models as ir
 from puya.ir.types_ import AVMBytesEncoding
 from puya.ir.visitor import IRVisitor
@@ -82,20 +84,14 @@
             models.PushTemplateVar(
                 name=deploy_var.name,
                 atype=deploy_var.atype,
                 source_location=deploy_var.source_location,
             )
         )
 
-    def visit_value_tuple(self, tup: ir.ValueTuple) -> None:
-        raise InternalError(
-            "Encountered ValueTuple during codegen - should have been eliminated in prior stages",
-            tup.source_location,
-        )
-
     def visit_uint64_constant(self, const: ir.UInt64Constant) -> None:
         self._add_op(
             models.PushInt(
                 const.value if not const.teal_alias else const.teal_alias,
                 source_location=const.source_location,
             )
         )
@@ -130,39 +126,31 @@
         self._add_op(
             models.PushMethod(
                 const.value,
                 source_location=const.source_location,
             )
         )
 
-    def visit_phi(self, phi: ir.Phi) -> None:
-        raise InternalError(
-            "Encountered Phi node during codegen - should have been eliminated in prior stages",
-            phi.source_location,
-        )
-
-    def visit_phi_argument(self, arg: ir.PhiArgument) -> None:
-        raise InternalError(
-            "Encountered PhiArgument during codegen - should have been eliminated in prior stages",
-            arg.source_location,
-        )
-
     def visit_intrinsic_op(self, intrinsic: ir.Intrinsic) -> None:
+        discard_results = intrinsic is self.active_op
         for arg in intrinsic.args:
             arg.accept(self)
+        produces = len(intrinsic.op_signature.returns)
         self._add_op(
             models.IntrinsicOp(
                 op_code=intrinsic.op.code,
                 immediates=intrinsic.immediates,
                 source_location=intrinsic.source_location,
                 consumes=len(intrinsic.op_signature.args),
-                produces=len(intrinsic.op_signature.returns),
+                produces=produces,
                 comment=intrinsic.comment,
             )
         )
+        if discard_results and produces:
+            self._add_op(models.Pop(produces))
 
     def visit_invoke_subroutine(self, callsub: ir.InvokeSubroutine) -> None:
         discard_results = callsub is self.active_op
         target = callsub.target
 
         callsub_op = models.CallSub(
             target=self.context.subroutine_names[target],
@@ -296,7 +284,30 @@
         return models.MemoryBasicBlock(
             block_name=block_name,
             ops=self.current_ops,
             predecessors=predecessors,
             successors=successors,
             source_location=block.source_location,
         )
+
+    def visit_value_tuple(self, tup: ir.ValueTuple) -> None:
+        _unexpected_node(tup)
+
+    def visit_itxn_constant(self, const: ir.ITxnConstant) -> None:
+        _unexpected_node(const)
+
+    def visit_inner_transaction_field(self, field: ir.InnerTransactionField) -> None:
+        _unexpected_node(field)
+
+    def visit_phi(self, phi: ir.Phi) -> None:
+        _unexpected_node(phi)
+
+    def visit_phi_argument(self, arg: ir.PhiArgument) -> None:
+        _unexpected_node(arg)
+
+
+def _unexpected_node(node: ir.IRVisitable) -> typing.Never:
+    raise InternalError(
+        f"Encountered node of type {type(node).__name__!r} during codegen"
+        f" - should have been eliminated in prior stages",
+        node.source_location,
+    )
```

## puya/mir/main.py

```diff
@@ -58,13 +58,13 @@
     return models.MemorySubroutine(
         signature=models.Signature(
             name=subroutine.full_name,
             parameters=[
                 models.Parameter(name=p.name, local_id=p.local_id, atype=p.atype)
                 for p in subroutine.parameters
             ],
-            returns=subroutine.returns,
+            returns=[r.avm_type for r in subroutine.returns],
         ),
         is_main=is_main,
         preamble=preamble,
         body=body,
     )
```

## puya/mir/models.py

```diff
@@ -22,16 +22,15 @@
 
 @attrs.frozen(kw_only=True, eq=False, str=False)
 class BaseOp(abc.ABC):
     comment: str | None = None
     source_location: SourceLocation | None = None
 
     @abc.abstractmethod
-    def accept(self, visitor: MIRVisitor[_T]) -> _T:
-        ...
+    def accept(self, visitor: MIRVisitor[_T]) -> _T: ...
 
 
 @attrs.frozen(eq=False)
 class PushInt(BaseOp):
     value: int | str
 
     def accept(self, visitor: MIRVisitor[_T]) -> _T:
@@ -117,23 +116,33 @@
 
 
 @attrs.frozen(kw_only=True, eq=False)
 class StoreOp(MemoryOp, abc.ABC):
     """An op for storing values"""
 
     local_id: str
-    atype: AVMType
+    atype: AVMType = attrs.field()
+
+    @atype.validator
+    def _validate_not_any(self, _attribute: object, atype: AVMType) -> None:
+        if atype is AVMType.any:
+            raise InternalError(f"Register has type any: {self}", self.source_location)
 
 
 @attrs.frozen(kw_only=True, eq=False)
 class LoadOp(MemoryOp, abc.ABC):
     """An op for loading values"""
 
     local_id: str
-    atype: AVMType
+    atype: AVMType = attrs.field()
+
+    @atype.validator
+    def _validate_not_any(self, _attribute: object, atype: AVMType) -> None:
+        if atype is AVMType.any:
+            raise InternalError(f"Register has type any: {self}", self.source_location)
 
 
 @attrs.frozen(eq=False)
 class StoreVirtual(StoreOp):
     def accept(self, visitor: MIRVisitor[_T]) -> _T:
         return visitor.visit_store_virtual(self)
 
@@ -360,16 +369,15 @@
             # e.g. consider assert comments
             teal += ("//", self.comment)
         return " ".join(teal)
 
 
 class BranchingOp(IntrinsicOp, abc.ABC):
     @abc.abstractmethod
-    def targets(self) -> Sequence[str]:
-        ...
+    def targets(self) -> Sequence[str]: ...
 
 
 @attrs.frozen(eq=False)
 class Branch(BranchingOp):
     op_code: str = attrs.field(default="b", init=False)
     consumes: int = attrs.field(default=0, init=False)
     produces: int = attrs.field(default=0, init=False)
```

## puya/mir/output.py

```diff
@@ -26,15 +26,15 @@
             case models.Comment():
                 context.writer.append(f"// {op.comment}")
                 if debug_level < 1:
                     context.writer.ignore_line()
             case _ if debug_level < VIRTUAL_STACK_DEBUG_LEVEL:
                 context.writer.ignore_line()
     for teal_op_idx, teal_op in enumerate(teal_ops):
-        context.writer.append(str(teal_op))
+        context.writer.append(teal_op.teal())
         # omit new line for all but the last op
         if teal_op_idx < len(teal_ops) - 1:
             context.writer.new_line()
     for annotate_op in op_annotaters:
         annotate_op.annotate(context.writer, op)
     context.writer.new_line()
```

## puya/mir/stack.py

```diff
@@ -167,17 +167,19 @@
             self._stack_error(f"{local_id} not found in f-stack")
         frame_dig = self.f_stack.index(local_id)
         dig = self._get_f_stack_dig_bury(local_id)
         self.l_stack.append(local_id)
         if self.use_frame:
             return [teal.FrameDig(frame_dig, source_location=load.source_location)]
         return [
-            teal.Dig(dig, source_location=load.source_location)
-            if dig
-            else teal.Dup(source_location=load.source_location)
+            (
+                teal.Dig(dig, source_location=load.source_location)
+                if dig
+                else teal.Dup(source_location=load.source_location)
+            )
         ]
 
     def visit_store_x_stack(self, store: models.StoreXStack) -> list[teal.TealOp]:
         local_id = store.local_id
         if not self.l_stack:
             self._stack_error(f"l-stack too small to store {local_id} to x-stack")
         # re-alias top of l-stack
@@ -228,17 +230,19 @@
             self._stack_error(f"{local_id} not found in l-stack")
         index = self.l_stack.index(local_id)
         uncover = len(self.l_stack) - index - 1
 
         if load.copy:
             self.l_stack.append(local_id)
             return [
-                teal.Dup(source_location=load.source_location)
-                if uncover == 0
-                else teal.Dig(uncover, source_location=load.source_location)
+                (
+                    teal.Dup(source_location=load.source_location)
+                    if uncover == 0
+                    else teal.Dig(uncover, source_location=load.source_location)
+                )
             ]
         else:
             self.l_stack.pop(index)
             self.l_stack.append(local_id)
             return [teal.Uncover(uncover, source_location=load.source_location)]
 
     def visit_load_param(self, load: models.LoadParam) -> list[teal.TealOp]:
@@ -290,17 +294,19 @@
 
     def visit_pop(self, pop: models.Pop) -> list[teal.TealOp]:
         if len(self.l_stack) < pop.n:
             self._stack_error(f"l-stack too small to pop {pop.n}")
         for _ in range(pop.n):
             self.l_stack.pop()
         return [
-            teal.PopN(pop.n, source_location=pop.source_location)
-            if pop.n > 1
-            else teal.Pop(source_location=pop.source_location)
+            (
+                teal.PopN(pop.n, source_location=pop.source_location)
+                if pop.n > 1
+                else teal.Pop(source_location=pop.source_location)
+            )
         ]
 
     def visit_callsub(self, callsub: models.CallSub) -> list[teal.TealOp]:
         if len(self.l_stack) < callsub.parameters:
             self._stack_error(f"l-stack too small to call {callsub}")
         op_code = f"{{{callsub.target}}}"
         if callsub.returns > 1:
```

## puya/mir/stack_allocation/frame_allocation.py

```diff
@@ -45,19 +45,23 @@
     # determine variables to allocate at beginning of frame,
     # and order them so bytes are listed first, followed by uints
     byte_vars = []
     uint64_vars = []
     variable_type_mapping = get_local_id_types(subroutine)
     for variable in all_variables:
         match variable_type_mapping.get(variable):
-            # treat any as uint when pre-allocating
-            case AVMType.uint64 | AVMType.any:
+            case AVMType.uint64:
                 uint64_vars.append(variable)
             case AVMType.bytes:
                 byte_vars.append(variable)
+            case AVMType.any:
+                raise InternalError(
+                    "Encountered AVM type any on preamble construction",
+                    subroutine.preamble.source_location,
+                )
             case None:
                 raise CodeError(
                     f"Undefined register: {variable}."
                     " This can be caused by attempting to reference variables that are only"
                     " defined in other execution paths.",
                     subroutine.preamble.source_location,
                 )
```

## puya/mir/visitor.py

```diff
@@ -7,97 +7,74 @@
     from puya.mir import models
 
 _T = typing.TypeVar("_T")
 
 
 class MIRVisitor(abc.ABC, typing.Generic[_T]):
     @abc.abstractmethod
-    def visit_push_int(self, push: models.PushInt) -> _T:
-        ...
+    def visit_push_int(self, push: models.PushInt) -> _T: ...
 
     @abc.abstractmethod
-    def visit_push_bytes(self, push: models.PushBytes) -> _T:
-        ...
+    def visit_push_bytes(self, push: models.PushBytes) -> _T: ...
 
     @abc.abstractmethod
-    def visit_comment(self, comment: models.Comment) -> _T:
-        ...
+    def visit_comment(self, comment: models.Comment) -> _T: ...
 
     @abc.abstractmethod
-    def visit_store_l_stack(self, store: models.StoreLStack) -> _T:
-        ...
+    def visit_store_l_stack(self, store: models.StoreLStack) -> _T: ...
 
     @abc.abstractmethod
-    def visit_load_l_stack(self, load: models.LoadLStack) -> _T:
-        ...
+    def visit_load_l_stack(self, load: models.LoadLStack) -> _T: ...
 
     @abc.abstractmethod
-    def visit_store_x_stack(self, store: models.StoreXStack) -> _T:
-        ...
+    def visit_store_x_stack(self, store: models.StoreXStack) -> _T: ...
 
     @abc.abstractmethod
-    def visit_load_x_stack(self, load: models.LoadXStack) -> _T:
-        ...
+    def visit_load_x_stack(self, load: models.LoadXStack) -> _T: ...
 
     @abc.abstractmethod
-    def visit_store_f_stack(self, store: models.StoreFStack) -> _T:
-        ...
+    def visit_store_f_stack(self, store: models.StoreFStack) -> _T: ...
 
     @abc.abstractmethod
-    def visit_load_f_stack(self, load: models.LoadFStack) -> _T:
-        ...
+    def visit_load_f_stack(self, load: models.LoadFStack) -> _T: ...
 
     @abc.abstractmethod
-    def visit_load_param(self, load: models.LoadParam) -> _T:
-        ...
+    def visit_load_param(self, load: models.LoadParam) -> _T: ...
 
     @abc.abstractmethod
-    def visit_store_param(self, load: models.StoreParam) -> _T:
-        ...
+    def visit_store_param(self, load: models.StoreParam) -> _T: ...
 
     @abc.abstractmethod
-    def visit_store_virtual(self, store: models.StoreVirtual) -> _T:
-        ...
+    def visit_store_virtual(self, store: models.StoreVirtual) -> _T: ...
 
     @abc.abstractmethod
-    def visit_load_virtual(self, load: models.LoadVirtual) -> _T:
-        ...
+    def visit_load_virtual(self, load: models.LoadVirtual) -> _T: ...
 
     @abc.abstractmethod
-    def visit_proto(self, proto: models.Proto) -> _T:
-        ...
+    def visit_proto(self, proto: models.Proto) -> _T: ...
 
     @abc.abstractmethod
-    def visit_allocate(self, allocate: models.Allocate) -> _T:
-        ...
+    def visit_allocate(self, allocate: models.Allocate) -> _T: ...
 
     @abc.abstractmethod
-    def visit_pop(self, pop: models.Pop) -> _T:
-        ...
+    def visit_pop(self, pop: models.Pop) -> _T: ...
 
     @abc.abstractmethod
-    def visit_callsub(self, callsub: models.CallSub) -> _T:
-        ...
+    def visit_callsub(self, callsub: models.CallSub) -> _T: ...
 
     @abc.abstractmethod
-    def visit_retsub(self, retsub: models.RetSub) -> _T:
-        ...
+    def visit_retsub(self, retsub: models.RetSub) -> _T: ...
 
     @abc.abstractmethod
-    def visit_intrinsic(self, intrinsic: models.IntrinsicOp) -> _T:
-        ...
+    def visit_intrinsic(self, intrinsic: models.IntrinsicOp) -> _T: ...
 
     @abc.abstractmethod
-    def visit_virtual_stack(self, nop: models.VirtualStackOp) -> _T:
-        ...
+    def visit_virtual_stack(self, nop: models.VirtualStackOp) -> _T: ...
 
     @abc.abstractmethod
-    def visit_push_address(self, addr: models.PushAddress) -> _T:
-        ...
+    def visit_push_address(self, addr: models.PushAddress) -> _T: ...
 
     @abc.abstractmethod
-    def visit_push_method(self, method: models.PushMethod) -> _T:
-        ...
+    def visit_push_method(self, method: models.PushMethod) -> _T: ...
 
     @abc.abstractmethod
-    def visit_push_deploy_var(self, deploy_var: models.PushTemplateVar) -> _T:
-        ...
+    def visit_push_deploy_var(self, deploy_var: models.PushTemplateVar) -> _T: ...
```

## puya/parse.py

```diff
@@ -108,23 +108,21 @@
                     line = min(dec.line, line)
                 end_line = max(line, class_body.line - 1)
                 return cls(
                     file=file,
                     line=line,
                     end_line=end_line,
                 )
-            case (
-                mypy.nodes.WhileStmt(body=compound_body) | mypy.nodes.ForStmt(body=compound_body)
-            ):
+            case mypy.nodes.WhileStmt(body=compound_body) | mypy.nodes.ForStmt(body=compound_body):
                 return cls(
                     file=file,
                     line=node.line,
                     end_line=compound_body.line - 1,
                 )
-            case (mypy.nodes.IfStmt(body=[*bodies], else_body=else_body)):
+            case mypy.nodes.IfStmt(body=[*bodies], else_body=else_body):
                 body_start: int | None = None
                 if else_body is not None:
                     bodies.append(else_body)
                 for body in bodies:
                     if body_start is None:
                         body_start = body.line
                     else:
```

## puya/teal/main.py

```diff
@@ -37,17 +37,19 @@
     )
     referenced_labels = _get_referenced_labels(mir_sub)
     for block_idx, mir_block in enumerate(mir_sub.all_blocks):
         stack.begin_block(mir_sub, mir_block)
         if block_idx == 0 or mir_block.block_name in referenced_labels:
             sub.blocks.append(
                 teal_models.TealBlock(
-                    label=mir_block.block_name
-                    if not (mir_sub.is_main and block_idx == 0)
-                    else mir_sub.signature.name,
+                    label=(
+                        mir_block.block_name
+                        if not (mir_sub.is_main and block_idx == 0)
+                        else mir_sub.signature.name
+                    ),
                     ops=[],
                     entry_stack_height=mir_block.entry_stack_height,
                     exit_stack_height=-1,
                 )
             )
         sub.blocks[-1].exit_stack_height = mir_block.exit_stack_height
```

## puya/teal/models.py

```diff
@@ -4,35 +4,36 @@
 
 from puya.errors import InternalError
 from puya.ir.types_ import AVMBytesEncoding
 from puya.ir.utils import format_bytes
 from puya.parse import SourceLocation
 
 
-@attrs.frozen(str=False, kw_only=True)
+@attrs.frozen(kw_only=True)
 class TealOp:
     op_code: str
     consumes: int
     produces: int
     source_location: SourceLocation | None = attrs.field(eq=False)
     comment: str | None = None
     """A comment that is always emitted, should only be used for user comments related to an
     op such as assert or err"""
 
     @property
     def immediates(self) -> Sequence[int | str]:
         return ()
 
-    def __str__(self) -> str:
-        return self.teal_str(self.op_code, *self.immediates)
+    def teal(self) -> str:
+        return self._teal_str(self.op_code, *self.immediates)
 
-    def teal_str(self, op_code: str, *immediates: int | str) -> str:
+    def _teal_str(self, op_code: str, *immediates: int | str) -> str:
         teal_args = [op_code, *map(str, immediates)]
         if self.comment:
-            teal_args.append(f"// {self.comment}")
+            comment = "\n//".join(self.comment.splitlines())
+            teal_args.append(f"// {comment}")
         return " ".join(teal_args)
 
     @property
     def stack_height_delta(self) -> int:
         return self.produces - self.consumes
 
 
@@ -82,19 +83,19 @@
     def _consumes(self) -> int:
         return self.n + 1
 
     @produces.default
     def _produces(self) -> int:
         return self.n + 1
 
-    def __str__(self) -> str:
+    def teal(self) -> str:
         if self.n == 1:
-            return self.teal_str("swap")
+            return self._teal_str("swap")
         else:
-            return super().__str__()
+            return super().teal()
 
 
 @attrs.frozen
 class Uncover(TealOpN):
     op_code: str = attrs.field(default="uncover", init=False)
     consumes: int = attrs.field(init=False)
     produces: int = attrs.field(init=False)
@@ -103,19 +104,19 @@
     def _consumes(self) -> int:
         return self.n + 1
 
     @produces.default
     def _produces(self) -> int:
         return self.n + 1
 
-    def __str__(self) -> str:
+    def teal(self) -> str:
         if self.n == 1:
-            return self.teal_str("swap")
+            return self._teal_str("swap")
         else:
-            return super().__str__()
+            return super().teal()
 
 
 @attrs.frozen
 class Dig(TealOpN):
     op_code: str = attrs.field(default="dig", init=False)
     consumes: int = attrs.field(init=False)
     produces: int = attrs.field(init=False)
```

## puya/teal/output.py

```diff
@@ -30,10 +30,10 @@
                     if whole_lines_location != last_location:
                         last_location = whole_lines_location
                         src = context.try_get_source(whole_lines_location)
                         result.append(f"{indent}// {src.location}")
                         lines = textwrap.dedent("\n".join(src.code or ())).splitlines()
                         result.extend(f"{indent}// {line.rstrip()}" for line in lines)
 
-                result.append(f"{indent}{teal_op}")
+                result.append(f"{indent}{teal_op.teal()}")
             result.append("")
     return result
```

## puya/utils.py

```diff
@@ -1,13 +1,13 @@
 import contextlib
 import functools
 import math
 import os
 import typing
-from collections.abc import Callable, Iterable, Iterator, MutableMapping, MutableSet, Set
+from collections.abc import Callable, Iterable, Iterator, MutableMapping, MutableSet, Sequence, Set
 from pathlib import Path
 
 import attrs
 
 if typing.TYPE_CHECKING:
     from puya.options import PuyaOptions
 
@@ -228,30 +228,31 @@
     byte_length = math.ceil(value.bit_length() / 8.0)
     assert byte_length <= 64, "Biguints must be 64 bytes or less"
     big_uint_bytes = value.to_bytes(byteorder="big", length=byte_length)
     return big_uint_bytes
 
 
 @typing.overload
-def coalesce(arg1: T | None, arg2: T, /) -> T:
-    ...
+def coalesce(arg1: T | None, arg2: T, /) -> T: ...
 
 
 @typing.overload
-def coalesce(arg1: T | None, arg2: T | None, arg3: T, /) -> T:
-    ...
+def coalesce(arg1: T | None, arg2: T | None, arg3: T, /) -> T: ...
 
 
 @typing.overload
-def coalesce(*args: T | None) -> T | None:
-    ...
+def coalesce(*args: T | None) -> T | None: ...
 
 
 def coalesce(*args: T | None) -> T | None:
     """Shorthand for `a if a is not None else b`, with eager evaluation as a tradeoff"""
     # REFACTOR: if there's a better way to do the above overloads, we should.
     #           the problem is you can't have a positional argument after *args,
     #           and we want to take the last one's type separately
     for arg in args:
         if arg is not None:
             return arg
     return None
+
+
+def positive_index(idx: int, seq: Sequence[T]) -> int:
+    return idx if idx >= 0 else len(seq) + idx
```

## puya/_typeshed/stdlib/algopy/_contract.pyi

```diff
@@ -77,14 +77,16 @@
          This setting is not inherited, and only applies to the exact `Contract` it is specified
          on. If a base class does specify this setting, and a derived class does not, a warning
          will be emitted for the derived class. To resolve this warning, `state_totals` must be
          specified. Note that it is valid to not provide any arguments to the `StateTotals`
          constructor, like so `state_totals=StateTotals()`, in which case all values will be
          automatically calculated.
         """
+
     @abc.abstractmethod
     def approval_program(self) -> UInt64 | bool:
         """Represents the program called for all transactions
         where `OnCompletion` != `ClearState`"""
+
     @abc.abstractmethod
     def clear_state_program(self) -> UInt64 | bool:
         """Represents the program called when `OnCompletion` == `ClearState`"""
```

## puya/_typeshed/stdlib/algopy/_primitives.pyi

```diff
@@ -12,226 +12,267 @@
     def __init__(self, value: int = 0, /) -> None:
         """A UInt64 can be initialized with a Python int literal, or an int variable
         declared at the module level"""
     # TODO: mypy suggests due to Liskov below should be other: object
     #       need to consider ramifications here, ignoring it for now
     def __eq__(self, other: UInt64 | int) -> bool:  # type: ignore[override]
         """A UInt64 can use the `==` operator with another UInt64 or int"""
+
     def __ne__(self, other: UInt64 | int) -> bool:  # type: ignore[override]
         """A UInt64 can use the `!=` operator with another UInt64 or int"""
+
     def __le__(self, other: UInt64 | int) -> bool:
         """A UInt64 can use the `<=` operator with another UInt64 or int"""
+
     def __lt__(self, other: UInt64 | int) -> bool:
         """A UInt64 can use the `<` operator with another UInt64 or int"""
+
     def __ge__(self, other: UInt64 | int) -> bool:
         """A UInt64 can use the `>=` operator with another UInt64 or int"""
+
     def __gt__(self, other: UInt64 | int) -> bool:
         """A UInt64 can use the `>` operator with another UInt64 or int"""
     # truthiness
     def __bool__(self) -> bool:
         """A UInt64 will evaluate to `False` if zero, and `True` otherwise"""
     # ~~~ https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types ~~~
     # +
     def __add__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be added with another UInt64 or int e.g. `UInt(4) + 2`.
 
         This will error on overflow"""
+
     def __radd__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be added with another UInt64 or int e.g. `4 + UInt64(2)`.
 
         This will error on overflow"""
+
     def __iadd__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be incremented with another UInt64 or int e.g. `a += UInt(2)`.
 
         This will error on overflow"""
     # -
     def __sub__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be subtracted with another UInt64 or int e.g. `UInt(4) - 2`.
 
         This will error on underflow"""
+
     def __rsub__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be subtracted with another UInt64 or int e.g. `4 - UInt64(2)`.
 
         This will error on underflow"""
+
     def __isub__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be subtracted with another UInt64 or int e.g. `a -= UInt64(2)`.
 
         This will error on underflow"""
     # *
     def __mul__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be multiplied with another UInt64 or int e.g. `4 + UInt64(2)`.
 
         This will error on overflow"""
+
     def __rmul__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be multiplied with another UInt64 or int e.g. `UInt64(4) + 2`.
 
         This will error on overflow"""
+
     def __imul__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be multiplied with another UInt64 or int e.g. `a*= UInt64(2)`.
 
         This will error on overflow"""
     # //
     def __floordiv__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be floor divided with another UInt64 or int e.g. `UInt64(4) // 2`.
 
         This will error on divide by zero"""
+
     def __rfloordiv__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be floor divided with another UInt64 or int e.g. `4 // UInt64(2)`.
 
         This will error on divide by zero"""
+
     def __ifloordiv__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be floor divided with another UInt64 or int e.g. `a //= UInt64(2)`.
 
         This will error on divide by zero"""
     # %
     def __mod__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be modded with another UInt64 or int e.g. `UInt64(4) % 2`.
 
         This will error on mod by zero"""
+
     def __rmod__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be modded with another UInt64 or int e.g. `4 % UInt64(2)`.
 
         This will error on mod by zero"""
+
     def __imod__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be modded with another UInt64 or int e.g. `a %= UInt64(2)`.
 
         This will error on mod by zero"""
     # TODO: __divmod__? only supported as single op via divmodw though 🤔
     # **, pow
     def __pow__(self, power: UInt64 | int) -> UInt64:
         """A UInt64 can be raised to the power of another UInt64 or int e.g. `UInt64(4) ** 2`.
 
         This will error on overflow"""
+
     def __rpow__(self, power: UInt64 | int) -> UInt64:
         """A UInt64 can be raised to the power of another UInt64 or int e.g. `4 ** UInt64(2)`.
 
         This will error on overflow"""
+
     def __ipow__(self, power: UInt64 | int) -> UInt64:
         """A UInt64 can be raised to the power of another UInt64 or int e.g. `a **= UInt64(2)`.
 
         This will error on overflow"""
     # <<
     def __lshift__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be left shifted by another UInt64 or int e.g. `UInt64(4) << 2`"""
+
     def __rlshift__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be left shifted by another UInt64 or int e.g. `4 << UInt64(2)`"""
+
     def __ilshift__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be left shifted by another UInt64 or int e.g. `a <<= UInt64(2)`"""
     # >>
     def __rshift__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be right shifted by another UInt64 or int e.g. `UInt64(4) >> 2`"""
+
     def __rrshift__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be right shifted by another UInt64 or int e.g. `4 >> UInt64(2)`"""
+
     def __irshift__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can be right shifted by another UInt64 or int e.g. `a >>= UInt64(2)`"""
     # &
     def __and__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can bitwise and with another UInt64 or int e.g. `UInt64(4) & 2`"""
+
     def __rand__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can bitwise and with another UInt64 or int e.g. `4 & UInt64(2)`"""
+
     def __iand__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can bitwise and with another UInt64 or int e.g. `a &= UInt64(2)`"""
     # ^
     def __xor__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can bitwise xor with another UInt64 or int e.g. `UInt64(4) ^ 2`"""
+
     def __rxor__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can bitwise xor with another UInt64 or int e.g. `4 ^ UInt64(2)`"""
+
     def __ixor__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can bitwise xor with another UInt64 or int e.g. `a ^= UInt64(2)`"""
     # |
     def __or__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can bitwise or with another UInt64 or int e.g. `UInt64(4) | 2`"""
+
     def __ror__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can bitwise or with another UInt64 or int e.g. `4 | UInt64(2)`"""
+
     def __ior__(self, other: UInt64 | int) -> UInt64:
         """A UInt64 can bitwise or with another UInt64 or int e.g. `a |= UInt64(2)`"""
     # ~
     def __invert__(self) -> UInt64:
         """A UInt64 can be bitwise inverted e.g. `~UInt64(4)`"""
+
     def __index__(self) -> int:
         """A UInt64 can be used in indexing/slice expressions"""
 
+    def __pos__(self) -> UInt64:
+        """Supports unary + operator. Redundant given the type is unsigned"""
+
 class Bytes(Reversible[Bytes]):
     """A byte sequence, with a maximum length of 4096 bytes, one of the primary data types on the AVM"""
 
     __match_value__: bytes
     __match_args__ = ("__match_value__",)
-    @typing.overload
-    def __init__(self) -> None:
-        """Initializes an empty sequence of bytes"""
-    @typing.overload
-    def __init__(self, value: bytes, /):
+    def __init__(self, value: bytes = b"", /):
         """Bytes can be initialized with a Python bytes literal, or bytes variable
         declared at the module level"""
+
     @staticmethod
     def from_base32(value: str, /) -> Bytes:
         """Creates Bytes from a base32 encoded string e.g. `Bytes.from_base32("74======")`"""
+
     @staticmethod
     def from_base64(value: str, /) -> Bytes:
         """Creates Bytes from a base64 encoded string e.g. `Bytes.from_base64("RkY=")`"""
+
     @staticmethod
     def from_hex(value: str, /) -> Bytes:
         """Creates Bytes from a hex/octal encoded string e.g. `Bytes.from_hex("FF")`"""
+
     def __add__(self, other: Bytes | bytes) -> Bytes:
         """Concatenate Bytes with another Bytes or bytes literal
         e.g. `Bytes(b"Hello ") + b"World"`."""
+
     def __radd__(self, other: Bytes | bytes) -> Bytes:
         """Concatenate Bytes with another Bytes or bytes literal
         e.g. `b"Hello " + Bytes(b"World")`."""
+
     def __iadd__(self, other: Bytes | bytes) -> Bytes:
         """Concatenate Bytes with another Bytes or bytes literal
         e.g. `a += Bytes(b"World")`."""
     # NOTE: __len__ is enforced to return int at runtime (not even a subtype is allowed)
     @property
     def length(self) -> UInt64:
         """Returns the length of the Bytes"""
     # truthiness
     def __bool__(self) -> bool:
         """Returns `True` if length of bytes is >0"""
+
     def __getitem__(
         self, index: UInt64 | int | slice
     ) -> Bytes:  # maps to substring/substring3 if slice, extract/extract3 otherwise?
         """Returns a Bytes containing a single byte if indexed with UInt64 or int
         otherwise the substring o bytes described by the slice"""
+
     def __iter__(self) -> Iterator[Bytes]:
         """Bytes can be iterated, yielding each consecutive byte"""
+
     def __reversed__(self) -> Iterator[Bytes]:
         """Bytes can be iterated in reverse, yield each preceding byte starting at the end"""
     # mypy suggests due to Liskov below should be other: object
     # need to consider ramifications here, ignoring it for now
     def __eq__(self, other: Bytes | bytes) -> bool:  # type: ignore[override]
         """Bytes can be compared using the `==` operator with another Bytes or bytes"""
+
     def __ne__(self, other: Bytes | bytes) -> bool:  # type: ignore[override]
         """Bytes can be compared using the `!=` operator with another Bytes or bytes"""
     # bitwise operators
     # &
     def __and__(self, other: Bytes | bytes) -> Bytes:
         """Bytes can bitwise and with another Bytes or bytes e.g. `Bytes(b"FF") & b"0F")`"""
+
     def __iand__(self, other: Bytes | bytes) -> Bytes:
         """Bytes can bitwise and with another Bytes or bytes e.g. `a &= Bytes(b"0F")`"""
     # ^
     def __xor__(self, other: Bytes | bytes) -> Bytes:
         """Bytes can bitwise xor with another Bytes or bytes e.g. `Bytes(b"FF") ^ b"0F")`"""
+
     def __ixor__(self, other: Bytes | bytes) -> Bytes:
         """Bytes can bitwise xor with another Bytes or bytes e.g. `a ^= Bytes(b"0F")`"""
     # |
     def __or__(self, other: Bytes | bytes) -> Bytes:
         """Bytes can bitwise or with another Bytes or bytes e.g. `Bytes(b"FF") | b"0F")`"""
+
     def __ior__(self, other: Bytes | bytes) -> Bytes:
         """Bytes can bitwise or with another Bytes or bytes e.g. `a |= Bytes(b"0F")`"""
     # ~
     def __invert__(self) -> Bytes:
         """Bytes can be bitwise inverted e.g. `~Bytes(b"FF)`"""
 
 class BytesBacked(typing.Protocol):
     """Represents a type that is a single bytes value"""
 
     @classmethod
     def from_bytes(cls, value: Bytes | bytes, /) -> typing.Self:
         """Construct an instance from the underlying bytes (no validation)"""
+
     @property
     def bytes(self) -> Bytes:
         """Get the underlying Bytes"""
 
 class String(BytesBacked, Container[String]):
     """A UTF-8 encoded string.
 
@@ -244,50 +285,59 @@
     """
 
     __match_value__: str
     __match_args__ = ("__match_value__",)
     def __init__(self, value: str = "", /):
         """A String can be initialized with a Python `str` literal, or a `str` variable
         declared at the module level"""
+
     def __add__(self, other: String | str) -> String:
         """Concatenate `String` with another `String` or `str` literal
         e.g. `String("Hello ") + "World"`."""
+
     def __radd__(self, other: String | str) -> String:
         """Concatenate String with another `String` or `str` literal
         e.g. `"Hello " + String("World")`."""
+
     def __iadd__(self, other: String | str) -> String:
         """Concatenate `String` with another `String` or `str` literal
         e.g. `a = String("Hello"); a += "World"`."""
+
     def __bool__(self) -> bool:
         """Returns `True` if the string is not empty"""
     # mypy suggests due to Liskov below should be other: object
     # need to consider ramifications here, ignoring it for now
     def __eq__(self, other: String | str) -> bool:  # type: ignore[override]
         """Supports using the `==` operator with another `String` or literal `str`"""
+
     def __ne__(self, other: String | str) -> bool:  # type: ignore[override]
         """Supports using the `!=` operator with another `String` or literal `str`"""
+
     def __contains__(self, other: String | str) -> bool:  # type: ignore[override]
         """Test whether another string is a substring of this one.
         Note this is expensive due to a lack of AVM support."""
+
     def startswith(self, prefix: String | str) -> bool:
         """Check if this string starts with another string.
 
         The behaviour should mirror `str.startswith`, for example, if `prefix` is the empty string,
         the result will always be `True`.
 
         Only a single argument is currently supported.
         """
+
     def endswith(self, suffix: String | str) -> bool:
         """Check if this string ends with another string.
 
         The behaviour should mirror `str.endswith`, for example, if `suffix` is the empty string,
         the result will always be `True`.
 
         Only a single argument is currently supported.
         """
+
     def join(self, others: tuple[String, ...], /) -> String:  # TODO: support str literals in tuple
         """Join a sequence of Strings with a common separator.
 
         The behaviour should mirror `str.join`.
         """
 
 class BigUInt(BytesBacked):
@@ -301,95 +351,119 @@
     def __init__(self, value: UInt64 | int = 0, /) -> None:
         """A BigUInt can be initialized with a UInt64, a Python int literal, or an int variable
         declared at the module level"""
     # TODO: mypy suggests due to Liskov below should be other: object
     #       need to consider ramifications here, ignoring it for now
     def __eq__(self, other: BigUInt | UInt64 | int) -> bool:  # type: ignore[override]
         """A BigUInt can use the `==` operator with another BigUInt, UInt64 or int"""
+
     def __ne__(self, other: BigUInt | UInt64 | int) -> bool:  # type: ignore[override]
         """A BigUInt can use the `!=` operator with another BigUInt, UInt64 or int"""
+
     def __le__(self, other: BigUInt | UInt64 | int) -> bool:
         """A BigUInt can use the `<=` operator with another BigUInt, UInt64 or int"""
+
     def __lt__(self, other: BigUInt | UInt64 | int) -> bool:
         """A BigUInt can use the `<` operator with another BigUInt, UInt64 or int"""
+
     def __ge__(self, other: BigUInt | UInt64 | int) -> bool:
         """A BigUInt can use the `>=` operator with another BigUInt, UInt64 or int"""
+
     def __gt__(self, other: BigUInt | UInt64 | int) -> bool:
         """A BigUInt can use the `>` operator with another BigUInt, UInt64 or int"""
     # truthiness
     def __bool__(self) -> bool:
         """A BigUInt will evaluate to `False` if zero, and `True` otherwise"""
     # ~~~ https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types ~~~
     # +
     def __add__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be added with another BigUInt, UInt64 or int e.g. `BigUInt(4) + 2`."""
+
     def __radd__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be added with another BigUInt, UInt64 or int e.g. `4 + BigUInt(2)`."""
+
     def __iadd__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be incremented with another BigUInt, UInt64 or int e.g. `a += BigUInt(2)`."""
     # -
     def __sub__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be subtracted with another BigUInt, UInt64 or int e.g. `BigUInt(4) - 2`.
 
         This will error on underflow"""
+
     def __rsub__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be subtracted with another BigUInt, UInt64 or int e.g. `4 - BigUInt(2)`.
 
         This will error on underflow"""
+
     def __isub__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be subtracted with another BigUInt, UInt64 or int e.g. `a -= BigUInt(2)`.
 
         This will error on underflow"""
     # *
     def __mul__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be multiplied with another BigUInt, UInt64 or int e.g. `4 + BigUInt(2)`."""
+
     def __rmul__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be multiplied with another BigUInt, UInt64 or int e.g. `BigUInt(4) + 2`."""
+
     def __imul__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be multiplied with another BigUInt, UInt64 or int e.g. `a*= BigUInt(2)`."""
     # //
     def __floordiv__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be floor divided with another BigUInt, UInt64 or int e.g. `BigUInt(4) // 2`.
 
         This will error on divide by zero"""
+
     def __rfloordiv__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be floor divided with another BigUInt, UInt64 or int e.g. `4 // BigUInt(2)`.
 
         This will error on divide by zero"""
+
     def __ifloordiv__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be floor divided with another BigUInt, UInt64 or int e.g. `a //= BigUInt(2)`.
 
         This will error on divide by zero"""
     # %
     def __mod__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be modded with another BigUInt, UInt64 or int e.g. `BigUInt(4) % 2`.
 
         This will error on mod by zero"""
+
     def __rmod__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be modded with another BigUInt, UInt64 or int e.g. `4 % BigUInt(2)`.
 
         This will error on mod by zero"""
+
     def __imod__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can be modded with another BigUInt, UInt64 or int e.g. `a %= BigUInt(2)`.
 
         This will error on mod by zero"""
     # &
     def __and__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can bitwise and with another BigUInt, UInt64 or int e.g. `BigUInt(4) & 2`"""
+
     def __rand__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can bitwise and with another BigUInt, UInt64 or int e.g. `4 & BigUInt(2)`"""
+
     def __iand__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can bitwise and with another BigUInt, UInt64 or int e.g. `a &= BigUInt(2)`"""
     # ^
     def __xor__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can bitwise xor with another BigUInt, UInt64 or int e.g. `BigUInt(4) ^ 2`"""
+
     def __rxor__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can bitwise xor with another BigUInt, UInt64 or int e.g. `4 ^ BigUInt(2)`"""
+
     def __ixor__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can bitwise xor with another BigUInt, UInt64 or int e.g. `a ^= BigUInt(2)`"""
     # |
     def __or__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can bitwise or with another BigUInt, UInt64 or int e.g. `BigUInt(4) | 2`"""
+
     def __ror__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can bitwise or with another BigUInt, UInt64 or int e.g. `4 | BigUInt(2)`"""
+
     def __ior__(self, other: BigUInt | UInt64 | int) -> BigUInt:
         """A BigUInt can bitwise or with another BigUInt, UInt64 or int e.g. `a |= BigUInt(2)`"""
+
+    def __pos__(self) -> BigUInt:
+        """Supports unary + operator. Redundant given the type is unsigned"""
```

## puya/_typeshed/stdlib/algopy/_reference.pyi

```diff
@@ -12,330 +12,376 @@
         """
         If `value` is a string, it should be a 58 character base32 string,
         ie a base32 string-encoded 32 bytes public key + 4 bytes checksum.
         If `value` is a Bytes, it's length checked to be 32 bytes - to avoid this
         check, use `Address.from_bytes(...)` instead.
         Defaults to the zero-address.
         """
+
     def __eq__(self, other: Account | str) -> bool:  # type: ignore[override]
         """Account equality is determined by the address of another `Account` or `str`"""
+
     def __ne__(self, other: Account | str) -> bool:  # type: ignore[override]
         """Account equality is determined by the address of another `Account` or `str`"""
     # truthiness
     def __bool__(self) -> bool:
         """Returns `True` if not equal to the zero-address"""
+
     @property
     def balance(self) -> UInt64:
         """Account balance in microalgos
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def min_balance(self) -> UInt64:
         """Minimum required balance for account, in microalgos
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def auth_address(self) -> Account:
         """Address the account is rekeyed to
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def total_num_uint(self) -> UInt64:
         """The total number of uint64 values allocated by this account in Global and Local States.
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def total_num_byte_slice(self) -> Bytes:
         """The total number of byte array values allocated by this account in Global and Local States.
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def total_extra_app_pages(self) -> UInt64:
         """The number of extra app code pages used by this account.
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def total_apps_created(self) -> UInt64:
         """The number of existing apps created by this account.
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def total_apps_opted_in(self) -> UInt64:
         """The number of apps this account is opted into.
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def total_assets_created(self) -> UInt64:
         """The number of existing ASAs created by this account.
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def total_assets(self) -> UInt64:
         """The numbers of ASAs held by this account (including ASAs this account created).
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def total_boxes(self) -> UInt64:
         """The number of existing boxes created by this account's app.
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     @property
     def total_box_bytes(self) -> UInt64:
         """The total number of bytes used by this account's app's box keys and values.
 
         ```{note}
         Account must be an available resource
         ```
         """
+
     def is_opted_in(self, asset_or_app: Asset | Application, /) -> bool:
         """Returns true if this account is opted in to the specified Asset or Application.
 
         ```{note}
         Account and Asset/Application must be an available resource
         ```
         """
 
 class Asset:
     """An Asset on the Algorand network."""
 
     def __init__(self, asset_id: UInt64 | int = 0, /):
         """Initialized with the id of an asset. Defaults to zero (an invalid ID)."""
+
     @property
     def id(self) -> UInt64:
         """Returns the id of the Asset"""
+
     def __eq__(self, other: Asset) -> bool:  # type: ignore[override]
         """Asset equality is determined by the equality of an Asset's id"""
+
     def __ne__(self, other: Asset) -> bool:  # type: ignore[override]
         """Asset equality is determined by the equality of an Asset's id"""
     # truthiness
     def __bool__(self) -> bool:
         """Returns `True` if `asset_id` is not `0`"""
+
     @property
     def total(self) -> UInt64:
         """Total number of units of this asset
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def decimals(self) -> UInt64:
         """See AssetParams.Decimals
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def default_frozen(self) -> bool:
         """Frozen by default or not
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def unit_name(self) -> Bytes:
         """Asset unit name
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def name(self) -> Bytes:
         """Asset name
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def url(self) -> Bytes:
         """URL with additional info about the asset
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def metadata_hash(self) -> Bytes:
         """Arbitrary commitment
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def manager(self) -> Account:
         """Manager address
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def reserve(self) -> Account:
         """Reserve address
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def freeze(self) -> Account:
         """Freeze address
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def clawback(self) -> Account:
         """Clawback address
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     @property
     def creator(self) -> Account:
         """Creator address
 
         ```{note}
         Asset must be an available resource
         ```
         """
+
     def balance(self, account: Account, /) -> UInt64:
-        """Amount of the asset unit held by this account
+        """Amount of the asset unit held by this account. Fails if the account has not
+        opted in to the asset.
 
         ```{note}
         Asset and supplied Account must be an available resource
         ```
         """
+
     def frozen(self, account: Account, /) -> bool:
-        """Is the asset frozen or not
+        """Is the asset frozen or not. Fails if the account has not
+        opted in to the asset.
 
         ```{note}
         Asset and supplied Account must be an available resource
         ```
         """
 
 class Application:
     """An Application on the Algorand network."""
 
     def __init__(self, application_id: UInt64 | int = 0, /):
         """Initialized with the id of an application. Defaults to zero (an invalid ID)."""
+
     @property
     def id(self) -> UInt64:
         """Returns the id of the application"""
+
     def __eq__(self, other: Application) -> bool:  # type: ignore[override]
         """Application equality is determined by the equality of an Application's id"""
+
     def __ne__(self, other: Application) -> bool:  # type: ignore[override]
         """Application equality is determined by the equality of an Application's id"""
     # truthiness
     def __bool__(self) -> bool:
         """Returns `True` if `application_id` is not `0`"""
+
     @property
     def approval_program(self) -> Bytes:
         """Bytecode of Approval Program
 
         ```{note}
         Application must be an available resource
         ```
         """
+
     @property
     def clear_state_program(self) -> Bytes:
         """Bytecode of Clear State Program
 
         ```{note}
         Application must be an available resource
         ```
         """
+
     @property
     def global_num_uint(self) -> UInt64:
         """Number of uint64 values allowed in Global State
 
         ```{note}
         Application must be an available resource
         ```
         """
+
     @property
     def global_num_bytes(self) -> UInt64:
         """Number of byte array values allowed in Global State
 
         ```{note}
         Application must be an available resource
         ```
         """
+
     @property
     def local_num_uint(self) -> UInt64:
         """Number of uint64 values allowed in Local State
 
         ```{note}
         Application must be an available resource
         ```
         """
+
     @property
     def local_num_bytes(self) -> UInt64:
         """Number of byte array values allowed in Local State
 
         ```{note}
         Application must be an available resource
         ```
         """
+
     @property
     def extra_program_pages(self) -> UInt64:
         """Number of Extra Program Pages of code space
 
         ```{note}
         Application must be an available resource
         ```
         """
+
     @property
     def creator(self) -> Account:
         """Creator address
 
         ```{note}
         Application must be an available resource
         ```
         """
+
     @property
     def address(self) -> Account:
         """Address for which this application has authority
 
         ```{note}
         Application must be an available resource
         ```
```

## puya/_typeshed/stdlib/algopy/_state.pyi

```diff
@@ -1,12 +1,12 @@
 import typing
 
-from algopy import Account, Bytes, BytesBacked, UInt64
+from algopy import Account, UInt64
 
-_TState = typing.TypeVar("_TState", bound=UInt64 | Bytes | BytesBacked)
+_TState = typing.TypeVar("_TState")
 
 class LocalState(typing.Generic[_TState]):
     """Local state associated with the application and an account"""
 
     def __init__(
         self,
         type_: type[_TState],
@@ -17,50 +17,56 @@
     ) -> None:
         """Declare the local state key and it's associated type
 
         ```python
         self.names = LocalState(algopy.Bytes)
         ```
         """
+
     def __getitem__(self, account: Account | UInt64 | int) -> _TState:
         """Data can be accessed by an `Account` reference or foreign account index
 
         ```python
         account_name = self.names[account]
         ```
         """
+
     def __setitem__(self, account: Account | UInt64 | int, value: _TState) -> None:
         """Data can be stored by using an `Account` reference or foreign account index
 
         ```python
         self.names[account] = account_name
         ```
         """
+
     def __delitem__(self, account: Account | UInt64 | int) -> None:
         """Data can be removed by using an `Account` reference or foreign account index
 
         ```python
         del self.names[account]
         ```
         """
+
     def __contains__(self, account: Account | UInt64 | int) -> bool:
         """Can test if data exists by using an `Account` reference or foreign account index
 
         ```python
         assert account in self.names
         ```
         """
+
     def get(self, account: Account | UInt64 | int, default: _TState) -> _TState:
         """Can retrieve value using an `Account` reference or foreign account index,
         and a fallback default value.
 
         ```python
         name = self.names.get(account, Bytes(b"no name")
         ```
         """
+
     def maybe(self, account: Account | UInt64 | int) -> tuple[_TState, bool]:
         """Can retrieve value, and a bool indicating if the value was present
         using an `Account` reference or foreign account index.
 
         ```python
         name, name_exists = self.names.maybe(account)
         if not name_exists:
@@ -86,56 +92,63 @@
         type_: type[_TState],
         /,
         *,
         key: bytes | str | None = None,
         description: str | None = None,
     ) -> None:
         """Declare the global state key and its type without initializing its value"""
+
     @typing.overload
     def __init__(
         self,
         initial_value: _TState,
         /,
         key: str | bytes | None = None,
         description: str | None = None,
     ) -> None:
         """Declare the global state key and initialize its value"""
+
     @property
     def value(self) -> _TState:
         """Returns the value or and error if the value is not set
 
         ```python
         name = self.name.value
         ```
         """
+
     @value.setter
     def value(self, value: _TState) -> None:
         """Sets the value
 
         ```python
         self.name.value = Bytes(b"Alice")
         ```
         """
+
     @value.deleter
     def value(self) -> None:
         """Removes the value
 
         ```python
         del self.name.value
         ```
         """
+
     def __bool__(self) -> bool:
         """Returns `True` if the key has a value set, regardless of the truthiness of that value"""
+
     def get(self, default: _TState) -> _TState:
         """Returns the value or `default` if no value is set
 
         ```python
         name = self.name.get(Bytes(b"no name")
         ```
         """
+
     def maybe(self) -> tuple[_TState, bool]:
         """Returns the value, and a bool
 
         ```python
         name, name_exists = self.name.maybe()
         if not name_exists:
             name = Bytes(b"no name")
```

## puya/_typeshed/stdlib/algopy/_transaction.pyi

```diff
@@ -98,65 +98,85 @@
     @property
     def frozen(self) -> bool: ...
 
 class ApplicationProtocol(typing.Protocol):
     @property
     def app_id(self) -> Application:
         """ApplicationID from ApplicationCall transaction"""
+
     @property
     def on_completion(self) -> OnCompleteAction:
         """ApplicationCall transaction on completion action"""
+
     @property
     def num_app_args(self) -> UInt64:
         """Number of ApplicationArgs"""
+
     @property
     def num_accounts(self) -> UInt64:
         """Number of ApplicationArgs"""
+
     @property
     def approval_program(self) -> Bytes:
         """Approval program"""
+
     @property
     def clear_state_program(self) -> Bytes:
         """Clear State program"""
+
     @property
     def num_assets(self) -> UInt64:
         """Number of Assets"""
+
     @property
     def num_apps(self) -> UInt64:
         """Number of Applications"""
+
     @property
     def global_num_uint(self) -> UInt64:
         """Number of global state integers in ApplicationCall"""
+
     @property
     def global_num_bytes(self) -> UInt64:
         """Number of global state byteslices in ApplicationCall"""
+
     @property
     def local_num_uint(self) -> UInt64:
         """Number of local state integers in ApplicationCall"""
+
     @property
     def local_num_bytes(self) -> UInt64:
         """Number of local state byteslices in ApplicationCall"""
+
     @property
     def extra_program_pages(self) -> UInt64:
         """Number of additional pages for each of the application's approval and clear state programs. An ExtraProgramPages of 1 means 2048 more total bytes, or 1024 for each program."""
+
     @property
     def last_log(self) -> Bytes:
         """The last message emitted. Empty bytes if none were emitted. Application mode only"""
+
     @property
     def num_approval_program_pages(self) -> UInt64:
         """Number of Approval Program pages"""
+
     @property
     def num_clear_state_program_pages(self) -> UInt64:
         """Number of Clear State Program pages"""
     # TODO: make the following sequences instead?
     def app_args(self, index: UInt64 | int, /) -> Bytes:
         """Arguments passed to the application in the ApplicationCall transaction"""
+
     def accounts(self, index: UInt64 | int, /) -> Account:
         """Accounts listed in the ApplicationCall transaction"""
+
     def assets(self, index: UInt64 | int, /) -> Asset:
         """Foreign Assets listed in the ApplicationCall transaction"""
+
     def apps(self, index: UInt64 | int, /) -> Application:
         """Foreign Apps listed in the ApplicationCall transaction"""
+
     def approval_program_pages(self, index: UInt64 | int, /) -> Bytes:
         """Approval Program as an array of pages"""
+
     def clear_state_program_pages(self, index: UInt64 | int, /) -> Bytes:
         """Clear State Program as an array of pages"""
```

## puya/_typeshed/stdlib/algopy/_util.pyi

```diff
@@ -7,15 +7,15 @@
     """Only the excess fee (credit) on the outer group should be used (set inner_tx.fee=0)"""
     AppAccount: OpUpFeeSource = ...
     """The app's account will cover all fees (set inner_tx.fee=Global.min_tx_fee())"""
     Any: OpUpFeeSource = ...
     """First the excess will be used, remaining fees will be taken from the app account"""
 
 def ensure_budget(
-    required_budget: UInt64 | int, fee_source: OpUpFeeSource = OpUpFeeSource.Any
+    required_budget: UInt64 | int, fee_source: OpUpFeeSource = OpUpFeeSource.GroupCredit
 ) -> None:
     """Ensure the available op code budget is greater than or equal to required_budget"""
 
 def log(
     *args: UInt64 | Bytes | BytesBacked | str | bytes | int, sep: Bytes | bytes | str = b""
 ) -> None:
     """Concatenates and logs supplied args as a single bytes value.
```

## puya/_typeshed/stdlib/algopy/arc4.pyi

```diff
@@ -31,25 +31,31 @@
 def abimethod(
     *,
     allow_actions: AllowedOnCompletes | None = None,
     create: typing.Literal["allow", "require", "disallow"] = "disallow",
     name: str | None = None,
     readonly: bool = False,
     default_args: Mapping[str, str | _TABIDefaultArgSource] | None = None,
-) -> Callable[[Callable[_P, _R]], Callable[_P, _R],]:
+) -> Callable[
+    [Callable[_P, _R]],
+    Callable[_P, _R],
+]:
     """Decorator that indicates a method is an ARC4 ABI method"""
 
 @typing.overload
 def baremethod(fn: Callable[_P, _R], /) -> Callable[_P, _R]: ...
 @typing.overload
 def baremethod(
     *,
     allow_actions: AllowedOnCompletes | None = None,
     create: typing.Literal["allow", "require", "disallow"] = "disallow",
-) -> Callable[[Callable[_P, _R]], Callable[_P, _R],]:
+) -> Callable[
+    [Callable[_P, _R]],
+    Callable[_P, _R],
+]:
     """Decorator that indicates a method is an ARC4 bare method"""
 
 def arc4_signature(signature: str, /) -> algopy.Bytes:
     """Returns the ARC4 encoded method selector for the specified signature"""
 
 class ARC4Contract(algopy.Contract):
     """A contract that conforms to the ARC4 ABI specification, functions decorated with
@@ -72,14 +78,15 @@
 class String(_ABIEncoded):
     """An ARC4 sequence of bytes containing a UTF8 string"""
 
     def __init__(self, value: algopy.String | str = "", /) -> None: ...
     @property
     def native(self) -> algopy.String:
         """Return the String representation of the UTF8 string after ARC4 decoding"""
+
     def __add__(self, other: String | str) -> String: ...
     def __iadd__(self, other: String | str) -> String: ...
     def __radd__(self, other: String | str) -> String: ...
     def __eq__(self, other: String | str) -> bool: ...  # type: ignore[override]
     def __bool__(self) -> bool:
         """Returns `True` if length is not zero"""
 
@@ -144,27 +151,29 @@
     Max size: 64 bits"""
 
     def __init__(self, value: str = "0.0", /):
         """
         Construct an instance of UFixedNxM where value (v) is determined from the original
         decimal value (d) by the formula v = round(d * (10^M))
         """
+
     def __bool__(self) -> bool:
         """Returns `True` if not equal to zero"""
 
 class BigUFixedNxM(_ABIEncoded, typing.Generic[_TBitSize, _TDecimalPlaces]):
     """An ARC4 UFixed representing a decimal with the number of bits and precision specified.
 
     Max size: 512 bits"""
 
     def __init__(self, value: str = "0.0", /):
         """
         Construct an instance of UFixedNxM where value (v) is determined from the original
         decimal value (d) by the formula v = round(d * (10^M))
         """
+
     def __bool__(self) -> bool:
         """Returns `True` if not equal to zero"""
 
 class Byte(UIntN[typing.Literal[8]]):
     """An ARC4 alias for a UInt8"""
 
 UInt8: typing.TypeAlias = UIntN[typing.Literal[8]]
@@ -309,67 +318,80 @@
         item9: _TArrayItem,
         /,
     ): ...
     @typing.overload
     def __init__(self, *items: _TArrayItem): ...
     def __iter__(self) -> typing.Iterator[_TArrayItem]:
         """Returns an iterator for the items in the array"""
+
     def __reversed__(self) -> typing.Iterator[_TArrayItem]:
         """Returns an iterator for the items in the array, in reverse order"""
+
     @property
     def length(self) -> algopy.UInt64:
         """Returns the current length of the array"""
+
     def __getitem__(self, index: algopy.UInt64 | int | slice) -> _TArrayItem: ...
     def __setitem__(self, index: algopy.UInt64 | int, value: _TArrayItem) -> _TArrayItem: ...
     def copy(self) -> typing.Self:
         """Create a copy of this array"""
 
 class DynamicArray(_ABIEncoded, typing.Generic[_TArrayItem], Reversible[_TArrayItem]):
     """A dynamically sized ARC4 Array of the specified type"""
 
     def __init__(self, *items: _TArrayItem): ...
     def __iter__(self) -> typing.Iterator[_TArrayItem]:
         """Returns an iterator for the items in the array"""
+
     def __reversed__(self) -> typing.Iterator[_TArrayItem]:
         """Returns an iterator for the items in the array, in reverse order"""
+
     @property
     def length(self) -> algopy.UInt64:
         """Returns the current length of the array"""
+
     def __getitem__(self, index: algopy.UInt64 | int | slice) -> _TArrayItem: ...
     def append(self, item: _TArrayItem, /) -> None:
         """Append items to this array"""
+
     def extend(self, other: Iterable[_TArrayItem], /) -> None:
         """Extend this array with the contents of another array"""
+
     def __setitem__(self, index: algopy.UInt64 | int, value: _TArrayItem) -> _TArrayItem: ...
     def __add__(self, other: Iterable[_TArrayItem]) -> DynamicArray[_TArrayItem]: ...
     def pop(self) -> _TArrayItem: ...
     def copy(self) -> typing.Self:
         """Create a copy of this array"""
+
     def __bool__(self) -> bool:
         """Returns `True` if not an empty array"""
 
 class Address(StaticArray[Byte, typing.Literal[32]]):
     """An alias for an array containing 32 bytes representing an Algorand address"""
 
     def __init__(self, value: algopy.Account | str | algopy.Bytes = ..., /):
         """
         If `value` is a string, it should be a 58 character base32 string,
         ie a base32 string-encoded 32 bytes public key + 4 bytes checksum.
         If `value` is a Bytes, it's length checked to be 32 bytes - to avoid this
         check, use `Address.from_bytes(...)` instead.
         Defaults to the zero-address.
         """
+
     @property
     def native(self) -> algopy.Account:
         """Return the Account representation of the address after ARC4 decoding"""
+
     def __bool__(self) -> bool:
         """Returns `True` if not equal to the zero address"""
+
     def __eq__(self, other: Address | algopy.Account | str) -> bool:  # type: ignore[override]
         """Address equality is determined by the address of another
         `arc4.Address`, `Account` or `str`"""
+
     def __ne__(self, other: Address | algopy.Account | str) -> bool:  # type: ignore[override]
         """Address equality is determined by the address of another
         `arc4.Address`, `Account` or `str`"""
 
 class DynamicBytes(DynamicArray[Byte]):
     """A variable sized array of bytes"""
 
@@ -384,14 +406,15 @@
 _TTuple = typing.TypeVarTuple("_TTuple")
 
 class Tuple(_ABIEncoded, tuple[typing.Unpack[_TTuple]]):
     """An ARC4 ABI tuple, containing other ARC4 ABI types"""
 
     def __init__(self, items: tuple[typing.Unpack[_TTuple]], /):
         """Construct an ARC4 tuple from a python tuple"""
+
     @property
     def native(self) -> tuple[typing.Unpack[_TTuple]]:
         """Return the Bytes representation of the address after ARC4 decoding"""
 
 @typing.dataclass_transform(
     eq_default=False, order_default=False, kw_only_default=False, field_specifiers=()
 )
@@ -407,20 +430,23 @@
 
 class Struct(metaclass=_StructMeta):
     """Base class for ARC4 Struct types"""
 
     @classmethod
     def from_bytes(cls, value: algopy.Bytes | bytes, /) -> typing.Self:
         """Construct an instance from the underlying bytes[] (no validation)"""
+
     @property
     def bytes(self) -> algopy.Bytes:
         """Get the underlying bytes[]"""
+
     @classmethod
     def from_log(cls, log: algopy.Bytes, /) -> typing.Self:
         """Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`"""
+
     def copy(self) -> typing.Self:
         """Create a copy of this struct"""
 
 class ARC4Client(typing.Protocol): ...
 
 _TABIResult_co = typing.TypeVar("_TABIResult_co", covariant=True)
 _TABIArg: typing.TypeAlias = (
@@ -469,15 +495,15 @@
         approval_program: algopy.Bytes | bytes | tuple[algopy.Bytes, ...] = ...,
         clear_state_program: algopy.Bytes | bytes | tuple[algopy.Bytes, ...] = ...,
         global_num_uint: UInt64 | int = ...,
         global_num_bytes: UInt64 | int = ...,
         local_num_uint: UInt64 | int = ...,
         local_num_bytes: UInt64 | int = ...,
         extra_program_pages: UInt64 | int = ...,
-        fee: algopy.UInt64 | int = ...,
+        fee: algopy.UInt64 | int = 0,
         sender: algopy.Account | str = ...,
         note: algopy.Bytes | bytes | str = ...,
         rekey_to: algopy.Account | str = ...,
     ) -> algopy.itxn.ApplicationCallInnerTransaction: ...
     @typing.overload
     def __call__(  # type: ignore[misc]
         self,
@@ -489,15 +515,15 @@
         approval_program: algopy.Bytes | bytes | tuple[algopy.Bytes, ...] = ...,
         clear_state_program: algopy.Bytes | bytes | tuple[algopy.Bytes, ...] = ...,
         global_num_uint: UInt64 | int = ...,
         global_num_bytes: UInt64 | int = ...,
         local_num_uint: UInt64 | int = ...,
         local_num_bytes: UInt64 | int = ...,
         extra_program_pages: UInt64 | int = ...,
-        fee: algopy.UInt64 | int = ...,
+        fee: algopy.UInt64 | int = 0,
         sender: algopy.Account | str = ...,
         note: algopy.Bytes | bytes | str = ...,
         rekey_to: algopy.Account | str = ...,
     ) -> tuple[_TABIResult_co, algopy.itxn.ApplicationCallInnerTransaction]: ...
     def __getitem__(
         self, _: type[_TABIResult_co]
     ) -> _ABICallWithReturnProtocol[_TABIResult_co]: ...
```

## puya/_typeshed/stdlib/algopy/itxn.pyi

```diff
@@ -46,17 +46,19 @@
 class ApplicationCallInnerTransaction(
     ApplicationProtocol, TransactionBaseProtocol, typing.Protocol
 ):
     """Application Call inner transaction"""
 
     def logs(self, index: UInt64 | int) -> Bytes:
         """Log messages emitted by an application call"""
+
     @property
     def num_logs(self) -> UInt64:
         """Number of logs"""
+
     @property
     def created_app(self) -> Application:
         """ApplicationID allocated by the creation of an application"""
 
 class InnerTransactionResult(
     PaymentInnerTransaction,
     KeyRegistrationInnerTransaction,
@@ -72,14 +74,15 @@
     "_TResult_co",
     covariant=True,
 )
 
 class _InnerTransaction(typing.Protocol[_TResult_co]):
     def submit(self) -> _TResult_co:
         """Submits inner transaction parameters and returns the resulting inner transaction"""
+
     def copy(self) -> typing.Self:
         """Copies a set of inner transaction parameters"""
 
 class InnerTransaction(_InnerTransaction[InnerTransactionResult]):
     """Creates a set of fields used to submit an inner transaction of any type"""
 
     def __init__(
@@ -110,14 +113,15 @@
         manager: Account | str = ...,
         reserve: Account | str = ...,
         freeze: Account | str = ...,
         clawback: Account | str = ...,
         ## asset transfer
         xfer_asset: Asset | UInt64 | int = ...,
         asset_amount: UInt64 | int = ...,
+        asset_sender: Account | str = ...,
         asset_receiver: Account | str = ...,
         asset_close_to: Account | str = ...,
         ## asset freeze
         freeze_asset: Asset | UInt64 | int = ...,
         freeze_account: Account | str = ...,
         frozen: bool = ...,
         ## application call
@@ -132,15 +136,15 @@
         extra_program_pages: UInt64 | int = ...,
         app_args: tuple[Bytes, ...] = ...,
         accounts: tuple[Account, ...] = ...,
         assets: tuple[Asset, ...] = ...,
         apps: tuple[Application, ...] = ...,
         ## shared
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ): ...
     def set(
         self,
         *,
         type: TransactionType = ...,  # noqa: A002
@@ -168,14 +172,15 @@
         manager: Account | str = ...,
         reserve: Account | str = ...,
         freeze: Account | str = ...,
         clawback: Account | str = ...,
         ## asset transfer
         xfer_asset: Asset | UInt64 | int = ...,
         asset_amount: UInt64 | int = ...,
+        asset_sender: Account | str = ...,
         asset_receiver: Account | str = ...,
         asset_close_to: Account | str = ...,
         ## asset freeze
         freeze_asset: Asset | UInt64 | int = ...,
         freeze_account: Account | str = ...,
         frozen: bool = ...,
         ## application call
@@ -190,15 +195,15 @@
         extra_program_pages: UInt64 | int = ...,
         app_args: tuple[Bytes, ...] = ...,
         accounts: tuple[Account, ...] = ...,
         assets: tuple[Asset, ...] = ...,
         apps: tuple[Application, ...] = ...,
         ## shared
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None:
         """Updates inner transaction parameter values"""
 
 class Payment(_InnerTransaction[PaymentInnerTransaction]):
     """Creates a set of fields used to submit a Payment inner transaction"""
@@ -206,26 +211,26 @@
     def __init__(
         self,
         *,
         receiver: Account | str,
         amount: UInt64 | int = ...,
         close_remainder_to: Account | str = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ): ...
     def set(
         self,
         *,
         receiver: Account | str = ...,
         amount: UInt64 | int = ...,
         close_remainder_to: Account | str = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None:
         """Updates inner transaction parameter values"""
 
 class KeyRegistration(_InnerTransaction[KeyRegistrationInnerTransaction]):
     """Creates a set of fields used to submit a Key Registration inner transaction"""
@@ -237,30 +242,30 @@
         selection_key: Bytes | bytes,
         vote_first: UInt64 | int,
         vote_last: UInt64 | int,
         vote_key_dilution: UInt64 | int,
         non_participation: UInt64 | int | bool = ...,
         state_proof_key: Bytes | bytes = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ): ...
     def set(
         self,
         *,
         vote_key: Bytes | bytes = ...,
         selection_key: Bytes | bytes = ...,
         vote_first: UInt64 | int = ...,
         vote_last: UInt64 | int = ...,
         vote_key_dilution: UInt64 | int = ...,
         non_participation: UInt64 | int | bool = ...,
         state_proof_key: Bytes | bytes = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None:
         """Updates inner transaction parameter values"""
 
 class AssetConfig(_InnerTransaction[AssetConfigInnerTransaction]):
     """Creates a set of fields used to submit an Asset Config inner transaction"""
@@ -277,15 +282,15 @@
         url: String | Bytes | str | bytes = ...,
         metadata_hash: Bytes | bytes = ...,
         manager: Account | str = ...,
         reserve: Account | str = ...,
         freeze: Account | str = ...,
         clawback: Account | str = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None: ...
     def set(
         self,
         *,
         config_asset: Asset | UInt64 | int = ...,
@@ -297,44 +302,46 @@
         url: String | Bytes | str | bytes = ...,
         metadata_hash: Bytes | bytes = ...,
         manager: Account | str = ...,
         reserve: Account | str = ...,
         freeze: Account | str = ...,
         clawback: Account | str = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None:
         """Updates inner transaction parameter values"""
 
 class AssetTransfer(_InnerTransaction[AssetTransferInnerTransaction]):
     """Creates a set of fields used to submit an Asset Transfer inner transaction"""
 
     def __init__(
         self,
         *,
         xfer_asset: Asset | UInt64 | int,
         asset_receiver: Account | str,
         asset_amount: UInt64 | int = ...,
+        asset_sender: Account | str = ...,
         asset_close_to: Account | str = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None: ...
     def set(
         self,
         *,
         xfer_asset: Asset | UInt64 | int = ...,
         asset_amount: UInt64 | int = ...,
+        asset_sender: Account | str = ...,
         asset_receiver: Account | str = ...,
         asset_close_to: Account | str = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None:
         """Updates transaction parameter values"""
 
 class AssetFreeze(_InnerTransaction[AssetFreezeInnerTransaction]):
     """Creates a set of fields used to submit a Asset Freeze inner transaction"""
@@ -342,26 +349,26 @@
     def __init__(
         self,
         *,
         freeze_asset: Asset | UInt64 | int,
         freeze_account: Account | str,
         frozen: bool,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None: ...
     def set(
         self,
         *,
         freeze_asset: Asset | UInt64 | int = ...,
         freeze_account: Account | str = ...,
         frozen: bool = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None:
         """Updates inner transaction parameter values"""
 
 class ApplicationCall(_InnerTransaction[ApplicationCallInnerTransaction]):
     """Creates a set of fields used to submit an Application Call inner transaction"""
@@ -379,15 +386,15 @@
         local_num_bytes: UInt64 | int = ...,
         extra_program_pages: UInt64 | int = ...,
         app_args: tuple[Bytes | BytesBacked, ...] = ...,
         accounts: tuple[Account, ...] = ...,
         assets: tuple[Asset, ...] = ...,
         apps: tuple[Application, ...] = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None: ...
     def set(
         self,
         *,
         app_id: Application | UInt64 | int = ...,
@@ -400,15 +407,15 @@
         local_num_bytes: UInt64 | int = ...,
         extra_program_pages: UInt64 | int = ...,
         app_args: tuple[Bytes | BytesBacked, ...] = ...,
         accounts: tuple[Account, ...] = ...,
         assets: tuple[Asset, ...] = ...,
         apps: tuple[Application, ...] = ...,
         sender: Account | str = ...,
-        fee: UInt64 | int = ...,
+        fee: UInt64 | int = 0,
         note: String | Bytes | str | bytes = ...,
         rekey_to: Account | str = ...,
     ) -> None:
         """Updates inner transaction parameter values"""
 
 _T1 = typing.TypeVar("_T1")
 _T2 = typing.TypeVar("_T2")
```

## puya/_typeshed/stdlib/algopy/op.pyi

```diff
@@ -64,23 +64,23 @@
 
      Decodes A using the base64 encoding E. Specify the encoding with an immediate arg either as URL and Filename Safe (`URLEncoding`) or Standard (`StdEncoding`). See [RFC 4648 sections 4 and 5](https://rfc-editor.org/rfc/rfc4648.html#section-4). It is assumed that the encoding ends with the exact number of `=` padding characters as required by the RFC. When padding occurs, any unused pad bits in the encoding must be set to zero or the decoding will fail. The special cases of `\\n` and `\\r` are allowed but completely ignored. An error will result when attempting to decode a string with a character that is not in the encoding alphabet or not one of `=`, `\\r`, or `\\n`.
     :param Base64 e: encoding index
 
     Native TEAL opcode: [`base64_decode`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#base64_decode)
     """
 
-def bitlen(a: Bytes | bytes | UInt64 | int, /) -> UInt64:
+def bitlen(a: Bytes | UInt64 | bytes | int, /) -> UInt64:
     """
     The highest set bit in A. If A is a byte-array, it is interpreted as a big-endian unsigned integer. bitlen of 0 is 0, bitlen of 8 is 4
     bitlen interprets arrays as big-endian integers, unlike setbit/getbit
 
     Native TEAL opcode: [`bitlen`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#bitlen)
     """
 
-def bsqrt(a: BigUInt, /) -> BigUInt:
+def bsqrt(a: BigUInt | int, /) -> BigUInt:
     """
     The largest integer I such that I^2 <= A. A and I are interpreted as big-endian unsigned integers
 
     Native TEAL opcode: [`bsqrt`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#bsqrt)
     """
 
 def btoi(a: Bytes | bytes, /) -> UInt64:
@@ -239,15 +239,15 @@
     """
     ID of the asset or application created in the Ath transaction of the current group
     `gaids` fails unless the requested transaction created an asset or application and A < GroupIndex.
 
     Native TEAL opcode: [`gaid`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gaid), [`gaids`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gaids)
     """
 
-def getbit(a: Bytes | bytes | UInt64 | int, b: UInt64 | int, /) -> UInt64:
+def getbit(a: Bytes | UInt64 | bytes | int, b: UInt64 | int, /) -> UInt64:
     """
     Bth bit of (byte-array or integer) A. If B is greater than or equal to the bit length of the value (8*byte length), the program fails
     see explanation of bit ordering in setbit
 
     Native TEAL opcode: [`getbit`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#getbit)
     """
 
@@ -305,23 +305,37 @@
     """
     Copy of A with the bytes starting at B replaced by the bytes of C. Fails if B+len(C) exceeds len(A)
     `replace3` can be called using `replace` with no immediates.
 
     Native TEAL opcode: [`replace2`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#replace2), [`replace3`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#replace3)
     """
 
-def setbit_bytes(a: Bytes | bytes | UInt64 | int, b: UInt64 | int, c: UInt64 | int, /) -> Bytes:
+def select_bytes(a: Bytes | bytes, b: Bytes | bytes, c: bool | UInt64 | int, /) -> Bytes:
+    """
+    selects one of two values based on top-of-stack: B if C != 0, else A
+
+    Native TEAL opcode: [`select`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#select)
+    """
+
+def select_uint64(a: UInt64 | int, b: UInt64 | int, c: bool | UInt64 | int, /) -> UInt64:
+    """
+    selects one of two values based on top-of-stack: B if C != 0, else A
+
+    Native TEAL opcode: [`select`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#select)
+    """
+
+def setbit_bytes(a: Bytes | bytes, b: UInt64 | int, c: UInt64 | int, /) -> Bytes:
     """
     Copy of (byte-array or integer) A, with the Bth bit set to (0 or 1) C. If B is greater than or equal to the bit length of the value (8*byte length), the program fails
     When A is a uint64, index 0 is the least significant bit. Setting bit 3 to 1 on the integer 0 yields 8, or 2^3. When A is a byte array, index 0 is the leftmost bit of the leftmost byte. Setting bits 0 through 11 to 1 in a 4-byte-array of 0s yields the byte array 0xfff00000. Setting bit 3 to 1 on the 1-byte-array 0x00 yields the byte array 0x10.
 
     Native TEAL opcode: [`setbit`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#setbit)
     """
 
-def setbit_uint64(a: Bytes | bytes | UInt64 | int, b: UInt64 | int, c: UInt64 | int, /) -> UInt64:
+def setbit_uint64(a: UInt64 | int, b: UInt64 | int, c: UInt64 | int, /) -> UInt64:
     """
     Copy of (byte-array or integer) A, with the Bth bit set to (0 or 1) C. If B is greater than or equal to the bit length of the value (8*byte length), the program fails
     When A is a uint64, index 0 is the least significant bit. Setting bit 3 to 1 on the integer 0 yields 8, or 2^3. When A is a byte array, index 0 is the leftmost bit of the leftmost byte. Setting bits 0 through 11 to 1 in a 4-byte-array of 0s yields the byte array 0xfff00000. Setting bit 3 to 1 on the 1-byte-array 0x00 yields the byte array 0x10.
 
     Native TEAL opcode: [`setbit`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#setbit)
     """
 
@@ -401,84 +415,95 @@
     @staticmethod
     def acct_balance(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         Account balance in microalgos
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_min_balance(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         Minimum required balance for account, in microalgos
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_auth_addr(a: Account | UInt64 | int, /) -> tuple[Account, bool]:
         """
         Address the account is rekeyed to.
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_total_num_uint(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         The total number of uint64 values allocated by this account in Global and Local States.
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_total_num_byte_slice(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         The total number of byte array values allocated by this account in Global and Local States.
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_total_extra_app_pages(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         The number of extra app code pages used by this account.
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_total_apps_created(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         The number of existing apps created by this account.
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_total_apps_opted_in(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         The number of apps this account is opted into.
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_total_assets_created(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         The number of existing ASAs created by this account.
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_total_assets(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         The numbers of ASAs held by this account (including ASAs this account created).
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_total_boxes(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         The number of existing boxes created by this account's app.
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
+
     @staticmethod
     def acct_total_box_bytes(a: Account | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         The total number of bytes used by this account's app's box keys and values.
 
         Native TEAL opcode: [`acct_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#acct_params_get)
         """
@@ -493,50 +518,55 @@
     def get_bytes(a: Bytes | bytes, /) -> Bytes:
         """
         global state of the key A in the current application
         params: state key. Return: value. The value is zero (of type uint64) if the key does not exist.
 
         Native TEAL opcode: [`app_global_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_global_get)
         """
+
     @staticmethod
     def get_uint64(a: Bytes | bytes, /) -> UInt64:
         """
         global state of the key A in the current application
         params: state key. Return: value. The value is zero (of type uint64) if the key does not exist.
 
         Native TEAL opcode: [`app_global_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_global_get)
         """
+
     @staticmethod
     def get_ex_bytes(a: Application | UInt64 | int, b: Bytes | bytes, /) -> tuple[Bytes, bool]:
         """
         X is the global state of application A, key B. Y is 1 if key existed, else 0
         params: Txn.ForeignApps offset (or, since v4, an _available_ application id), state key. Return: did_exist flag (top of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.
 
         Native TEAL opcode: [`app_global_get_ex`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_global_get_ex)
         """
+
     @staticmethod
     def get_ex_uint64(a: Application | UInt64 | int, b: Bytes | bytes, /) -> tuple[UInt64, bool]:
         """
         X is the global state of application A, key B. Y is 1 if key existed, else 0
         params: Txn.ForeignApps offset (or, since v4, an _available_ application id), state key. Return: did_exist flag (top of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.
 
         Native TEAL opcode: [`app_global_get_ex`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_global_get_ex)
         """
+
     @staticmethod
     def delete(a: Bytes | bytes, /) -> None:
         """
         delete key A from the global state of the current application
         params: state key.
 
         Deleting a key which is already absent has no effect on the application global state. (In particular, it does _not_ cause the program to fail.)
 
         Native TEAL opcode: [`app_global_del`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_global_del)
         """
+
     @staticmethod
-    def put(a: Bytes | bytes, b: Bytes | bytes | UInt64 | int, /) -> None:
+    def put(a: Bytes | bytes, b: Bytes | UInt64 | bytes | int, /) -> None:
         """
         write B to key A in the global state of the current application
 
         Native TEAL opcode: [`app_global_put`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_global_put)
         """
 
 class AppLocal:
@@ -549,55 +579,60 @@
     def get_bytes(a: Account | UInt64 | int, b: Bytes | bytes, /) -> Bytes:
         """
         local state of the key B in the current application in account A
         params: Txn.Accounts offset (or, since v4, an _available_ account address), state key. Return: value. The value is zero (of type uint64) if the key does not exist.
 
         Native TEAL opcode: [`app_local_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_local_get)
         """
+
     @staticmethod
     def get_uint64(a: Account | UInt64 | int, b: Bytes | bytes, /) -> UInt64:
         """
         local state of the key B in the current application in account A
         params: Txn.Accounts offset (or, since v4, an _available_ account address), state key. Return: value. The value is zero (of type uint64) if the key does not exist.
 
         Native TEAL opcode: [`app_local_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_local_get)
         """
+
     @staticmethod
     def get_ex_bytes(
         a: Account | UInt64 | int, b: Application | UInt64 | int, c: Bytes | bytes, /
     ) -> tuple[Bytes, bool]:
         """
         X is the local state of application B, key C in account A. Y is 1 if key existed, else 0
         params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset), state key. Return: did_exist flag (top of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.
 
         Native TEAL opcode: [`app_local_get_ex`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_local_get_ex)
         """
+
     @staticmethod
     def get_ex_uint64(
         a: Account | UInt64 | int, b: Application | UInt64 | int, c: Bytes | bytes, /
     ) -> tuple[UInt64, bool]:
         """
         X is the local state of application B, key C in account A. Y is 1 if key existed, else 0
         params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset), state key. Return: did_exist flag (top of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.
 
         Native TEAL opcode: [`app_local_get_ex`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_local_get_ex)
         """
+
     @staticmethod
     def delete(a: Account | UInt64 | int, b: Bytes | bytes, /) -> None:
         """
         delete key B from account A's local state of the current application
         params: Txn.Accounts offset (or, since v4, an _available_ account address), state key.
 
         Deleting a key which is already absent has no effect on the application local state. (In particular, it does _not_ cause the program to fail.)
 
         Native TEAL opcode: [`app_local_del`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_local_del)
         """
+
     @staticmethod
     def put(
-        a: Account | UInt64 | int, b: Bytes | bytes, c: Bytes | bytes | UInt64 | int, /
+        a: Account | UInt64 | int, b: Bytes | bytes, c: Bytes | UInt64 | bytes | int, /
     ) -> None:
         """
         write C to key B in account A's local state of the current application
         params: Txn.Accounts offset (or, since v4, an _available_ account address), state key, value.
 
         Native TEAL opcode: [`app_local_put`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_local_put)
         """
@@ -611,63 +646,71 @@
     @staticmethod
     def app_approval_program(a: Application | UInt64 | int, /) -> tuple[Bytes, bool]:
         """
         Bytecode of Approval Program
 
         Native TEAL opcode: [`app_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_params_get)
         """
+
     @staticmethod
     def app_clear_state_program(a: Application | UInt64 | int, /) -> tuple[Bytes, bool]:
         """
         Bytecode of Clear State Program
 
         Native TEAL opcode: [`app_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_params_get)
         """
+
     @staticmethod
     def app_global_num_uint(a: Application | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         Number of uint64 values allowed in Global State
 
         Native TEAL opcode: [`app_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_params_get)
         """
+
     @staticmethod
     def app_global_num_byte_slice(a: Application | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         Number of byte array values allowed in Global State
 
         Native TEAL opcode: [`app_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_params_get)
         """
+
     @staticmethod
     def app_local_num_uint(a: Application | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         Number of uint64 values allowed in Local State
 
         Native TEAL opcode: [`app_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_params_get)
         """
+
     @staticmethod
     def app_local_num_byte_slice(a: Application | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         Number of byte array values allowed in Local State
 
         Native TEAL opcode: [`app_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_params_get)
         """
+
     @staticmethod
     def app_extra_program_pages(a: Application | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         Number of Extra Program Pages of code space
 
         Native TEAL opcode: [`app_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_params_get)
         """
+
     @staticmethod
     def app_creator(a: Application | UInt64 | int, /) -> tuple[Account, bool]:
         """
         Creator address
 
         Native TEAL opcode: [`app_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_params_get)
         """
+
     @staticmethod
     def app_address(a: Application | UInt64 | int, /) -> tuple[Account, bool]:
         """
         Address for which this application has authority
 
         Native TEAL opcode: [`app_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_params_get)
         """
@@ -683,14 +726,15 @@
         a: Account | UInt64 | int, b: Asset | UInt64 | int, /
     ) -> tuple[UInt64, bool]:
         """
         Amount of the asset unit held by this account
 
         Native TEAL opcode: [`asset_holding_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_holding_get)
         """
+
     @staticmethod
     def asset_frozen(a: Account | UInt64 | int, b: Asset | UInt64 | int, /) -> tuple[bool, bool]:
         """
         Is the asset frozen or not
 
         Native TEAL opcode: [`asset_holding_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_holding_get)
         """
@@ -704,84 +748,95 @@
     @staticmethod
     def asset_total(a: Asset | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         Total number of units of this asset
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_decimals(a: Asset | UInt64 | int, /) -> tuple[UInt64, bool]:
         """
         See AssetParams.Decimals
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_default_frozen(a: Asset | UInt64 | int, /) -> tuple[bool, bool]:
         """
         Frozen by default or not
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_unit_name(a: Asset | UInt64 | int, /) -> tuple[Bytes, bool]:
         """
         Asset unit name
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_name(a: Asset | UInt64 | int, /) -> tuple[Bytes, bool]:
         """
         Asset name
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_url(a: Asset | UInt64 | int, /) -> tuple[Bytes, bool]:
         """
         URL with additional info about the asset
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_metadata_hash(a: Asset | UInt64 | int, /) -> tuple[Bytes, bool]:
         """
         Arbitrary commitment
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_manager(a: Asset | UInt64 | int, /) -> tuple[Account, bool]:
         """
         Manager address
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_reserve(a: Asset | UInt64 | int, /) -> tuple[Account, bool]:
         """
         Reserve address
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_freeze(a: Asset | UInt64 | int, /) -> tuple[Account, bool]:
         """
         Freeze address
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_clawback(a: Asset | UInt64 | int, /) -> tuple[Account, bool]:
         """
         Clawback address
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
+
     @staticmethod
     def asset_creator(a: Asset | UInt64 | int, /) -> tuple[Account, bool]:
         """
         Creator address
 
         Native TEAL opcode: [`asset_params_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#asset_params_get)
         """
@@ -794,14 +849,15 @@
 
     @staticmethod
     def blk_seed(a: UInt64 | int, /) -> Bytes:
         """
 
         Native TEAL opcode: [`block`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#block)
         """
+
     @staticmethod
     def blk_timestamp(a: UInt64 | int, /) -> UInt64:
         """
 
         Native TEAL opcode: [`block`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#block)
         """
 
@@ -815,65 +871,73 @@
     def create(a: Bytes | bytes, b: UInt64 | int, /) -> bool:
         """
         create a box named A, of length B. Fail if the name A is empty or B exceeds 32,768. Returns 0 if A already existed, else 1
         Newly created boxes are filled with 0 bytes. `box_create` will fail if the referenced box already exists with a different size. Otherwise, existing boxes are unchanged by `box_create`.
 
         Native TEAL opcode: [`box_create`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#box_create)
         """
+
     @staticmethod
     def delete(a: Bytes | bytes, /) -> bool:
         """
         delete box named A if it exists. Return 1 if A existed, 0 otherwise
 
         Native TEAL opcode: [`box_del`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#box_del)
         """
+
     @staticmethod
     def extract(a: Bytes | bytes, b: UInt64 | int, c: UInt64 | int, /) -> Bytes:
         """
         read C bytes from box A, starting at offset B. Fail if A does not exist, or the byte range is outside A's size.
 
         Native TEAL opcode: [`box_extract`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#box_extract)
         """
+
     @staticmethod
     def get(a: Bytes | bytes, /) -> tuple[Bytes, bool]:
         """
         X is the contents of box A if A exists, else ''. Y is 1 if A exists, else 0.
         For boxes that exceed 4,096 bytes, consider `box_create`, `box_extract`, and `box_replace`
 
         Native TEAL opcode: [`box_get`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#box_get)
         """
+
     @staticmethod
     def length(a: Bytes | bytes, /) -> tuple[UInt64, bool]:
         """
         X is the length of box A if A exists, else 0. Y is 1 if A exists, else 0.
 
         Native TEAL opcode: [`box_len`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#box_len)
         """
+
     @staticmethod
     def put(a: Bytes | bytes, b: Bytes | bytes, /) -> None:
         """
         replaces the contents of box A with byte-array B. Fails if A exists and len(B) != len(box A). Creates A if it does not exist
         For boxes that exceed 4,096 bytes, consider `box_create`, `box_extract`, and `box_replace`
 
         Native TEAL opcode: [`box_put`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#box_put)
         """
+
     @staticmethod
     def replace(a: Bytes | bytes, b: UInt64 | int, c: Bytes | bytes, /) -> None:
         """
         write byte-array C into box A, starting at offset B. Fail if A does not exist, or the byte range is outside A's size.
 
         Native TEAL opcode: [`box_replace`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#box_replace)
         """
+
     @staticmethod
     def resize(a: Bytes | bytes, b: UInt64 | int, /) -> None:
         """
         change the size of box named A to be of length B, adding zero bytes to end or removing bytes from the end, as needed. Fail if the name A is empty, A is not an existing box, or B exceeds 32,768.
 
         Native TEAL opcode: [`box_resize`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#box_resize)
         """
+
     @staticmethod
     def splice(a: Bytes | bytes, b: UInt64 | int, c: UInt64 | int, d: Bytes | bytes, /) -> None:
         """
         set box A to contain its previous bytes up to index B, followed by D, followed by the original bytes of A that began at index B+C.
         Boxes are of constant length. If C < len(D), then len(D)-C bytes will be removed from the end. If C > len(D), zero bytes will be appended to the end to reach the box length.
 
         Native TEAL opcode: [`box_splice`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#box_splice)
@@ -899,52 +963,57 @@
         Fails if A or B is not in G.
         A and/or B are allowed to be the point at infinity.
         Does _not_ check if A and B are in the main prime-order subgroup.
         :param EC g: curve index
 
         Native TEAL opcode: [`ec_add`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ec_add)
         """
+
     @staticmethod
     def map_to(g: EC, a: Bytes | bytes, /) -> Bytes:
         """
         maps field element A to group G
         BN254 points are mapped by the SVDW map. BLS12-381 points are mapped by the SSWU map.
         G1 element inputs are base field elements and G2 element inputs are quadratic field elements, with nearly the same encoding rules (for field elements) as defined in `ec_add`. There is one difference of encoding rule: G1 element inputs do not need to be 0-padded if they fit in less than 32 bytes for BN254 and less than 48 bytes for BLS12-381. (As usual, the empty byte array represents 0.) G2 elements inputs need to be always have the required size.
         :param EC g: curve index
 
         Native TEAL opcode: [`ec_map_to`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ec_map_to)
         """
+
     @staticmethod
     def scalar_mul_multi(g: EC, a: Bytes | bytes, b: Bytes | bytes, /) -> Bytes:
         """
         for curve points A and scalars B, return curve point B0A0 + B1A1 + B2A2 + ... + BnAn
         A is a list of concatenated points, encoded and checked as described in `ec_add`. B is a list of concatenated scalars which, unlike ec_scalar_mul, must all be exactly 32 bytes long.
         The name `ec_multi_scalar_mul` was chosen to reflect common usage, but a more consistent name would be `ec_multi_scalar_mul`. AVM values are limited to 4096 bytes, so `ec_multi_scalar_mul` is limited by the size of the points in the group being operated upon.
         :param EC g: curve index
 
         Native TEAL opcode: [`ec_multi_scalar_mul`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ec_multi_scalar_mul)
         """
+
     @staticmethod
     def pairing_check(g: EC, a: Bytes | bytes, b: Bytes | bytes, /) -> bool:
         """
         1 if the product of the pairing of each point in A with its respective point in B is equal to the identity element of the target group Gt, else 0
         A and B are concatenated points, encoded and checked as described in `ec_add`. A contains points of the group G, B contains points of the associated group (G2 if G is G1, and vice versa). Fails if A and B have a different number of points, or if any point is not in its described group or outside the main prime-order subgroup - a stronger condition than other opcodes. AVM values are limited to 4096 bytes, so `ec_pairing_check` is limited by the size of the points in the groups being operated upon.
         :param EC g: curve index
 
         Native TEAL opcode: [`ec_pairing_check`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ec_pairing_check)
         """
+
     @staticmethod
     def scalar_mul(g: EC, a: Bytes | bytes, b: Bytes | bytes, /) -> Bytes:
         """
         for curve point A and scalar B, return the curve point BA, the point A multiplied by the scalar B.
         A is a curve point encoded and checked as described in `ec_add`. Scalar B is interpreted as a big-endian unsigned integer. Fails if B exceeds 32 bytes.
         :param EC g: curve index
 
         Native TEAL opcode: [`ec_scalar_mul`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ec_scalar_mul)
         """
+
     @staticmethod
     def subgroup_check(g: EC, a: Bytes | bytes, /) -> bool:
         """
         1 if A is in the main prime-order subgroup of G (including the point at infinity) else 0. Program fails if A is not in G at all.
         :param EC g: curve index
 
         Native TEAL opcode: [`ec_subgroup_check`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ec_subgroup_check)
@@ -960,542 +1029,609 @@
     def sender(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def fee(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: microalgos
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def first_valid(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: round number
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def first_valid_time(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: UNIX timestamp of block before txn.FirstValid. Fails if negative
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def last_valid(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: round number
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def note(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: Any data up to 1024 bytes
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def lease(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: 32 byte lease value
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def receiver(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def amount(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: microalgos
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def close_remainder_to(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def vote_pk(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def selection_pk(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def vote_first(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: The first round that the participation key is valid.
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def vote_last(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: The last round that the participation key is valid.
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def vote_key_dilution(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Dilution for the 2-level participation key
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def type(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: Transaction type as bytes
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def type_enum(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Transaction type as integer
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def xfer_asset(t: int, /) -> Asset:
         """
         :param int t: transaction group index
         :returns Asset: Asset ID
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def asset_amount(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: value in Asset's units
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def asset_sender(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address. Source of assets if Sender is the Asset's Clawback address.
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def asset_receiver(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def asset_close_to(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def group_index(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Position of this transaction within an atomic transaction group. A stand-alone transaction is implicitly element 0 in a group of 1
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def tx_id(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: The computed ID for this transaction. 32 bytes.
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def application_id(t: int, /) -> Application:
         """
         :param int t: transaction group index
         :returns Application: ApplicationID from ApplicationCall transaction
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def on_completion(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: ApplicationCall transaction on completion action
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def application_args(t: int, a: UInt64 | int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: Arguments passed to the application in the ApplicationCall transaction
 
         Native TEAL opcode: [`gitxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxna), [`gitxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxnas)
         """
+
     @staticmethod
     def num_app_args(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of ApplicationArgs
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def accounts(t: int, a: UInt64 | int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: Accounts listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`gitxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxna), [`gitxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxnas)
         """
+
     @staticmethod
     def num_accounts(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of Accounts
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def approval_program(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: Approval program
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def clear_state_program(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: Clear state program
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def rekey_to(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte Sender's new AuthAddr
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset(t: int, /) -> Asset:
         """
         :param int t: transaction group index
         :returns Asset: Asset ID in asset config transaction
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_total(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Total number of units of this asset created
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_decimals(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of digits to display after the decimal place when displaying the asset
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_default_frozen(t: int, /) -> bool:
         """
         :param int t: transaction group index
         :returns bool: Whether the asset's slots are frozen by default or not, 0 or 1
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_unit_name(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: Unit name of the asset
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_name(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: The asset name
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_url(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: URL
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_metadata_hash(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: 32 byte commitment to unspecified asset metadata
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_manager(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_reserve(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_freeze(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def config_asset_clawback(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def freeze_asset(t: int, /) -> Asset:
         """
         :param int t: transaction group index
         :returns Asset: Asset ID being frozen or un-frozen
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def freeze_asset_account(t: int, /) -> Account:
         """
         :param int t: transaction group index
         :returns Account: 32 byte address of the account whose asset slot is being frozen or un-frozen
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def freeze_asset_frozen(t: int, /) -> bool:
         """
         :param int t: transaction group index
         :returns bool: The new frozen value, 0 or 1
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def assets(t: int, a: UInt64 | int, /) -> Asset:
         """
         :param int t: transaction group index
         :returns Asset: Foreign Assets listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`gitxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxna), [`gitxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxnas)
         """
+
     @staticmethod
     def num_assets(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of Assets
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def applications(t: int, a: UInt64 | int, /) -> Application:
         """
         :param int t: transaction group index
         :returns Application: Foreign Apps listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`gitxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxna), [`gitxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxnas)
         """
+
     @staticmethod
     def num_applications(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of Applications
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def global_num_uint(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of global state integers in ApplicationCall
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def global_num_byte_slice(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of global state byteslices in ApplicationCall
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def local_num_uint(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of local state integers in ApplicationCall
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def local_num_byte_slice(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of local state byteslices in ApplicationCall
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def extra_program_pages(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of additional pages for each of the application's approval and clear state programs. An ExtraProgramPages of 1 means 2048 more total bytes, or 1024 for each program.
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def nonparticipation(t: int, /) -> bool:
         """
         :param int t: transaction group index
         :returns bool: Marks an account nonparticipating for rewards
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def logs(t: int, a: UInt64 | int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: Log messages emitted by an application call (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`gitxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxna), [`gitxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxnas)
         """
+
     @staticmethod
     def num_logs(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of Logs (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def created_asset_id(t: int, /) -> Asset:
         """
         :param int t: transaction group index
         :returns Asset: Asset ID allocated by the creation of an ASA (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def created_application_id(t: int, /) -> Application:
         """
         :param int t: transaction group index
         :returns Application: ApplicationID allocated by the creation of an application (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def last_log(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: The last message emitted. Empty bytes if none were emitted. Application mode only
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def state_proof_pk(t: int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: 64 byte state proof public key
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def approval_program_pages(t: int, a: UInt64 | int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: Approval Program as an array of pages
 
         Native TEAL opcode: [`gitxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxna), [`gitxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxnas)
         """
+
     @staticmethod
     def num_approval_program_pages(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of Approval Program pages
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
         """
+
     @staticmethod
     def clear_state_program_pages(t: int, a: UInt64 | int, /) -> Bytes:
         """
         :param int t: transaction group index
         :returns Bytes: ClearState Program as an array of pages
 
         Native TEAL opcode: [`gitxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxna), [`gitxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxnas)
         """
+
     @staticmethod
     def num_clear_state_program_pages(t: int, /) -> UInt64:
         """
         :param int t: transaction group index
         :returns UInt64: Number of ClearState Program pages
 
         Native TEAL opcode: [`gitxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gitxn)
@@ -1510,476 +1646,543 @@
     @staticmethod
     def sender(a: UInt64 | int, /) -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def fee(a: UInt64 | int, /) -> UInt64:
         """
         microalgos
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def first_valid(a: UInt64 | int, /) -> UInt64:
         """
         round number
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def first_valid_time(a: UInt64 | int, /) -> UInt64:
         """
         UNIX timestamp of block before txn.FirstValid. Fails if negative
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def last_valid(a: UInt64 | int, /) -> UInt64:
         """
         round number
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def note(a: UInt64 | int, /) -> Bytes:
         """
         Any data up to 1024 bytes
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def lease(a: UInt64 | int, /) -> Bytes:
         """
         32 byte lease value
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def receiver(a: UInt64 | int, /) -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def amount(a: UInt64 | int, /) -> UInt64:
         """
         microalgos
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def close_remainder_to(a: UInt64 | int, /) -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def vote_pk(a: UInt64 | int, /) -> Bytes:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def selection_pk(a: UInt64 | int, /) -> Bytes:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def vote_first(a: UInt64 | int, /) -> UInt64:
         """
         The first round that the participation key is valid.
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def vote_last(a: UInt64 | int, /) -> UInt64:
         """
         The last round that the participation key is valid.
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def vote_key_dilution(a: UInt64 | int, /) -> UInt64:
         """
         Dilution for the 2-level participation key
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def type(a: UInt64 | int, /) -> Bytes:
         """
         Transaction type as bytes
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def type_enum(a: UInt64 | int, /) -> UInt64:
         """
         Transaction type as integer
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def xfer_asset(a: UInt64 | int, /) -> Asset:
         """
         Asset ID
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def asset_amount(a: UInt64 | int, /) -> UInt64:
         """
         value in Asset's units
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def asset_sender(a: UInt64 | int, /) -> Account:
         """
         32 byte address. Source of assets if Sender is the Asset's Clawback address.
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def asset_receiver(a: UInt64 | int, /) -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def asset_close_to(a: UInt64 | int, /) -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def group_index(a: UInt64 | int, /) -> UInt64:
         """
         Position of this transaction within an atomic transaction group. A stand-alone transaction is implicitly element 0 in a group of 1
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def tx_id(a: UInt64 | int, /) -> Bytes:
         """
         The computed ID for this transaction. 32 bytes.
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def application_id(a: UInt64 | int, /) -> Application:
         """
         ApplicationID from ApplicationCall transaction
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def on_completion(a: UInt64 | int, /) -> UInt64:
         """
         ApplicationCall transaction on completion action
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def application_args(a: UInt64 | int, b: UInt64 | int, /) -> Bytes:
         """
         Arguments passed to the application in the ApplicationCall transaction
 
         Native TEAL opcode: [`gtxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxna), [`gtxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnas), [`gtxnsa`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsa), [`gtxnsas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsas)
         """
+
     @staticmethod
     def num_app_args(a: UInt64 | int, /) -> UInt64:
         """
         Number of ApplicationArgs
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def accounts(a: UInt64 | int, b: UInt64 | int, /) -> Account:
         """
         Accounts listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`gtxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxna), [`gtxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnas), [`gtxnsa`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsa), [`gtxnsas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsas)
         """
+
     @staticmethod
     def num_accounts(a: UInt64 | int, /) -> UInt64:
         """
         Number of Accounts
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def approval_program(a: UInt64 | int, /) -> Bytes:
         """
         Approval program
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def clear_state_program(a: UInt64 | int, /) -> Bytes:
         """
         Clear state program
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def rekey_to(a: UInt64 | int, /) -> Account:
         """
         32 byte Sender's new AuthAddr
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset(a: UInt64 | int, /) -> Asset:
         """
         Asset ID in asset config transaction
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_total(a: UInt64 | int, /) -> UInt64:
         """
         Total number of units of this asset created
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_decimals(a: UInt64 | int, /) -> UInt64:
         """
         Number of digits to display after the decimal place when displaying the asset
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_default_frozen(a: UInt64 | int, /) -> bool:
         """
         Whether the asset's slots are frozen by default or not, 0 or 1
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_unit_name(a: UInt64 | int, /) -> Bytes:
         """
         Unit name of the asset
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_name(a: UInt64 | int, /) -> Bytes:
         """
         The asset name
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_url(a: UInt64 | int, /) -> Bytes:
         """
         URL
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_metadata_hash(a: UInt64 | int, /) -> Bytes:
         """
         32 byte commitment to unspecified asset metadata
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_manager(a: UInt64 | int, /) -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_reserve(a: UInt64 | int, /) -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_freeze(a: UInt64 | int, /) -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def config_asset_clawback(a: UInt64 | int, /) -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def freeze_asset(a: UInt64 | int, /) -> Asset:
         """
         Asset ID being frozen or un-frozen
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def freeze_asset_account(a: UInt64 | int, /) -> Account:
         """
         32 byte address of the account whose asset slot is being frozen or un-frozen
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def freeze_asset_frozen(a: UInt64 | int, /) -> bool:
         """
         The new frozen value, 0 or 1
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def assets(a: UInt64 | int, b: UInt64 | int, /) -> Asset:
         """
         Foreign Assets listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`gtxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxna), [`gtxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnas), [`gtxnsa`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsa), [`gtxnsas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsas)
         """
+
     @staticmethod
     def num_assets(a: UInt64 | int, /) -> UInt64:
         """
         Number of Assets
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def applications(a: UInt64 | int, b: UInt64 | int, /) -> Application:
         """
         Foreign Apps listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`gtxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxna), [`gtxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnas), [`gtxnsa`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsa), [`gtxnsas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsas)
         """
+
     @staticmethod
     def num_applications(a: UInt64 | int, /) -> UInt64:
         """
         Number of Applications
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def global_num_uint(a: UInt64 | int, /) -> UInt64:
         """
         Number of global state integers in ApplicationCall
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def global_num_byte_slice(a: UInt64 | int, /) -> UInt64:
         """
         Number of global state byteslices in ApplicationCall
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def local_num_uint(a: UInt64 | int, /) -> UInt64:
         """
         Number of local state integers in ApplicationCall
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def local_num_byte_slice(a: UInt64 | int, /) -> UInt64:
         """
         Number of local state byteslices in ApplicationCall
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def extra_program_pages(a: UInt64 | int, /) -> UInt64:
         """
         Number of additional pages for each of the application's approval and clear state programs. An ExtraProgramPages of 1 means 2048 more total bytes, or 1024 for each program.
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def nonparticipation(a: UInt64 | int, /) -> bool:
         """
         Marks an account nonparticipating for rewards
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def logs(a: UInt64 | int, b: UInt64 | int, /) -> Bytes:
         """
         Log messages emitted by an application call (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`gtxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxna), [`gtxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnas), [`gtxnsa`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsa), [`gtxnsas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsas)
         """
+
     @staticmethod
     def num_logs(a: UInt64 | int, /) -> UInt64:
         """
         Number of Logs (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def created_asset_id(a: UInt64 | int, /) -> Asset:
         """
         Asset ID allocated by the creation of an ASA (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def created_application_id(a: UInt64 | int, /) -> Application:
         """
         ApplicationID allocated by the creation of an application (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def last_log(a: UInt64 | int, /) -> Bytes:
         """
         The last message emitted. Empty bytes if none were emitted. Application mode only
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def state_proof_pk(a: UInt64 | int, /) -> Bytes:
         """
         64 byte state proof public key
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def approval_program_pages(a: UInt64 | int, b: UInt64 | int, /) -> Bytes:
         """
         Approval Program as an array of pages
 
         Native TEAL opcode: [`gtxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxna), [`gtxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnas), [`gtxnsa`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsa), [`gtxnsas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsas)
         """
+
     @staticmethod
     def num_approval_program_pages(a: UInt64 | int, /) -> UInt64:
         """
         Number of Approval Program pages
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
+
     @staticmethod
     def clear_state_program_pages(a: UInt64 | int, b: UInt64 | int, /) -> Bytes:
         """
         ClearState Program as an array of pages
 
         Native TEAL opcode: [`gtxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxna), [`gtxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnas), [`gtxnsa`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsa), [`gtxnsas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxnsas)
         """
+
     @staticmethod
     def num_clear_state_program_pages(a: UInt64 | int, /) -> UInt64:
         """
         Number of ClearState Program pages
 
         Native TEAL opcode: [`gtxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxn), [`gtxns`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gtxns)
         """
@@ -2091,476 +2294,543 @@
     @staticmethod
     def sender() -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def fee() -> UInt64:
         """
         microalgos
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def first_valid() -> UInt64:
         """
         round number
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def first_valid_time() -> UInt64:
         """
         UNIX timestamp of block before txn.FirstValid. Fails if negative
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def last_valid() -> UInt64:
         """
         round number
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def note() -> Bytes:
         """
         Any data up to 1024 bytes
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def lease() -> Bytes:
         """
         32 byte lease value
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def receiver() -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def amount() -> UInt64:
         """
         microalgos
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def close_remainder_to() -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def vote_pk() -> Bytes:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def selection_pk() -> Bytes:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def vote_first() -> UInt64:
         """
         The first round that the participation key is valid.
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def vote_last() -> UInt64:
         """
         The last round that the participation key is valid.
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def vote_key_dilution() -> UInt64:
         """
         Dilution for the 2-level participation key
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def type() -> Bytes:
         """
         Transaction type as bytes
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def type_enum() -> UInt64:
         """
         Transaction type as integer
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def xfer_asset() -> Asset:
         """
         Asset ID
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def asset_amount() -> UInt64:
         """
         value in Asset's units
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def asset_sender() -> Account:
         """
         32 byte address. Source of assets if Sender is the Asset's Clawback address.
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def asset_receiver() -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def asset_close_to() -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def group_index() -> UInt64:
         """
         Position of this transaction within an atomic transaction group. A stand-alone transaction is implicitly element 0 in a group of 1
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def tx_id() -> Bytes:
         """
         The computed ID for this transaction. 32 bytes.
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def application_id() -> Application:
         """
         ApplicationID from ApplicationCall transaction
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def on_completion() -> UInt64:
         """
         ApplicationCall transaction on completion action
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def application_args(a: UInt64 | int, /) -> Bytes:
         """
         Arguments passed to the application in the ApplicationCall transaction
 
         Native TEAL opcode: [`itxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxna), [`itxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxnas)
         """
+
     @staticmethod
     def num_app_args() -> UInt64:
         """
         Number of ApplicationArgs
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def accounts(a: UInt64 | int, /) -> Account:
         """
         Accounts listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`itxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxna), [`itxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxnas)
         """
+
     @staticmethod
     def num_accounts() -> UInt64:
         """
         Number of Accounts
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def approval_program() -> Bytes:
         """
         Approval program
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def clear_state_program() -> Bytes:
         """
         Clear state program
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def rekey_to() -> Account:
         """
         32 byte Sender's new AuthAddr
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset() -> Asset:
         """
         Asset ID in asset config transaction
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_total() -> UInt64:
         """
         Total number of units of this asset created
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_decimals() -> UInt64:
         """
         Number of digits to display after the decimal place when displaying the asset
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_default_frozen() -> bool:
         """
         Whether the asset's slots are frozen by default or not, 0 or 1
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_unit_name() -> Bytes:
         """
         Unit name of the asset
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_name() -> Bytes:
         """
         The asset name
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_url() -> Bytes:
         """
         URL
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_metadata_hash() -> Bytes:
         """
         32 byte commitment to unspecified asset metadata
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_manager() -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_reserve() -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_freeze() -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def config_asset_clawback() -> Account:
         """
         32 byte address
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def freeze_asset() -> Asset:
         """
         Asset ID being frozen or un-frozen
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def freeze_asset_account() -> Account:
         """
         32 byte address of the account whose asset slot is being frozen or un-frozen
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def freeze_asset_frozen() -> bool:
         """
         The new frozen value, 0 or 1
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def assets(a: UInt64 | int, /) -> Asset:
         """
         Foreign Assets listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`itxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxna), [`itxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxnas)
         """
+
     @staticmethod
     def num_assets() -> UInt64:
         """
         Number of Assets
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def applications(a: UInt64 | int, /) -> Application:
         """
         Foreign Apps listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`itxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxna), [`itxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxnas)
         """
+
     @staticmethod
     def num_applications() -> UInt64:
         """
         Number of Applications
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def global_num_uint() -> UInt64:
         """
         Number of global state integers in ApplicationCall
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def global_num_byte_slice() -> UInt64:
         """
         Number of global state byteslices in ApplicationCall
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def local_num_uint() -> UInt64:
         """
         Number of local state integers in ApplicationCall
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def local_num_byte_slice() -> UInt64:
         """
         Number of local state byteslices in ApplicationCall
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def extra_program_pages() -> UInt64:
         """
         Number of additional pages for each of the application's approval and clear state programs. An ExtraProgramPages of 1 means 2048 more total bytes, or 1024 for each program.
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def nonparticipation() -> bool:
         """
         Marks an account nonparticipating for rewards
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def logs(a: UInt64 | int, /) -> Bytes:
         """
         Log messages emitted by an application call (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`itxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxna), [`itxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxnas)
         """
+
     @staticmethod
     def num_logs() -> UInt64:
         """
         Number of Logs (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def created_asset_id() -> Asset:
         """
         Asset ID allocated by the creation of an ASA (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def created_application_id() -> Application:
         """
         ApplicationID allocated by the creation of an application (only with `itxn` in v5). Application mode only
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def last_log() -> Bytes:
         """
         The last message emitted. Empty bytes if none were emitted. Application mode only
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def state_proof_pk() -> Bytes:
         """
         64 byte state proof public key
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def approval_program_pages(a: UInt64 | int, /) -> Bytes:
         """
         Approval Program as an array of pages
 
         Native TEAL opcode: [`itxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxna), [`itxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxnas)
         """
+
     @staticmethod
     def num_approval_program_pages() -> UInt64:
         """
         Number of Approval Program pages
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
+
     @staticmethod
     def clear_state_program_pages(a: UInt64 | int, /) -> Bytes:
         """
         ClearState Program as an array of pages
 
         Native TEAL opcode: [`itxna`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxna), [`itxnas`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxnas)
         """
+
     @staticmethod
     def num_clear_state_program_pages() -> UInt64:
         """
         Number of ClearState Program pages
 
         Native TEAL opcode: [`itxn`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn)
         """
@@ -2575,380 +2845,433 @@
     def begin() -> None:
         """
         begin preparation of a new inner transaction in a new transaction group
         `itxn_begin` initializes Sender to the application address; Fee to the minimum allowable, taking into account MinTxnFee and credit from overpaying in earlier transactions; FirstValid/LastValid to the values in the invoking transaction, and all other fields to zero or empty values.
 
         Native TEAL opcode: [`itxn_begin`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_begin)
         """
+
     @staticmethod
     def next() -> None:
         """
         begin preparation of a new inner transaction in the same transaction group
         `itxn_next` initializes the transaction exactly as `itxn_begin` does
 
         Native TEAL opcode: [`itxn_next`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_next)
         """
+
     @staticmethod
     def submit() -> None:
         """
         execute the current inner transaction group. Fail if executing this group would exceed the inner transaction limit, or if any transaction in the group fails.
         `itxn_submit` resets the current transaction so that it can not be resubmitted. A new `itxn_begin` is required to prepare another inner transaction.
 
         Native TEAL opcode: [`itxn_submit`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_submit)
         """
+
     @staticmethod
     def set_sender(a: Account, /) -> None:
         """
         :param Account a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_fee(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: microalgos
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_note(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: Any data up to 1024 bytes
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_receiver(a: Account, /) -> None:
         """
         :param Account a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_amount(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: microalgos
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_close_remainder_to(a: Account, /) -> None:
         """
         :param Account a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_vote_pk(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_selection_pk(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_vote_first(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: The first round that the participation key is valid.
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_vote_last(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: The last round that the participation key is valid.
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_vote_key_dilution(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Dilution for the 2-level participation key
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_type(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: Transaction type as bytes
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_type_enum(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Transaction type as integer
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_xfer_asset(a: Asset | UInt64 | int, /) -> None:
         """
         :param Asset | UInt64 | int a: Asset ID
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_asset_amount(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: value in Asset's units
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_asset_sender(a: Account, /) -> None:
         """
         :param Account a: 32 byte address. Source of assets if Sender is the Asset's Clawback address.
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_asset_receiver(a: Account, /) -> None:
         """
         :param Account a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_asset_close_to(a: Account, /) -> None:
         """
         :param Account a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_application_id(a: Application | UInt64 | int, /) -> None:
         """
         :param Application | UInt64 | int a: ApplicationID from ApplicationCall transaction
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_on_completion(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: ApplicationCall transaction on completion action
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_application_args(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: Arguments passed to the application in the ApplicationCall transaction
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_accounts(a: Account, /) -> None:
         """
         :param Account a: Accounts listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_approval_program(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: Approval program
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_clear_state_program(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: Clear state program
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_rekey_to(a: Account, /) -> None:
         """
         :param Account a: 32 byte Sender's new AuthAddr
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset(a: Asset | UInt64 | int, /) -> None:
         """
         :param Asset | UInt64 | int a: Asset ID in asset config transaction
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_total(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Total number of units of this asset created
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_decimals(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Number of digits to display after the decimal place when displaying the asset
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_default_frozen(a: bool | UInt64 | int, /) -> None:
         """
         :param bool | UInt64 | int a: Whether the asset's slots are frozen by default or not, 0 or 1
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_unit_name(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: Unit name of the asset
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_name(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: The asset name
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_url(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: URL
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_metadata_hash(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: 32 byte commitment to unspecified asset metadata
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_manager(a: Account, /) -> None:
         """
         :param Account a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_reserve(a: Account, /) -> None:
         """
         :param Account a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_freeze(a: Account, /) -> None:
         """
         :param Account a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_config_asset_clawback(a: Account, /) -> None:
         """
         :param Account a: 32 byte address
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_freeze_asset(a: Asset | UInt64 | int, /) -> None:
         """
         :param Asset | UInt64 | int a: Asset ID being frozen or un-frozen
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_freeze_asset_account(a: Account, /) -> None:
         """
         :param Account a: 32 byte address of the account whose asset slot is being frozen or un-frozen
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_freeze_asset_frozen(a: bool | UInt64 | int, /) -> None:
         """
         :param bool | UInt64 | int a: The new frozen value, 0 or 1
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_assets(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Foreign Assets listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_applications(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Foreign Apps listed in the ApplicationCall transaction
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_global_num_uint(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Number of global state integers in ApplicationCall
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_global_num_byte_slice(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Number of global state byteslices in ApplicationCall
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_local_num_uint(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Number of local state integers in ApplicationCall
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_local_num_byte_slice(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Number of local state byteslices in ApplicationCall
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_extra_program_pages(a: UInt64 | int, /) -> None:
         """
         :param UInt64 | int a: Number of additional pages for each of the application's approval and clear state programs. An ExtraProgramPages of 1 means 2048 more total bytes, or 1024 for each program.
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_nonparticipation(a: bool | UInt64 | int, /) -> None:
         """
         :param bool | UInt64 | int a: Marks an account nonparticipating for rewards
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_state_proof_pk(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: 64 byte state proof public key
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_approval_program_pages(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: Approval Program as an array of pages
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
+
     @staticmethod
     def set_clear_state_program_pages(a: Bytes | bytes, /) -> None:
         """
         :param Bytes | bytes a: ClearState Program as an array of pages
 
         Native TEAL opcode: [`itxn_field`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itxn_field)
         """
@@ -2961,20 +3284,22 @@
 
     @staticmethod
     def json_string(a: Bytes | bytes, b: Bytes | bytes, /) -> Bytes:
         """
 
         Native TEAL opcode: [`json_ref`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#json_ref)
         """
+
     @staticmethod
     def json_uint64(a: Bytes | bytes, b: Bytes | bytes, /) -> UInt64:
         """
 
         Native TEAL opcode: [`json_ref`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#json_ref)
         """
+
     @staticmethod
     def json_object(a: Bytes | bytes, b: Bytes | bytes, /) -> Bytes:
         """
 
         Native TEAL opcode: [`json_ref`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#json_ref)
         """
 
@@ -2987,23 +3312,25 @@
     @staticmethod
     def load_bytes(a: UInt64 | int, /) -> Bytes:
         """
         Ath scratch space value.  All scratch spaces are 0 at program start.
 
         Native TEAL opcode: [`loads`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#loads)
         """
+
     @staticmethod
     def load_uint64(a: UInt64 | int, /) -> UInt64:
         """
         Ath scratch space value.  All scratch spaces are 0 at program start.
 
         Native TEAL opcode: [`loads`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#loads)
         """
+
     @staticmethod
-    def store(a: UInt64 | int, b: Bytes | bytes | UInt64 | int, /) -> None:
+    def store(a: UInt64 | int, b: Bytes | UInt64 | bytes | int, /) -> None:
         """
         store B to the Ath scratch space
 
         Native TEAL opcode: [`stores`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#stores)
         """
 
 class Txn:
```

## Comparing `puyapy-1.0.1.dist-info/LICENSE` & `puyapy-2.0.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `puyapy-1.0.1.dist-info/METADATA` & `puyapy-2.0.0.dist-info/METADATA`

 * *Files 5% similar despite different names*

```diff
@@ -1,79 +1,75 @@
 Metadata-Version: 2.1
 Name: puyapy
-Version: 1.0.1
+Version: 2.0.0
 Summary: An optimising compiler for Algorand Python
+License: AGPL-3.0-or-later
 Author: Algorand Foundation
 Author-email: contact@algorand.foundation
 Requires-Python: >=3.12,<4.0
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: GNU Affero General Public License v3 or later (AGPLv3+)
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.12
 Classifier: Topic :: Software Development :: Compilers
 Requires-Dist: attrs (>=23.2.0,<24.0.0)
+Requires-Dist: colorama (>=0.4.6,<0.5.0) ; sys_platform == "win32"
 Requires-Dist: docstring-parser (>=0.14.1)
 Requires-Dist: immutabledict (>=4.2.0,<5.0.0)
 Requires-Dist: mypy_extensions (>=1.0.0,<2.0.0)
-Requires-Dist: networkx (>=3.1,<4.0)
 Requires-Dist: packaging (>=24.0,<25.0)
 Requires-Dist: pycryptodomex (>=3.6.0,<4)
 Requires-Dist: structlog (>=24.1.0,<25.0.0)
-Requires-Dist: typing-extensions (>=4.10.0,<5.0.0)
+Requires-Dist: typing-extensions (>=4.11.0,<5.0.0)
 Description-Content-Type: text/markdown
 
 # Algorand Python
- 
+
 Algorand Python is a partial implementation of the Python programming language that runs on the AVM. It includes a statically typed framework for development of Algorand smart contracts and logic signatures, with Pythonic interfaces to underlying AVM functionality that works with standard Python tooling.
 
 Algorand Python is compiled for execution on the AVM by PuyaPy, an optimising compiler that ensures the resulting AVM bytecode execution semantics that match the given Python code. PuyaPy produces output that is directly compatible with [AlgoKit typed clients](https://github.com/algorandfoundation/algokit-cli/blob/main/docs/features/generate.md#1-typed-clients) to make deployment and calling easy.
 
-[Documentation](https://algorandfoundation.github.io/puya/) | [Language guide](https://algorandfoundation.github.io/puya/language_guide.html)
+[Documentation](https://algorandfoundation.github.io/puya/) | [Language guide](https://algorandfoundation.github.io/puya/language-guide.html)
 
 ## Quick start
 
 The easiest way to use Algorand Python is to instantiate a template with AlgoKit via `algokit init -t python`. This will give you a full development environment with intellisense, linting, automatic formatting, breakpoint debugging, deployment and CI/CD.
 
 Alternatively, if you want to start from scratch you can do the following:
 
 1. Ensure you have Python 3.12+
-2. Install the PuyaPy compiler into your project `poetry add puya --group=dev` and/or install [AlgoKit CLI](https://github.com/algorandfoundation/algokit-cli?tab=readme-ov-file#install)
+2. Install [AlgoKit CLI](https://github.com/algorandfoundation/algokit-cli?tab=readme-ov-file#install)
 3. Check you can run the compiler:
     ```shell
-    puyapy -h
-    # OR
     algokit compile py -h
     ```
-4. Create a contract in a (e.g.) `contact.py` file:
+4. Install Algorand Python into your project `poetry add algorand-python`
+5. Create a contract in a (e.g.) `contract.py` file:
     ```python
     from algopy import ARC4Contract, arc4
     class HelloWorldContract(ARC4Contract):
         @arc4.abimethod
         def hello(self, name: arc4.String) -> arc4.String:
             return "Hello, " + name
     ```
-5. Compile the contract:
+6. Compile the contract:
     ```shell
-    # After running `poetry shell`:
-    puyapy contract.py
-    # OR if using AlgoKit CLI:
     algokit compile py contract.py
     ```
-6. You should now have `HelloWorldContract.approval.teal` and `HelloWorldContract.clear.teal` on the file system!
-7. We generally recommend using ARC-32 and [generated typed clients](https://github.com/algorandfoundation/algokit-cli/blob/main/docs/features/generate.md#1-typed-clients) to have the most optimal deployment and consumption experience; to do this you need to ask PuyaPy to output an ARC-32 compatible app spec file:
+7. You should now have `HelloWorldContract.approval.teal` and `HelloWorldContract.clear.teal` on the file system!
+8. We generally recommend using ARC-32 and [generated typed clients](https://github.com/algorandfoundation/algokit-cli/blob/main/docs/features/generate.md#1-typed-clients) to have the most optimal deployment and consumption experience; to do this you need to ask PuyaPy to output an ARC-32 compatible app spec file:
     ```shell
-    puyapy contract.py --output-arc32 --no-output-teal
-    # OR
     algokit compile py contract.py --output-arc32 --no-output-teal
     ```
-8. You should now have `HelloWorldContract.arc32.json`, which can be generated into a client e.g. using AlgoKit CLI:
+9. You should now have `HelloWorldContract.arc32.json`, which can be generated into a client e.g. using AlgoKit CLI:
     ```shell
     algokit generate client HelloWorldContract.arc32.json --output client.py
     ```
-9. From here you can dive into the [examples](https://github.com/algorandfoundation/puya/tree/main/examples) or look at the [documentation](https://algorandfoundation.github.io/puya/).
+10. From here you can dive into the [examples](https://github.com/algorandfoundation/puya/tree/main/examples) or look at the [documentation](https://algorandfoundation.github.io/puya/).
 
 ## Examples
 
 There are [many](https://github.com/algorandfoundation/puya/tree/main/examples) [examples](https://github.com/algorandfoundation/puya/tree/main/test_cases) in this repo, here are some of the more useful ones that showcase what
 is possible.
 
 -   [hello world](https://github.com/algorandfoundation/puya/tree/main/examples/hello_world/contract.py)
```

## Comparing `puyapy-1.0.1.dist-info/RECORD` & `puyapy-2.0.0.dist-info/RECORD`

 * *Files 5% similar despite different names*

```diff
@@ -1,106 +1,106 @@
 puya/ARCHITECTURE.md,sha256=Q5OByBNx-cupwgASu4VyeweNDyysh6zD08UAhs_SzS8,453
 puya/__init__.py,sha256=hnPi_IQS-c3qP2bj1O2zfBoeu60e4r9ERP_XVPopCB4,123
 puya/__main__.py,sha256=mUUY5PkJAe3nHhHuY8OK3KPK8njxzhRxTZ3uN2FqXTY,3727
 puya/_typeshed/README.md,sha256=DDbUqsaEUPZSRcMlHi5GXr1pzc7qa1G5FRiH5pVIDdc,564
-puya/_typeshed/stdlib/VERSIONS,sha256=RJxiX5YMal8yeIQFX1ZTBy9Qe4LEpU47hI1fTMO9kzM,5573
-puya/_typeshed/stdlib/_collections_abc.pyi,sha256=VWYwf0infGuFexg95Ak_fcJBKaO5cLh0PoCHUXHKiDU,2476
-puya/_typeshed/stdlib/_typeshed/__init__.pyi,sha256=Rtv12fuJ5lqzwMZVffysIorA-8AnDeHqvrnLrvyVOds,11385
-puya/_typeshed/stdlib/abc.pyi,sha256=hJjhC69Xi1WUCtxOrnKKrXsdw7czKe-6L6GR9W39cVk,1794
-puya/_typeshed/stdlib/builtins.pyi,sha256=RUaRFR2UMHFJv05HOcYYmxAxpfiPIZws1AHAUq7k_pM,81222
+puya/_typeshed/stdlib/VERSIONS,sha256=6VzoCpnA5IznPA6LMduJVvJzrkgQ5G_LD02fP0vGyw0,5587
+puya/_typeshed/stdlib/_collections_abc.pyi,sha256=CqX05Vg9Z5P_g47hxM59yLbo6Bcf_5hOsKXryk_ho9w,2479
+puya/_typeshed/stdlib/_typeshed/__init__.pyi,sha256=Tq2TyLy5dk-5jxOhjztIvH6CAVADrXVoBNkfUNglAK4,11408
+puya/_typeshed/stdlib/abc.pyi,sha256=rW_mX3B7ihg8tHZoTOJk6Lv7QgnYAPTCWREuIlQ3mCo,2023
+puya/_typeshed/stdlib/builtins.pyi,sha256=2Q3Vdmz1YwvPAEEBEDjt8f5_BMKgY-PcHz6FDHleHUU,81291
 puya/_typeshed/stdlib/collections/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_typeshed/stdlib/collections/abc.pyi,sha256=kBiZAN0VPf8qpkInbjqKZRRe0PXrZ7jxNmCGs4o5UOc,79
-puya/_typeshed/stdlib/sys/__init__.pyi,sha256=7w1U1yuSpXML4NDTyIG-bXwo4u9QPuzWGGwf_AiXMI0,12333
-puya/_typeshed/stdlib/types.pyi,sha256=OvcjEMF9nz_5Ptuv5N2leEA2TrxbWq8xy92OuIqIQKI,20245
-puya/_typeshed/stdlib/typing.pyi,sha256=OdmKJ_JyUVABUtzy4jdO4jrMw9KYTwqfwfVBicMPfCg,33638
-puya/_typeshed/stdlib/typing_extensions.pyi,sha256=UajcAGhX_tkbuLlu2XTtGDiG7l036gZ_sfYcTzgEqaQ,15035
+puya/_typeshed/stdlib/sys/__init__.pyi,sha256=mIl_z7dMO1R2_I7vy5r1PYr1e6xsdIdv0H5fMB3O-gc,12402
+puya/_typeshed/stdlib/types.pyi,sha256=OkjKaDksi3JwjAj8mS8gr8tvfU2HLOl3lzyv82LJAYA,20405
+puya/_typeshed/stdlib/typing.pyi,sha256=D4QWxOz9q13KyFYGRZ_Q9r9hOxokbBH-rTpU8W0STyg,33870
+puya/_typeshed/stdlib/typing_extensions.pyi,sha256=OKVq76McAtaQGf3EfJYrBu1vzBxUvr84F1xsnIMDRV4,15184
 puya/_typeshed/stubs/mypy-extensions/mypy_extensions.pyi,sha256=M00bMpf1XZOilHhHPjPrdRK7a9qw35DqOWh0PeT8aj4,8892
-puya/_vendor/mypy/.version,sha256=MkK6mwND_QYNvorIvNcCyyaMTZZV6pb8afm1yfK2Cmw,47
+puya/_vendor/mypy/.version,sha256=dUfszkAsHUvn6aB3BpCLysdtX4MrplP4jCW9ztEg9tM,49
 puya/_vendor/mypy/__init__.py,sha256=4yp43qNAZZ0ViBpVn56Bc7MA4H2UMXe0WTVPdkODP6k,37
 puya/_vendor/mypy/__main__.py,sha256=OYmAgQIvrZCCYYZc1L4ZM_ZebZ5ZkcxqNeWkJG4Zg70,1061
 puya/_vendor/mypy/api.py,sha256=z1YRAJA2Tk5dvAspKo4yCkan0fB6OSBtQq-qKQEMEBM,2922
-puya/_vendor/mypy/applytype.py,sha256=yBGL9iCTk4vXsT4BCyDhafeME-NuY9mp6qlEtv80u1I,6009
+puya/_vendor/mypy/applytype.py,sha256=zK9aU-82uWrq3Lbcl_KIzncmAOAuowj-XsMnbOMcIs0,6545
 puya/_vendor/mypy/argmap.py,sha256=WmAj3MZSSvzDgpCif6_EgLhgYX-vzg1yR_a-zSdNZ2Q,11300
 puya/_vendor/mypy/binder.py,sha256=gAUsHvKu-Tganr0ipi8WfWIY38bRe769PtqgPDmf200,21037
 puya/_vendor/mypy/bogus_type.py,sha256=w3GrsWoj5FKbfEUsc87OVFO812HC9BvnWnSaV2T4u1c,816
 puya/_vendor/mypy/build.py,sha256=cW0LclcBJUfxFyx4-pEJ1oyeTxz1arxERxE22JjMFv8,144784
-puya/_vendor/mypy/checker.py,sha256=H9Zg30TQSJ-h1jdZTXWribkX5V1AKQNpFMRh-djNA6E,375773
-puya/_vendor/mypy/checkexpr.py,sha256=yanC2S4LJlSZzLxabqYDCbjZ15pqeKYqAI39YtO8s9w,288076
-puya/_vendor/mypy/checkmember.py,sha256=4HP38JZXMlb_R4ePUgckrHE1iMfOu7YnuCHpC912YcY,53621
-puya/_vendor/mypy/checkpattern.py,sha256=gT0YwJ9JkUCBBkWKMRh7oiR0qhxs1XmdtC3YlYlQgmE,32908
+puya/_vendor/mypy/checker.py,sha256=Uiek98TbiIYJZLRNWh64b63CQawjRXMVW9PtHqGahs4,379921
+puya/_vendor/mypy/checkexpr.py,sha256=YC7xXNIJtH-HgdX1Rbdb9GJhT1DcUQhEVlohiTyXxks,288412
+puya/_vendor/mypy/checkmember.py,sha256=RhzQEbTQG_9e1ZVWP5PD2AMGm4IOUgDQEiIml7-Qnj4,53886
+puya/_vendor/mypy/checkpattern.py,sha256=uM176sOeGt1soIZqxAi3NAV-a54mSpGT2BB5KTKJACA,32916
 puya/_vendor/mypy/checkstrformat.py,sha256=RRh6UYgrmRLMqEeSta9Agt1ASNqKy88IrybJOTJfkCk,46273
 puya/_vendor/mypy/config_parser.py,sha256=3sHjJKX8Mlltw3cmnDaoR89RbJzqvbm1DQSooy5xvQA,23389
 puya/_vendor/mypy/constant_fold.py,sha256=tAkvl9svLCOKMRZQnnUKdMUhU5bEBZmtBK89dtrPKmo,6071
-puya/_vendor/mypy/constraints.py,sha256=Z2O17Qw6WT1-knLdwjxnoBikkTyWdmIDsVyNVO7RtXk,75662
+puya/_vendor/mypy/constraints.py,sha256=sfZ5hBJHfOubNJ8yVwWR2bYWI2TE--HHTh_kQJcSW_U,76295
 puya/_vendor/mypy/copytype.py,sha256=uD1VnR8yP40osAbJZa0aAKGBp5YzJriyUV7gXE0xux4,4425
 puya/_vendor/mypy/defaults.py,sha256=HBMvRWdOTbR_d9jZEwYiSHbzH1GO8P31XSrZcBFJwtY,1558
 puya/_vendor/mypy/dmypy/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/dmypy/__main__.py,sha256=u6ZYw52bfIJ11Oo88mzx7p4WD2WUo1-H9PRsT45eswU,128
 puya/_vendor/mypy/dmypy/client.py,sha256=wSl-VF45IvzJ2Y1G3KdGDVzyXfyAxTCIfJadG8z0oUs,24616
 puya/_vendor/mypy/dmypy_os.py,sha256=nmfi-HdtYmmEa06t2516asBL-ozX048daR1OxaxFU9w,1154
 puya/_vendor/mypy/dmypy_server.py,sha256=7v7Oz2O8NnCz0G027-Jha4XR4Mmn-wpWPSK_wHd3HKA,44588
 puya/_vendor/mypy/dmypy_util.py,sha256=6TgpJ0p1Rw2ov2CfMAFSUkooiC4n-Xx2eZx9GMuMfaQ,2995
 puya/_vendor/mypy/erasetype.py,sha256=VqDoeiGaIeygup0whYEiAkSLlr1x_2XlH87JWgpgpdo,10382
-puya/_vendor/mypy/errorcodes.py,sha256=F9w70qjx_YDk-KcS8kHjle58kor9wsl8ak1TbmCkj3U,10507
+puya/_vendor/mypy/errorcodes.py,sha256=azYkx3CKjaH2WTmrnp4QZgtY6sx9NISE94c6veg_XjM,10702
 puya/_vendor/mypy/errors.py,sha256=Zwr4pLpdzMpnykDBv7Ca2EWcbvaPVUN3K9R1FR0j_V4,47836
 puya/_vendor/mypy/evalexpr.py,sha256=vbE26plXENo59eeKm_ChFieLd5nAEiiVs1a9VMOrx0c,6562
-puya/_vendor/mypy/expandtype.py,sha256=gpDVeiAYihY5S1VMe70OCAVBnB7j3eoR-NyEJaTB7-g,21102
-puya/_vendor/mypy/exprtotype.py,sha256=8MGJF1oBalx_LQpLCczfMyQ9_q2AcvLmMhY6XF265pg,7582
+puya/_vendor/mypy/expandtype.py,sha256=x7zigxYn3GXHOsW1jpEJ5f0DTRISNtZDCzclwCJmKiM,22005
+puya/_vendor/mypy/exprtotype.py,sha256=qr2Ylo4KwWiYAFagr_KMDtnI8JZRgQWa90wOVcQr3aE,7674
 puya/_vendor/mypy/fastparse.py,sha256=1D5hiXpiPUXSLINSlJZMveMB9N8apbIat2RX_xXXIVs,82599
 puya/_vendor/mypy/find_sources.py,sha256=LtHK4iJKl05aXO3oheb2Re2FkKoyFfeO68BjFwU-jTs,9362
-puya/_vendor/mypy/fixup.py,sha256=VWr-KTZ2iI6calNqsCB22LSXQXAXGJCRM3sbo3f0Qro,15803
+puya/_vendor/mypy/fixup.py,sha256=YpfmhqZDkUWkGSMDzPKvEqJE0Ou7RP1xHVmKIDYtNcY,15874
 puya/_vendor/mypy/freetree.py,sha256=yz4_ZUq8Ja89176nbDEAiBk-Et2nP74_KXyCcaW4inA,617
 puya/_vendor/mypy/fscache.py,sha256=WvM25Tew6sIpSIXggPgSUS9sK0kl5pWdruDwetGx0z0,11328
 puya/_vendor/mypy/fswatcher.py,sha256=l4klHOpQLSPPeH1_B8OAeIVTFDXhzFM6BOpjRBbYHVI,3969
 puya/_vendor/mypy/gclogger.py,sha256=8-Af1sazzjueP0xkOFixPHsN77H7pbGaoIccZSCqLNo,1641
 puya/_vendor/mypy/git.py,sha256=FYdMg-3fTtikKjUwfFPXbWiNmpOIMG4rNgMAWIPBsLM,980
 puya/_vendor/mypy/graph_utils.py,sha256=HD2zzPpq80hbBJPj759W1RmTm6eDtHBirQt5ih0o_Gg,3343
 puya/_vendor/mypy/indirection.py,sha256=H3VHroI-TE4ZVTJhBr-93VuZwazedexbwlJPKo-uy-U,4595
 puya/_vendor/mypy/infer.py,sha256=i1wzXEV3QekpUXxU1Av2XXB64eSk5pzVb8987sqZ8Yc,2511
 puya/_vendor/mypy/inspections.py,sha256=V6XW-_ZlatqRbMk4EBKTYNSoBZCb423w5Q1YdQCcbCE,23820
 puya/_vendor/mypy/ipc.py,sha256=C_Hdb2HOEEdkgsGzprhaurSeRx36acLxhub1YTuvPsQ,11702
-puya/_vendor/mypy/join.py,sha256=TT0mEqeFtuL_cB7izn-uIPNAaTHx99BH1iN5EngwLLM,36109
+puya/_vendor/mypy/join.py,sha256=SskNmCFNSsCZIMO34Lm3OnXtZcnRnlJYWHBuwVufyjc,36433
 puya/_vendor/mypy/literals.py,sha256=mhy-7_Gq4C9U4hyCZv1TKs3pJEOITJpq6S97IQzQCs8,8749
 puya/_vendor/mypy/lookup.py,sha256=azRWZ_lXiK6ZN_bxslUBjAkFcqywGO0dlQgjpWaBtSg,2054
 puya/_vendor/mypy/main.py,sha256=AV23cvTN8iXxucI9v_m2XWNLMohhWiAYutd5M0433YU,58327
 puya/_vendor/mypy/maptype.py,sha256=USEg3N_4LCesekOVOLhwFoq65urhcR5CotSkprcJleU,4331
 puya/_vendor/mypy/meet.py,sha256=owLg7c4zyZUljFhyRVsrRJa1jAjLPvMui5lLzuWyITs,47442
 puya/_vendor/mypy/memprofile.py,sha256=5_FQvTONgPFZInsMhvKUHhZ979IdMZCY1nQ2303F1Mo,4153
-puya/_vendor/mypy/message_registry.py,sha256=7hFlKhQ5ZjVLoNgHLG6jLLy9mM4nx42YS6QeO-4P_Sk,15478
-puya/_vendor/mypy/messages.py,sha256=vsf7p7lzv9mBHhqku8dbddxCF5hAxevXJ_3PhRScPZ4,125104
+puya/_vendor/mypy/message_registry.py,sha256=I9SVvWEVP_9emRw7lPgp3G7d5SqHP-CkPPSHiIesBf4,15616
+puya/_vendor/mypy/messages.py,sha256=AELHMfBH5ZNWwm_tn15D61jyKxyOprSjPJnMfzHV8No,125738
 puya/_vendor/mypy/metastore.py,sha256=iqAJblXYktNBrVF2kRjEE1tcUCOU22E36FJl0RHBnyA,6708
 puya/_vendor/mypy/mixedtraverser.py,sha256=DaMtHVpcy6JUfve7VOaJLkbGnspCKAj_zkhpeXtyfFw,3205
-puya/_vendor/mypy/modulefinder.py,sha256=D-eip6SF_DNUpgL7sfBh9u-m2n738_EaqGUhVBj4JQg,37888
+puya/_vendor/mypy/modulefinder.py,sha256=VOvlvcOV6yqTxAOJbBbiD8Sym15TD_l6zj1suGCP7kA,37888
 puya/_vendor/mypy/moduleinspect.py,sha256=HCEI7yW61OkMNFqUqjuRB09HcTDpalcmtVBYjlWfxyo,6326
 puya/_vendor/mypy/mro.py,sha256=Mj_6Ke6W-s2ordeoLWS-LAya3-LUNTv-p2iHFcyxF1A,1993
-puya/_vendor/mypy/nodes.py,sha256=uFMT6tcdxfNIqCkaYQdqizSXE9rKXT8hr8hVonwSnGA,134416
+puya/_vendor/mypy/nodes.py,sha256=750cyTk-jjPPVDbbysa4dKrWXYYq7J9OlB41WSv1cKY,134517
 puya/_vendor/mypy/operators.py,sha256=BHafr2ENZYPmUytEgKOYMS1GwPKFebWBs5pnk8pyZk8,2866
 puya/_vendor/mypy/options.py,sha256=ekqYxy1FopNcbl0Px9cQe_1MrSlpS7DuUmFFWmeRPSs,22845
 puya/_vendor/mypy/parse.py,sha256=jj7RqYXwGzUCeU6s9ynMtSrk6q7PSWCbBhgt_UI6a8U,913
 puya/_vendor/mypy/partially_defined.py,sha256=YjZxnVX1GPuEYHjHb2uqBf-u3opp_xdlhg_loT7O258,25368
 puya/_vendor/mypy/patterns.py,sha256=epS_R9Fv5mnSAGsc6EtUxtmo34_DD1lJ5BevTdMn8Ak,4048
 puya/_vendor/mypy/plugin.py,sha256=mz3ELi2F8dfQZ_LQF4hHk9bA6M6Ph_v6GFZRVCJD9zc,35435
 puya/_vendor/mypy/plugins/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-puya/_vendor/mypy/plugins/attrs.py,sha256=XBq531eKye1O5ou1QRS6o7zZyq70zxPK4uvNjFSru8U,45109
+puya/_vendor/mypy/plugins/attrs.py,sha256=VzqarCTnCgjLuXqMKqqCkmdu-JWz9PBRVRjuvSnV2YU,45794
 puya/_vendor/mypy/plugins/common.py,sha256=EZ8UrpNjFnUqzDe7IrKrczZo-0mKj3QvR2lB4TDWSug,14148
 puya/_vendor/mypy/plugins/ctypes.py,sha256=uB84xNCEzCVfeKjC7FHy7dFF5o55V3L-Rve9OD3YoxM,10675
-puya/_vendor/mypy/plugins/dataclasses.py,sha256=dreTYSoRu5ox9xiNPdKPid4SS3plQe6UkL9dJGkB4tA,45569
-puya/_vendor/mypy/plugins/default.py,sha256=UW1kkra9XlNhddkG6IkLSsai9wJt3XvT3xwu_DrUeIg,20704
+puya/_vendor/mypy/plugins/dataclasses.py,sha256=2WbKSQ0sYNvyuK6lqWVoZXhSDERnt3lRwfgImz0EPYY,46008
+puya/_vendor/mypy/plugins/default.py,sha256=NKOZOna3nMVpIocBz8HDXKwSNk8xBYwHh6RISajyzoc,21160
 puya/_vendor/mypy/plugins/enums.py,sha256=2az1_b4C0ZPuMUaElz0gbb_Xtr8xaYL1DIkqiOn4k2I,10441
 puya/_vendor/mypy/plugins/functools.py,sha256=QdNwW__sgZjRdd1kojyCNJz6b6_7nSj-r81N2e5Kk1I,4004
 puya/_vendor/mypy/plugins/proper_plugin.py,sha256=ZR9_cQGfQDFTRcL8BXxuYZ_t6-xpNhB-2FI1qVdXIE8,6442
 puya/_vendor/mypy/plugins/singledispatch.py,sha256=KfHOjVVwVtCn53C35sdbr8Lh20mamYUWlJQTPOlUsQw,8446
 puya/_vendor/mypy/py.typed,sha256=zlBhTdAQBRfJxeJXD-QnlXiZYsiAJYYkr3mbEsmwSac,64
 puya/_vendor/mypy/pyinfo.py,sha256=Ehwg91OYfin7ItkRZGBITakcEPONGkerMiGnmIw2Eqw,2941
 puya/_vendor/mypy/reachability.py,sha256=OGbKiojvAArwJA7-UpyYyFWE9H4zcrW8gYaF5pWHVSk,12690
 puya/_vendor/mypy/refinfo.py,sha256=qaWKWtkgdlYQVxNucU3KG-4U2OsOBCSG8K8lqupc2S8,2784
 puya/_vendor/mypy/renaming.py,sha256=SPchyfoEPjRRrrl1GlPNNz_sCabpM8IvDye6Cd93Ioo,19910
 puya/_vendor/mypy/report.py,sha256=Ts7JPFn9xB53F0-YKLuMer7ta86ZPkpKxg-FL4rr858,34288
 puya/_vendor/mypy/scope.py,sha256=eryiNXSPPgPj8E5miH8aVOa0uPKa-J8wUbQS_M_65I4,4258
-puya/_vendor/mypy/semanal.py,sha256=EQSqpTtBMRpfRDJkS4hkrxpTOSiZRrMNE6C_fCzZVrM,300858
+puya/_vendor/mypy/semanal.py,sha256=8VKBkCL2xZUc_waZWowiwm45duE4fDaiEr56tgLSm-8,308533
 puya/_vendor/mypy/semanal_classprop.py,sha256=KKdpf6oOuC-Bv1t45-TqU3OBQtL5QyG75PqOOWODifw,7687
 puya/_vendor/mypy/semanal_enum.py,sha256=PcHcc3gSCfkl4BhWPKwut6GHlgRNWEwpAhxdSOMMoqo,9395
 puya/_vendor/mypy/semanal_infer.py,sha256=05i_H20jwVcECXtFXXoWAVmBAqXN5Ce2c5mdjCny01A,5180
 puya/_vendor/mypy/semanal_main.py,sha256=eT44A7v2aaDC4aqoTBaul4nwWKoKd19MPha3c-fOg6Y,20430
 puya/_vendor/mypy/semanal_namedtuple.py,sha256=_vC2hlhZRoZnN_lrgWL39YJFYnykJE3EA4dhq2zr8ow,28624
 puya/_vendor/mypy/semanal_newtype.py,sha256=OFhU6_2GCZcs8mb7cne0EsYHjSPEddUIoForsBtJS4M,10577
 puya/_vendor/mypy/semanal_pass1.py,sha256=x_PquFz46tOlSOx_0bqal46kzEHYKP0pQHKatiw6eVI,5439
@@ -121,25 +121,25 @@
 puya/_vendor/mypy/sharedparse.py,sha256=fDaWJyO37T5v6VPR8u_Hw-1sFGofK1eUx9R17MoDsoU,2102
 puya/_vendor/mypy/solve.py,sha256=30QHhGTmszgKvyRDXEYhGuqGicA9Q0v_L3vXot9VLZk,22796
 puya/_vendor/mypy/split_namespace.py,sha256=P67HianSrsMSZoeuS6F9swM5eK-B2fEBU3XJ6RFtYo0,1289
 puya/_vendor/mypy/state.py,sha256=okCVIeCimJ6ikTCHTg9gL2I4HIvg43YI21Upq8ZKBDA,824
 puya/_vendor/mypy/stats.py,sha256=kuNUse_gRHM1YNWJ4lAQ_4ULHACy-ujM7ONDBeRa4bk,16562
 puya/_vendor/mypy/strconv.py,sha256=ZWmx_F95TTXONtHXFjbxEzTNGqxsNLBzgqhA9EDp2NY,23394
 puya/_vendor/mypy/stubdoc.py,sha256=-iLSgYuuqoncwuHIS1WXZ7ggpGQjxEaj0Htb5zXrcpk,16799
-puya/_vendor/mypy/stubgen.py,sha256=CvpfYf8x1vtqLpOdEQSvpDbtdBAEhnkjI3abQS9hqo4,71012
-puya/_vendor/mypy/stubgenc.py,sha256=7-iAYbDgRzXZnwxLo3qts7HbGqZOxG4MqgKcGAPAOQI,37237
+puya/_vendor/mypy/stubgen.py,sha256=QI2XZZImyxKZ2a5WUkKW-03J05KSkq1WsxvOwZz5x6E,71705
+puya/_vendor/mypy/stubgenc.py,sha256=ESzSrA46qqR0perKbx6sSSV9Ua9VRNuW68hcAG48Nvg,37229
 puya/_vendor/mypy/stubinfo.py,sha256=0wmasSA1MosUEoo4Z0PK1JqffCLuzjHI1T8YYdjmLNg,6232
-puya/_vendor/mypy/stubtest.py,sha256=Z7CY3zFRiAXjRKrk_uLr95bzmJsZek3S37OZEPRPJik,82825
-puya/_vendor/mypy/stubutil.py,sha256=Isf3CqgQtlupIuWS7V8YALy33GOuPguE3cvVIAHFw90,30268
-puya/_vendor/mypy/subtypes.py,sha256=yc7QWYzRE_caDRNPeUuir7sFnwuE5_B9XnkHY-q8jpI,86045
+puya/_vendor/mypy/stubtest.py,sha256=7zd_nclOKp8WlUkCU0W6pwFc5vbhOrIsg26VA3MGq24,82842
+puya/_vendor/mypy/stubutil.py,sha256=IFNhw45Pm3zHRNobp2kKA7SL6Y7E3moTJ0URnagizaY,31386
+puya/_vendor/mypy/subtypes.py,sha256=i8xSaO6cn8Hifx50M9o1eZqY_vEF96aMletEF_w_LQY,86810
 puya/_vendor/mypy/suggestions.py,sha256=0f9T6WnQVj3F4IOE8ZWRlYD9th9E51JEM1CamuxQ7rQ,38070
 puya/_vendor/mypy/test/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/test/config.py,sha256=MreYObGnynJA3wO-4Yeu88PMnFwuEHKFgbkp5-9O3MA,1160
-puya/_vendor/mypy/test/data.py,sha256=bJerrfQwDW0QC0klF3_TkB6Dz5m8gko8cUGqGhvhD08,29976
-puya/_vendor/mypy/test/helpers.py,sha256=zmVKzzFhtnxDmxsAko-cJ-Q23-Wl_vcah-37TDZmSXI,16231
+puya/_vendor/mypy/test/data.py,sha256=cjePkVuAzZeVzfp6aG91LBS_5iBM8HYzpkQpUbv8APA,29913
+puya/_vendor/mypy/test/helpers.py,sha256=lh4BbnNHPCkrFq9gYrnQPVuH3tOgnMMP8iOR12E7VUo,16234
 puya/_vendor/mypy/test/meta/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/test/meta/_pytest.py,sha256=mqeXsl91-eZxYWV0PMcRKUu-pPcQefS5t-NsURiVRqk,2267
 puya/_vendor/mypy/test/meta/test_diff_helper.py,sha256=ETTk0kyEvdKP_CMIKddY2sX6oSwTeUzEqNgDeBPLI6E,1692
 puya/_vendor/mypy/test/meta/test_parse_data.py,sha256=467QiFJsu-9-P0Yjs6yds32QI_rlZJ5ThR5RmfWwH78,1931
 puya/_vendor/mypy/test/meta/test_update_data.py,sha256=ywoiRYRr4dyi8gkxw5-uaRACei6NQR6f7NVL1y6UC2w,4814
 puya/_vendor/mypy/test/test_find_sources.py,sha256=-ilBplbRWcIY5NUc6GysV5hk1VWCR7gjyEsrKl0R3z4,13684
 puya/_vendor/mypy/test/test_ref_info.py,sha256=hz0P6MOqKTppSCyUXWvGamUDX433v15IpfVIHKgqFJw,1432
@@ -177,157 +177,158 @@
 puya/_vendor/mypy/test/testtypes.py,sha256=oejSHsJqEkPhP02e1BI5FLDyaY1MhDCrrQmjVtT1SxI,61897
 puya/_vendor/mypy/test/testutil.py,sha256=HqmkgHC3TBnm7VUF5059l394PKLhS-YItLheKq8htLU,4233
 puya/_vendor/mypy/test/typefixture.py,sha256=vMCdQxuI7lccc9jEcCykuNOdmBmbL4dF8qgPz_9nONQ,15758
 puya/_vendor/mypy/test/update_data.py,sha256=EEHotU9p5rij90Tvf0z4nXe3PDnHH01djlA6PKqDFX4,3676
 puya/_vendor/mypy/test/visitors.py,sha256=cfsPawFO9J2UnoeZGzkYbAbZcuZ8HRDc1FKGd9SV1E0,2089
 puya/_vendor/mypy/traverser.py,sha256=s5FBKg1_B1Ynh6brpvUGgAi2zaNLzU-gm2M32Be9bo8,26863
 puya/_vendor/mypy/treetransform.py,sha256=O5O9ikjl8WRWScxUEZnsGjOHJhN8HxduvToOBxpYi_E,28486
-puya/_vendor/mypy/tvar_scope.py,sha256=g-PrV-qvv8BPIni3S-VxRrH_nFoWhnMbTHjiqtxC7IE,5099
+puya/_vendor/mypy/tvar_scope.py,sha256=QAKKVU4zHCGy5_sVsUck6sq3cXJdEPbfXZxq4fVhYy4,5839
 puya/_vendor/mypy/type_visitor.py,sha256=UqSr-yEr_m4mwd7dyjrByd5CLpp2OwlCYay7eRRR9t0,18092
-puya/_vendor/mypy/typeanal.py,sha256=oMUH8FvzkMoFn7v-YYmGdVmqgsdcjv7drp2djGMVZ64,105972
+puya/_vendor/mypy/typeanal.py,sha256=y0JA8rvzNz6cBYqBB1eI3NKJ1OF_yB6ufj8tWv5cLgM,109791
 puya/_vendor/mypy/typeops.py,sha256=vqL2bXu7SN4O5U6a0-w0IyfbApdcwlRRq3LBW6sPkNE,41115
-puya/_vendor/mypy/types.py,sha256=9bQoMIQBRqO5cwJ7YYRemI2oIoQknFzGkWDOrvzR_lg,132958
+puya/_vendor/mypy/types.py,sha256=55noIjAZdEtDrhfGCNrBcP-ysI465d1xZ4cw2HMQZJQ,133873
 puya/_vendor/mypy/types_utils.py,sha256=nHbme78MaMvvedz9y3WIvv_raTFVlt_iU3jD5vIN_eo,5671
 puya/_vendor/mypy/typeshed/LICENSE,sha256=KV-FOMlK5cMEMwHPfP8chS2ranhqjd7kceBhtA1eyr4,12657
-puya/_vendor/mypy/typeshed/stdlib/VERSIONS,sha256=RJxiX5YMal8yeIQFX1ZTBy9Qe4LEpU47hI1fTMO9kzM,5573
+puya/_vendor/mypy/typeshed/stdlib/VERSIONS,sha256=6VzoCpnA5IznPA6LMduJVvJzrkgQ5G_LD02fP0vGyw0,5587
 puya/_vendor/mypy/typeshed/stdlib/__future__.pyi,sha256=qIwWDmjaw3XCiulKYoKBQB_eJjLxweesUKwBdpkgQkU,915
 puya/_vendor/mypy/typeshed/stdlib/__main__.pyi,sha256=3fBxcSppJr6EOEcUojvflG3Eegg7lv2Qp0dNQQILrP4,63
-puya/_vendor/mypy/typeshed/stdlib/_ast.pyi,sha256=FPa9QKnia1j6eLgyGGdeXpWZW9j_2_ouV1-fPlXm7NA,15352
+puya/_vendor/mypy/typeshed/stdlib/_ast.pyi,sha256=kgDB1DiLUViKcnzSv2wwg_4g-vhzb4EFXtGz4XLfRWU,15576
 puya/_vendor/mypy/typeshed/stdlib/_bisect.pyi,sha256=FbUBdcUSPSGrnXSN89eA0gqCBVWMm8NlpxHKz6guO8Y,2651
 puya/_vendor/mypy/typeshed/stdlib/_bootlocale.pyi,sha256=vSVnoBvURsNzi7MPLR1b_wpuh-yySKzPValAwQ3OVT8,64
-puya/_vendor/mypy/typeshed/stdlib/_codecs.pyi,sha256=yzWtnhYuC627PNSiuucDUaIDMTYNm8RuUpGfrUF2oqA,7042
-puya/_vendor/mypy/typeshed/stdlib/_collections_abc.pyi,sha256=VWYwf0infGuFexg95Ak_fcJBKaO5cLh0PoCHUXHKiDU,2476
+puya/_vendor/mypy/typeshed/stdlib/_codecs.pyi,sha256=K6kTeXS0rKpZUz1bf_5XBWij4FLt7YIq_h1R7VyAsVQ,6961
+puya/_vendor/mypy/typeshed/stdlib/_collections_abc.pyi,sha256=CqX05Vg9Z5P_g47hxM59yLbo6Bcf_5hOsKXryk_ho9w,2479
 puya/_vendor/mypy/typeshed/stdlib/_compat_pickle.pyi,sha256=sjo4_LT7N6KZgL68z0ojpak04NRsMN44bePUG2xDG9A,356
-puya/_vendor/mypy/typeshed/stdlib/_compression.pyi,sha256=hO1Jre9kkSh8zrie_PYuETpbGgJa4toWK7xbWWqVZSY,814
+puya/_vendor/mypy/typeshed/stdlib/_compression.pyi,sha256=gpHitZ7JoDtrjPsQAUrfCDPQ4y-G22Gt8Z4hx9U0D5Q,816
 puya/_vendor/mypy/typeshed/stdlib/_csv.pyi,sha256=MtS3kCqBTjJP_ZFAlFd6An6YrBLnApqqKBYESIC81zE,2499
-puya/_vendor/mypy/typeshed/stdlib/_ctypes.pyi,sha256=XYdDjvwwi99HfZzOMrTJUSTfDF3_VoHfKhyHoAK7ArQ,8144
-puya/_vendor/mypy/typeshed/stdlib/_curses.pyi,sha256=rqng7P2QLaH7RcnF1J08WNAlS0zXRhy4ptNJ56DgwUA,17423
-puya/_vendor/mypy/typeshed/stdlib/_decimal.pyi,sha256=CSpd4Uweu-eCU2IU0Y-sh4fMZEULYoT1ZF0eWq2h2y4,13776
-puya/_vendor/mypy/typeshed/stdlib/_dummy_thread.pyi,sha256=Y4Ys6KdPlBoQ6n84SJjpRXhVE8_eqvFARVhP1dWls64,1046
+puya/_vendor/mypy/typeshed/stdlib/_ctypes.pyi,sha256=KHicZOB-k-dOz3wqsDWrkGt_kYbeRMaeB4ljVDugbTI,8139
+puya/_vendor/mypy/typeshed/stdlib/_curses.pyi,sha256=XkZ3YUwMitzg-vB3q7j_WaLt69V0DLmpX-5W_LiAHH0,15379
+puya/_vendor/mypy/typeshed/stdlib/_decimal.pyi,sha256=_CKFz654uCFDbXLzJTxVkQyeAJjrhm56gOSfyxVq5io,13802
+puya/_vendor/mypy/typeshed/stdlib/_dummy_thread.pyi,sha256=n_fuG0kKGWmLB7TEbw_tnSP6sUqz4VgGc0w42VjXQIk,1252
 puya/_vendor/mypy/typeshed/stdlib/_dummy_threading.pyi,sha256=4wFhNqq6njjBieQUtoIPg3Vlxvm3R9mUCH1lWL1ypwk,5087
-puya/_vendor/mypy/typeshed/stdlib/_heapq.pyi,sha256=cbdc4jO_a27XR9ZtNVyZ6s5_YzY-UXsXlx3TnqWHdMM,338
-puya/_vendor/mypy/typeshed/stdlib/_imp.pyi,sha256=arj7IyHTju0_cDEj-MNDTORMlwjCExmwxOyZlb-XjoU,1114
+puya/_vendor/mypy/typeshed/stdlib/_heapq.pyi,sha256=gQIu7N6I07NgIqhb1nbxCxaF9ZQu0-Qx7z49TZWKEH0,337
+puya/_vendor/mypy/typeshed/stdlib/_imp.pyi,sha256=wTi0XQiNTkl5Z57svXXAcw7rNCOzRmYK9wpGDmn_59M,1121
 puya/_vendor/mypy/typeshed/stdlib/_json.pyi,sha256=HFIXAeQDtXQZWanh-w2AbXpFjxeU8sYYII_H5a-E9m4,1452
-puya/_vendor/mypy/typeshed/stdlib/_locale.pyi,sha256=EzWV4PxhzsaPxU1NUZR56f2vXQCZ9WuaHJHJJTb2D2M,2268
+puya/_vendor/mypy/typeshed/stdlib/_locale.pyi,sha256=sluw1n5bEtFUdy_57OgWYAqxDGiORPRFA8nu9nIhbQc,2264
+puya/_vendor/mypy/typeshed/stdlib/_lsprof.pyi,sha256=CfCIuR9wFC4iY9mZrOGhnA-CxRlWl4RQJX8_fB2qeNk,1264
 puya/_vendor/mypy/typeshed/stdlib/_markupbase.pyi,sha256=WGSjv5DRDrdgbB7rtDQoeW2g3ZASHBUSZfF5l6PEx-Y,722
-puya/_vendor/mypy/typeshed/stdlib/_msi.pyi,sha256=CD4qc_RxH3M8d25gtwj8KYeH1pvsuTUEaWnmK271vqU,3260
-puya/_vendor/mypy/typeshed/stdlib/_operator.pyi,sha256=qsyVH4YrjsR61-PKRoICdUZZXUWDkIDFlAxeXWFNzAg,6079
+puya/_vendor/mypy/typeshed/stdlib/_msi.pyi,sha256=vSr3uBj5MlpcIzLBwCqdjG_duIFjoJLhTbhNKfkS8zA,3260
+puya/_vendor/mypy/typeshed/stdlib/_operator.pyi,sha256=T5x6arx3qfatCrnVvyvxqNL9-a1XZtRs6NoJBNHBBBA,6044
 puya/_vendor/mypy/typeshed/stdlib/_osx_support.pyi,sha256=X-2TPJrLg6nYCJ3A6ODFiIsVuN9-aRtj1VMCpy9aLCs,1865
-puya/_vendor/mypy/typeshed/stdlib/_posixsubprocess.pyi,sha256=fMd9wOf8nrEmgnjzsKrSiuenX3MBP_oMEeutkyWFhNM,966
-puya/_vendor/mypy/typeshed/stdlib/_py_abc.pyi,sha256=R0z0SRyolByTpUzBnKYU3R-Y9HgZsfYEiWGRdv0rFaY,402
+puya/_vendor/mypy/typeshed/stdlib/_posixsubprocess.pyi,sha256=89PDHkgrePr869WEzsm89OpUL0PGSzZn2kl5uPuw1ig,931
+puya/_vendor/mypy/typeshed/stdlib/_py_abc.pyi,sha256=yKisRv9tmwucBsWB1ILLo35NcNrZWwIkKRL6Pu8GH5s,397
 puya/_vendor/mypy/typeshed/stdlib/_pydecimal.pyi,sha256=ryisw8Pi3ne96GxJMFW5ViAgMqmc4PF4uJE53WP-f0M,895
-puya/_vendor/mypy/typeshed/stdlib/_random.pyi,sha256=_c80ak9c8eWe0WKY0aRBFPGD0WQeZ1U6Umkbor0Xx4g,405
+puya/_vendor/mypy/typeshed/stdlib/_random.pyi,sha256=sZwNISDNw0vpwCy4qh-yPTDz28bh3NijMFp6zzszvWQ,408
 puya/_vendor/mypy/typeshed/stdlib/_sitebuiltins.pyi,sha256=XFPuPRtLAqd_gS5H83b7caPySnJpOx9a_1REEYRewYo,518
-puya/_vendor/mypy/typeshed/stdlib/_socket.pyi,sha256=_Pwjpe_PG5yupgXYdgu9QH3wXxxi25PLqroSf3bPgM8,21636
+puya/_vendor/mypy/typeshed/stdlib/_socket.pyi,sha256=nn1Bz8VfVymYVg3PozsgL35PxLgh4_XjRBCv2xfN050,21634
 puya/_vendor/mypy/typeshed/stdlib/_stat.pyi,sha256=JHx8K3MhY4RRHe6-behcppAWStkt6_OIs30g-MIqvsw,2902
-puya/_vendor/mypy/typeshed/stdlib/_thread.pyi,sha256=yF4IFKFN8p2lxFqIRCmaAa6JwllewO1Dq66Hi28bIq0,1799
+puya/_vendor/mypy/typeshed/stdlib/_thread.pyi,sha256=-azjP4rB68uko02Ks5fFGD9itAd3UUzPI0gNCwT22T0,2005
 puya/_vendor/mypy/typeshed/stdlib/_threading_local.pyi,sha256=ZThgVxdPOLAua_HHMoReeI3flStJ0qCnFaHYcEZyyBQ,516
-puya/_vendor/mypy/typeshed/stdlib/_tkinter.pyi,sha256=9fDyKz_Q_G_xOV1_53wHiMPI5Usv1TF5PL-i2zMAUc4,3965
-puya/_vendor/mypy/typeshed/stdlib/_tracemalloc.pyi,sha256=n3ZG2Dp8lSKm_pYV2vcx_rgal-izk1nSKhoBGky8J1A,546
+puya/_vendor/mypy/typeshed/stdlib/_tkinter.pyi,sha256=2tpnNKADV0kGjqsU-7B0eACPtmrMFrNKuChL7Hp6Zqg,3976
+puya/_vendor/mypy/typeshed/stdlib/_tracemalloc.pyi,sha256=SF9nbWx2NoLx0WjVBpx5k2V1htMuCctt2Vqqif2BZZM,548
 puya/_vendor/mypy/typeshed/stdlib/_typeshed/README.md,sha256=upGLmqNVRlXIE70i0vGA969dc26GVqU9Gs5cHEzb8Ys,1043
-puya/_vendor/mypy/typeshed/stdlib/_typeshed/__init__.pyi,sha256=Rtv12fuJ5lqzwMZVffysIorA-8AnDeHqvrnLrvyVOds,11385
-puya/_vendor/mypy/typeshed/stdlib/_typeshed/dbapi.pyi,sha256=DeU6U1Pthzsff0fR8Edji3tY68uVwxtVFeP2cV2pfM4,1638
-puya/_vendor/mypy/typeshed/stdlib/_typeshed/wsgi.pyi,sha256=G3kPBIPIQONoBQfiC3wXVrNjmavM0sthuj9Hiapure8,1635
-puya/_vendor/mypy/typeshed/stdlib/_typeshed/xml.pyi,sha256=OorpstwPE0W6XZNV07sB3eLpfy2ldWFTRX7ZbsNfeQc,506
+puya/_vendor/mypy/typeshed/stdlib/_typeshed/__init__.pyi,sha256=Tq2TyLy5dk-5jxOhjztIvH6CAVADrXVoBNkfUNglAK4,11408
+puya/_vendor/mypy/typeshed/stdlib/_typeshed/dbapi.pyi,sha256=DbFvZC7aeSFuw_hopshe-nz6OL_btPB06zIoJ8O-9tA,1636
+puya/_vendor/mypy/typeshed/stdlib/_typeshed/wsgi.pyi,sha256=qNH7QQT9Y_i8GxSoS2LUViFSmM4mH3-K5hxh7sGT5K4,1637
+puya/_vendor/mypy/typeshed/stdlib/_typeshed/xml.pyi,sha256=W4c9PcHw737FUoezcPAkfRuoMB--7Up7uKlZ0ShNIG0,499
 puya/_vendor/mypy/typeshed/stdlib/_warnings.pyi,sha256=3K2O8vL7O0b2T7SjP4xv5wHpe7xXi_-Wvw48uUML2DU,1562
-puya/_vendor/mypy/typeshed/stdlib/_weakref.pyi,sha256=JM3GR8tdf10Cn-JFONW37ZAhF3H0AEqppQH0GKNg-B0,1426
+puya/_vendor/mypy/typeshed/stdlib/_weakref.pyi,sha256=pQHZsJ86IBuYmOn6uBwGO3HFtYgphP29GcY-Gc1jNQk,1428
 puya/_vendor/mypy/typeshed/stdlib/_weakrefset.pyi,sha256=AtZNDJp6m6_kRRbz-XHswuFAjhZ70kO-k-GeNSdOiBU,2361
-puya/_vendor/mypy/typeshed/stdlib/_winapi.pyi,sha256=RrOlNqOYuPc4YhvGEbE8Nh_MhNOC02aZWGE8__mvJlA,9415
-puya/_vendor/mypy/typeshed/stdlib/abc.pyi,sha256=hJjhC69Xi1WUCtxOrnKKrXsdw7czKe-6L6GR9W39cVk,1794
+puya/_vendor/mypy/typeshed/stdlib/_winapi.pyi,sha256=tD7Lgfq3Q9yB9ur-fBneF6EfS6TP98d78VTV6K-jH8k,9390
+puya/_vendor/mypy/typeshed/stdlib/abc.pyi,sha256=rW_mX3B7ihg8tHZoTOJk6Lv7QgnYAPTCWREuIlQ3mCo,2023
 puya/_vendor/mypy/typeshed/stdlib/aifc.pyi,sha256=ed7eFoiGBYTyey4YmCdECzZh92xwMSEP2hQTjseNicU,3354
 puya/_vendor/mypy/typeshed/stdlib/antigravity.pyi,sha256=AT_uMXdsZR3AL8NfPU7aH05CAQaYpiM7yv2pBm7F78k,123
-puya/_vendor/mypy/typeshed/stdlib/argparse.pyi,sha256=dLBP2U_ZbnWmrx6WDviUPM7YhosRLhfATMU81zuRsXs,21654
-puya/_vendor/mypy/typeshed/stdlib/array.pyi,sha256=QpY-Z3cDl_ssjHx58pwOBBceHayg3vHHH_HkZ7VdkrM,4043
+puya/_vendor/mypy/typeshed/stdlib/argparse.pyi,sha256=PrjnIPqdfudOIRIAa1g61qTR1qkO0mLpHzH1PV3DyQo,22493
+puya/_vendor/mypy/typeshed/stdlib/array.pyi,sha256=VUFKR-SvobFcoeLwOsQ8Rs84JJlms9PhZHtI9oC9E0Q,4058
 puya/_vendor/mypy/typeshed/stdlib/ast.pyi,sha256=Ec2cDb-Eynl3cakaiAdS7ztRcr43UdgjQyXza7c1zSw,11480
 puya/_vendor/mypy/typeshed/stdlib/asynchat.pyi,sha256=jFTiOSXClcmhNvWXQc9JdRD44AT5o9Cq7xSC2fbVC2k,787
 puya/_vendor/mypy/typeshed/stdlib/asyncio/__init__.pyi,sha256=3F3MqFgp9sHI_lFljbFV9Be-Dm3sHLUlipaMz62HceQ,1181
 puya/_vendor/mypy/typeshed/stdlib/asyncio/base_events.pyi,sha256=1AWiF5ggVHEi-F5xFHrx1EzQQ4GhQK_EN1Io_2w5CZs,17849
 puya/_vendor/mypy/typeshed/stdlib/asyncio/base_futures.pyi,sha256=uM1I3ZnN0tRD7oczfM-VAsxYVvzCaFXTso07dXRx8Xw,719
 puya/_vendor/mypy/typeshed/stdlib/asyncio/base_subprocess.pyi,sha256=CjBQyvXQcYWcmmVfWAq3z6ZY3MhXntxMh_xgtJhwKUQ,2680
 puya/_vendor/mypy/typeshed/stdlib/asyncio/base_tasks.pyi,sha256=1qMENIsXTar5-dVXn33qy8hpWzOtFOs_I-kf5I92dsI,404
 puya/_vendor/mypy/typeshed/stdlib/asyncio/constants.pyi,sha256=eP6xw0IKAQYjvTPptRFYWyu1aGTe07gBWB0zZmWM8G0,568
 puya/_vendor/mypy/typeshed/stdlib/asyncio/coroutines.pyi,sha256=wfOcyuEHiSzve1DZMEmG_DVdlxFGrBOI6AYoua6jVrU,1031
-puya/_vendor/mypy/typeshed/stdlib/asyncio/events.pyi,sha256=KkELSdWf7NUvUN-M7f7B0MbVEfWohPsBDVjDAS_CebE,21824
+puya/_vendor/mypy/typeshed/stdlib/asyncio/events.pyi,sha256=BUFqeSsVYP4BkzILy2MAR1t_tx7YaBhYD_MSsOD09PE,22233
 puya/_vendor/mypy/typeshed/stdlib/asyncio/exceptions.pyi,sha256=f6XVtjjmDgx1qWBDSceeR87PRm64-hJi2jT2fiNVEkY,1099
 puya/_vendor/mypy/typeshed/stdlib/asyncio/format_helpers.pyi,sha256=pqidJZJBMxN17PB9i3WKeAiZ7vbrfW-7b94xk53es28,887
-puya/_vendor/mypy/typeshed/stdlib/asyncio/futures.pyi,sha256=Qz28vPcl6kkO3OD5bdsYUqV4XmQqocv3scC3eoLylKc,2325
+puya/_vendor/mypy/typeshed/stdlib/asyncio/futures.pyi,sha256=JXzaWSmtnsB-8oiOl4ZBg89E4-6K0BuxuxkzWFWPgX0,2329
 puya/_vendor/mypy/typeshed/stdlib/asyncio/locks.pyi,sha256=0kZO1vFgBsHEuRxWZ6cFCEfvDDyMYPi1-17LDHgl1o4,4288
 puya/_vendor/mypy/typeshed/stdlib/asyncio/log.pyi,sha256=Ql97njxNKmNn76c8-vomSAM7P-V14o-17SOIgG47V-U,39
 puya/_vendor/mypy/typeshed/stdlib/asyncio/mixins.pyi,sha256=YqQRvFzqgxJ0BvStd6F56A4DaIEM3KvD4fDELKCYhco,215
 puya/_vendor/mypy/typeshed/stdlib/asyncio/proactor_events.pyi,sha256=VTZgFMBqk6IuGbY3WcPuxqEZWzYe3p2J5rZR0-1JBlA,2532
 puya/_vendor/mypy/typeshed/stdlib/asyncio/protocols.pyi,sha256=7ec4bMbkO0Xd05dsLFooOCp5rMwg8mNu2ePuvu3wiVk,1631
 puya/_vendor/mypy/typeshed/stdlib/asyncio/queues.pyi,sha256=lyTJx_zgwUEyiqSetbOxEhzow8ldAbhfboVlcrhbIHc,1544
 puya/_vendor/mypy/typeshed/stdlib/asyncio/runners.pyi,sha256=N7otk344x70gXyVsogk6_RBc4c8WjCTmOM4YreSsMO0,1141
 puya/_vendor/mypy/typeshed/stdlib/asyncio/selector_events.pyi,sha256=V2A71DnovAWTNDBxU4kUlB6m2i4GvN7ZzzvTLOCIuXo,223
-puya/_vendor/mypy/typeshed/stdlib/asyncio/sslproto.pyi,sha256=sfZj5sdu9WAwUlR67MZ7NeGJM0CaCWQQhm9AeiKDPfg,6286
+puya/_vendor/mypy/typeshed/stdlib/asyncio/sslproto.pyi,sha256=ZfgFK_h9S13aBlmhoXdRcUsLlBSWRBjLzrY26l1bvBI,6356
 puya/_vendor/mypy/typeshed/stdlib/asyncio/staggered.pyi,sha256=vtlD5Xfya4AEfvkwJmIL9zXXgRlsI8MmGOFitDK9h7g,341
-puya/_vendor/mypy/typeshed/stdlib/asyncio/streams.pyi,sha256=sfbDaHvG2btvZqa4mkVzc29fPDg0mme5TdgB6Z28fCM,5659
+puya/_vendor/mypy/typeshed/stdlib/asyncio/streams.pyi,sha256=cvx-SaNZvBo5V7i2m-rp7auEj-QvgpbkQ3tNaRNigQo,5807
 puya/_vendor/mypy/typeshed/stdlib/asyncio/subprocess.pyi,sha256=ts8h14ZoT16uWX7MHw-T0jvkOmzOPnfgctOiJqxCncs,9237
 puya/_vendor/mypy/typeshed/stdlib/asyncio/taskgroups.pyi,sha256=nPGSVSM_YzK4N7mbJTaUJ-NDb3xr8gfkK19m_IofpS0,794
-puya/_vendor/mypy/typeshed/stdlib/asyncio/tasks.pyi,sha256=cx1Cn1jNbygahgLaZJGFz93vxpyu8NjBCnydnA95AW4,18364
-puya/_vendor/mypy/typeshed/stdlib/asyncio/threads.pyi,sha256=f_9nq2fb0eZ8uUWY82DgtdBnEGeQStvQu0xXgp0TQ44,265
+puya/_vendor/mypy/typeshed/stdlib/asyncio/tasks.pyi,sha256=BXUWafZAKZAUZ2XKDugtk2eLARpFEK6pDMK-Fr1gJHM,18566
+puya/_vendor/mypy/typeshed/stdlib/asyncio/threads.pyi,sha256=2T_xgTgXetVfnurKmgaxs4wMK0gGb8QCBT7XaYkDLtY,266
 puya/_vendor/mypy/typeshed/stdlib/asyncio/timeouts.pyi,sha256=0vX-OEsZREaaCbCzR1y-eAAtF58_1JnYsUkIUWVqN04,653
 puya/_vendor/mypy/typeshed/stdlib/asyncio/transports.pyi,sha256=8kLgFY7IK3nNPdq4eCaB61mVKui7juFEh2o47k2moXI,2040
-puya/_vendor/mypy/typeshed/stdlib/asyncio/trsock.pyi,sha256=pLt4Vb1eAcMb_-ZEAkjPxU4xWKrWqHjkqYYcbxKpKO4,4703
-puya/_vendor/mypy/typeshed/stdlib/asyncio/unix_events.pyi,sha256=gDPhnklR3taSeyrx8COt210mFt4K-ir9dbhI5TcmS4Y,8477
-puya/_vendor/mypy/typeshed/stdlib/asyncio/windows_events.pyi,sha256=Zf3_Q43aphqztF7NNevrlmsq2hQDRb_duVUcYlnNoQE,4068
+puya/_vendor/mypy/typeshed/stdlib/asyncio/trsock.pyi,sha256=xNXnYD7HSKQtBQdFCmbsjCDnfltM6-Sn7DsorYUGEqs,4644
+puya/_vendor/mypy/typeshed/stdlib/asyncio/unix_events.pyi,sha256=q_9WjregbqGtjxpgnxX_D0nRgvLi8_hGO98x8RBIAnY,8856
+puya/_vendor/mypy/typeshed/stdlib/asyncio/windows_events.pyi,sha256=EHy2m3InGYJR9tPRm05Vu-Nm_1ZWLxDeHQAcgB_Ay5k,4070
 puya/_vendor/mypy/typeshed/stdlib/asyncio/windows_utils.pyi,sha256=Lqfw9C7ubM0H_Lc7mNEmIID1sHQyPzASsUxIbP0zZus,1941
 puya/_vendor/mypy/typeshed/stdlib/asyncore.pyi,sha256=xRANk6i8v5AshNfEgtRCInPWVEwL1NP40G7aRRqaaWs,3670
 puya/_vendor/mypy/typeshed/stdlib/atexit.pyi,sha256=WucU9TxdhsTUhdv4OarVmMtMikCo87HAjGiPCGiLZTY,392
-puya/_vendor/mypy/typeshed/stdlib/audioop.pyi,sha256=JJT_ftnNM_7YLIeILh1amX9N6kZLdf-BZyiSTl2K-TA,2141
+puya/_vendor/mypy/typeshed/stdlib/audioop.pyi,sha256=HejncmT9zLjlROXs2_EzdHD76UBWBHSy3Gv0WIasMSY,2085
 puya/_vendor/mypy/typeshed/stdlib/base64.pyi,sha256=tk3Gf3KPnPObtYkWnaa3zmFFYX5hviTqEIRUlH7FhcU,2188
-puya/_vendor/mypy/typeshed/stdlib/bdb.pyi,sha256=L5048IfdmfCkD-247l935ePPkn1UB8YbO8Tb-f7LZWY,4640
-puya/_vendor/mypy/typeshed/stdlib/binascii.pyi,sha256=4OLD2G-X4aZutm_n7ZjnupEOD8ilJhZzsK6e8n_5lVk,1517
+puya/_vendor/mypy/typeshed/stdlib/bdb.pyi,sha256=-uZFxw7-57VA79OutLtdJvpDofatg0CT9Iohq8XZiCE,4641
+puya/_vendor/mypy/typeshed/stdlib/binascii.pyi,sha256=EmZjuIcMQ2vKagl1tQVZoWVVGR9_kk_qVMr__sVNsJI,1526
 puya/_vendor/mypy/typeshed/stdlib/binhex.pyi,sha256=oA_erfzVCOoGPFhmRkjQiRoGPe-tiRQYsegznNftEew,1279
 puya/_vendor/mypy/typeshed/stdlib/bisect.pyi,sha256=sQn9UUS0Cw5XZMEGcEj8Ka5VKPVobL43Pex_SagjXg8,67
-puya/_vendor/mypy/typeshed/stdlib/builtins.pyi,sha256=RUaRFR2UMHFJv05HOcYYmxAxpfiPIZws1AHAUq7k_pM,81222
-puya/_vendor/mypy/typeshed/stdlib/bz2.pyi,sha256=q3uXPwMzmpysjzsVLjMTuL0iJlbn_znyq_aWE9xVhsE,4870
-puya/_vendor/mypy/typeshed/stdlib/cProfile.pyi,sha256=h5kJxfCKoD76nh0UoyT7ev-Ve_APN2EvrTJRvCK3cnM,1484
-puya/_vendor/mypy/typeshed/stdlib/calendar.pyi,sha256=ItZyYxy5EkOAzmVXT4ahc6nfLPX08XEVeQ4wZgTkXaY,7323
-puya/_vendor/mypy/typeshed/stdlib/cgi.pyi,sha256=fDq4QBFrF0DJRBw-TjL4bmw1qMhPzpFc4TiGq5tp62E,3699
+puya/_vendor/mypy/typeshed/stdlib/builtins.pyi,sha256=2Q3Vdmz1YwvPAEEBEDjt8f5_BMKgY-PcHz6FDHleHUU,81291
+puya/_vendor/mypy/typeshed/stdlib/bz2.pyi,sha256=ckPwZq3e1OjKDqUtlJ6Bi4L42JP0_8nRtyqAXDJFjtM,4872
+puya/_vendor/mypy/typeshed/stdlib/cProfile.pyi,sha256=A4JboUpYmICTII80x9SxI32bCj7fKULaad15l3bORKc,1298
+puya/_vendor/mypy/typeshed/stdlib/calendar.pyi,sha256=axCoK5Mjyh-3rw_tsThrXvL_vd25crAfqdELh1bGC_Y,7327
+puya/_vendor/mypy/typeshed/stdlib/cgi.pyi,sha256=h7bnlSb8Yl2T8H8TmYcM5pnG4kTwxau86nRJf6x6JZk,3700
 puya/_vendor/mypy/typeshed/stdlib/cgitb.pyi,sha256=l7aliv3yXrfw0MM15pXDdgeNpbIK1N1e84OjSEt2TFU,1394
 puya/_vendor/mypy/typeshed/stdlib/chunk.pyi,sha256=691YVfWjwx20ngjDSBGS5Pjs7IrLViQinuTBg8ddmX4,614
-puya/_vendor/mypy/typeshed/stdlib/cmath.pyi,sha256=DDQp2FD0LUi-WDoY69Ob1V0iTdqedWXE_QQQv5ieXj0,1157
+puya/_vendor/mypy/typeshed/stdlib/cmath.pyi,sha256=TfTb9WegfzacOnGbWLCYTz_sd5jdszYGcvAv5482xsc,1175
 puya/_vendor/mypy/typeshed/stdlib/cmd.pyi,sha256=b6jZ42AQYmq_xl7dXJp_q-dBTB4OLzJ4AI0Tk7uQjPI,1725
 puya/_vendor/mypy/typeshed/stdlib/code.pyi,sha256=bCi9Kmcv189tCNmJ0jawDbQKY34WAAC4zBdeghyRxlM,1481
-puya/_vendor/mypy/typeshed/stdlib/codecs.pyi,sha256=bYzxjuVsTD5zZ1oPNmtqL7hDbOzNo4oECf1cbXRSx1g,11816
+puya/_vendor/mypy/typeshed/stdlib/codecs.pyi,sha256=2LJvqdXrLs0AX_nNunT_EMEFZYu6GDmP7Xj82Azx_J4,11812
 puya/_vendor/mypy/typeshed/stdlib/codeop.pyi,sha256=BshEWu9RnM658m5FO9jt4flB20HIf80Ykr3sZrKxhT0,466
-puya/_vendor/mypy/typeshed/stdlib/collections/__init__.pyi,sha256=xWoZLwyYK-AXxvAnxdcUuls_o4P5NhARgq0iJu2sLLw,22788
+puya/_vendor/mypy/typeshed/stdlib/collections/__init__.pyi,sha256=RimIaE7VKWl50Pp2rs9x6_FM1j11MhInFwYeUWBzwXE,23112
 puya/_vendor/mypy/typeshed/stdlib/collections/abc.pyi,sha256=kBiZAN0VPf8qpkInbjqKZRRe0PXrZ7jxNmCGs4o5UOc,79
 puya/_vendor/mypy/typeshed/stdlib/colorsys.pyi,sha256=o1mphr041ViW0Iw-diYI36c3wTP2D8x3KZ9oi2_SPoA,648
-puya/_vendor/mypy/typeshed/stdlib/compileall.pyi,sha256=LjnR50_yt9fukXcsn5AzetUz8A0nXRCx6mYzlGDYjSg,3440
+puya/_vendor/mypy/typeshed/stdlib/compileall.pyi,sha256=mk8L4a6FHSEKaKDEisGiD0RIL7PzwIPbeHurUtcZ84w,3441
 puya/_vendor/mypy/typeshed/stdlib/concurrent/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/__init__.pyi,sha256=2j3ItM1HQpJDQ1Y2FUCLBZ8VjDtsTsEKGhYw6BNDOPg,818
-puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/_base.pyi,sha256=wVxVMdFVj_8k7TrGI_NVQG_0R49qrxilUYMzdaD42WM,4375
+puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/_base.pyi,sha256=g8rl4XscSEAIqH-F7C1e2uWQyXKBsl3vU_mxq-shlb0,4593
 puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/process.pyi,sha256=F3gea0Tiq9RZcRmgvUwO_1QXtAEBYOpol4YsKH9OTrg,7977
 puya/_vendor/mypy/typeshed/stdlib/concurrent/futures/thread.pyi,sha256=PBKhiYUHs-apnYr6lN_iIaz_u9zRxRrZ3otM7Q6DxVM,2326
 puya/_vendor/mypy/typeshed/stdlib/configparser.pyi,sha256=Imsubz8StJgO2f0vzxiYRb5zPYmOGi9LqvgJq6A5HCw,12657
-puya/_vendor/mypy/typeshed/stdlib/contextlib.pyi,sha256=FX-k4bnG0HEOCaEU_m6GFw8CIeV9NmIjvhmJ2B-sHUg,8938
-puya/_vendor/mypy/typeshed/stdlib/contextvars.pyi,sha256=9DyD5W-IhOKpUIyCiYF0W7mVhhNGgGkcQWM1cekyo8w,2160
+puya/_vendor/mypy/typeshed/stdlib/contextlib.pyi,sha256=_TOqWdsQ0mRe3fI0Zt04QGLKIxJDgYiZXoor50KyhpI,8930
+puya/_vendor/mypy/typeshed/stdlib/contextvars.pyi,sha256=4qAJAdfl8L07IbzNwuO-gb4Ph_1d1ao6xWk_6ACKb3Y,2163
 puya/_vendor/mypy/typeshed/stdlib/copy.pyi,sha256=iR27xJZfwjPi8T4sj3lynCv86Eo_b4Qfd6tD79Z17n0,350
 puya/_vendor/mypy/typeshed/stdlib/copyreg.pyi,sha256=59YPSECQJ5ppsEmYJxcvb1NOac6UTAu5CqP3SMd6VL4,983
 puya/_vendor/mypy/typeshed/stdlib/crypt.pyi,sha256=hIS4DwxYD1ocrl3s6uFffA5A2xX63YL73oHg8NH4NUg,383
 puya/_vendor/mypy/typeshed/stdlib/csv.pyi,sha256=8w7_ta7kxdUEGgAepZCXcz_zEtBEkjABkkdYlytO3uM,4323
 puya/_vendor/mypy/typeshed/stdlib/ctypes/__init__.pyi,sha256=zoObz5TA7bUCHA0m42isos8kuN96w0UzgjdHZTl-UM8,6646
 puya/_vendor/mypy/typeshed/stdlib/ctypes/_endian.pyi,sha256=V5852UiKvWNTVYf1dl4_kzqGbDiea4901mcSw5mX8fY,757
 puya/_vendor/mypy/typeshed/stdlib/ctypes/util.pyi,sha256=Lf_nOeoLmPYs5DJ00UmxbAlTex7Z8bwByM3bSg4wg1w,129
 puya/_vendor/mypy/typeshed/stdlib/ctypes/wintypes.pyi,sha256=aNtl75X0bZjqMx9Z3jxRw1FLPKlYWW80QPu086GfVRs,6341
-puya/_vendor/mypy/typeshed/stdlib/curses/__init__.pyi,sha256=w2qNwsrgzVou78UsaLJGQKuQyQqb7oCtkMmmBvcLQNQ,573
-puya/_vendor/mypy/typeshed/stdlib/curses/ascii.pyi,sha256=6QYkjrJkj0h_zuFWKViJRxv5pAZ7sKR_Sd3EMLOuqEY,1393
-puya/_vendor/mypy/typeshed/stdlib/curses/has_key.pyi,sha256=1cQk4unAogRYYX0g6_1Q6Kbincq8V30kACec7zHeUZc,84
-puya/_vendor/mypy/typeshed/stdlib/curses/panel.pyi,sha256=YhKmDC4vSBMdHzpjKcWD_Hw7sDIqLr2Z5R_MA_egFyo,931
-puya/_vendor/mypy/typeshed/stdlib/curses/textpad.pyi,sha256=fUs_A09jazJOAta4pzdzwHY88mhxMoasV4uYkQaRa1M,514
-puya/_vendor/mypy/typeshed/stdlib/dataclasses.pyi,sha256=_rYFoAUKrdyiOr8dCvovwRUeHHOINqt1edT7L8QusvE,9152
-puya/_vendor/mypy/typeshed/stdlib/datetime.pyi,sha256=b-cRYujTxzFsd538FTmDtm6fELr6_180GerUGuxZ-ug,10561
+puya/_vendor/mypy/typeshed/stdlib/curses/__init__.pyi,sha256=BsJl11lf7Kr1tCKvri8n6aU92WcU53IQyGfXYOpC818,653
+puya/_vendor/mypy/typeshed/stdlib/curses/ascii.pyi,sha256=0k1CT-7YSPh8S1xrCeQUNxXjc3ymwmQAIFG3Sqbp1RQ,1127
+puya/_vendor/mypy/typeshed/stdlib/curses/has_key.pyi,sha256=1EoxgUM4xlB7ggY4Ru4eqnSa0Wn2mP7ylUE7p9V7Yc0,40
+puya/_vendor/mypy/typeshed/stdlib/curses/panel.pyi,sha256=yf0pVJXfpa6NItF8TX13-GPJeAXlMsB4PG94KcCF8As,816
+puya/_vendor/mypy/typeshed/stdlib/curses/textpad.pyi,sha256=Yzr4Dkt1EI6lC7wkC9oi9L6j6JaC1hWyxnQYZuGCD1c,443
+puya/_vendor/mypy/typeshed/stdlib/dataclasses.pyi,sha256=-sqbS6wY8_UzUMujTF8lzdJbmzPffTC6NtIqPqlHoTM,9326
+puya/_vendor/mypy/typeshed/stdlib/datetime.pyi,sha256=aQuZM4-IU_IWPUFyxXbUI9TE9c6_CZY6q3Es6TNZ8qY,10818
 puya/_vendor/mypy/typeshed/stdlib/dbm/__init__.pyi,sha256=74zQbyAsfOd-vOcSz4KYmP_4a4uc2_3ZXvcqXvgdQt0,1787
 puya/_vendor/mypy/typeshed/stdlib/dbm/dumb.pyi,sha256=Jl40HJzDQL90nBJX5Gt-_RXqzqqsAUBrDf8FKq-aSPY,1287
-puya/_vendor/mypy/typeshed/stdlib/dbm/gnu.pyi,sha256=kh-w9ny1KS0Tj1DSNkiQv2pk-tcVYLf3UsXDwQu562o,1665
-puya/_vendor/mypy/typeshed/stdlib/dbm/ndbm.pyi,sha256=oMAr_PcWWvCWhc73DER9-DXyxBQqm0zCmDhIcEzXdC8,1451
+puya/_vendor/mypy/typeshed/stdlib/dbm/gnu.pyi,sha256=eizvLzPhrKhFNp9ZRLtJwwBeeTz3_waLhuWxDPu-A40,1663
+puya/_vendor/mypy/typeshed/stdlib/dbm/ndbm.pyi,sha256=OlU93FVW20FXGkU7pubO9RRtlaT-jTxpEmvnS2yHAo0,1449
 puya/_vendor/mypy/typeshed/stdlib/decimal.pyi,sha256=Ovcm6bcpLZyxOWrrmdnZkdYVVB4DRZzyJlKYVDyynmk,117
-puya/_vendor/mypy/typeshed/stdlib/difflib.pyi,sha256=XZ6VGIbRP6A2C2a0fJ7L6XqkLSRueVMB-ZJqvzRLwwU,4504
+puya/_vendor/mypy/typeshed/stdlib/difflib.pyi,sha256=Td-gKYewrsgbcVMbjr7zUcNzCJ-bZhSrB_FizH_oyjQ,4557
 puya/_vendor/mypy/typeshed/stdlib/dis.pyi,sha256=aq9ywTXgwOE1Pi9WMak45xQlz_ymaStqkZMbqxNz_Sk,4646
 puya/_vendor/mypy/typeshed/stdlib/distutils/__init__.pyi,sha256=o-D0LAC_8LmRTahqNjjRUXycRSMyJ537NHeFaduZKVc,351
 puya/_vendor/mypy/typeshed/stdlib/distutils/archive_util.pyi,sha256=MaH28V7MYRGIRO-t1fuXeqVfl9zeM-du9AiRUdDvMZQ,545
 puya/_vendor/mypy/typeshed/stdlib/distutils/bcppcompiler.pyi,sha256=fge2cMbG4jp--o0I2zNcwykh24tJWZtk6leQgAH2NJw,78
 puya/_vendor/mypy/typeshed/stdlib/distutils/ccompiler.pyi,sha256=UAMqlekjUq-ROkMAl3FBrM4uHShC9ree01IYwUGNuYo,6346
 puya/_vendor/mypy/typeshed/stdlib/distutils/cmd.pyi,sha256=crtZybjdq_hjrprEiPeTem_Co-ZvimnIdwUpknQ-0jE,2896
 puya/_vendor/mypy/typeshed/stdlib/distutils/command/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
@@ -351,125 +352,125 @@
 puya/_vendor/mypy/typeshed/stdlib/distutils/command/install_headers.pyi,sha256=rT-1sQqlc8J2nqs_gf9RKmNBOorb5EAhC6qs8nUpfis,387
 puya/_vendor/mypy/typeshed/stdlib/distutils/command/install_lib.pyi,sha256=tHZ-f7Ulj7Z-K6tolL4Mtpa4jD9OmeG7-Kv5UU8QDq4,598
 puya/_vendor/mypy/typeshed/stdlib/distutils/command/install_scripts.pyi,sha256=okwcG_xRAomZj1zWLUHMhHoJpycTEMmgaI0ibbfNOeI,426
 puya/_vendor/mypy/typeshed/stdlib/distutils/command/register.pyi,sha256=KG_UraoJa6x0_iGya4WGQ3InY0RuuiqvQ1Sz5c5tW7E,570
 puya/_vendor/mypy/typeshed/stdlib/distutils/command/sdist.pyi,sha256=tJkV01XU2RKeqVvBWOtHk6d4kwPPFtoObcAX9Q0QHng,1118
 puya/_vendor/mypy/typeshed/stdlib/distutils/command/upload.pyi,sha256=TsjsCOSOxh4S4M_SonwMai2DG68WTyPeuymzmqtszeY,462
 puya/_vendor/mypy/typeshed/stdlib/distutils/config.pyi,sha256=Bmpm5-txSuUYd92XnDnfpAevSl9bk5YfXO-I_wXC2QI,497
-puya/_vendor/mypy/typeshed/stdlib/distutils/core.pyi,sha256=Pm-PZ9owP8e7Sr1d7xcRE0jUmHMGI8UmTgRmSENVgHE,1841
+puya/_vendor/mypy/typeshed/stdlib/distutils/core.pyi,sha256=wB2XcMeJdpsDeVBjYRFTEvQLIl0Ckio4MgZmdvi0gWY,1849
 puya/_vendor/mypy/typeshed/stdlib/distutils/cygwinccompiler.pyi,sha256=KnssyrciHduf8Ia43vkxULUZV88sc-WOTgqVVEv8lco,534
 puya/_vendor/mypy/typeshed/stdlib/distutils/debug.pyi,sha256=MPYhYD0EJVkAAiL_6t7_Xfd2ctbMia2QEsy0D-HhLDY,19
 puya/_vendor/mypy/typeshed/stdlib/distutils/dep_util.pyi,sha256=TAeLwrEamwS67ykJBm8kV6fGy2a0FiY5RHnBqJOfYS4,224
 puya/_vendor/mypy/typeshed/stdlib/distutils/dir_util.pyi,sha256=gWjFQqveLrdnLvdd593ZEwZNhQdy8IaU4J8hG71BeZQ,510
 puya/_vendor/mypy/typeshed/stdlib/distutils/dist.pyi,sha256=MfmIPU7fERFXX8l0eKdp1xm2azC15EuYjrMgtORqwr0,5879
 puya/_vendor/mypy/typeshed/stdlib/distutils/errors.pyi,sha256=l1W_FgoP9L-D-hEPFA2BzZuybjN0lV4WBXl0VJ-k7J8,852
 puya/_vendor/mypy/typeshed/stdlib/distutils/extension.pyi,sha256=KosWjLSvvyfdQTtOCu3fibblHyiFIXm8iHHWrWk916E,1236
 puya/_vendor/mypy/typeshed/stdlib/distutils/fancy_getopt.pyi,sha256=XtlTxwRpJcDPvHrmyFH0_XFbty7r_NSc_4gdA71Oj_8,1162
 puya/_vendor/mypy/typeshed/stdlib/distutils/file_util.pyi,sha256=l7rfxgTQXO64_jYXB_uAtPHPd1DXzPpqChAq0Z5LeiI,429
 puya/_vendor/mypy/typeshed/stdlib/distutils/filelist.pyi,sha256=7x2cBdCIlNaO9Yptx4p8BqcAXnd_PRAn39R_uUhlIcs,2175
 puya/_vendor/mypy/typeshed/stdlib/distutils/log.pyi,sha256=SV3wrT_9-Emn66QuN6htDFVeEoc4hEaljLOPgIQp_G4,843
 puya/_vendor/mypy/typeshed/stdlib/distutils/msvccompiler.pyi,sha256=qQLr26msfhjz-omJutWcRHik3shLh1CIt7CDI3jBd3I,78
 puya/_vendor/mypy/typeshed/stdlib/distutils/spawn.pyi,sha256=oaH_dzZkyOOHR6a3EHZBFj9RxX540tNpMltTAI4ME3w,187
-puya/_vendor/mypy/typeshed/stdlib/distutils/sysconfig.pyi,sha256=XnioDAEApQhL01IeAc4upSe4w6DFmy-Xj-e4Fhl2cXU,791
+puya/_vendor/mypy/typeshed/stdlib/distutils/sysconfig.pyi,sha256=0qsuDcJys-JjyczMbu635a1dY72DeU5WrfD-eme7wv8,1113
 puya/_vendor/mypy/typeshed/stdlib/distutils/text_file.pyi,sha256=bWqk509MdjmhUI6QPk9mVpZ0QFBFPMdWEW62d5fMozs,682
 puya/_vendor/mypy/typeshed/stdlib/distutils/unixccompiler.pyi,sha256=R3VKldSfFPIPPIhygeq0KEphtTp0gxUzLoOHd0QoWW8,79
 puya/_vendor/mypy/typeshed/stdlib/distutils/util.pyi,sha256=iqn6ZpjTOv3Ww7CwId6r4Pe2pzFAuxUvkK2sfp-UnQU,1550
 puya/_vendor/mypy/typeshed/stdlib/distutils/version.pyi,sha256=yIGp2uvie77qTBWlT2ffBGNXIKJmPfJLPzaE2zua1fc,1308
 puya/_vendor/mypy/typeshed/stdlib/doctest.pyi,sha256=Sarb7Lbg2teXeq-Xs_ZKgMLwxdMBXNpdrh6H4l5jsJA,7401
 puya/_vendor/mypy/typeshed/stdlib/dummy_threading.pyi,sha256=ZI04ySfGgI8qdlogWtA8USUTFGfzm32t2ZxL5Ps53O8,79
 puya/_vendor/mypy/typeshed/stdlib/email/__init__.pyi,sha256=a--ccM_KLv044YhJ9UdgPBV4BDqr-m6axEsBnp4sMjs,1054
 puya/_vendor/mypy/typeshed/stdlib/email/_header_value_parser.pyi,sha256=BI_alIvEZKn9_zzWxF7dqqRRD3ou4A-DoFxhkn87Ppg,11135
 puya/_vendor/mypy/typeshed/stdlib/email/_policybase.pyi,sha256=GZPRwPgNMZ6yfJg3xP71PnFRbZ6EYrumENCWPwEOiqM,1971
 puya/_vendor/mypy/typeshed/stdlib/email/base64mime.pyi,sha256=g98A7lvsErIaif8dVjP_LyoVFSXd6lNuJ_pOiTHudqs,559
-puya/_vendor/mypy/typeshed/stdlib/email/charset.pyi,sha256=VtNYicy6WtvnA9dCQlz0UK5CswcCjsQbo994J-3s7QU,1273
+puya/_vendor/mypy/typeshed/stdlib/email/charset.pyi,sha256=z1Bpqyrve-aO0PIL65jm9CfRClEho95mMQl-0uUqbBg,1274
 puya/_vendor/mypy/typeshed/stdlib/email/contentmanager.pyi,sha256=UwmeUcRuRTCDHXVEDzDASBN4lEtVG1A9BonNaMmv0b8,480
 puya/_vendor/mypy/typeshed/stdlib/email/encoders.pyi,sha256=dJc5t6R6TtZGffzRC_ji2O2KNj9n_fJHzkAnKWTbfcQ,293
 puya/_vendor/mypy/typeshed/stdlib/email/errors.pyi,sha256=ynSYv-EvzwFIpxnJv6n0D_A33bbhMI9hAdM4qLmoWbk,1533
 puya/_vendor/mypy/typeshed/stdlib/email/feedparser.pyi,sha256=gcSAUxqhpG9Coso6DaAwjKWzimnz1kejVMLXBsZvLgM,956
 puya/_vendor/mypy/typeshed/stdlib/email/generator.pyi,sha256=m37jgKtezrebkOME2GhUtmQaX5rFXL7A8YGU8Vfrjtk,1175
-puya/_vendor/mypy/typeshed/stdlib/email/header.pyi,sha256=2Y72KRnu5SyQK6Vy_lcvw6VGIqXmMFMs8Jqn8SN0Vi0,1264
-puya/_vendor/mypy/typeshed/stdlib/email/headerregistry.pyi,sha256=4q6gdgwiTupud4YpDZeCnCUJcw5FTB6dliMtA5sJtzo,6129
+puya/_vendor/mypy/typeshed/stdlib/email/header.pyi,sha256=pa2Dn58tNgjRa9mIr-7WgbSfDKs4aNbvf5rgGXHzlGA,1265
+puya/_vendor/mypy/typeshed/stdlib/email/headerregistry.pyi,sha256=V5-kVDHnWI2C8SujCzSOoc-Bah7n4tCesZnS38lkA7Q,6129
 puya/_vendor/mypy/typeshed/stdlib/email/iterators.pyi,sha256=Vou7LSsfU52ckW-lKx4i49KGi0rd54LctjXHimRblrc,648
-puya/_vendor/mypy/typeshed/stdlib/email/message.pyi,sha256=7-E_6fJHKnHHgiueei3tuUDGmFbgRsmudkMWb4QTdMA,8170
+puya/_vendor/mypy/typeshed/stdlib/email/message.pyi,sha256=YhVNR5eJuP0Z3LJdnIDslQlMOurgbRL4pQYlxObSHZ8,8423
 puya/_vendor/mypy/typeshed/stdlib/email/mime/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/typeshed/stdlib/email/mime/application.pyi,sha256=PkqCQXJMdIRSXBV14unvCnpQTuNcEQO23W8CJ8hhtAc,498
 puya/_vendor/mypy/typeshed/stdlib/email/mime/audio.pyi,sha256=hsnNC5xAaI2pvS7DYMr58Y46U-hv4MjAKUF0wXWnDfs,482
 puya/_vendor/mypy/typeshed/stdlib/email/mime/base.pyi,sha256=zMUOzyzRFw00inwMFYk-GG8ap-SM9dtp1GRTxjfAiWU,271
 puya/_vendor/mypy/typeshed/stdlib/email/mime/image.pyi,sha256=E3zejA7f_g0NY09tvTj8y1jzGQ0IPrhsKDAofd6ZObA,482
 puya/_vendor/mypy/typeshed/stdlib/email/mime/message.pyi,sha256=obSuhQRP3v-8BeLonA8MWIuomlk7ywUcLEu5mVl6OMU,294
 puya/_vendor/mypy/typeshed/stdlib/email/mime/multipart.pyi,sha256=xeTg6yNg93HdN3OOIQk85d-nw8Rr-RW-kVH5kdwtDak,485
 puya/_vendor/mypy/typeshed/stdlib/email/mime/nonmultipart.pyi,sha256=YW7_zxIBEwStGGAuw7nQEYYS7Yz_TMuTW4-ZIFpIpM4,108
 puya/_vendor/mypy/typeshed/stdlib/email/mime/text.pyi,sha256=YQOSm74Bk8ngTj4y8PaucRTyxkREUT89UnBmVyyV6Z0,293
 puya/_vendor/mypy/typeshed/stdlib/email/parser.pyi,sha256=FWcbxX0V408Zabk1EPsJ2utlcbOcV-AGEUtPsdX9aj4,1328
 puya/_vendor/mypy/typeshed/stdlib/email/policy.pyi,sha256=dQeYfYUSyhgd0C5qa7ereHqpjSIPEimlwPKhUq2nsLY,1390
 puya/_vendor/mypy/typeshed/stdlib/email/quoprimime.pyi,sha256=bSFnFlSadE1pXHmqDzvAEnWwNyeWSLm-i21Kczwrt6A,835
-puya/_vendor/mypy/typeshed/stdlib/email/utils.pyi,sha256=woNGF7i2312ZZd5XqpherFkP1njQMuAYrSGkG0EJzz4,2367
+puya/_vendor/mypy/typeshed/stdlib/email/utils.pyi,sha256=fovIIdTa7e-KOv9Rw2m2U0V7Xmq3i2Q54KXb8WY3Wao,2578
 puya/_vendor/mypy/typeshed/stdlib/encodings/__init__.pyi,sha256=mjHeGjmXCdZHm-KK-XvpvSIf5rY8DOCyKZ_Ot-BJT30,309
-puya/_vendor/mypy/typeshed/stdlib/encodings/utf_8.pyi,sha256=pP3w9phIJOSOw_8I6o2BttSVIiuk8snVD3983_ZpJmE,904
+puya/_vendor/mypy/typeshed/stdlib/encodings/utf_8.pyi,sha256=deQStm6CniNNpdm6A6s-RmrG6AcajLf9q_qXAIACmmY,896
 puya/_vendor/mypy/typeshed/stdlib/encodings/utf_8_sig.pyi,sha256=CAvKrplGLrXKmpdEW4-PjihiA5UICRtcD8YaJX5dhiM,1059
 puya/_vendor/mypy/typeshed/stdlib/ensurepip/__init__.pyi,sha256=8tmoDM1Cy7ojGznNaYzp_-zzoTYP_FunKhPvKpsVU4I,264
-puya/_vendor/mypy/typeshed/stdlib/enum.pyi,sha256=NaO6IQmp4Rr-NLs7l4G41TKDdydhXvFxx5xJb30PUc0,11271
+puya/_vendor/mypy/typeshed/stdlib/enum.pyi,sha256=sPCeCj7YD5OJ49wLNCvtjrUqj9pcHj4m-dADN-vKBxc,11274
 puya/_vendor/mypy/typeshed/stdlib/errno.pyi,sha256=Xts6o5Z1LT1N2OHAI0Bhp3Hy4R7ZsDNUz6iEJ8b8Vpo,3957
 puya/_vendor/mypy/typeshed/stdlib/faulthandler.pyi,sha256=jn6gMdF0GEZljfFTc1splgef8zIo99X1H44qgWxU8sE,644
-puya/_vendor/mypy/typeshed/stdlib/fcntl.pyi,sha256=APvYxOA0Gc3tSdsose361Zc1vYngy7QiQadaT0j9WII,3830
+puya/_vendor/mypy/typeshed/stdlib/fcntl.pyi,sha256=gfYkq_fWJxOKzCqOGzCURtYmbhTeQG0Mw1He4VCJH98,3796
 puya/_vendor/mypy/typeshed/stdlib/filecmp.pyi,sha256=EHL82gJWIESxLEmBZXeW3Ir69DQGUSjvyG678vjR_QQ,1936
 puya/_vendor/mypy/typeshed/stdlib/fileinput.pyi,sha256=4zfc-ySxpfwkXtwiAUBv91tp88_RiAKsJSSU-3BSAi4,7161
 puya/_vendor/mypy/typeshed/stdlib/fnmatch.pyi,sha256=BdxrklLHztHBzg2Ob26Q0axULmgd-Z82xRNvY9hh_5Y,339
 puya/_vendor/mypy/typeshed/stdlib/formatter.pyi,sha256=PoCFa7jJ7efz-ZO-IJU73MK_O9t7mjbYwjxBaSppqpU,3711
-puya/_vendor/mypy/typeshed/stdlib/fractions.pyi,sha256=Z0JcgbNRqdAiEOL0slkxjrZBEeZpYPTtXpmsvorVMzM,5091
-puya/_vendor/mypy/typeshed/stdlib/ftplib.pyi,sha256=dcxViUWyslSZRsuTo5vsASri8emUqYEHqON-hfD6tCo,6491
-puya/_vendor/mypy/typeshed/stdlib/functools.pyi,sha256=PleKwSdSLK4VUXacRlnwiPLyVzECw0GRHP4XMOS3UhQ,7334
-puya/_vendor/mypy/typeshed/stdlib/gc.pyi,sha256=vyfoMy8jdWC15bFn7cxKIU9EmlmH4e_1irMoYtqoXZM,1197
+puya/_vendor/mypy/typeshed/stdlib/fractions.pyi,sha256=wMQ59PniuwSmpr6kE2MELjFWp5OnUpGtqyRJu4yhtHM,5092
+puya/_vendor/mypy/typeshed/stdlib/ftplib.pyi,sha256=gs7LVYpj8iIDkWXUTdl-BoyBmVrOb5a41Miz0_y15M0,6535
+puya/_vendor/mypy/typeshed/stdlib/functools.pyi,sha256=BjIvsIvgvEQKV4Q39Hkft4kDmzP420G_koXyr18uqY0,8281
+puya/_vendor/mypy/typeshed/stdlib/gc.pyi,sha256=RG5LEvV_L7YnRbnRmO02NWbzLf_fI2vjpxg6ZxRicG0,1200
 puya/_vendor/mypy/typeshed/stdlib/genericpath.pyi,sha256=l_BnUXhXxrsoD3IqoJCTc4wvOur9HQK6q2bIYkJtGQ0,1924
 puya/_vendor/mypy/typeshed/stdlib/getopt.pyi,sha256=-4KTGgePwlf-_mHrgy5uxrJb0l8UxM0zBNCfrHqz_70,439
 puya/_vendor/mypy/typeshed/stdlib/getpass.pyi,sha256=HHVTCLX2MOEjVm1Hhf8l1SHi0S3kAUBWcT0dHy27wZ8,227
 puya/_vendor/mypy/typeshed/stdlib/gettext.pyi,sha256=g01i9OTGiFGY5qgTlxv-klB6-epHZZ1vRyR2z0dfMn4,6121
 puya/_vendor/mypy/typeshed/stdlib/glob.pyi,sha256=sjh3z3zHQ-yG9qh7RJpMwakq1y5XOhnHoXqCw_w1B6I,1421
 puya/_vendor/mypy/typeshed/stdlib/graphlib.pyi,sha256=pAiBbKU2aBWlIpq53Fksc9FISuDjn80fZUqn_C37J-U,914
-puya/_vendor/mypy/typeshed/stdlib/grp.pyi,sha256=gvOYPkWrfSu3BcVFgYsrbzYFyPZ4EDkXB9ZsadOtygU,701
-puya/_vendor/mypy/typeshed/stdlib/gzip.pyi,sha256=oRbqsp6lV_wEJGdLjZaTeWRTIH14wgaycKqLs-QTaQg,4858
-puya/_vendor/mypy/typeshed/stdlib/hashlib.pyi,sha256=JLZtAus9mad3goIz-vMGU9H0jmCjf_upYTI2AWJfb4s,5006
-puya/_vendor/mypy/typeshed/stdlib/heapq.pyi,sha256=3PP_NDlAPvbBFFCz0GCkN5a_kBvX67q6dbNVCQy3GKc,759
-puya/_vendor/mypy/typeshed/stdlib/hmac.pyi,sha256=p9ORZT-3Cb-PF8lUz01oSWoUZc_iDf6OGzvr7OAo1bA,1345
+puya/_vendor/mypy/typeshed/stdlib/grp.pyi,sha256=2hJQL4kCKhQ-QBAa87oM83ldvW4WaOkWTlySGzB9VGg,702
+puya/_vendor/mypy/typeshed/stdlib/gzip.pyi,sha256=jDScmj-re1Dni_y0_DLPfXmx257IFBy1ff7sKZX3uqA,4861
+puya/_vendor/mypy/typeshed/stdlib/hashlib.pyi,sha256=TcAMxVkMpybPO7PmYURl-r6C8iLSRc6HpTJf2m--j00,5036
+puya/_vendor/mypy/typeshed/stdlib/heapq.pyi,sha256=IAv_UPegeCDu9MS2wd6G4w7F9ri56QL4qHCUTzhZqRs,760
+puya/_vendor/mypy/typeshed/stdlib/hmac.pyi,sha256=jJ9F5J6KB-zUy-mRsXns-HGED_ENis8rYj39DHnaFEo,1343
 puya/_vendor/mypy/typeshed/stdlib/html/__init__.pyi,sha256=TKNt2K9D-oAvCTmt9_EtgRndcpb--8rawxYFMPHTSC0,157
 puya/_vendor/mypy/typeshed/stdlib/html/entities.pyi,sha256=h-6Ku1fpOhkthtjVMXLTkVwKmc-yZwY4hZN3GkaLaMg,182
 puya/_vendor/mypy/typeshed/stdlib/html/parser.pyi,sha256=DpUIH4HLOZc9J3VyIrHf8JDwoN11H7lFpbaJZdboeaQ,1714
 puya/_vendor/mypy/typeshed/stdlib/http/__init__.pyi,sha256=mYqM0LLWCHcNk5fSkGGS-4ELTtO4zWPwkaet3B2hs18,2674
 puya/_vendor/mypy/typeshed/stdlib/http/client.pyi,sha256=sinrJQMqvOU6PFVt2VVRoKuKvtnZCCoH6xsEolkV9Vc,8396
 puya/_vendor/mypy/typeshed/stdlib/http/cookiejar.pyi,sha256=QmcrjY2yiP9XQRDa64qP1cQ7cwteIDk1XYkl95UnPSQ,6688
 puya/_vendor/mypy/typeshed/stdlib/http/cookies.pyi,sha256=6l5OrZ7owJpCjzW1cszq7cEEAB491P7J5quj7zYk3mA,2312
 puya/_vendor/mypy/typeshed/stdlib/http/server.pyi,sha256=NuZNU_OyZlaM3ZgQN4MQCvZIl0xGEeqST2qMEAq6fcA,3471
 puya/_vendor/mypy/typeshed/stdlib/imaplib.pyi,sha256=VMiEMQHZHL0r5H39c5ojQKFINk6R-jG77RJYX0JdUz4,7857
-puya/_vendor/mypy/typeshed/stdlib/imghdr.pyi,sha256=wbmSFqEHc12geqlP3MabD7_b6YZ5JmJ_eRpGyZPHxtU,505
-puya/_vendor/mypy/typeshed/stdlib/imp.pyi,sha256=HhEtqRAcpYrv8OO_fJv87Kjp-qtC1aZUMUUUcPjZphk,2386
+puya/_vendor/mypy/typeshed/stdlib/imghdr.pyi,sha256=cwNZ6HVLRaxCgmOlftLPMC3rjHNOiOUhriXlbUbOAWM,507
+puya/_vendor/mypy/typeshed/stdlib/imp.pyi,sha256=3P5qkc-T65XrZyygy7x7_PYDtLSg48sqVSWkfwkSAIE,2383
 puya/_vendor/mypy/typeshed/stdlib/importlib/__init__.pyi,sha256=TqnVGBhSmSATLvpghGkCG4khBrO_s629ulOdH96Iphw,849
 puya/_vendor/mypy/typeshed/stdlib/importlib/_abc.pyi,sha256=ZlV-LilTyGYXuY0tdJAOcUPPCKFw2dpF61h2XLhKfDI,609
-puya/_vendor/mypy/typeshed/stdlib/importlib/abc.pyi,sha256=zIms7bDYLpyF0JJu_U74pHlH7bz0I7AbjubiG8fsi5g,6888
+puya/_vendor/mypy/typeshed/stdlib/importlib/abc.pyi,sha256=eSPq-KQYvxCYcLUWRAJlzlkkM-gDG6PALW2On9zkYhU,6887
 puya/_vendor/mypy/typeshed/stdlib/importlib/machinery.pyi,sha256=oSvzbHaylvvqAxVOzbN8RkKMEGlgzQivA47Ma335i3I,7004
-puya/_vendor/mypy/typeshed/stdlib/importlib/metadata/__init__.pyi,sha256=npJzHRadnc_uErM10U6d0ivGfmTMWQVhuOn69JvvvC8,9020
-puya/_vendor/mypy/typeshed/stdlib/importlib/metadata/_meta.pyi,sha256=4_blrwp-s9u91fhlMh-kcA-D051ZSj_RrjIhLdVvmlk,1471
+puya/_vendor/mypy/typeshed/stdlib/importlib/metadata/__init__.pyi,sha256=ZzMx9w0R9IRuuQ18Hco9A2jfavJyg3U-tSXnX7a3nZY,9284
+puya/_vendor/mypy/typeshed/stdlib/importlib/metadata/_meta.pyi,sha256=HpZJ3yaMvuIzWjaZXHn3VGPBW0Xgx5hwjR6U_Xjzykw,2010
 puya/_vendor/mypy/typeshed/stdlib/importlib/readers.pyi,sha256=_opfnlskd41lvw2f9oa4GkY9ssGxPhkKhEeAzDvMF0M,2584
 puya/_vendor/mypy/typeshed/stdlib/importlib/resources/__init__.pyi,sha256=VkHJ9xC6qtuU2w1L4hTwyy7j-F0VWRLT9g7bmQIPaqQ,1678
 puya/_vendor/mypy/typeshed/stdlib/importlib/resources/abc.pyi,sha256=uLq0IrUI45F5H19i5EhQvTQV34jW-ffft_W5_cJ_iTM,476
 puya/_vendor/mypy/typeshed/stdlib/importlib/resources/readers.pyi,sha256=L9ISdjyiVx8ppnP2bTSjbdd_dzvr1lY3_aRn6ZfitsM,398
-puya/_vendor/mypy/typeshed/stdlib/importlib/resources/simple.pyi,sha256=sXP_Af0zHXFNTAQQGmt_0lFbNpdgojCmedkL8s4b7aw,2149
+puya/_vendor/mypy/typeshed/stdlib/importlib/resources/simple.pyi,sha256=QNzW9FV5ELG2KD3lk6-YrhAyKnzzCY7MiUN1ENqo18I,2200
 puya/_vendor/mypy/typeshed/stdlib/importlib/simple.pyi,sha256=Px9D1mMPoXrh__Iy1JacqIN2AEUSTLHrV2fVGRRkTZI,354
 puya/_vendor/mypy/typeshed/stdlib/importlib/util.pyi,sha256=MEmOqOw3UDf7aKOTwltFNsQk5pPC8JZbhNlAnoNusO4,1826
-puya/_vendor/mypy/typeshed/stdlib/inspect.pyi,sha256=qXWKK4GUiCUaTxFhqjPbnzGyeKxbKTWC5ysEK_2hKUc,20239
-puya/_vendor/mypy/typeshed/stdlib/io.pyi,sha256=skEgK-Ff8gNKYduWEvkhVe2put0NPuDeGO5mTszBtoQ,8156
+puya/_vendor/mypy/typeshed/stdlib/inspect.pyi,sha256=QxjuEPO2MIFghtx_ptkkaU4K96wALCzWMFcecD_9joo,20241
+puya/_vendor/mypy/typeshed/stdlib/io.pyi,sha256=l5rZKibWJ7R1ORKEQEeq695U2FKs1nuD0TMJWvTDrjQ,9705
 puya/_vendor/mypy/typeshed/stdlib/ipaddress.pyi,sha256=k_hBcaSMIZZa9ngdCwNNRUMdI9YquVHJusB-hie-5ic,7328
-puya/_vendor/mypy/typeshed/stdlib/itertools.pyi,sha256=BdKPSqydgkpVdRQ7zYbE3ql7qbz4eJ8CgDxcDUum1A8,11637
+puya/_vendor/mypy/typeshed/stdlib/itertools.pyi,sha256=cfUMRx8k-x2x5qeSGv6yJ2IMjIx9KrKniXRLYlJkHeA,11055
 puya/_vendor/mypy/typeshed/stdlib/json/__init__.pyi,sha256=XhcpH-7ynXInaWJyf2TG0DKKt3fC_1Owvn2s6E6aefY,2061
 puya/_vendor/mypy/typeshed/stdlib/json/decoder.pyi,sha256=XdU0nhYShlWZbSXpxGdsgurtM3S_l0C9mDYCV9Tfaik,1117
-puya/_vendor/mypy/typeshed/stdlib/json/encoder.pyi,sha256=DFPWZRLUTpXXmBpD712DgBqeEsaqplsFo1B0_sse8H8,1073
+puya/_vendor/mypy/typeshed/stdlib/json/encoder.pyi,sha256=yFuE-KGKVQk8gye1j6KEm67p5ONHwCs4zcv070epf_A,1195
 puya/_vendor/mypy/typeshed/stdlib/json/tool.pyi,sha256=d4f22QGwpb1ZtDk-1Sn72ftvo4incC5E2JAikmjzfJI,24
 puya/_vendor/mypy/typeshed/stdlib/keyword.pyi,sha256=-p50eMrwinwQwjmO24AsOOjBX9bLeuUUAWWhy8IS5oc,565
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/btm_matcher.pyi,sha256=zWMSDahNavhi40hkU1rK-3lPsSgvlsDJtwhQfqAlmSU,860
-puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixer_base.pyi,sha256=hoOL2ssJKf7F6TJDX8eXWOKc_eLeyhStE6ACBXy-Crg,1693
+puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixer_base.pyi,sha256=NacQW1e6fooBSu5crrweMC0KKcBhXDQmsQbe11U3cj0,1692
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_apply.pyi,sha256=xMqbvuWy1ujOd9odCGJi3UpeSLmlYk6jNK9L5jydnAc,215
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_asserts.pyi,sha256=RvQ20PHvkQQEwxF4j-j7KRiNuxGky2tzzjLKQgn8lXE,245
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_basestring.pyi,sha256=lY1h20fQ_HpI-54CXXjhRpazbh-I8PMasjxPau1iJjc,240
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_buffer.pyi,sha256=RysLZN7QX0ouBHx4bD5sRCTtV_p6GQlF-PKTFpePqHo,224
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_dict.pyi,sha256=qcbZRE3X7cFCwAQ-BH_0Nkxk0wEvS04tPUOfJbcae4c,424
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/fixes/fix_except.pyi,sha256=Df6KW8jrbtYWU_kWAqlY5FRLc8drkCgE8pmpp1S14Lo,415
@@ -529,432 +530,436 @@
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/pgen2/token.pyi,sha256=k1QtetXMmv43tbZLjQ_sYeIQ49aqe7yL4dC_mI_HRkw,958
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/pgen2/tokenize.pyi,sha256=mdjbHoIgTIFWGaGKpky1FqxpY6Ugih514SvAlNUT-8k,1972
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/pygram.pyi,sha256=cMDHpJNWgsy0aJVrG2e2uBDq9DbXd30htXQBMjAO_pA,2253
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/pytree.pyi,sha256=DgmAdSt5KPg1laF5lX1Y4DDx5lmsFM0_bGaAfixGHq8,4118
 puya/_vendor/mypy/typeshed/stdlib/lib2to3/refactor.pyi,sha256=vhGguYDE5gxdbUxG_LKxVPZ9KhkbryDjRT_hK7FSZ1U,3946
 puya/_vendor/mypy/typeshed/stdlib/linecache.pyi,sha256=9MQPCkBEhtgqvCkBedB-hgDst2dcLML5u2QfNY_DLlQ,958
 puya/_vendor/mypy/typeshed/stdlib/locale.pyi,sha256=Z0I4TRQ_hV5mrDB6m9gySdix0LD2XnctbSZenIrM5Zk,4341
-puya/_vendor/mypy/typeshed/stdlib/logging/__init__.pyi,sha256=lvXIgbwe_8cxWSHBhyqmAzl6so5SPD1qfM6NR3O1Fco,19919
+puya/_vendor/mypy/typeshed/stdlib/logging/__init__.pyi,sha256=EoWLFfLlC2ni9TZoJoSZeZJfNuStFfPdwsOpq6Yxqns,19986
 puya/_vendor/mypy/typeshed/stdlib/logging/config.pyi,sha256=9riqGfvtw3aMg4SiaxI7hitOiz0qNAksmV1jNDEbcWQ,5742
-puya/_vendor/mypy/typeshed/stdlib/logging/handlers.pyi,sha256=sbdZ4kKHddfnJWckNcZ20R2u5MAdcSeCl-FrKqRoTBc,9606
-puya/_vendor/mypy/typeshed/stdlib/lzma.pyi,sha256=dO9wwxqFYpNQah2Oh-nY_oCsiMnkjBqaPl-bqt0QsqA,5342
+puya/_vendor/mypy/typeshed/stdlib/logging/handlers.pyi,sha256=iwdWxqEYsabXTmmA-2S-Wz9FLxjTDUKZJQU6eB6qIdU,9607
+puya/_vendor/mypy/typeshed/stdlib/lzma.pyi,sha256=d7KTpOGcJkVw2rrM1e-TqpItFj6g-3KbX77O_p_erp8,5344
 puya/_vendor/mypy/typeshed/stdlib/mailbox.pyi,sha256=tiKaMtKElDkFqr5uUuZ73CSqw9gkMvqYImXiEWxpRUc,10459
 puya/_vendor/mypy/typeshed/stdlib/mailcap.pyi,sha256=h3wCqy9SD2DA8-aB5k7vW17ShyhlL-AZV6iYKpRTyP4,388
-puya/_vendor/mypy/typeshed/stdlib/marshal.pyi,sha256=vhtCdF0NOC0aFkBtigcLPfFQfutGsm7_n367POUooz4,841
-puya/_vendor/mypy/typeshed/stdlib/math.pyi,sha256=BMli6e_JVmqpQ23ToX6zLOmFtK3gRjXMlu2q0SKgoZU,4808
+puya/_vendor/mypy/typeshed/stdlib/marshal.pyi,sha256=v9pAeGPkTFHIyb18-pqGMl02nBvXtihVxfzfJxR6JVc,839
+puya/_vendor/mypy/typeshed/stdlib/math.pyi,sha256=sbxdg4erqr5Hrq9j5LPzK1Gy014fDyrcfAmZSKXPR7o,4838
 puya/_vendor/mypy/typeshed/stdlib/mimetypes.pyi,sha256=T1xrJGpUOGTeaUwqqL2FuJ624jWHHfQ2UHayXu1R8IM,1672
-puya/_vendor/mypy/typeshed/stdlib/mmap.pyi,sha256=9u8HhtvsfTFUXap5Mv4yi3q88Z7J-SjCJ3LSq6Q5FS0,3999
+puya/_vendor/mypy/typeshed/stdlib/mmap.pyi,sha256=RLA6-MAv8BhUHylU1VQiU9CRA4rlAAUXYolgcIfCGTw,4003
 puya/_vendor/mypy/typeshed/stdlib/modulefinder.pyi,sha256=6gAMqG4d5qqggEw-ZFbHTwwi80sILJp6LZJVNwkew78,3294
-puya/_vendor/mypy/typeshed/stdlib/msilib/__init__.pyi,sha256=WwONFfZpfki5SLx15Vd61L5B1e2nRbTebzHpzvEeBZk,5852
+puya/_vendor/mypy/typeshed/stdlib/msilib/__init__.pyi,sha256=pscpi4jpMvyj45Ol4_72ccTws6sNO2mZSI3j8q4WQIg,5853
 puya/_vendor/mypy/typeshed/stdlib/msilib/schema.pyi,sha256=hRHjm9DavaKkp9xDvvtbMaYjuRkOaPouAiUp9YGvPHU,2141
 puya/_vendor/mypy/typeshed/stdlib/msilib/sequence.pyi,sha256=Kr3fzhLlB_ejF3yzrW6G0U709ejvr7g1B2IwBZgtczE,362
 puya/_vendor/mypy/typeshed/stdlib/msilib/text.pyi,sha256=8HffYG4YsY1IfxxTyLlhpd0DW4Sl4hiAWiC6SBE_1lM,170
-puya/_vendor/mypy/typeshed/stdlib/msvcrt.pyi,sha256=h8qeOLSdwIoZFjRDwlzj8IC-H_jq5qgj9cDZdS-EDk4,1165
+puya/_vendor/mypy/typeshed/stdlib/msvcrt.pyi,sha256=UPtNvGLkwKvBuZmXAC6G_DUn64OqmjzSye9Y34GetqE,1166
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/__init__.pyi,sha256=KafkEHitV2NmXHJS956RawcoMZhXV6_mZ-io0ZpMSv4,3132
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/connection.pyi,sha256=aEQRiEyHLFhEdvXOHwioqemSJRcrQgfLsWcJ0it9ogw,2969
-puya/_vendor/mypy/typeshed/stdlib/multiprocessing/context.pyi,sha256=PKx1b3sgxVKlC9aapB32GMT1USF04UfyPBZHODxhMiw,7786
-puya/_vendor/mypy/typeshed/stdlib/multiprocessing/dummy/__init__.pyi,sha256=Oj54atey235ySe4VUgL1aOKtnkchWCLzDdr8QgDBpog,1935
+puya/_vendor/mypy/typeshed/stdlib/multiprocessing/context.pyi,sha256=5w0h-ZzaYGQx8eBwRrNHC-IukV8eq6ZAY3MkabY7lwg,7821
+puya/_vendor/mypy/typeshed/stdlib/multiprocessing/dummy/__init__.pyi,sha256=8Ra_8E5DWqZD_DtarXt3Z5R1kmAIsRJpHEUGJC7aNOc,1935
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/dummy/connection.pyi,sha256=WNsr78HeHz67VG14qLrc6xUkFNQkKt18jw95amhFBQg,1282
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/forkserver.pyi,sha256=S_67nMlJq7QCV2XLHPoqy6k4C_OAdcxpa_Z9JKPm-nw,1058
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/heap.pyi,sha256=UdBz1JsRfJdZMGAi5fdcWy1LUhCNLKJhC5EddcKI1cc,1046
-puya/_vendor/mypy/typeshed/stdlib/multiprocessing/managers.pyi,sha256=MqtecdNqsyIIJ3JCWM3d9PgvSZ7o1xBfRHmvx9RqMWE,8886
+puya/_vendor/mypy/typeshed/stdlib/multiprocessing/managers.pyi,sha256=FVfQMyU5f6ZqP7h-tZpNeALNx-Js9dnjnmoQHDxXQA4,8899
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/pool.pyi,sha256=BSs9eGnn6RT-3elvKE7U1qP-wLqXap_zO_wtJlamTBM,3888
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/popen_fork.pyi,sha256=mheawsbB0-LZ2gJmYvsMhCt06yXWCtg8tClPJJNKJ0Y,724
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/popen_forkserver.pyi,sha256=-f851cHQEbM_L9oXaw6PrUHI6bKAVasRR17OirOSd60,353
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/popen_spawn_posix.pyi,sha256=kuKZmJxw4id8R5dTTp-B7E-5qDWTSexAOkCqStEMoKo,524
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/popen_spawn_win32.pyi,sha256=t-0UShNiEUqeKfLEEt7tRM8eF1iRaxdaFKP_c0TXDNc,738
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/process.pyi,sha256=ys5dydqBBOoSL73rB51ywdRzzQArEhLd087HDtksgK4,1177
-puya/_vendor/mypy/typeshed/stdlib/multiprocessing/queues.pyi,sha256=59kIwC-rl7eL8GoaqwGhMgXJFSM2k3SomZ0Y0TD3H-w,1486
-puya/_vendor/mypy/typeshed/stdlib/multiprocessing/reduction.pyi,sha256=mIL-cXKAO9_1MN4ISmPopg6zNnoaLAUnr92nQW7KDUo,3134
+puya/_vendor/mypy/typeshed/stdlib/multiprocessing/queues.pyi,sha256=-PCZNaPm_EszBIolpkVwjBRUhUlSdhj4bVqP1tJ4bA8,1487
+puya/_vendor/mypy/typeshed/stdlib/multiprocessing/reduction.pyi,sha256=r_K5kHjt539yNVbz8qviENDCB70UjhI9o7BHWnUPd9U,3135
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/resource_sharer.pyi,sha256=d9OjiE5L4aC3-u2-WC7csArCtkqs_IMOhhOVMEi6UjY,420
-puya/_vendor/mypy/typeshed/stdlib/multiprocessing/resource_tracker.pyi,sha256=w2BBEY5ehBV36E_tZ2gOOcmpdCVYn3W3iNLjsf047dg,635
+puya/_vendor/mypy/typeshed/stdlib/multiprocessing/resource_tracker.pyi,sha256=QZeDRlhKpJ3WpE9NFJF8N2WGcHx_5URC_0A7N8SU508,609
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/shared_memory.pyi,sha256=ZvMn743e7Ldf2gQ2zC-iq7gPgAGgQqUnWDXKHIoBd38,1389
-puya/_vendor/mypy/typeshed/stdlib/multiprocessing/sharedctypes.pyi,sha256=SpoUNNUmVxYDgGrNIU0GXIWMXQSy2nL6ArPYP_oxXfo,4023
+puya/_vendor/mypy/typeshed/stdlib/multiprocessing/sharedctypes.pyi,sha256=yMxHf07EfVuJMK2IlFhQkRx6zLXBNx8FV4URmzyxCus,4200
 puya/_vendor/mypy/typeshed/stdlib/multiprocessing/spawn.pyi,sha256=qyGvnY6Byy0tHwPsz86lF1wAAL02B_vb6wu64vCsgNk,861
-puya/_vendor/mypy/typeshed/stdlib/multiprocessing/synchronize.pyi,sha256=g7ruX6xPaJs5DAxRYhGwpjvcu1wNAO-P4wFNBhwbcc4,2128
-puya/_vendor/mypy/typeshed/stdlib/multiprocessing/util.pyi,sha256=6AHRutz7qvA15q36ZsE9-ZOlQ_PLD4WTAaPl94q3xOw,2227
+puya/_vendor/mypy/typeshed/stdlib/multiprocessing/synchronize.pyi,sha256=TPj6Js8_V8PPf1klSQyQZkQO2vJ0cdeoHfuHvXIiEoc,2122
+puya/_vendor/mypy/typeshed/stdlib/multiprocessing/util.pyi,sha256=z1MDnAC8Oxwvmf4dAexXNr3TL_Vz_EDH8HGW8-MKzEk,2810
 puya/_vendor/mypy/typeshed/stdlib/netrc.pyi,sha256=tvfrFw9uqNzt6Xt_fJVlbF2uXIoJy7YXEAOzveB8AEo,745
 puya/_vendor/mypy/typeshed/stdlib/nis.pyi,sha256=jnKh2Xj3mroOTpZpm-C7BYPVe5M18UAIVeh66AFGyw0,293
 puya/_vendor/mypy/typeshed/stdlib/nntplib.pyi,sha256=LEW4hVdI-AwyLXysRzwPK4P2aCChw1yYxWlw3l9Dmv4,4490
 puya/_vendor/mypy/typeshed/stdlib/nt.pyi,sha256=XQYqWqSW_HoC0AxpsMIO83HGhR2Xv2b5tUcpc7QVK38,3273
-puya/_vendor/mypy/typeshed/stdlib/ntpath.pyi,sha256=An6tvHnBuRjaiH7VM-Ui8GC-3F8IDc9stIei4mFsWjw,2870
+puya/_vendor/mypy/typeshed/stdlib/ntpath.pyi,sha256=VpmYveUEYs-pk1XQwuxLk8mT2F_fMhwM4Vdq9nFcen8,2873
 puya/_vendor/mypy/typeshed/stdlib/nturl2path.pyi,sha256=E4_g6cF1KbaY3WxuH-K0-fdoY_Awea4D2Q0hQCFf3pQ,76
-puya/_vendor/mypy/typeshed/stdlib/numbers.pyi,sha256=E6Rox9tEBbB1X6UzJkVQpBZBjPCnu6HvRvBj1JQbapo,5481
-puya/_vendor/mypy/typeshed/stdlib/opcode.pyi,sha256=owS94_M4b11UDWzGN956FN8lyjrQgm_FId3pWPAOXH8,1273
+puya/_vendor/mypy/typeshed/stdlib/numbers.pyi,sha256=GKmKJElT-gosvXosseQ4kizBrtwjaGdiM_1TrXimpaQ,7370
+puya/_vendor/mypy/typeshed/stdlib/opcode.pyi,sha256=McMN00LcS1H9oZXh5VcIMCTmoobt2zzQvvOc-KXKtQU,1272
 puya/_vendor/mypy/typeshed/stdlib/operator.pyi,sha256=tYdNrYQHPWJRxg8tpq3tBoPIzxjXNp4_YGzReH04NiU,1644
-puya/_vendor/mypy/typeshed/stdlib/optparse.pyi,sha256=1VTQ2_uVELLVWuCp5GamcjLgYGOGrn1YyDrzh22YNWc,10286
-puya/_vendor/mypy/typeshed/stdlib/os/__init__.pyi,sha256=a4wIP6F0gbhU5W580yZwMFJzo8j8sY6gbrgER3C7I_U,39824
+puya/_vendor/mypy/typeshed/stdlib/optparse.pyi,sha256=gl9qZuyuth_uRSqmZ79hB2dTlN_-fdbhZ8pwFR68i5w,10527
+puya/_vendor/mypy/typeshed/stdlib/os/__init__.pyi,sha256=vHce9nqA7m5OYX2vNCFRWIDCWTl1QAKIcuC02bHCJHg,40258
 puya/_vendor/mypy/typeshed/stdlib/os/path.pyi,sha256=G76tJbvlG1_kzFd8gnCqS4Mht3gPzlC1ihIBqzurxDM,186
 puya/_vendor/mypy/typeshed/stdlib/ossaudiodev.pyi,sha256=j1opCPZBIQMNhCvSDwkIDC0RoNbuSri3yBEeJ5BLziw,3589
 puya/_vendor/mypy/typeshed/stdlib/parser.pyi,sha256=sAXk9ajaMltig6ZgRn8DnwJgV5-eAoiE0KGL0ZOuhrU,1017
-puya/_vendor/mypy/typeshed/stdlib/pathlib.pyi,sha256=LWBJBYjoCYRKtk1B9Dvhs_e8vTUIuQsdxskYDiYKuho,9020
+puya/_vendor/mypy/typeshed/stdlib/pathlib.pyi,sha256=0VapL24wBlvgL4IqAWtaNQxaQ3NDA0vejOe8prDkbEA,9022
 puya/_vendor/mypy/typeshed/stdlib/pdb.pyi,sha256=Q4UW0X-5j_Uk-qCcaKZU5fn6ua3xlVwbbdtpEmcZC5A,7549
-puya/_vendor/mypy/typeshed/stdlib/pickle.pyi,sha256=wncZhSVu5hR9VvKP7qMBGrx9tHofNrX9DcrCcynq_3E,5719
+puya/_vendor/mypy/typeshed/stdlib/pickle.pyi,sha256=fXhg1kRdn0OseQLsrSDpgks3K9IvTL4ZoIv_rrn-dKQ,5727
 puya/_vendor/mypy/typeshed/stdlib/pickletools.pyi,sha256=hfV2HoaGStXhWZ9jta9NAqCJDa6ws9YeAU34k3Fz9-s,3813
 puya/_vendor/mypy/typeshed/stdlib/pipes.pyi,sha256=FvE1GTA5YU-JHBIO-mCAIfrAARL7g2Ck0HmgJ765gNc,502
 puya/_vendor/mypy/typeshed/stdlib/pkgutil.pyi,sha256=H_Ng_anUtVpgupERZQuaOVzaiKC24J5tlvjqCrcvjp4,1914
 puya/_vendor/mypy/typeshed/stdlib/platform.pyi,sha256=YuLOdbcIjVNoFxX7hfsaswdDd6GZegaE3SMQrtcG47s,1660
 puya/_vendor/mypy/typeshed/stdlib/plistlib.pyi,sha256=TjA-IEwA1E7qgKgNEfx1iEpJvKWjJXR2NaPaoExk6UM,3724
 puya/_vendor/mypy/typeshed/stdlib/poplib.pyi,sha256=FKtzUscuBfuJPB3WiMs1WtR_mKbTBQuSIJzDrCQ8N9Y,2487
-puya/_vendor/mypy/typeshed/stdlib/posix.pyi,sha256=WUJhcLQD-7tTtRRQ2R0mtar-Wl1Is-d3nXr4WA_diT0,12035
-puya/_vendor/mypy/typeshed/stdlib/posixpath.pyi,sha256=Pd93wL2R12V8poIQKwab7lLUGNnw7IW9cW6BRCpBbQI,4640
+puya/_vendor/mypy/typeshed/stdlib/posix.pyi,sha256=i2oSHg4IxFgxxzZiJYcsEoC-VsMrYdSXdmcNqUnB52o,12107
+puya/_vendor/mypy/typeshed/stdlib/posixpath.pyi,sha256=FxE7y0bXK3_W3DRIgiFnjAxfEXZCrNJPOJ9Vl_NjzVg,4643
 puya/_vendor/mypy/typeshed/stdlib/pprint.pyi,sha256=H5Og_tEKGr9ellbyQIKXDYS5z0c0QKUrZM09BaUY2OQ,2984
-puya/_vendor/mypy/typeshed/stdlib/profile.pyi,sha256=VpPS5rX-U-fcd_c6RqY61jExGMMUtzY_QKV_Et0er6o,1400
-puya/_vendor/mypy/typeshed/stdlib/pstats.pyi,sha256=fPocmVAz1lu_nOoONRMXcnAVzByjszI2AzvKceZs3zM,2794
+puya/_vendor/mypy/typeshed/stdlib/profile.pyi,sha256=WctYqqd21kj4fmboSF0U4cb7qQQ5B5aDsyHjiwA2lYc,1401
+puya/_vendor/mypy/typeshed/stdlib/pstats.pyi,sha256=7pq-7qQoGx1Qv0-ynJ9EGe4NLqk6pmldKJnYxYAM_dU,2804
 puya/_vendor/mypy/typeshed/stdlib/pty.pyi,sha256=2eqzzeIOIazVAWGBL8WvvkZyMBGYmuSEEdWTkz-KlZs,697
-puya/_vendor/mypy/typeshed/stdlib/pwd.pyi,sha256=0418dhInVae4wF-VSyzk47xvmVMTGFxsroE7szfh79E,902
+puya/_vendor/mypy/typeshed/stdlib/pwd.pyi,sha256=rXA9jXtUOJeQ5D06dv5C8twQxrOatqmQrlg1SZFfxUU,905
 puya/_vendor/mypy/typeshed/stdlib/py_compile.pyi,sha256=RDneINea_xhqvlpQiVyN_su-gThuERjClDQnelpnRic,897
 puya/_vendor/mypy/typeshed/stdlib/pyclbr.pyi,sha256=xZ2POHrJZT7xe7eaueO6wxdgpFFkdf1BePdF0PuSbqc,2284
 puya/_vendor/mypy/typeshed/stdlib/pydoc.pyi,sha256=OUt8PU8kmQ74zdk4c2zxvr5zsXFZ6vDi8cJo5LjeUQs,10881
 puya/_vendor/mypy/typeshed/stdlib/pydoc_data/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/typeshed/stdlib/pydoc_data/topics.pyi,sha256=e6t5ek6ktCuHqVHsBY_gFm5Lzj4BupyBch13u0t2JVc,23
-puya/_vendor/mypy/typeshed/stdlib/pyexpat/__init__.pyi,sha256=B5tLCZXNPRTOQDX_9ZLVgqgQEXjMS5ccjCoSVW6wspo,3396
+puya/_vendor/mypy/typeshed/stdlib/pyexpat/__init__.pyi,sha256=3zS2HMBjLGg-35jRPCL2S0M6sHgbpR1AqXufBvKyyK8,3549
 puya/_vendor/mypy/typeshed/stdlib/pyexpat/errors.pyi,sha256=X8RDjOTN_gpDtmIZMIkMump2fA-wBWRLQ9PCWAN43Ac,1477
 puya/_vendor/mypy/typeshed/stdlib/pyexpat/model.pyi,sha256=LlBMaLvt3TBD1JQSAQTYUrHKAfKNEeQYaDw5GsJA--g,205
-puya/_vendor/mypy/typeshed/stdlib/queue.pyi,sha256=Uvl7OyniSZunXc-pGwZcgI2oC9_gl9j36WtnM06jEXw,2042
+puya/_vendor/mypy/typeshed/stdlib/queue.pyi,sha256=w7wDop6G6aPz-jMvHNXY-CgJXJPkeH1b53GSKm5AHdI,2290
 puya/_vendor/mypy/typeshed/stdlib/quopri.pyi,sha256=dS5VRBZNFkbcr7iEbgkiZzaVMBikOVqqerPCYxtunjY,635
 puya/_vendor/mypy/typeshed/stdlib/random.pyi,sha256=tk5Zfqr5Ls02BvHPFsE7HjvDNqr3rcRc9ddR99apCpI,5012
-puya/_vendor/mypy/typeshed/stdlib/re.pyi,sha256=8FhaLvA7hg4V6ZGnA35tpvog8bpj52n4miVpYWJs4cI,11305
-puya/_vendor/mypy/typeshed/stdlib/readline.pyi,sha256=IZlPSsDps5e06s_ScKfJxSaepjwpKPydrsETGOS78wQ,1862
+puya/_vendor/mypy/typeshed/stdlib/re.pyi,sha256=fuzQ6iPRY-oVXL3jXNjUtxJD6mj0c5OkFmDllrxnPMs,11314
+puya/_vendor/mypy/typeshed/stdlib/readline.pyi,sha256=APsI7YmmY5PbTTfnBmXJsEuFgJQB5WJpdAnKVZwVhOQ,1875
 puya/_vendor/mypy/typeshed/stdlib/reprlib.pyi,sha256=usKrUhRcCNeOVdYy3S6I8njRORXIQ9rXrGme00uGJd4,1986
-puya/_vendor/mypy/typeshed/stdlib/resource.pyi,sha256=mmWFX2TDpzBYz04q3PGHUToWdoEolTSEuJ4jMIEZbk0,2807
+puya/_vendor/mypy/typeshed/stdlib/resource.pyi,sha256=NpORCu0bCXUQgur4PhxO5DNQeVpztLXV6nsp4lXDMCg,2804
 puya/_vendor/mypy/typeshed/stdlib/rlcompleter.pyi,sha256=FtTt0Z1sNrWz6EMCyowIRAq8tzAeTpee6rUVJ5b-Tsw,322
 puya/_vendor/mypy/typeshed/stdlib/runpy.pyi,sha256=hrHtuhkdU-vJb7E6trWXD-ITI33AOQT_HH5CEsURVdQ,811
 puya/_vendor/mypy/typeshed/stdlib/sched.pyi,sha256=B8FhorZyvm0qvFqQ0kXb1kDQq4IhUFwDCqV3Q5Hinnk,1333
 puya/_vendor/mypy/typeshed/stdlib/secrets.pyi,sha256=GTDHK_EMcCaMZ9h-8OploY5SQiAaqTDRbh3ROug0M4I,624
-puya/_vendor/mypy/typeshed/stdlib/select.pyi,sha256=TzOi24zvOinhon8JX2K23E5pKvXI-GgNICUaAjBXF44,4538
+puya/_vendor/mypy/typeshed/stdlib/select.pyi,sha256=dRA1pA498tjxBlzJofu8PE3Aq3D7magrvklZ2UVop7A,4544
 puya/_vendor/mypy/typeshed/stdlib/selectors.pyi,sha256=wNZwMYv5eLvWa7vEkXhOpXJ-rXM9QBcAGKR9N-ZtCEw,2782
 puya/_vendor/mypy/typeshed/stdlib/shelve.pyi,sha256=tAihZ-myy-PZ9bEDf7Jou17M7FHuyrXpoZP79rQ8jsM,1892
-puya/_vendor/mypy/typeshed/stdlib/shlex.pyi,sha256=GCD8I9l0Fab9CETf6J_1htRCVNhpyU9cPBrU2I2HSE0,1371
-puya/_vendor/mypy/typeshed/stdlib/shutil.pyi,sha256=c8wBltWy9bDC828QM52BhIWjWXsxZDzQPqEEHhZwWmY,6750
-puya/_vendor/mypy/typeshed/stdlib/signal.pyi,sha256=xxmKXKBQFpZREFzFW9UdaWBuaPWbjoTWmyDlYLbCs6g,5642
+puya/_vendor/mypy/typeshed/stdlib/shlex.pyi,sha256=TAfwnNvbM1SrS7NFBdjy0PZZCaUJ7drKPhVt1qFajsQ,2206
+puya/_vendor/mypy/typeshed/stdlib/shutil.pyi,sha256=UVIY_jmQ3pP6Gt9up5m0AOoeiXje2nDUpQeMaHYRKqU,6892
+puya/_vendor/mypy/typeshed/stdlib/signal.pyi,sha256=nqYvLQLgyG9nSjNOqseCAPR6oB_n6UnwS2omZ0rxnrs,5404
 puya/_vendor/mypy/typeshed/stdlib/site.pyi,sha256=VLUjy224HMBMxypap1nqsUxzApffnonquUkMXDEvmwE,1358
 puya/_vendor/mypy/typeshed/stdlib/smtpd.pyi,sha256=ce_-rXeXmh2tgsxOR_tJJOPFQWLiQYqsnSggBP69huQ,2998
-puya/_vendor/mypy/typeshed/stdlib/smtplib.pyi,sha256=_77J9mXij4zgj6B5HbRqHMTKYjXn_4t9pGngqniZ_CY,6722
+puya/_vendor/mypy/typeshed/stdlib/smtplib.pyi,sha256=ThlMWWrtJ4U956G1bWQqRA3mWBRL-x_3702upUWVCOw,6724
 puya/_vendor/mypy/typeshed/stdlib/sndhdr.pyi,sha256=4boTiWWf2o3VW6QhITP8JNEePP734AlxyMeU1cn74CM,353
-puya/_vendor/mypy/typeshed/stdlib/socket.pyi,sha256=C80ezkN4N9ne7ta50ApTlQocMqbn1I7y5Y28bOioTLQ,29303
+puya/_vendor/mypy/typeshed/stdlib/socket.pyi,sha256=2vXVtWvICirnGvt3xU1zLP1IIGTIDAp6h6naE_n-JlI,29277
 puya/_vendor/mypy/typeshed/stdlib/socketserver.pyi,sha256=NMFHSpFLxzQcbUVfRdkKgc1AWO7IaR_i4la05-ydbFA,6732
-puya/_vendor/mypy/typeshed/stdlib/spwd.pyi,sha256=InQJhlt2R9qEqpr5wsnmFTRlZNU5532YAwttLhlsDyY,1151
+puya/_vendor/mypy/typeshed/stdlib/spwd.pyi,sha256=fv85SuDfTIf947QOkG5DuAFiHN2qUm3YyH8RB-toLjc,1153
 puya/_vendor/mypy/typeshed/stdlib/sqlite3/__init__.pyi,sha256=gceY1jvHvHiZ45SMdArnWeyTcRGArLc2PK28jNbtbXU,29
-puya/_vendor/mypy/typeshed/stdlib/sqlite3/dbapi2.pyi,sha256=hNH1PulclfygTdgb15oeB4DwbqkYrWgUjgfsWlrz4HE,17192
+puya/_vendor/mypy/typeshed/stdlib/sqlite3/dbapi2.pyi,sha256=CcoHtJu3VsSVt-xN2BzD4LwbfuIfhquWCWT9ZQ6ykkI,19822
 puya/_vendor/mypy/typeshed/stdlib/sre_compile.pyi,sha256=yc1nsmNzAJbfAUFaKTMoik99gA4TgPwx92ux45r2VEA,332
 puya/_vendor/mypy/typeshed/stdlib/sre_constants.pyi,sha256=z7gyetbR-CCQlJZlAnER6fT1TD4dwLW67As3eEVZClw,3986
 puya/_vendor/mypy/typeshed/stdlib/sre_parse.pyi,sha256=9PT58-Q2oMDqtejzbWG2D5-UiBo8mQnptiAevjW7ZyQ,3790
-puya/_vendor/mypy/typeshed/stdlib/ssl.pyi,sha256=UsZ7W2qDvW-cJnrUaABwCIPOMxnD0mZ_hZhqulNJbyw,18909
+puya/_vendor/mypy/typeshed/stdlib/ssl.pyi,sha256=TDdkR_WccqMSuQpp871k6jZrHSTUVaWoY4_pO2yfISc,19244
 puya/_vendor/mypy/typeshed/stdlib/stat.pyi,sha256=H9gX7m5DJt9cT5h4xk3JwIDAVDdzSt_cHfoeVG_B2Ko,20
-puya/_vendor/mypy/typeshed/stdlib/statistics.pyi,sha256=UXPJkm1NqllcJNwx99O-DZ-eUogHtGYVvxVmc-SU2LU,4808
-puya/_vendor/mypy/typeshed/stdlib/string.pyi,sha256=zES75mTdIJQiklC5SZEXuyWHQPFU9y0EoI0y7bVK1kY,3097
+puya/_vendor/mypy/typeshed/stdlib/statistics.pyi,sha256=k_8WQfSeBthAez0oEe4w1EimlBJxbhVvdBoT89kkAOw,4803
+puya/_vendor/mypy/typeshed/stdlib/string.pyi,sha256=23ggE_jfO0cvb0A8vZLwbtZD37XrQm53eUpdaxjD3KY,3108
 puya/_vendor/mypy/typeshed/stdlib/stringprep.pyi,sha256=Zcj538_tsMh7ijQYUgxe01Qhdu0YUzWtYk2Hl9cT-tw,910
-puya/_vendor/mypy/typeshed/stdlib/struct.pyi,sha256=VHGwv1FizhOZu9fTSpnMwTceXkTCrdEudLzoibejGas,1271
-puya/_vendor/mypy/typeshed/stdlib/subprocess.pyi,sha256=nkE5SeM2dK35Nd8VXPgO4BwH8dp961rTCvVz1R3vPvY,90836
+puya/_vendor/mypy/typeshed/stdlib/struct.pyi,sha256=N17y0Uih2VB6gZWV9Nx-xuuHUzyD8LfbB7LCRw7ZVw8,1271
+puya/_vendor/mypy/typeshed/stdlib/subprocess.pyi,sha256=SGklAaNa_5jYBsxQTk5HXUOBE-LE0Q4J_pZPkZ0Db5I,90809
 puya/_vendor/mypy/typeshed/stdlib/sunau.pyi,sha256=vlhIYEKS7WifFVYe5uWTeoBc7zs7s-UqpHXiIT_wfAI,2937
 puya/_vendor/mypy/typeshed/stdlib/symbol.pyi,sha256=CRvfBBbEX_MceSZhoywjffBS1OAafBtemHNP0KoXWVI,1467
 puya/_vendor/mypy/typeshed/stdlib/symtable.pyi,sha256=9BmoR0gA8_SAdFO4hHHnocciu8Hw57hjp7b4o_o1edQ,2146
-puya/_vendor/mypy/typeshed/stdlib/sys/__init__.pyi,sha256=7w1U1yuSpXML4NDTyIG-bXwo4u9QPuzWGGwf_AiXMI0,12333
-puya/_vendor/mypy/typeshed/stdlib/sys/_monitoring.pyi,sha256=zgBiUflpydFRQofaFoHH0ujgMOzVBA_D1Jh9lMbUgOU,1498
-puya/_vendor/mypy/typeshed/stdlib/sysconfig.pyi,sha256=pHNEtCguMV6zCyWMbh9zMM1wByHZkaWxsGAq7USR6TM,1370
-puya/_vendor/mypy/typeshed/stdlib/syslog.pyi,sha256=XkhbmyL419QtfcT_-Olad5tWqzm7sAB2qm7yfVXNOkQ,1344
+puya/_vendor/mypy/typeshed/stdlib/sys/__init__.pyi,sha256=mIl_z7dMO1R2_I7vy5r1PYr1e6xsdIdv0H5fMB3O-gc,12402
+puya/_vendor/mypy/typeshed/stdlib/sys/_monitoring.pyi,sha256=4rhFF9mcF8IHz72-jibcYwPy3DY93HjCMrz93wFEdks,1492
+puya/_vendor/mypy/typeshed/stdlib/sysconfig.pyi,sha256=QMN533jQaOpEoArNdkYmWBi3tGoLjJ7OTQHgYCR-guo,1569
+puya/_vendor/mypy/typeshed/stdlib/syslog.pyi,sha256=4NxqAhjiiQ_6ZHmFNYgDWlyIuREk__nGKTcCsq4YOt0,1347
 puya/_vendor/mypy/typeshed/stdlib/tabnanny.pyi,sha256=qBHW9MY44U92xKdFbYgrSXljglOVtAY0GYTa41BHwbE,514
-puya/_vendor/mypy/typeshed/stdlib/tarfile.pyi,sha256=tx_JNvtvI6IX9YJfyxOXxSPCV4E8KrZ4GrHtWDUvuEs,14143
+puya/_vendor/mypy/typeshed/stdlib/tarfile.pyi,sha256=kbSblKXUFSZ-65KnaCRAyEGTHieqUN4AsXB6keBuyE8,14357
 puya/_vendor/mypy/typeshed/stdlib/telnetlib.pyi,sha256=IbpWjfdDW68IFUdmgaL_OoGLGqIqGNbI2W1S1h_BAw0,2862
-puya/_vendor/mypy/typeshed/stdlib/tempfile.pyi,sha256=QDiJYV7iB3h3CU-oD_h72_E07sVXJjPWPjR7BteyI6E,16449
-puya/_vendor/mypy/typeshed/stdlib/termios.pyi,sha256=RpfOjQxx8lCfP6mODCZNsWnIs0eyVK7cnWdtF_79peM,5172
+puya/_vendor/mypy/typeshed/stdlib/tempfile.pyi,sha256=yfpvYNuhlW03DzitIlSwOd1B1CEjRdCUWqn9RaxSgO0,16453
+puya/_vendor/mypy/typeshed/stdlib/termios.pyi,sha256=A966eM9jB5ld9TSxj_6wjzNrafUiPFNU-DHHfLHRAqg,5168
 puya/_vendor/mypy/typeshed/stdlib/textwrap.pyi,sha256=6eEGWUkmDRU_-fA-aOIWWse9-1GIq8T89S4Vaf9aJ7Y,3233
 puya/_vendor/mypy/typeshed/stdlib/this.pyi,sha256=qeiwAiqbPK8iEcH4W--jUM_ickhZFNnx8cEvTqVPvCY,25
 puya/_vendor/mypy/typeshed/stdlib/threading.pyi,sha256=7bM6ruLJ15hnGE2htWH1tTuw98G5T9gAbhqDhJrFwzE,5932
-puya/_vendor/mypy/typeshed/stdlib/time.pyi,sha256=hf4yi9tEPhvjgpU0nWSHuH2cxD1tYvXTjrw8WCiKRLI,3681
+puya/_vendor/mypy/typeshed/stdlib/time.pyi,sha256=088e1qqXLRkvf-uSGnrHCUx6fPGaicqFsQKOVd7xU7Y,3682
 puya/_vendor/mypy/typeshed/stdlib/timeit.pyi,sha256=4yMgBR4T5Ame22l3SkRnXrq134Jivk3bJIclXNsp6lo,1240
-puya/_vendor/mypy/typeshed/stdlib/tkinter/__init__.pyi,sha256=t6NAyKKihQcOSu7XeZ0yhrSy0koqrswFTGEOpCDIBtY,137019
+puya/_vendor/mypy/typeshed/stdlib/tkinter/__init__.pyi,sha256=7xKLs7KNN7kh1uPsRy24Pu5G_VdaFPGZjudSPW5G3xo,137438
 puya/_vendor/mypy/typeshed/stdlib/tkinter/colorchooser.pyi,sha256=XEQaC9ihB5nJr6yGUmxGMZYct_9Vn0mXTncq59rtKOk,654
-puya/_vendor/mypy/typeshed/stdlib/tkinter/commondialog.pyi,sha256=AEiY_bOF0XKQNltMTeEao6OzvOkU2HRrBnJYwEw7gA8,436
+puya/_vendor/mypy/typeshed/stdlib/tkinter/commondialog.pyi,sha256=nC7AtrXvV3xWPwZRddK1EWjokn3KbNOfMoFsatMKdcE,398
 puya/_vendor/mypy/typeshed/stdlib/tkinter/constants.pyi,sha256=NspDokhZ5e8Elgxzj7Y1VWetXfBacVhhc_2Dpp3jHsU,1875
-puya/_vendor/mypy/typeshed/stdlib/tkinter/dialog.pyi,sha256=Zx4Lp6NNRdSdmQeu_rTE8RBmfyVmD8HIXrNmHoFxkuA,413
-puya/_vendor/mypy/typeshed/stdlib/tkinter/dnd.pyi,sha256=eAE7-0TTXcYbAoWp4GfHbvBEEIrFL6lODGarMsT2Vf4,787
+puya/_vendor/mypy/typeshed/stdlib/tkinter/dialog.pyi,sha256=3iCTtqSl2H_9Yl_rlyao4XsFcxou3NAG6HvEPNpdXlI,401
+puya/_vendor/mypy/typeshed/stdlib/tkinter/dnd.pyi,sha256=z-SJKqNGeZHZ0SHKEogaR4ml5X9z4AvvEFf4I_JxNNk,786
 puya/_vendor/mypy/typeshed/stdlib/tkinter/filedialog.pyi,sha256=gz1wn9aUyeyYlTFDpGO84TTKzscIb3Vatxo60IYvHtk,5203
-puya/_vendor/mypy/typeshed/stdlib/tkinter/font.pyi,sha256=2C5aCgAHRm0Jaur9e8GfNqH4N3PYkJZYw4swFKXQuTc,4342
+puya/_vendor/mypy/typeshed/stdlib/tkinter/font.pyi,sha256=Xd4VxCrtAEhksJRBa7heMxKQmua6sBiqNRJQcgouiWM,4344
 puya/_vendor/mypy/typeshed/stdlib/tkinter/messagebox.pyi,sha256=v-AB9-m9M1yTzZAV__Y_wDjNIbb2z_OS06STV0j5lsQ,1321
-puya/_vendor/mypy/typeshed/stdlib/tkinter/scrolledtext.pyi,sha256=hx0HadZ4WRUK6Vf4vh4kRnWJIAtgo3GO8EmfeSsHWcg,347
+puya/_vendor/mypy/typeshed/stdlib/tkinter/scrolledtext.pyi,sha256=Hp_LlFfwVwR3W4iDZKthreGUofPbIbiOkjl1O-HEL9o,302
 puya/_vendor/mypy/typeshed/stdlib/tkinter/simpledialog.pyi,sha256=ZZxYKT7uNQ7t1FJ4RqlXX5BCJg9Zcs93e3uFRqt-bSU,1596
 puya/_vendor/mypy/typeshed/stdlib/tkinter/tix.pyi,sha256=asW0L2aGs8LhYl2DP70ziEtQ_mA2kBPiDQoSPiw6GDw,14405
-puya/_vendor/mypy/typeshed/stdlib/tkinter/ttk.pyi,sha256=RgJUJe8SJYN_3qL_x7LU0-47noGNMJKbg39Xicu_498,45070
+puya/_vendor/mypy/typeshed/stdlib/tkinter/ttk.pyi,sha256=BGdjHA21Fywq4B5kVlWTCCamqCg73A8UiEuw7Crc1AI,45734
 puya/_vendor/mypy/typeshed/stdlib/token.pyi,sha256=qPgWdOOtujNEPmclCOUpolA-Aon6NEKguYPFr-1eoUg,2494
 puya/_vendor/mypy/typeshed/stdlib/tokenize.pyi,sha256=NDpI-Gxe_LqiqWJ334NXMRGoYx6bGQ1rfDNK6nYVg4A,4268
-puya/_vendor/mypy/typeshed/stdlib/tomllib.pyi,sha256=8PrxthyKN9Ki3Bz9XP0hCXwrXfvNInW_iwJQB6lKVvE,374
-puya/_vendor/mypy/typeshed/stdlib/trace.pyi,sha256=qcLFZ2YKGlLnANkfmadnYtvXak8Pa7nUw50Hm3mwdNw,3447
-puya/_vendor/mypy/typeshed/stdlib/traceback.pyi,sha256=mjvmtNBWjsMJ_QX4_sp0dS8OFKWan80u_e8KNEcVW88,8954
+puya/_vendor/mypy/typeshed/stdlib/tomllib.pyi,sha256=FOJyrFvYlPf90EyoFdkji3Lh_VtziArR-AvpZnGMEMw,376
+puya/_vendor/mypy/typeshed/stdlib/trace.pyi,sha256=fWIkIL4nDYiBSBHIf2zW_WoprKRF3sMBCxU4jBEC0UM,3448
+puya/_vendor/mypy/typeshed/stdlib/traceback.pyi,sha256=ZPSKR-KeUV1KBHY0457NGq1K0HqKaT0kTZSZUQtM0sw,9056
 puya/_vendor/mypy/typeshed/stdlib/tracemalloc.pyi,sha256=FXchj_ZEpT2Ft30krFJqmuDgbSyxiZaXnMjYT32S0VA,4575
 puya/_vendor/mypy/typeshed/stdlib/tty.pyi,sha256=G5Gf_9SNhZHaE7G-OIh9nIW1JCvZvsFxULlB8h1aSyk,822
 puya/_vendor/mypy/typeshed/stdlib/turtle.pyi,sha256=uvajDgOaJenIf4BTa2qVHYVJrmw6GaaENgCpeX1teB8,22749
-puya/_vendor/mypy/typeshed/stdlib/types.pyi,sha256=OvcjEMF9nz_5Ptuv5N2leEA2TrxbWq8xy92OuIqIQKI,20245
-puya/_vendor/mypy/typeshed/stdlib/typing.pyi,sha256=OdmKJ_JyUVABUtzy4jdO4jrMw9KYTwqfwfVBicMPfCg,33638
-puya/_vendor/mypy/typeshed/stdlib/typing_extensions.pyi,sha256=UajcAGhX_tkbuLlu2XTtGDiG7l036gZ_sfYcTzgEqaQ,15035
-puya/_vendor/mypy/typeshed/stdlib/unicodedata.pyi,sha256=6pa12lBhQlCwKoGf6NSyygRHckmzcg-EQOI89997f-k,2434
+puya/_vendor/mypy/typeshed/stdlib/types.pyi,sha256=OkjKaDksi3JwjAj8mS8gr8tvfU2HLOl3lzyv82LJAYA,20405
+puya/_vendor/mypy/typeshed/stdlib/typing.pyi,sha256=D4QWxOz9q13KyFYGRZ_Q9r9hOxokbBH-rTpU8W0STyg,33870
+puya/_vendor/mypy/typeshed/stdlib/typing_extensions.pyi,sha256=OKVq76McAtaQGf3EfJYrBu1vzBxUvr84F1xsnIMDRV4,15184
+puya/_vendor/mypy/typeshed/stdlib/unicodedata.pyi,sha256=A_3wfeMqI3QCM_mvWjD1SZKruAKveRlBf8YvrKqcn7k,2575
 puya/_vendor/mypy/typeshed/stdlib/unittest/__init__.pyi,sha256=tn8RPj7FOkT8aVjQD_wEgVf7JZWM7u-3ekUA7gJ5nWc,1813
 puya/_vendor/mypy/typeshed/stdlib/unittest/_log.pyi,sha256=QnmSKoFS_D1bcRLqFAvfJinXn2-0-DjyBSqH_92vr4g,912
-puya/_vendor/mypy/typeshed/stdlib/unittest/async_case.pyi,sha256=ktdNWzQiaKd6zj9rXwE2f07-2WqAE9IDvxUZtUjpUPM,737
-puya/_vendor/mypy/typeshed/stdlib/unittest/case.pyi,sha256=rfQfVXrPUikx6N2W-l4jHD-fVlPe_aBtEVp7yZDtq5Y,14659
+puya/_vendor/mypy/typeshed/stdlib/unittest/async_case.pyi,sha256=b7q3q2fNoU_7RWHK8mcY2WzeGsIBorIWv4ch6lAiPn0,738
+puya/_vendor/mypy/typeshed/stdlib/unittest/case.pyi,sha256=z-JfJ33-kfKXBuNfp820vGOId66flUqiz7KdTbG0zLs,14662
 puya/_vendor/mypy/typeshed/stdlib/unittest/loader.pyi,sha256=GuPlzX9ohHzv3OQuq9NdCoujlQ0AgaV362twfS3zJsA,2181
-puya/_vendor/mypy/typeshed/stdlib/unittest/main.pyi,sha256=gQbr78qopGorzAlAa-H5XsAU-TeZpuvEPOWsnzBbSDI,2429
-puya/_vendor/mypy/typeshed/stdlib/unittest/mock.pyi,sha256=an0SWItfRZZDW-rIpTLQeZAOEUiAv0-2hmbc5m2KUk0,14563
-puya/_vendor/mypy/typeshed/stdlib/unittest/result.pyi,sha256=GUMYu2LwjxIcwpiii1CLCW5FMGRLBGiS7LlctKdWBsw,2028
+puya/_vendor/mypy/typeshed/stdlib/unittest/main.pyi,sha256=Vmu0-GWGd5AWbTx__2ABWGtEaquHo8rwIGPjGvjtK1U,2430
+puya/_vendor/mypy/typeshed/stdlib/unittest/mock.pyi,sha256=RpkOUqoNEgI_gj-EadOnyCVLOK9ivbRf6VOCb3ZocBs,14562
+puya/_vendor/mypy/typeshed/stdlib/unittest/result.pyi,sha256=ORa6Ffa4LHszjLqees45oXYs6lw6NBDuZoCyxlGgzkA,2029
 puya/_vendor/mypy/typeshed/stdlib/unittest/runner.pyi,sha256=XLE_xkkMuHUIy0vn0c8F49xLVlJ0O-4hYJiNWhhXXkg,2506
 puya/_vendor/mypy/typeshed/stdlib/unittest/signals.pyi,sha256=6rqsVHXOvSPHSkeF_vYPf5sUaLgqqFSmFihkaDqPhSw,488
 puya/_vendor/mypy/typeshed/stdlib/unittest/suite.pyi,sha256=gu8_zNvsjXQSRvMSC7prG0RZCymHJMQx096BIPN91U4,983
 puya/_vendor/mypy/typeshed/stdlib/unittest/util.pyi,sha256=p3Dvc-Nr4gIqCsZRVJDrqGGo0C-jyP5OqdU0sSNbF1k,1009
 puya/_vendor/mypy/typeshed/stdlib/urllib/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/typeshed/stdlib/urllib/error.pyi,sha256=I-uhiBMZN9tuYrjeZWczbBT5Mwe7X-Eupqf74_4eXgo,816
 puya/_vendor/mypy/typeshed/stdlib/urllib/parse.pyi,sha256=fCRrgWFd0u93DV9iPTo0HxvhGoKHbi1zG-M4M6ALEs8,6532
-puya/_vendor/mypy/typeshed/stdlib/urllib/request.pyi,sha256=d8h3_E4bm6kzPQ88asteom20Oy-fhvtYy2Ob4e7zaZI,18000
+puya/_vendor/mypy/typeshed/stdlib/urllib/request.pyi,sha256=RA8fYOqKY2y6qHCaHAeBzHJqmLpSMVWSMff47nfkv7U,18009
 puya/_vendor/mypy/typeshed/stdlib/urllib/response.pyi,sha256=h9tp8P36JESKrg5ewOXt-0GbD5AhxU9hdkKLE1WXjcY,1635
 puya/_vendor/mypy/typeshed/stdlib/urllib/robotparser.pyi,sha256=sA7npNj2rB3b_aFOhXqGlQNh-G7kGmyYaZ3wz__N96o,683
 puya/_vendor/mypy/typeshed/stdlib/uu.pyi,sha256=yMt5ZRAepWSra-qWti133ZGibCtrJXkMZg5kKJe-MdM,431
 puya/_vendor/mypy/typeshed/stdlib/uuid.pyi,sha256=smrMATi22fL4z2QrQojy39wROuBVzYMFFSRzHtLu1Q0,2677
 puya/_vendor/mypy/typeshed/stdlib/venv/__init__.pyi,sha256=aKgJDxdGYcVUVH-VkdZhcKW21JVBYL_6Rgal_6PN2qs,2665
 puya/_vendor/mypy/typeshed/stdlib/warnings.pyi,sha256=hVhJHgMWcoR9OjOFijaRA_QJzhuv7mVxxGcqyTlpkoQ,3682
 puya/_vendor/mypy/typeshed/stdlib/wave.pyi,sha256=9RSWcERVmNiKfWcHYSHZfnHuTUGc6GRZc53e-AuNFDc,3240
-puya/_vendor/mypy/typeshed/stdlib/weakref.pyi,sha256=NBSMtC7TvRZSI7Z0G7_JJvoH37oGCIazTA7kIEXrV1s,6424
+puya/_vendor/mypy/typeshed/stdlib/weakref.pyi,sha256=Dtyb0Wm2U91031lTcwygXCk23xzZqdrK5qCPA1ljrHo,6350
 puya/_vendor/mypy/typeshed/stdlib/webbrowser.pyi,sha256=-H3s9k5TsMxgZ7CIVHhJUYbXTpy7NEapWkW6z7ODrXc,2563
-puya/_vendor/mypy/typeshed/stdlib/winreg.pyi,sha256=S4f9rDwbgknFI5f5i-Bltri0GBXbEMa7kTesu2hAcC8,4439
+puya/_vendor/mypy/typeshed/stdlib/winreg.pyi,sha256=yR8Wvj1Te7QMMQllxLgqNQuo2NkUnzniQhWWrroIBCM,5494
 puya/_vendor/mypy/typeshed/stdlib/winsound.pyi,sha256=psbIikYmhTj3gBrDO6CwHCJMk7hU6rqw94lmO2jwzgQ,956
 puya/_vendor/mypy/typeshed/stdlib/wsgiref/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/typeshed/stdlib/wsgiref/handlers.pyi,sha256=d4qMJ3ZNLNAnDk1I___l8nIUK9uxDol-bXsjtc9BsX0,3068
 puya/_vendor/mypy/typeshed/stdlib/wsgiref/headers.pyi,sha256=rw-QVHeN939ReRhzZTvPABuQQo4L5k35EYsBS2uU2yE,1036
 puya/_vendor/mypy/typeshed/stdlib/wsgiref/simple_server.pyi,sha256=-nQD3wVKCs_VDpTeehZ8CdKILXm0Hec0ZeGRdCSZJjs,1398
-puya/_vendor/mypy/typeshed/stdlib/wsgiref/types.pyi,sha256=OXMbejbY89BqvXfn1yTqD7iBLERExvXclEi5v0a5xU0,1258
+puya/_vendor/mypy/typeshed/stdlib/wsgiref/types.pyi,sha256=JoF2V6xRGOCwjFxs2Mt51_up-GV5HBK0OGrf2F9xaU0,1260
 puya/_vendor/mypy/typeshed/stdlib/wsgiref/util.pyi,sha256=OaPZRbiITLo8QbXqiW5tRJtzXNM5fQbaRyyUPOCxZaQ,995
 puya/_vendor/mypy/typeshed/stdlib/wsgiref/validate.pyi,sha256=NCpbRPP9fTt21peGNlXLgegq6U1yZaeAxFO-SUfBlng,1737
 puya/_vendor/mypy/typeshed/stdlib/xdrlib.pyi,sha256=wxJVHCfO5rju29ihBF96XgK3dj5b-LbsVGeotGgp15k,2368
 puya/_vendor/mypy/typeshed/stdlib/xml/__init__.pyi,sha256=1v5PXkWd1I909FrHSGV42z-AW-79lZBHfSIrbB3DeW8,35
 puya/_vendor/mypy/typeshed/stdlib/xml/dom/NodeFilter.pyi,sha256=bi0L5SEOxk4FyEhf18oU-I8Msf9S9o_tJt-mVc93f28,457
 puya/_vendor/mypy/typeshed/stdlib/xml/dom/__init__.pyi,sha256=p3WpjR2_q3xdrf0_xp5vsEdiZkhXQRAB9Mw_wad4OYk,1889
 puya/_vendor/mypy/typeshed/stdlib/xml/dom/domreg.pyi,sha256=LNRgIl78O0eH3m7E5GFqG0BKQ0JSsHxTBnwr5KznZvI,418
 puya/_vendor/mypy/typeshed/stdlib/xml/dom/expatbuilder.pyi,sha256=vJRZwYGT5ufRjNqAqi7VvhjU1Hewx1bL1eQjVoAUN5I,4847
 puya/_vendor/mypy/typeshed/stdlib/xml/dom/minicompat.pyi,sha256=B05TSy1z80NZh65yaIc5jNc-QS4E2u2p2LYXcs-4TFE,678
-puya/_vendor/mypy/typeshed/stdlib/xml/dom/minidom.pyi,sha256=sXvp_RFdO22LmUB0XhDRrZdxgandAHvbwot05yhu59k,15038
+puya/_vendor/mypy/typeshed/stdlib/xml/dom/minidom.pyi,sha256=JfHDStOoZ-8z6sLZ6PMY0SKBr9kflCI-M_crbd8aQRU,15066
 puya/_vendor/mypy/typeshed/stdlib/xml/dom/pulldom.pyi,sha256=uEH_glzOjuIDiltMReXeVEXb1JWJz7FxxOT5IOlWzZ0,3453
-puya/_vendor/mypy/typeshed/stdlib/xml/dom/xmlbuilder.pyi,sha256=RUGkjrzB_QjDmJ2wY7GV3w7izhoOY5yvQ9J2aVzEzkY,4206
+puya/_vendor/mypy/typeshed/stdlib/xml/dom/xmlbuilder.pyi,sha256=ICk5n87SjKJiEj2eYfmJUa6DZ4ys0krprrEpTqocu-U,4199
 puya/_vendor/mypy/typeshed/stdlib/xml/etree/ElementInclude.pyi,sha256=j-auBTW6n_Ady1Ikya3Epum8Uq3AvJ3gejRakI2jd2g,983
 puya/_vendor/mypy/typeshed/stdlib/xml/etree/ElementPath.pyi,sha256=lcIxOcA8hTuptcicWV6vDioMDPK0fG3AryHTitElC34,1636
-puya/_vendor/mypy/typeshed/stdlib/xml/etree/ElementTree.pyi,sha256=ZySrw6JchWx-i_4cPWV-sZ5MKTvDN8NZ6y4Yk3aZKsY,12341
+puya/_vendor/mypy/typeshed/stdlib/xml/etree/ElementTree.pyi,sha256=tYvtPP_JLdHC5WumoP6t5wogylmx2OoU5BFTXtgVsfo,12618
 puya/_vendor/mypy/typeshed/stdlib/xml/etree/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/typeshed/stdlib/xml/etree/cElementTree.pyi,sha256=iYR7ebpdB3g9zfBvICnV1VzvQktMya-Dh6lX4C9u4Uo,36
 puya/_vendor/mypy/typeshed/stdlib/xml/parsers/__init__.pyi,sha256=PS75lzF6CFuo_xdO83zK-IOQrnoJQ3FkUoMSOMdwWJM,39
 puya/_vendor/mypy/typeshed/stdlib/xml/parsers/expat/__init__.pyi,sha256=qmz8tuPGbZ2rBfRrfYANxDZNxn9BTQXdd9AugF5wDW0,22
 puya/_vendor/mypy/typeshed/stdlib/xml/parsers/expat/errors.pyi,sha256=mH9YRZuV4quzksDMLEmxiisAFgNhMOhl8p07ZzlS2XE,29
 puya/_vendor/mypy/typeshed/stdlib/xml/parsers/expat/model.pyi,sha256=M7GVdd-AxOh6oGw6zfONEATLMsxAIYW2y9kROXnn-Zg,28
 puya/_vendor/mypy/typeshed/stdlib/xml/sax/__init__.pyi,sha256=fFuGtgf6FfI7X4piOK9Iavkk92E9JGRuBJp_MKrNQpY,1148
 puya/_vendor/mypy/typeshed/stdlib/xml/sax/_exceptions.pyi,sha256=2A6XuBvZ07OwdVacWxFnF-8Zti1t80TTgNr_XVLkbAA,755
 puya/_vendor/mypy/typeshed/stdlib/xml/sax/handler.pyi,sha256=GuQLgUMdQLYcE6D56o2ZebeNEz9Q2g6JC65S8_Yccxk,2102
 puya/_vendor/mypy/typeshed/stdlib/xml/sax/saxutils.pyi,sha256=0-Gjsyr9HO5EjRAwimx6JF7EdEJvl0ImmDJWNbe3xNg,3187
 puya/_vendor/mypy/typeshed/stdlib/xml/sax/xmlreader.pyi,sha256=554M5Je2Xz7RfhXI2zWq2dAaW_Ju1WpzBIDM0Hdck1I,3829
 puya/_vendor/mypy/typeshed/stdlib/xmlrpc/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/_vendor/mypy/typeshed/stdlib/xmlrpc/client.pyi,sha256=oxyyF529GN16KdHAyY6zEctcllnpBEFWgfpyQ9Ksl3s,11757
-puya/_vendor/mypy/typeshed/stdlib/xmlrpc/server.pyi,sha256=-EeIIcQM0Vho-4uKelSAr3pTdn8LJdoXy2xKpvPxdEI,6073
-puya/_vendor/mypy/typeshed/stdlib/xxlimited.pyi,sha256=aZ7ZC93XyfGZHjFPh3Bd76x08Sp1-8JuFaJBUO5Tr58,423
+puya/_vendor/mypy/typeshed/stdlib/xmlrpc/server.pyi,sha256=c65GmhV0aoxPVK_QWsTRhe3bpvCDeEFejjeZJYk_imo,6065
+puya/_vendor/mypy/typeshed/stdlib/xxlimited.pyi,sha256=A44Xm-SODWh0RKbLbM9IOi_VTEm08pK4i945FH_MkF4,423
 puya/_vendor/mypy/typeshed/stdlib/zipapp.pyi,sha256=gOkFhcdfGpy6PIboXe45wODMw-94YtC1ypUTCxBxTfU,553
-puya/_vendor/mypy/typeshed/stdlib/zipfile/__init__.pyi,sha256=Bzy4ktbnKmF2cq3FJ39QVOLcYssgWtdk_JjO35DucyY,10208
+puya/_vendor/mypy/typeshed/stdlib/zipfile/__init__.pyi,sha256=0TGnjgGCT_lzFng36T6XuCTcEFM8ahL7BOLE0dqkcbI,10211
 puya/_vendor/mypy/typeshed/stdlib/zipfile/_path.pyi,sha256=APwEPcvvOl6X1DOedOdpFAqAmzbn8PxLWG0ir091XpE,3640
 puya/_vendor/mypy/typeshed/stdlib/zipimport.pyi,sha256=GugZHeBRMCTQfmg8B-RYb-uDwQepHRv54ESWV3aNq7A,1349
-puya/_vendor/mypy/typeshed/stdlib/zlib.pyi,sha256=QBDHGPCDo97piAiWyd5klk_Yw-nCNi8HJ0zhE6d-9Bs,1776
-puya/_vendor/mypy/typeshed/stdlib/zoneinfo/__init__.pyi,sha256=x2bw7ohsupcJs7XMiVmzzHGi-u6N3Oo6ANbaqLe5X0k,1513
+puya/_vendor/mypy/typeshed/stdlib/zlib.pyi,sha256=wdlBAJUOtWhsTeqD7pVI2MPLPEUmMnat0FUyUlag0ys,1777
+puya/_vendor/mypy/typeshed/stdlib/zoneinfo/__init__.pyi,sha256=Kbhl8PaWFhILmzFcwEoI-9GjLBLfu0wXmgYkMR_tUdk,1517
 puya/_vendor/mypy/typeshed/stubs/mypy-extensions/@tests/stubtest_allowlist.txt,sha256=jT8xDbE1vAhW9Y0KaiNja491VRh702fHXy15pLaTdoU,56
 puya/_vendor/mypy/typeshed/stubs/mypy-extensions/METADATA.toml,sha256=am-pxmLmJVYq3_8hg7MiQYW4gYseVn4_lkNHjX5LdoM,63
 puya/_vendor/mypy/typeshed/stubs/mypy-extensions/mypy_extensions.pyi,sha256=M00bMpf1XZOilHhHPjPrdRK7a9qw35DqOWh0PeT8aj4,8892
 puya/_vendor/mypy/typestate.py,sha256=AbF6d2nYuRCuCHsOwqD9YxFFzcXiWvr4w_rnt_pPSf0,15736
-puya/_vendor/mypy/typetraverser.py,sha256=Xop8Bz5c24h0TQyELACQaM36rMxzGf6qiQ2D4J8nAYw,3724
+puya/_vendor/mypy/typetraverser.py,sha256=t74hZCUEOtocpe7aA5siaZ3obocEhocw-H-yRwlK0Os,3924
 puya/_vendor/mypy/typevars.py,sha256=aIfesQc_pmLgowMahV-UXEQxxORDN-3SuzRUImz6Gag,3297
 puya/_vendor/mypy/typevartuples.py,sha256=QrMYuC5rXX0REGpHs4QK0o64jSfoBUU-P00SDQzw058,901
-puya/_vendor/mypy/util.py,sha256=SlDEm6-c7SmIlOeBHcje8swCBnBYITn9yT3_ffAwPfY,30284
-puya/_vendor/mypy/version.py,sha256=3aHpPevwaUW7vGzn1dp53zL0MtYFBzsCsRUUMASEwk8,594
+puya/_vendor/mypy/util.py,sha256=EoNhXRPSvG9T8ELK4JST0IGSEQiJ6D8rlU9CRyZ-fTo,30250
+puya/_vendor/mypy/version.py,sha256=zQlJfxCUhtQqlRDnmZf1pExIiRuTnsFjOOLQ-q2syh0,595
 puya/_vendor/mypy/visitor.py,sha256=FTsBCo74V8F_Q_uId10wvORCQ8rexQjuQuUWhK21XdU,15882
 puya/_vendor/mypy/xml/mypy-html.css,sha256=-e3IQLmSIuw_RVP8BzyIIsgGg-eOsefWawOg2b3H2KY,1409
 puya/_vendor/mypy/xml/mypy-html.xslt,sha256=19QUoO3-8HArENuzA1n5sgTiIuUHQEl1YuFy9pJCd3M,3824
 puya/_vendor/mypy/xml/mypy-txt.xslt,sha256=r94I7UBJQRb-QVytQdPlpRVi4R1AZ49vgf1HN-DPp4k,4686
 puya/_vendor/mypy/xml/mypy.xsd,sha256=RQw6a6mG9eTaXDT5p2xxLX8rRhfDUyCMCeyDrmLIhdE,2173
 puya/algo_constants.py,sha256=WB8dnfzCGgoe97Mb4-PmxVpx5ZR5YU2j1ym_zgme-e8,661
 puya/arc32.py,sha256=rDmb-kONyl6NqBunWvMbpS8GOVgGjpUdCrgK392XQ8M,10673
-puya/arc4_util.py,sha256=82-9jY4Yidb0jmHNB-I3qU6JgKqpmYxiaYVPZZnjX_Q,6325
+puya/arc4_util.py,sha256=TOqhwbSse7c0kAqSZEw2Ywb0Zn9Yr5hHTKYG_zHcIUg,7435
 puya/avm_type.py,sha256=GYOJ4ncoNKBHtc26mvh9Plxpz_f_pd3dUmw_uRzD17M,127
 puya/awst/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-puya/awst/function_traverser.py,sha256=IjOeEKX-jSpmceEvNCNAQ7Y8NhcPPDv4lIb-fPrWgRY,9831
-puya/awst/nodes.py,sha256=MNW7mhr_tt0aUaJ3kRvptRD0uDGEfm9-6In7-OIIEZE,54659
-puya/awst/to_code_visitor.py,sha256=syFPjlIoAA0-g_uUwXSaxFa-s60Mz2AAFfVKb-H9QU8,22234
-puya/awst/visitors.py,sha256=ZzQzaX6LFuRjnAG_jmtzCdBevGHBzSu3R0lZYUNgRJ4,8928
-puya/awst/wtypes.py,sha256=oZQ4qrXNwLYGCSne6o6tzzzBAKkxgaGRcjE_1BkHuJU,18374
+puya/awst/function_traverser.py,sha256=upsoQASI2Ib65YyS1uDHd6u0euIy4n7EwAx0HQqQcdw,9829
+puya/awst/nodes.py,sha256=FaCajXcRIntl2HvChwZBKJFjUCon0mekZSiR2SYWIok,55887
+puya/awst/to_code_visitor.py,sha256=XDksH5XUyceGRUDjJ6yudy_Gy8qKijZOoqjsZ3p6n5k,21981
+puya/awst/visitors.py,sha256=5bnxz2Tr3Wp11XSMswu5JvGBUsdNyF3FuL7WeQvwsNs,8282
+puya/awst/wtypes.py,sha256=-f3syHZNV0wGnd2Ecbd2ypVA4VunHAyR02-a_-EvQSM,17861
 puya/awst_build/README.md,sha256=fnCFui_VhpyuhOvxk4d_CgLByB3xpInzAQ-V8a07gm0,1211
 puya/awst_build/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-puya/awst_build/arc4_utils.py,sha256=MYhW6oSlMEg46RXXYiUAX-uUeblCx1rnF0TRA8fsi4M,13207
-puya/awst_build/base_mypy_visitor.py,sha256=Ky_livMp9sn47WvehCqXWPquHc7J3P8y2yHDLSPC6bM,12168
-puya/awst_build/constants.py,sha256=7dOT0AGdl_D4mQYMQERRe3z76-dvCE0l8pz_2kaiAQk,5444
-puya/awst_build/context.py,sha256=Rddvx98u_M6yCDSngpvmbqtfOFBTfApc4yl5YgYIfa8,9500
-puya/awst_build/contract.py,sha256=LL2toobSCRl7VAVDcYS76-fjRbPFowPY02L0VkMUeps,22165
+puya/awst_build/arc4_utils.py,sha256=hwoUCbiF7SaOGZqzEWKh0wexF-kLr-cFRubVXuxKmqg,13210
+puya/awst_build/base_mypy_visitor.py,sha256=OtN9u7tjjAa9SIwDTiZAf4K0sTChIZZQeZFvxwp3I8s,12152
+puya/awst_build/constants.py,sha256=O0Vo2N8VNGq6YPWwUPP19vm6WncGeWRRzxN-iEungVk,5442
+puya/awst_build/context.py,sha256=xIsPe5Uof5LHOWA6yBQmjtMkttjNIB22okczEdeiVLI,9138
+puya/awst_build/contract.py,sha256=flhxLpZKTRD1o2vkuntfMOajVlWghu73O0to4PjDRZk,22200
 puya/awst_build/contract_data.py,sha256=ymnrATbU0Sr2Z6bBxPwlgUPO2iB8UnzogKKFt-7EC-A,667
 puya/awst_build/eb/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/awst_build/eb/_utils.py,sha256=g4xbA_RffHLihcCaqUfBySejqqgJKA3b7PjyWry2Ap0,1099
 puya/awst_build/eb/app_account_state.py,sha256=AVu31FtTwOHBBAlL-P-uLksTdlj1_p9K4r1Yz7NTHSQ,9182
-puya/awst_build/eb/app_state.py,sha256=TG0M4sV84ICYwjR91uh8zjRCMk5YQRIALb2T-JO862I,8089
+puya/awst_build/eb/app_state.py,sha256=6IEeIRje6Oq0DQHz_hRx_Ad0F8ewHQgdtFgX2Qds9wI,8336
 puya/awst_build/eb/arc4/__init__.py,sha256=yK4EcINrGeVLb1YNSjAQ8-H1ZuPg0Lz-CY9J_IpTbj8,429
-puya/awst_build/eb/arc4/_utils.py,sha256=00p4hW7JNVZbzWwOMNYXKzzYCnJZqVZbwR_VnWsBD7Q,10630
-puya/awst_build/eb/arc4/abi_call.py,sha256=Ltqc7Zn78cOA97-a-8w2KNweGe_qXEUOVAVkPaiodgY,13048
-puya/awst_build/eb/arc4/arrays.py,sha256=_8f6r6Niy6jrEFYB0NBy2Pxg6rIELg8tSMHZgKO-oQQ,22133
-puya/awst_build/eb/arc4/base.py,sha256=PQiSbHbdDDIqS9-a97F_eloySj6qMI9YGzWesRR1zOQ,8003
-puya/awst_build/eb/arc4/bool.py,sha256=cB6BE_qsFkAXPmMutre__s-udyrJnS9dbnJmmWil0hQ,1955
-puya/awst_build/eb/arc4/dynamic_bytes.py,sha256=wea_TrO_WMjp3wTOsPPtDRepFk1aO6hCfSG-Pb_yTq0,2745
-puya/awst_build/eb/arc4/emit.py,sha256=LLzlF6w_WgtYzOdnn7Q-RslEzRM5C5ZSq5u-0k-TdJE,2459
-puya/awst_build/eb/arc4/numeric.py,sha256=KywCQqz4Pye0BLjeun17cg2j4GTDU-ueD7D-S0XmTwY,8437
+puya/awst_build/eb/arc4/_utils.py,sha256=AyP86HCZqUFO4XoNuNsDlDsjQO-Ih3oEuVA_dM16ePQ,10375
+puya/awst_build/eb/arc4/abi_call.py,sha256=0_-GUvbcUqQQWNLrmM0_S8WCVangvGIEet_tzhi_PGY,13733
+puya/awst_build/eb/arc4/arrays.py,sha256=79v6wferWm5AYYeAWzNkLAnHcuY6onEPn_n6vTxYUEs,21741
+puya/awst_build/eb/arc4/base.py,sha256=W0Es0sAfcRqI2e4aJmcXIfNNfB6BjmKR-HjpCPciRMU,7079
+puya/awst_build/eb/arc4/bool.py,sha256=fSneZO-i_FPLGrS85bdSe7GPw1IahZwi4_vX3qD5dZ0,1958
+puya/awst_build/eb/arc4/dynamic_bytes.py,sha256=6NP4MGFvWJRaaxWkTxumuaOqjeZD_LxTp1kPRt7J1ks,2856
+puya/awst_build/eb/arc4/emit.py,sha256=hfquNLic0DiqIeFujEXeGOlNG1nGUEkGSRwg1PbxJkA,2267
+puya/awst_build/eb/arc4/numeric.py,sha256=lGXAB-iMtQ4J44M-acsjhsmZVtyBV9H94w-ctSlsfeU,8276
 puya/awst_build/eb/arc4/string.py,sha256=LFu6lNflBqfJw4cCMEVZSQ2zxbLJxMa9bkHLKa5Nmr0,5591
-puya/awst_build/eb/arc4/struct.py,sha256=Y1Ui7F0NvaCsmuoJxHhZtwklAhlKhrhr3nSKXOUMwgU,4077
-puya/awst_build/eb/arc4/tuple.py,sha256=ISh1qcX1FENfiP3Df7t3tj_vL__mBkDuykvmD-lGvlE,6091
-puya/awst_build/eb/array.py,sha256=ginkmS1NVbTfnd3TfWGl7mOvJG3gpfC18_EXt_LY1Lg,4446
-puya/awst_build/eb/base.py,sha256=ta9GYnrlIIjg3_eMEI39_MdshyYS3ONC8BPZypVk2Lg,14959
-puya/awst_build/eb/biguint.py,sha256=QuoHu5_pAdp3UDtQuKPFcHD_M3EyYjWcRQmFcLTlFgI,6518
+puya/awst_build/eb/arc4/struct.py,sha256=GPNp1Rr9mCC9yjy0gzgU4kjwhTN4_W6SwSPERcWwSp0,3832
+puya/awst_build/eb/arc4/tuple.py,sha256=iUh2tw3pes-g9bLdk-GdwaE6ZoMb-jW6745RZgpSZo4,4583
+puya/awst_build/eb/array.py,sha256=kFdv86uLAX3E2XLX7woJ_6lmAVBkOujZPPiHcNNtfWs,4444
+puya/awst_build/eb/base.py,sha256=9XW3Yhe9uV5SX5C6hHK7XhmFHXFliUPxsdQd8Mcd8Ws,15064
+puya/awst_build/eb/biguint.py,sha256=ehjECkeBUwve3IS3mnBV-7yjFNhuGw-fMgtEbGhe6Zo,6237
 puya/awst_build/eb/bool.py,sha256=2vvASBsuSzx9gvaFvyk7mc6AIrUMHAkceo4yw6EgzKo,2267
-puya/awst_build/eb/bytes.py,sha256=TR1EbBXGZZqNyObonjXgNuYVrGqEEICHtNfwACfRPl8,12068
+puya/awst_build/eb/bytes.py,sha256=FEkbFptkkq0eTmegF2E6RrINys3kH3xIdOstaJIB17c,12185
 puya/awst_build/eb/bytes_backed.py,sha256=A4o1btidSS0zrk0tnVrMqZwTdQFBlLc33Ojp_FvEAbE,1974
 puya/awst_build/eb/contracts.py,sha256=eUKm8ekMMm1Q1ffATlNroLLe8cQf9ZrDnqTjn7Lyw7k,3239
-puya/awst_build/eb/ensure_budget.py,sha256=vVjTRKCMC0NIV6ocMNhsD61FMvoP982X9S6RoFwGvLk,3442
-puya/awst_build/eb/intrinsics.py,sha256=FvGuFI3jAkGTBltf4Q5xFc3gaq2BAlbQhs0teG7rle4,11829
-puya/awst_build/eb/log.py,sha256=SmmI4tGxPEOfEjB6fVXC8irzCiqAgGdmI5dQTik0YBs,3640
+puya/awst_build/eb/ensure_budget.py,sha256=8v72QWDjeYtAPg6Q0rZZMYf9NU8JLbM_11CN6lWIo5s,3442
+puya/awst_build/eb/intrinsics.py,sha256=9IG2zW8nD5ahVzPnbMZQRRNvtUlDcj8memCniR1JD2Y,9453
+puya/awst_build/eb/log.py,sha256=QtFcZNVDVxg0h9tJK0IX_23es_mTQKAuh6nLef1bxt8,3521
 puya/awst_build/eb/named_int_constants.py,sha256=9te_ynj5ltVKX97KCxmVNdLKuqIu1It40YqMvHvixMk,1128
 puya/awst_build/eb/reference_types/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-puya/awst_build/eb/reference_types/account.py,sha256=AtJUnvUSi6skTn4bWVGWMCC4-LUIcdPvNe5aBUzaVMA,7489
-puya/awst_build/eb/reference_types/application.py,sha256=4Z2BKJAD--iVeLfHmSs4Jmexc7_Endqn1Oa0xCdJ-YM,2482
-puya/awst_build/eb/reference_types/asset.py,sha256=oQRU7RrrE6ViDowTsfgtC0q8wbGm5tmQaLlczoUvJs0,4426
+puya/awst_build/eb/reference_types/account.py,sha256=jyE2YZYUsZDEwmNG8p-N-SwdwaqNF0Ec_1POu-Umv5Q,7556
+puya/awst_build/eb/reference_types/application.py,sha256=3lSffkDmAVMl-BEhSW2500SLdQFgNXjDkhaG-MrFUDI,2638
+puya/awst_build/eb/reference_types/asset.py,sha256=Wi6nDKmWo_sSfpnBbZ97v9Xib33yk0-D5gr053TVXUU,4575
 puya/awst_build/eb/reference_types/base.py,sha256=7CGAzFy0cWX_JHF-1R59DkPhrDiVOP_czYI4FPutBLk,3237
-puya/awst_build/eb/string.py,sha256=Acpe0Bppg0OxVAMTBbd70YjyeDtEJGY6o7awJv4T4nY,9403
-puya/awst_build/eb/struct.py,sha256=sCSGqijrwJTxjpRRbzCBr7U665pSsO9ud17iaDYWYMM,2020
+puya/awst_build/eb/string.py,sha256=lXOmi-CcoVIYk8m3SNlNvAg8iBAPO929f3avkkG6dSg,9618
+puya/awst_build/eb/struct.py,sha256=cwuWosas9zl_Cn0OFkXHh3LMPV1GfMBVvDAxfnQr8lY,1586
 puya/awst_build/eb/subroutine.py,sha256=So2vN5uKRj8vVLgZTe7O-5yCj5eMtClmureB1SwyGuQ,4078
 puya/awst_build/eb/template_variables.py,sha256=66JGSGu7bipGDndg-vrz-No7g-Hlj57uFlXEeCpqRfc,2963
 puya/awst_build/eb/transaction/__init__.py,sha256=PmG5aQT08Mtjg45qfJeoQyMHqx8oCaosD5xPf3vSJuM,934
-puya/awst_build/eb/transaction/base.py,sha256=SFZZl0qQb9aM0qjnnKAG39XIYKgBqNArv9vSX8splUc,1746
+puya/awst_build/eb/transaction/base.py,sha256=GQNbNHwM_LBG4BRz5FQPDKh-uZoXOJKRkoQzSc4_Vig,1730
 puya/awst_build/eb/transaction/fields.py,sha256=7NKc8riGSgJESb4Ei20Ob0jwCZssgk0cKPsVYhANOco,1360
 puya/awst_build/eb/transaction/group.py,sha256=Hq6zTK_ZrrfVOkDXrRYd6ZykUPgDLUNuZYIA4EQ_eQI,5282
 puya/awst_build/eb/transaction/inner.py,sha256=jPBo356NwPh9zh7XzEjURaZxfpcEX-uM9UWvF5uVw8A,4833
-puya/awst_build/eb/transaction/inner_params.py,sha256=wTX6mSl0ZbmDzdCtSRDDeKFUuJ22lLtb-I6bsRgDpag,7768
-puya/awst_build/eb/tuple.py,sha256=6iad1MTHgAXj6jGaTDwG59SpLqt_gKmglxSuW9ckd24,7634
-puya/awst_build/eb/type_registry.py,sha256=NhmtrksNRFGqfg28BgK17FvB9uiuiU1ZtviNpOjkL0I,6998
-puya/awst_build/eb/uint64.py,sha256=1s_rgbh5efqSX9evvZay3R7ALCyVrGT5YFFDUmvbvRs,5806
+puya/awst_build/eb/transaction/inner_params.py,sha256=BuT4SlmjbgTOnjHYC1cJSUwV7oYqxMj6MInvJU5zj4I,7915
+puya/awst_build/eb/tuple.py,sha256=xbpksmLZIzGV3GMCL0KSyX4L5_dxY_kyheS_mvyEXlc,7696
+puya/awst_build/eb/type_registry.py,sha256=c_YVp2vTrXBGss_SHmuGpj1OrI0t5gueRnpg4-1tTUY,7019
+puya/awst_build/eb/uint64.py,sha256=7wIgKjyRShy1eAk-Zx2lSpDnOCZRbhbDKjKxlEbBj1E,5527
 puya/awst_build/eb/unsigned_builtins.py,sha256=IDuy4D_7bcIfNhMeRuzhJH_JAFXBMJ83vsbdD9MZQBg,4633
 puya/awst_build/eb/value_proxy.py,sha256=DcXDc3VOHjcpn-YTRMf1R6MmemdoS9SiCW2DinEmYwg,3103
 puya/awst_build/eb/var_factory.py,sha256=_QoPIAB2OLShFoyFReNQ9kVvh523c73u1yn9gwSC9-Y,250
 puya/awst_build/eb/void.py,sha256=2ollYCuzbkc19tY2fFNDNm0Pxo-ns5Q_n2WyoI0xayc,602
 puya/awst_build/exceptions.py,sha256=u9uJr9MfFLZQF6hgSIdAbsRV4awvrRJCYpkQv7MUECA,447
-puya/awst_build/intrinsic_data.py,sha256=Ad52BE6NBMsgfofa3R1a27VExmhFp9lbuu2GSQg7pmE,296370
+puya/awst_build/intrinsic_data.py,sha256=Y6SRxA4QjMlQgWgBsdZqBPIU1tDUdA_h6VMesZtzIUY,281089
 puya/awst_build/intrinsic_factory.py,sha256=8h1VAt2mHYoSFHCnU8580PGF80SYKdWx5Z4F0pxWaNw,3576
-puya/awst_build/intrinsic_models.py,sha256=fwGWBLJKiRnrJa45HOAAnuVWdwhjKDVJfVYyOoVG6B0,1585
+puya/awst_build/intrinsic_models.py,sha256=CNY8UF75aegMAuilyLpT0_r3nPHDenpUMJmZy3W8yI4,1671
 puya/awst_build/main.py,sha256=OpHyrq8LFb_y6HcDgRvAtcibtvGGQfOIuLtplXRIC6U,2821
-puya/awst_build/module.py,sha256=ktEIE4SZu-O0ZizIZ8lJn08UtZ5XEdkyyKWG40EoBEc,32183
-puya/awst_build/subroutine.py,sha256=j57Spvxhw2_J5aKKh26FGYCgbyfjPvopKJbcBN4HdeY,55861
-puya/awst_build/utils.py,sha256=Fl4sV3nsWNwYWiLqq0P60FBtKelKycgFmjIGJJcunMg,11148
+puya/awst_build/module.py,sha256=-ob67l1Tf0G09KWQ7i5kgggMdlhXk53KiXYOJfr8eiM,32231
+puya/awst_build/subroutine.py,sha256=Pi_edAruLd4FvZP_eOxbwsOzDFAYN5Gq1V-uYX8u4i8,55795
+puya/awst_build/utils.py,sha256=boZGzabfYKSNWu3BGmjC435VCpY93KkVDkdQx87oYhs,11343
 puya/awst_build/validation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-puya/awst_build/validation/arc4_copy.py,sha256=4HwWcBWAgSQRTtBc4LGd0OBRvA368re1q0OG8rWzsXU,5239
+puya/awst_build/validation/arc4_copy.py,sha256=sLq5qMcCaayEPQTvaicveGW5ZeN5Pl4l4MhT-8ewUHI,4893
 puya/awst_build/validation/awst_traverser.py,sha256=KlD6UBDUECadWo91aNkBbTIVN7rA0wGoMPTf6ycgEa8,1806
 puya/awst_build/validation/base_invoker.py,sha256=LjCPeULz3pzh3lOlg97QrBiE4BEkJecp9ZTpMI_FTnQ,2032
-puya/awst_build/validation/inner_transactions.py,sha256=r6XQUPaw3PLtA-ALA-TzfixeA2fGISTdKCuMknHZBTs,7333
-puya/awst_build/validation/main.py,sha256=UNghEey5TU2Gn1pleekjr-ZNJthfm5-3WnDwjCIgIgE,590
+puya/awst_build/validation/inner_transactions.py,sha256=4d1qTkdUn7_nkcadmGEBlzYK2NUrlyeyPqYIgjiNEJY,17439
+puya/awst_build/validation/main.py,sha256=-BGvcoNkNreRh6vL9ajCG8FkaIWtPXx7buBcWNmrUpA,689
 puya/awst_build/validation/scratch_slots.py,sha256=c18RY4soW93AJe4sq8KaocnA3Odw7TwD0UkfX_dJ8O4,2083
 puya/client_gen.py,sha256=SMGQrllglwxFlJ24ppAueWNcZtIQiGyTiA58gh_N-Ug,6511
-puya/compile.py,sha256=ShUjlV7apy6rpubEOyxFD1KcobuJqYE8VK_sdD5Y5o0,12793
+puya/compile.py,sha256=FTdWUuWVLGElo4bN2uAmRM6o4tkg3YpGey500bRouY4,13918
 puya/context.py,sha256=ou6bPPtIzs1b14j_VCzF7762ZN8C2ksuGqBCteEzcv4,1858
-puya/errors.py,sha256=B148dTaEp5Zo7AOOvI9U-pe2ZFhzdCXY0g2bJHPHtWk,2285
+puya/errors.py,sha256=9z3aeUhPz4qiSYwS5UAzsMd1pomvvZ_feGoo82MDJYA,2039
 puya/ir/__init__.py,sha256=umMbCh7O7ZmsQGNFyD1e3LXav2bTpIWNgSDywb6Zzkk,105
-puya/ir/arc4_router.py,sha256=gUXj1dzajWu0RXF8tdm88YluGY_3NrscYzUxLAvsBhc,26799
-puya/ir/avm_ops.py,sha256=YA1JK9gFKkBYlZYtawVzEA65Lc9uywSf-gwESvjUyz4,183593
+puya/ir/arc4_router.py,sha256=ziHCHqAy2qdPWdQSZ3iWN9IA8IDiSkkygdFOJZlS9E4,26535
+puya/ir/avm_ops.py,sha256=n3nlxG7Yb3-ONT9DeOSYQTpXdPm9lk7QBcpbaxBkuhE,183589
 puya/ir/avm_ops_models.py,sha256=upakbyr6Kf-5iad29Sjk0LYQ5X57B0Eps64sUHMc_6s,1352
 puya/ir/builder/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-puya/ir/builder/_utils.py,sha256=XOwJV0CJfJf7NaY5pEahGq4nXp7QIDqtyYkYl8ssBfM,6706
-puya/ir/builder/arc4.py,sha256=_k0iph-Xl4zb_p3NXy6uJDeab_yimG3H6zp82VUlEpk,57672
-puya/ir/builder/assignment.py,sha256=zMDoXQLq74DyulzsHLnf7LMpuHvLL0LHzztOdqsgOA8,5212
-puya/ir/builder/blocks.py,sha256=i1X13wl_khLXgc1EpDAuaigrbfGMcwFW1WGVLcZEUsQ,6173
+puya/ir/builder/_utils.py,sha256=ErGwQFppvIqXFAJ136D9ib349e3p7iNizlYMAw3mzFQ,6675
+puya/ir/builder/arc4.py,sha256=MyzEJ_qMRRiTK1R6jPUH1a9jpZCsZwI61jxXm_oGK-0,57659
+puya/ir/builder/assignment.py,sha256=0E18h4eJoRyBufdicelH6BJgU3EeEhY3qhif-8pRfHE,6201
+puya/ir/builder/blocks.py,sha256=1HWKSe5DLPp91uRYm-CqBQtFL0UIi-CLgGGuc9AXLhI,6175
 puya/ir/builder/callsub.py,sha256=oz-OKHvZP2XpXtQeRQustQ1WtKGrEuzMCV0Ez58318A,3195
-puya/ir/builder/flow_control.py,sha256=GjOuElKp8j0C-nEDT0OkkbLHIHBr9u8ulrFtTZY9uOI,8738
-puya/ir/builder/iteration.py,sha256=fmOrebswcsS-B5tPv0MMSCAh3LrEeJXW_r7BbumAvUw,23932
-puya/ir/builder/itxn.py,sha256=4caa67oj1AL79HP_W2djEAfZiYHQruNgGT6ppVqQrKo,23427
-puya/ir/builder/main.py,sha256=E5isKoD9mcKhLt1GA_Qkdb79hJ3dfYfoO9-Tsd2ysgs,42045
-puya/ir/builder/state.py,sha256=QiIIl1K_M8hV39k2eg2qydBfV0K8phnKASHB_Y48yQ0,4985
+puya/ir/builder/flow_control.py,sha256=ZwUDz_zXyl9-lk6BQYbbZEriqtvqlkEDjXX2oL469ec,8738
+puya/ir/builder/iteration.py,sha256=PNj1J0CF2KSCmKeQHIvOXrN35a4_0AkX6TSrpIB1yE8,24002
+puya/ir/builder/itxn.py,sha256=47XB1UBOqXRLOqNBibKgN-dJRnigyFiBqSMtK-MlpOg,25112
+puya/ir/builder/main.py,sha256=HybNax0wRNELd11OnE1Xkiiw_I9_ATac98_cmJpcL-4,43992
+puya/ir/builder/state.py,sha256=60jRR1vvb_2vEzObifRrcCPPoeY5gvAXmmi5RnwbUOY,5148
 puya/ir/context.py,sha256=y2nVsdY25YAc4cIwny5dbT6WLWVKhz5YUctJQrVS2vA,6658
 puya/ir/destructure/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-puya/ir/destructure/coalesce_locals.py,sha256=QFsAYsgSir5MQ5ThKD8KXDyRyb1R_Q0SCytpRlICG28,6730
+puya/ir/destructure/coalesce_locals.py,sha256=sOPXl-_1Sn1bAKmfoxEr7w4fewicSgH_BKGLBgptoq0,7028
 puya/ir/destructure/main.py,sha256=LS02_vsoZHPc1KZoHDUfYDZaAG98Uuti14sBsH6LXN4,899
 puya/ir/destructure/optimize.py,sha256=6zm1IxQFrvN9J2CYyByMPv8DHbQe3lAnCX3ZgAXepXo,2619
-puya/ir/destructure/parcopy.py,sha256=altQZNlBbypaRuIhWjGplE9Dkp4DhSl1yUVVj1foO9s,4397
-puya/ir/destructure/remove_phi.py,sha256=vUCrvjIxjRhyibaDvEDpBi8jfLp3FvlmR_KGNvH1LkA,4333
-puya/ir/main.py,sha256=Q6IseQywYCFPJ_0I1666_PD0bEcZ-sbdn-WIKeykxX8,19194
-puya/ir/models.py,sha256=OqIXXKNVRQNnH389JC8f3dg0Nt2YRw753eT-rLTvj1c,26813
+puya/ir/destructure/parcopy.py,sha256=IMFO1TLMpMZpqDa4xNX7rlFJx5S3hLVjrjwOZTTAv2U,4401
+puya/ir/destructure/remove_phi.py,sha256=Pb1-Nc-OAwGKpJtLsILjm0_Izp_qCJuGx8vNZnbv2GY,4337
+puya/ir/main.py,sha256=jHdPZm2P3Wtm8yHpelRITf3FngucPndpGw-L_xdO0W0,19492
+puya/ir/models.py,sha256=RbSBurv1xjl50N1EFzDXMzTG2VDtF6WMJSO_vasZVeE,29547
 puya/ir/optimize/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/ir/optimize/_utils.py,sha256=wtYOJ8L8ow0bl166FuMy-VI9JSwk1Bah-u-NwH_dnc4,1117
 puya/ir/optimize/assignments.py,sha256=3_P6K1wJv1w_Bj4yWhewyH9YuR5gMHurvArxtJRkjhg,2822
 puya/ir/optimize/collapse_blocks.py,sha256=Rx1v4o8_M0O0SHAxPG95x2_XMiFfipMP5_IdsyU2upo,5791
 puya/ir/optimize/constant_propagation.py,sha256=XvV-Y9Z-NQFveO7iD83ptEg5Bxr_7nfOMthGsLldsxw,2074
-puya/ir/optimize/control_op_simplification.py,sha256=_I7HHTw5gDuPvb-QGIZAMF4MO_01T_hcwXR8_dwFUoQ,11834
-puya/ir/optimize/dead_code_elimination.py,sha256=ptKtNYDqUI7t4HV9QiJhbDIUFqgIDZBsr_8LBDHiNUA,10193
-puya/ir/optimize/intrinsic_simplification.py,sha256=BXf06pbMeTOWESbxlWWWsLGdiJoDAWOMFFGHx6Ef_Y8,28317
-puya/ir/optimize/main.py,sha256=Tbmc7PsWSKWFlmR16Ys2Swcq59hFR9rna09qlVPzuFk,5279
+puya/ir/optimize/control_op_simplification.py,sha256=tbVeJulOIEzZxQD7I2ixU2pWFbC0EwLL5ClnrzGD8W8,11867
+puya/ir/optimize/dead_code_elimination.py,sha256=DpegPYGCHHiB7Ac_oaOj267h2aI9g4uOjjDMxI28Ems,10226
+puya/ir/optimize/inner_txn.py,sha256=hXkYc1r--BoD71LSfK_2rgGc92c-qsExRQquqRnUGhI,2372
+puya/ir/optimize/intrinsic_simplification.py,sha256=fEmbNudr4bnFkyYYgSASb0pKnWMtzCC8yLD14t_7yAg,28845
+puya/ir/optimize/main.py,sha256=nTQxC0htuFZlzJTztk5iS9RzqcIadYomw02JFztDhvU,5597
 puya/ir/optimize/repeated_code_elimination.py,sha256=ou0SIrV2sDX_lr3Fn5Ey-DEf_oWgMAkZhkUc_0qTmrM,5402
-puya/ir/ssa.py,sha256=kAbUaSps8hAEStQYQ83BSw2eoMVsZ7ceRpn8m_4tGlM,9233
-puya/ir/to_text_visitor.py,sha256=8JkmQQPgb4JR_n_F1ftQM_hQmcED6jVKw0nmOBosRnM,6962
-puya/ir/types_.py,sha256=QpV1SJZIijUCr7qZdXLtU8x592v_RvBfiQ5ppH2PsfQ,2969
-puya/ir/utils.py,sha256=aueN8-PqG31GFadUZeSNH_c2okW1yWP8ittSGYcze5A,2139
+puya/ir/ssa.py,sha256=Fsg3eCwoz4V6L1t3I3vO4nYYt7Q1Flt8W4puw9AWz0o,9253
+puya/ir/to_text_visitor.py,sha256=AuTL8NWHt5m0xRXjMEKYY3VeLg-5ArdRMw6PEkOe0Ho,7359
+puya/ir/types_.py,sha256=M6bpz3jNyxS5XXhqjKvLOCJuqLcraZJcbsukNOeN_qo,5999
+puya/ir/utils.py,sha256=25r4YJYVAXs_9PSc2rlmAIt9f8MhRHvOIMIzr5GMggc,2534
 puya/ir/validation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-puya/ir/validation/main.py,sha256=JV3J6kcCjew8qWHaCzI8FYO9x6oeVLPsFUr4qiBpo3U,422
-puya/ir/validation/min_avm_version_validator.py,sha256=t8B9eyXajODqDUa1scXxNMYb5hCbzI1jboxZCRfI1JA,1652
-puya/ir/validation/op_run_mode_validator.py,sha256=jh6Cp6zeMzqO05wNZQvJt6vwbOu6cH7bCK1gYLSjZsA,2111
-puya/ir/visitor.py,sha256=3wGXWcqvrCLfyC1-O7y-WafLi_oVfubDq97wVbxV2Ks,7393
+puya/ir/validation/_base.py,sha256=Z0BZyKSGjOHntw-S4cuFZliZqAJYKa2kw7qB0x3RP2g,1426
+puya/ir/validation/itxn_result_field_validator.py,sha256=3v1PvD6UJqEHsyoqYYJqbpYWz4RFI931RQvUQjJvmq4,867
+puya/ir/validation/main.py,sha256=sl6SptsQpY3gwRyRmwSzHqM1Y6PTZOFsV6zz7YPCxOM,630
+puya/ir/validation/min_avm_version_validator.py,sha256=FiXfFUa0JuC2TBJFHTbkLVwJzZbkougHgzP4y39HiHM,721
+puya/ir/validation/op_run_mode_validator.py,sha256=mjKIvhrX0Qd5sd-idBPktUbvgrAglcSVfh2G_TPlNXU,1138
+puya/ir/visitor.py,sha256=-vg_pfnuOjD9Ziqdt3n2La1MTm28RtYIjN5kXDG5RLg,8061
 puya/ir/visitor_mem_replacer.py,sha256=DyAiYOBamHNzejinCzS-DWvTJdy2-SFcH2PX9-BNrEo,824
-puya/ir/visitor_mutator.py,sha256=iSvsUEtoJ1-m0o4AMmqFEQwsxjOPBqG1hz1Sl3OnrQY,4565
+puya/ir/visitor_mutator.py,sha256=2L5RpqVGsNKBK1Up37_ubSHW_jMuL6Ugt4OrEwQu08g,5073
 puya/ir/vla.py,sha256=JZ_yDAB7GGPPVahA8rYqnre92MKdIEpNKTxXb8baGyk,4360
 puya/lib_embedded/_algopy_.py,sha256=OZcaRuTw4F4r3BjqVrh2f0oxniapmJXI4f0qcrJZ3WE,1196
 puya/lib_embedded/algopy_lib_arc4.py,sha256=z_5SzuelLZq8aSOxAuzmk7ECZk_05wph7sOjZ48zhFc,7432
 puya/lib_embedded/algopy_lib_bytes.py,sha256=-2oMZgqGsGIgTMDgYICDzxvxIUUdvXmn03jPLHldX74,388
-puya/log.py,sha256=FvWdM-rGgw-2L1GniVRuLUodZf_NvJz0m4s6dxSl4NE,11991
+puya/log.py,sha256=8y4zQHoK6859XsBzYIQq9ivmK7wfrKC4zflsxaa1DUc,12195
 puya/mir/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-puya/mir/annotaters.py,sha256=28QnUBZgt3OMfK2O-Ped1gAwKW5hj2j9t7eqepUIv2I,8583
-puya/mir/builder.py,sha256=3wEpJf4GbtPXVuh_S5i54A8YCQeTCNzRePAZlcGEZPc,10708
+puya/mir/annotaters.py,sha256=WZuTnf0w3p2STs6iGS5TL0AJiTnq-jRuxYIuvKy2ris,8551
+puya/mir/builder.py,sha256=xw1plvonnrHzqyXk2Allu4WoPn0-RcSdjLvihXbzKN0,10947
 puya/mir/context.py,sha256=1yI1mdTanFfQGtAZKq6qmEFTBwmABf-VM-0TLZFIgx4,2001
-puya/mir/main.py,sha256=KogcgLA5Zxjrs2WBhQ6hdShyqEkwKriGTMyUubSguqY,2426
-puya/mir/models.py,sha256=8LKR2TDZGpI5qjhhavs7Lh_sBK2uQPHU_KOC6vYBy4Q,13745
-puya/mir/output.py,sha256=GJMRxf3sB_A6N6fN-Vk3OnmgkgpU0mC4q4v4rEtfs5U,3445
-puya/mir/stack.py,sha256=ZCIWqORL54mqcXjn2lD0ah3dEhMw_9RwgIC0tTK7ScY,16390
+puya/mir/main.py,sha256=Rx2Pf5aY0NnudmXPEuizMsEPlZjNxvKOPMSmU0pb060,2448
+puya/mir/models.py,sha256=gSkj47Z3j3H-R09W5un6U_rLyYn_yOSVGryFeNJP0pw,14201
+puya/mir/output.py,sha256=AiybILdu84Zf3iXNqPDRM4WVfDdFudDA93PJvLktB-w,3447
+puya/mir/stack.py,sha256=rNXAeDPiqknqWfpUH4dL-YwdFp2k-Pzk8vhCFQtQmPI,16518
 puya/mir/stack_allocation/__init__.py,sha256=pVC98JU_qcNkOeZe56iyiRgAyLaozWbMEVIM9zKirnY,1035
 puya/mir/stack_allocation/baileys.py,sha256=izr9e3LgrnZGrd5gWKv92dilCk-PXWl-d6AAtcfm_Gs,12592
-puya/mir/stack_allocation/frame_allocation.py,sha256=m17iHvrjfdoGfJRSJeQkj2VJ6q3RZKV0ym_fUDeYIq8,4872
+puya/mir/stack_allocation/frame_allocation.py,sha256=Vgq9jQ1Zp-cprVmaUYHTyBWlrw8mot98ndnRS2GbMtY,5021
 puya/mir/stack_allocation/koopmans.py,sha256=YVKkYrwqLUuzX1JoYtMqWA8ATWYItfSiEDlH3LKvDKM,4365
 puya/mir/stack_allocation/peephole.py,sha256=N_mW5j0K4D28da0xipUl8js_yRPgt-KeekmGLROrLKY,8061
-puya/mir/visitor.py,sha256=DJivbFaSYcLKGPjkNwph1dR4HinevvX9ZmrKE2qDtUk,2515
+puya/mir/visitor.py,sha256=JzMwa_zEeKrRVJB2txuKG4NlRoA3seN1h1DlXeJg90A,2331
 puya/mir/vla.py,sha256=rTryYtSdhGmQBc1VtWziCmhb_cn-4PGonnHlLt7kLxA,4891
 puya/models.py,sha256=huPkfET8afNCa8KILm2cE6FGn0asmmf7mPj-32Y5mXE,3320
 puya/options.py,sha256=A_4bRNoSYJAH3YdAe7YVZUFoG3-Ma9XpyVVCpSc7z00,1267
-puya/parse.py,sha256=TrGV8N3nkBEg-UERWdVeAZOitUbP9bCGg88l6I1CkFQ,15756
+puya/parse.py,sha256=sQI6SYvhNPyUSHnwtZR9EK62tQbZih2We3OFKCMdmIE,15722
 puya/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/teal/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-puya/teal/main.py,sha256=ub5TZcoUxWEzxlxu1jXStBUWFY2pYqx87I1SicABopA,2432
-puya/teal/models.py,sha256=PawlOW2NgY7uCV2pPiki9jr3mnNZ5gIsuYM4McntynM,8352
+puya/teal/main.py,sha256=xelREKKfBcBrRbuBbjXJmKapHV0QqXk46C28CxvgW8w,2488
+puya/teal/models.py,sha256=ktUMcuLACg8tSRtTynGmv3UdUg8Wlf1yMipSWhISE1g,8386
 puya/teal/optimize/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 puya/teal/optimize/_data.py,sha256=QfcPvbUoI7ZVaU2Fe9HhUWycXEM5QYLNt-2d3Htk2WA,1645
 puya/teal/optimize/constant_stack_shuffling.py,sha256=KRQX_uf2cP1scxhymGZP-ovBwgOn0hJRbiQvNXX_U6A,2703
 puya/teal/optimize/main.py,sha256=CMQmcewGPi4bn--UPgHNrPO8EAsqMx5smw26KNs0NxA,1618
 puya/teal/optimize/peephole.py,sha256=c4SrVXxz4UCTj1M0aT1WK4htfefINQJq752A8IbnyVE,8381
 puya/teal/optimize/repeated_rotations.py,sha256=4bN_4Yu42ZC8oP80VJOFZXPugAYx3dF2fx2gbXPcFIE,1557
 puya/teal/optimize/repeated_rotations_search.py,sha256=cGgaYGZx3yoEAdJatdnGSL4BfYAMgtfUsnEOHZpwH_4,4276
-puya/teal/output.py,sha256=lq2SBVEjPkoUqYhmM0oGG8FjaKN4nA6RcvUKa3AM79Y,1547
-puya/utils.py,sha256=COBn_b_SVcEHXKAjr0FdDjkgILs63qzCBKLpGevkpA8,7433
+puya/teal/output.py,sha256=Sbyo9GPqdSHgoAbRyQehGAi9a6c1xzPtqC8eaUDUciA,1554
+puya/utils.py,sha256=aVKkmH0SGIKgglGbqb7zQB9bTCWahbTKudtqhVwx-Fw,7535
 puya/_typeshed/stdlib/algopy/__init__.pyi,sha256=7eDhxMg6VlWqwCwDECtBAZ7Gs9MLiulXGXudgBgcAVo,904
 puya/_typeshed/stdlib/algopy/_constants.pyi,sha256=e9ZdyynrOWoaTIzd_q-tEJKQ61eSX_jljdsBsyQEVGI,1806
-puya/_typeshed/stdlib/algopy/_contract.pyi,sha256=dqdc9OYU1vR-g5iYNjGgy7qLrMxN6zr8mwRVaBT2bwI,4045
+puya/_typeshed/stdlib/algopy/_contract.pyi,sha256=1H-IuwEZeIVcsMJse0Ux-XpLJeJz1PGntahBjFn-g_k,4047
 puya/_typeshed/stdlib/algopy/_hints.pyi,sha256=zhtGGW-0NicJIM51HUTy9L2JJ6Ffp_w7M51cIhkFzY0,648
 puya/_typeshed/stdlib/algopy/_logic_sig.pyi,sha256=juv7p4QZTNq1G4A3ODX45nPYq7zbya5PfN8Hipxq07Y,370
-puya/_typeshed/stdlib/algopy/_primitives.pyi,sha256=YDfUVQwHuTF4qJCNVH2spLPDd0hpZJKswhWqqnQEUvQ,20805
-puya/_typeshed/stdlib/algopy/_reference.pyi,sha256=NaQiUvZtk4uxcCGReNHQtmmHfowvU_kM54bF0ikRb18,9617
-puya/_typeshed/stdlib/algopy/_state.pyi,sha256=G_2ocWkFNpO7L1D6Gl-k7lfPyQQ6cflvXNowabxHisk,4375
+puya/_typeshed/stdlib/algopy/_primitives.pyi,sha256=eTGxzpzTZmh8V_gELBGYqQXjFecjYIdf47AJEF5gOBI,20981
+puya/_typeshed/stdlib/algopy/_reference.pyi,sha256=88OmsV6SGMo5FL18HSK9MPda79WDyyfjemr1Wm5DjzA,9783
+puya/_typeshed/stdlib/algopy/_state.pyi,sha256=rEb14xKzHRCBvFsedz3HZOwXlM_Cz6V-WEqyyRq8WY4,4332
 puya/_typeshed/stdlib/algopy/_template_variables.pyi,sha256=5GNAWmBJAH9Mx1BS14jUDGeedYYy5kfM-tUlT5V8wlo,549
-puya/_typeshed/stdlib/algopy/_transaction.pyi,sha256=9OvMECaFgANP5KaMn6JfPcj6Wnivm5qb0dKJj-ux548,5384
+puya/_typeshed/stdlib/algopy/_transaction.pyi,sha256=8L4NkTCdbBUptFNAWCS2b_29Urhyq6QkUicOH-KSA7E,5404
 puya/_typeshed/stdlib/algopy/_unsigned_builtins.pyi,sha256=-5GkX4Vbj1wxfP6HIppsKd0i_LX8G5LTz-JIEJSIHlU,1416
-puya/_typeshed/stdlib/algopy/_util.pyi,sha256=Xp1Ymn2O68MdTmPnTL82wUv9hRA1cbkZZtK1Trbuz8Y,1032
-puya/_typeshed/stdlib/algopy/arc4.pyi,sha256=R-fRE474aE73b7nlqYE8UQn5gTkxU-JM0kiqXD1tcL4,20317
+puya/_typeshed/stdlib/algopy/_util.pyi,sha256=qNafgMcUc1Tmna26o8W0Ifso-xOeS5neHwYmBeexgtU,1040
+puya/_typeshed/stdlib/algopy/arc4.pyi,sha256=cYB444e_ZgWkkbWzuSIRuEkgU43fiaVgTLPC5akr8n8,20353
 puya/_typeshed/stdlib/algopy/gtxn.pyi,sha256=bhYkoxgrVcczh6sbaKk7xvTOu9otu-t9oWzZXYfuUv0,1491
-puya/_typeshed/stdlib/algopy/itxn.pyi,sha256=kPJbuXRg8dDbXuuXyQPBCxel4mYs6LOxcK_DhfkujNM,21327
-puya/_typeshed/stdlib/algopy/op.pyi,sha256=eJH1POmOAeNtZ31IZ1yg-rS2xjs6lSjXX0YM9N4KS5Q,150074
-puyapy-1.0.1.dist-info/LICENSE,sha256=jRyAzzkz3HPr-knS8XWyDY8CyuU-L4RtydPP8uGWsUw,657
-puyapy-1.0.1.dist-info/METADATA,sha256=vdxDDur8on5LAYYeQ74HeQL4BtNxotv_v1pGXjp41g4,5134
-puyapy-1.0.1.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
-puyapy-1.0.1.dist-info/entry_points.txt,sha256=aznvB-Ck-TwWxW6Qtu3akZGtaE_gEtlG3nTtmIez_NU,83
-puyapy-1.0.1.dist-info/RECORD,,
+puya/_typeshed/stdlib/algopy/itxn.pyi,sha256=3Ij-yRQeIjpyvLcdQAxYPizs4vwq-eG154IH1oopTW8,21474
+puya/_typeshed/stdlib/algopy/op.pyi,sha256=Oiye2_r8regt4OonOg1qWbsTDc36ChbuEy0DZ_h816k,150962
+puyapy-2.0.0.dist-info/COPYING,sha256=DZak_2itbUtvHzD3E7GNUYSRK6jdOJ-GqncQ2weavLA,34523
+puyapy-2.0.0.dist-info/LICENSE,sha256=jRyAzzkz3HPr-knS8XWyDY8CyuU-L4RtydPP8uGWsUw,657
+puyapy-2.0.0.dist-info/METADATA,sha256=4ls1x-EsyQH21KOixcfJJ_t1BnJxAptvs1Wm0pM8aQg,5101
+puyapy-2.0.0.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
+puyapy-2.0.0.dist-info/entry_points.txt,sha256=aznvB-Ck-TwWxW6Qtu3akZGtaE_gEtlG3nTtmIez_NU,83
+puyapy-2.0.0.dist-info/RECORD,,
```

